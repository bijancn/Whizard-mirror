% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD main code as NOWEB source

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{User Code Interface}

Here we collect interface code that enables the user to inject his own
code into the WHIZARD workflow.  The code uses data types defined above, and
is referenced in the [[eval_trees]] module.

<<[[user_code_interface.f90]]>>=
<<File header>>

module user_code_interface

  use iso_c_binding !NODEP!
<<Use kinds>>
<<Use strings>>
  use diagnostics
  use c_particles
  use os_interface

<<Standard module head>>

<<User Code: public>>

<<User Code: variables>>

<<User Code: interfaces>>

contains

<<User Code: procedures>>

end module user_code_interface
@ %def user_code_interface
@
\subsection{User Code Management}
@ 
This data structure globally holds the filehandle of the user-code
library:
<<User Code: public>>=
  public :: has_user_lib
<<User Code: variables>>=
  type(dlaccess_t), save :: user_lib_handle
  logical, save :: has_user_lib = .false.
  type(string_t), save :: user

@ %def user_lib_handle has_user_lib user
@ 
Compile, link and load user code files.  Dlopen all user-provided
libraries, included the one just compiled (if any).

By default, we are looking for a library [[user.so/dylib]].  If this is not
present, try [[user.f90]] and compile it.  This can be overridden.

In detail: First, compile all sources explicitly specified on the
command line.  Then collect all libraries specified on the command
line, including [[user.so]] if it was generated.  If there is still no
code, check for an existing [[user.f90]] and compile this.  Link
everything into a [[user.la]] libtool library.  When 
done, dlopen all libraries that we have so far.
<<User Code: public>>=
  public :: user_code_init
<<User Code: procedures>>=
  subroutine user_code_init (user_src, user_lib, user_target, rebuild, os_data)
    type(string_t), dimension(:), intent(in) :: user_src, user_lib
    type(string_t), intent(in) :: user_target
    logical, intent(in) :: rebuild
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: user_src_file, user_obj_files, user_lib_file
    logical :: exist
    type(c_funptr) :: fptr
    integer :: i
    call msg_message ("Initializing user code")
    user = user_target;  if (user == "")  user = "user"
    user_obj_files = ""
    inquire (file = char (user) // ".la", exist = exist)
    if (rebuild .or. .not. exist) then
       do i = 1, size (user_src)
          user_src_file = user_src(i) // os_data%fc_src_ext
          inquire (file = char (user_src_file), exist = exist)
          if (exist) then
             call msg_message ("Found user-code source '" &
                  // char (user_src_file) // "'.")
             call compile_user_src (user_src_file, user_obj_files)
          else
             call msg_fatal ("User-code source '" // char (user_src_file) &
                  // "' not found")
          end if
       end do
       do i = 1, size (user_lib)
          user_lib_file = user_lib(i) // ".la"
          inquire (file = char (user_lib_file), exist = exist)
          if (exist) then
             call msg_message ("Found user-code library '" &
                  // char (user_lib_file) // "'.")
          else
             user_lib_file = user_lib(i) // os_data%shlib_ext
             inquire (file = char (user_lib_file), exist = exist)
             if (exist) then
                call msg_message ("Found user-code library '" &
                     // char (user_lib_file) // "'.")
             else
                call msg_fatal ("User-code library '" // char (user_lib(i)) &
                     // "' not found")
             end if
          end if
          user_obj_files = user_obj_files // " " // user_lib_file
       end do
       if (user_obj_files == "") then
          user_src_file = user // os_data%fc_src_ext
          inquire (file = char (user_src_file), exist = exist)
          if (exist) then
             call msg_message ("Found user-code source '" &
                  // char (user_src_file) // "'.")
             call compile_user_src (user_src_file, user_obj_files)
          else
             call msg_fatal ("User-code source '" // char (user_src_file) &
                  // "' not found")
          end if
       end if
       if (user_obj_files /= "") then
          call link_user (char (user), user_obj_files)
       end if
    end if
    call dlaccess_init &
         (user_lib_handle, var_str ("."), &
          user // os_data%shlib_ext, os_data)
    if (dlaccess_has_error (user_lib_handle)) then
       call msg_error (char (dlaccess_get_error (user_lib_handle)))
       call msg_fatal ("Loading user code library '" // char (user) &
            // ".la' failed")
    else
       call msg_message ("User code library '" // char (user) &
            // ".la' successfully loaded")
       has_user_lib = .true.
    end if
  contains
    subroutine compile_user_src (user_src_file, user_obj_files)
      type(string_t), intent(in) :: user_src_file
      type(string_t), intent(inout) :: user_obj_files
      type(string_t) :: basename, ext
      logical :: exist
      basename = user_src_file
      call split (basename, ext, ".", back=.true.)
      if ("." // ext == os_data%fc_src_ext) then
         inquire (file = char (user_src_file), exist = exist)
         if (exist) then
            call msg_message ("Compiling user code file '" &
                 // char (user_src_file) // "'")
            call os_compile_shared (basename, os_data)
            user_obj_files = user_obj_files // " " // basename // ".lo"
         else
            call msg_error ("User code file '" // char (user_src_file) &
                 // "' not found.")
         end if
      else
         call msg_error ("User code file '" // char (user_src_file) &
              // "' should have file extension '" &
              // char (os_data%fc_src_ext) // "'")
      end if
    end subroutine compile_user_src
    subroutine link_user (user_lib, user_obj_files)
      character(*), intent(in) :: user_lib
      type(string_t), intent(in) :: user_obj_files
      call msg_message ("Linking user code library '" &
           // user_lib // char (os_data%shlib_ext) // "'")
      call os_link_shared (user_obj_files, var_str (user_lib), os_data)
    end subroutine link_user
  end subroutine user_code_init

@ %def user_code_init
@ Unload all user-code libraries.
<<User Code: public>>=
  public :: user_code_final
<<User Code: procedures>>=
  subroutine user_code_final ()
    if (has_user_lib) then
       call dlaccess_final (user_lib_handle)
       has_user_lib = .false.
    end if
  end subroutine user_code_final

@ %def user_code_final
@ Try to load the possible user-defined procedures from the dlopened
libraries.  If a procedure is not found, do nothing.
<<User Code: public>>=
  public :: user_code_find_proc
<<User Code: procedures>>=
  function user_code_find_proc (name) result (fptr)
    type(string_t), intent(in) :: name
    type(c_funptr) :: fptr
    integer :: i
    fptr = c_null_funptr
    !!! Ticket #529
    ! fptr = libmanager_get_c_funptr (char (user), char (name))
    if (.not. c_associated (fptr)) then
       if (has_user_lib) then
          fptr = dlaccess_get_c_funptr (user_lib_handle, name)
          if (.not. c_associated (fptr)) then      
             call msg_fatal ("User procedure '" // char (name) // "' not found")
          end if
       else
          call msg_fatal ("User procedure '" // char (name) &
               // "' called without user library (missing -u flag?)")
       end if
    end if
  end function user_code_find_proc

@  %def user_code_find_proc
@ 
\subsection{Interfaces for user-defined functions}
The following functions represent user-defined real observables.  There may
be one or two particles as argument, the result is a real value.
<<User Code: public>>=
  public :: user_obs_int_unary
  public :: user_obs_int_binary
  public :: user_obs_real_unary
  public :: user_obs_real_binary
<<User Code: interfaces>>=
  abstract interface
     function user_obs_int_unary (prt1) result (ival) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), intent(in) :: prt1
       integer(c_int) :: ival
     end function user_obs_int_unary
  end interface

  abstract interface
     function user_obs_int_binary (prt1, prt2) result (ival) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), intent(in) :: prt1, prt2
       integer(c_int) :: ival
     end function user_obs_int_binary
  end interface

  abstract interface
     function user_obs_real_unary (prt1) result (rval) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), intent(in) :: prt1
       real(c_double) :: rval
     end function user_obs_real_unary
  end interface

  abstract interface
     function user_obs_real_binary (prt1, prt2) result (rval) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), intent(in) :: prt1, prt2
       real(c_double) :: rval
     end function user_obs_real_binary
  end interface

@ %def user_obs_real_unary
@ %def user_obs_real_binary
@
The following function takes an array of C-compatible particles and
return a single value.  The particle array represents a subevent.  For
C interoperability, we have to use an assumed-size array, hence the
array size has to be transferred explicitly.

The cut function returns an [[int]], which we should interpret as a
logical value (nonzero=true).
<<User Code: public>>=
  public :: user_cut_fun
<<User Code: interfaces>>=
  abstract interface
     function user_cut_fun (prt, n_prt) result (iflag) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), dimension(*), intent(in) :: prt
       integer(c_int), intent(in) :: n_prt
       integer(c_int) :: iflag
     end function user_cut_fun
  end interface

@ %def user_cut_fun
@ The event-shape function returns a real value.
<<User Code: public>>=
  public :: user_event_shape_fun
<<User Code: interfaces>>=
  abstract interface
     function user_event_shape_fun (prt, n_prt) result (rval) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), dimension(*), intent(in) :: prt
       integer(c_int), intent(in) :: n_prt
       real(c_double) :: rval
     end function user_event_shape_fun
  end interface

@ %def user_event_shape_fun
@ 
\subsection{Interfaces for user-defined interactions}
The following procedure interfaces pertain to user-defined
interactions, e.g., spectra or structure functions.

This subroutine retrieves the basic information for setting up the
interaction and event generation.  All parameters are
[[intent(inout)]], so we can provide default values.  [[n_in]] and
[[n_out]] are the number of incoming and outgoing particles,
respectively.  [[n_states]] is the total number of distinct states
that should be generated (counting all states of the incoming
particles).  [[n_col]] is the maximal number of color entries a
particle can have.  [[n_dim]] is the number of input parameters, i.e.,
integration dimensions, that the structure function call requires for
computing kinematics and matrix elements.
[[n_var]] is the number of variables (e.g., momentum fractions) that
the structure function call has to transfer from the kinematics to the
dynamics evaluation.
<<User Code: public>>=
  public :: user_int_info
<<User Code: interfaces>>=
  abstract interface
     subroutine user_int_info (n_in, n_out, n_states, n_col, n_dim, n_var) &
          bind(C)
       use iso_c_binding !NODEP!
       integer(c_int), intent(inout) :: n_in, n_out, n_states, n_col
       integer(c_int), intent(inout) :: n_dim, n_var
     end subroutine user_int_info
  end interface

@  %def user_int_info
@ This subroutine retrieves the settings for the quantum number mask
of a given particle index in the interaction.  A nonzero value
indicates that the corresponding quantum number is to be ignored.  The
lock index is the index of a particle that the current particle is
related to.  The relation applies if quantum numbers of one of the
locked particles are summed over.  (This is intended for helicity.)
<<User Code: public>>=
  public :: user_int_mask
<<User Code: interfaces>>=
  abstract interface
     subroutine user_int_mask (i_prt, m_flv, m_hel, m_col, i_lock) bind(C)
       use iso_c_binding !NODEP!
       integer(c_int), intent(in) :: i_prt
       integer(c_int), intent(inout) :: m_flv, m_hel, m_col, i_lock
     end subroutine user_int_mask
  end interface

@ %def user_int_mask
@ This subroutine retrieves the quantum numbers for the particle
index [[i_prt]] in state [[i_state]].  The [[flv]] value is a PDG
code.  The [[hel]] value is an integer helicity (twice the helicity
for fermions).  The [[col]] array is an array which has at most
[[n_col]] entries (see above).  All parameters are [[intent(inout)]]
since default values exist.  In particular, if a mask entry is set by
the previous procedure, the corresponding quantum number is ignored
anyway.
<<User Code: public>>=
  public :: user_int_state
<<User Code: interfaces>>=
  abstract interface
     subroutine user_int_state (i_state, i_prt, flv, hel, col) bind(C)
       use iso_c_binding !NODEP!
       integer(c_int), intent(in) :: i_state, i_prt
       integer(c_int), intent(inout) :: flv, hel
       integer(c_int), dimension(*), intent(inout) :: col
     end subroutine user_int_state
  end interface

@ %def user_int_state
@ This subroutine takes an array of particle objects
with array length [[n_in]] and an array of input parameters between 0 and 1
with array length [[n_dim]].  It returns an array of particle objects 
with array length [[n_out]].  In addition, it returns an array of
internal variables (e.g., momentum fractions, Jacobian) with array
length [[n_var]] that is used by the
following subroutine for evaluating the dynamics, i.e., the matrix
elements.
<<User Code: public>>=
  public :: user_int_kinematics
<<User Code: interfaces>>=
  abstract interface
     subroutine user_int_kinematics (prt_in, rval, prt_out, xval) bind(C)
       use iso_c_binding !NODEP!
       use c_particles !NODEP!
       type(c_prt_t), dimension(*), intent(in) :: prt_in
       real(c_double), dimension(*), intent(in) :: rval
       type(c_prt_t), dimension(*), intent(inout) :: prt_out
       real(c_double), dimension(*), intent(out) :: xval
     end subroutine user_int_kinematics
  end interface

@ %def user_int_kinematics
@ This subroutine takes the array of variables (e.g., momentum
fractions) with length [[n_var]] which has been generated by the
previous subroutine and a real variable, the energy scale of the
event.  It returns an array of matrix-element values, one entry for
each quantum state [[n_states]].  The ordering of matrix elements must
correspond to the ordering of states.
<<User Code: public>>=
  public :: user_int_evaluate
<<User Code: interfaces>>=
  abstract interface
     subroutine user_int_evaluate (xval, scale, fval) bind(C)
       use iso_c_binding !NODEP!
       real(c_double), dimension(*), intent(in) :: xval
       real(c_double), intent(in) :: scale
       real(c_double), dimension(*), intent(out) :: fval
     end subroutine user_int_evaluate
  end interface

@ %def user_int_evaluate
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Sindarin Base}

This part contains the basic internal structures of Sindarin: variables and
expressions.
\begin{description}
\item[eval\_trees] 
  Expressions of values of all kinds, represented in
  a tree structure.  This provides an implementation of the [[expr_base]]
  abstract type.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions as Eval Trees}

In this module we define the structures needed to parse a user-defined
expression, to compile it into an evaluation tree, and to evaluate it.

We have two flavors of expressions: one with particles and one without
particles.  The latter version is used for defining cut/selection
criteria and for online analysis.
<<[[eval_trees.f90]]>>=
<<File header>>

module eval_trees

  use, intrinsic :: iso_c_binding !NODEP!
<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use lorentz
  use md5
  use formats
  use sorting
  use ifiles
  use lexers
  use syntax_rules
  use parser
  use analysis
  use jets
  use pdg_arrays
  use subevents
  use user_code_interface
  use variables
  use expr_base

<<Standard module head>>

<<Eval trees: public>>

<<Eval trees: types>>

<<Eval trees: interfaces>>

<<Eval trees: variables>>

contains

<<Eval trees: procedures>>

<<Eval trees: tests>>

end module eval_trees
@ %def eval_trees
@ 
\subsection{Tree nodes}
The evaluation tree consists of branch nodes (unary and binary) and of
leaf nodes, originating from a common root.  The node object should be
polymorphic.  For the time being, polymorphism is emulated here.  This
means that we have to maintain all possibilities that the node may
hold, including associated procedures as pointers.

The following parameter values characterize the node.  Unary and
binary operators have sub-nodes.  The other are leaf nodes.  Possible
leafs are literal constants or named-parameter references.
<<Eval trees: types>>=
  integer, parameter :: EN_UNKNOWN = 0, EN_UNARY = 1, EN_BINARY = 2
  integer, parameter :: EN_CONSTANT = 3, EN_VARIABLE = 4
  integer, parameter :: EN_CONDITIONAL = 5, EN_BLOCK = 6
  integer, parameter :: EN_RECORD_CMD = 7
  integer, parameter :: EN_OBS1_INT = 11, EN_OBS2_INT = 12
  integer, parameter :: EN_OBS1_REAL = 21, EN_OBS2_REAL = 22
  integer, parameter :: EN_UOBS1_INT = 31, EN_UOBS2_INT = 32
  integer, parameter :: EN_UOBS1_REAL = 41, EN_UOBS2_REAL = 42
  integer, parameter :: EN_PRT_FUN_UNARY = 101, EN_PRT_FUN_BINARY = 102
  integer, parameter :: EN_EVAL_FUN_UNARY = 111, EN_EVAL_FUN_BINARY = 112
  integer, parameter :: EN_LOG_FUN_UNARY = 121, EN_LOG_FUN_BINARY = 122
  integer, parameter :: EN_INT_FUN_UNARY = 131, EN_INT_FUN_BINARY = 132
  integer, parameter :: EN_REAL_FUN_UNARY = 141, EN_REAL_FUN_BINARY = 142
  integer, parameter :: EN_FORMAT_STR = 161

@ %def EN_UNKNOWN EN_UNARY EN_BINARY EN_CONSTANT EN_VARIABLE EN_CONDITIONAL
@ %def EN_RECORD_CMD
@ %def EN_OBS1_INT EN_OBS2_INT EN_OBS1_REAL EN_OBS2_REAL
@ %def EN_UOBS1_INT EN_UOBS2_INT EN_UOBS1_REAL EN_UOBS2_REAL
@ %def EN_PRT_FUN_UNARY EN_PRT_FUN_BINARY
@ %def EN_EVAL_FUN_UNARY EN_EVAL_FUN_BINARY
@ %def EN_LOG_FUN_UNARY EN_LOG_FUN_BINARY
@ %def EN_INT_FUN_UNARY EN_INT_FUN_BINARY
@ %def EN_REAL_FUN_UNARY EN_REAL_FUN_BINARY
@ %def EN_FORMAT_STR
<<Eval trees: types>>=
  type :: eval_node_t
     private
     type(string_t) :: tag
     integer :: type = EN_UNKNOWN
     integer :: result_type = V_NONE
     type(var_list_t), pointer :: var_list => null ()
     type(string_t) :: var_name
     logical, pointer :: value_is_known => null ()
     logical,           pointer :: lval => null ()
     integer,           pointer :: ival => null ()
     real(default),     pointer :: rval => null ()
     complex(default),  pointer :: cval => null ()
     type(subevt_t),  pointer :: pval => null ()
     type(pdg_array_t), pointer :: aval => null ()
     type(string_t),    pointer :: sval => null ()
     type(eval_node_t), pointer :: arg0 => null ()
     type(eval_node_t), pointer :: arg1 => null ()
     type(eval_node_t), pointer :: arg2 => null ()
     type(eval_node_t), pointer :: arg3 => null ()
     type(eval_node_t), pointer :: arg4 => null ()
     procedure(obs_unary_int),   nopass, pointer :: obs1_int  => null ()
     procedure(obs_unary_real),  nopass, pointer :: obs1_real => null ()
     procedure(obs_binary_int),  nopass, pointer :: obs2_int  => null ()
     procedure(obs_binary_real), nopass, pointer :: obs2_real => null ()
     integer, pointer :: prt_type => null ()
     integer, pointer :: index => null ()
     real(default), pointer :: tolerance => null ()
     integer, pointer :: jet_algorithm => null ()
     real(default), pointer :: jet_r => null ()
     type(prt_t), pointer :: prt1 => null ()
     type(prt_t), pointer :: prt2 => null ()
     procedure(unary_log),  nopass, pointer :: op1_log  => null ()
     procedure(unary_int),  nopass, pointer :: op1_int  => null ()
     procedure(unary_real), nopass, pointer :: op1_real => null ()
     procedure(unary_cmplx), nopass, pointer :: op1_cmplx => null ()
     procedure(unary_pdg),  nopass, pointer :: op1_pdg  => null ()
     procedure(unary_sev),  nopass, pointer :: op1_sev  => null ()
     procedure(unary_str),  nopass, pointer :: op1_str  => null ()
     procedure(unary_cut),  nopass, pointer :: op1_cut  => null ()
     procedure(unary_evi),  nopass, pointer :: op1_evi  => null ()
     procedure(unary_evr),  nopass, pointer :: op1_evr  => null ()
     procedure(binary_log),  nopass, pointer :: op2_log  => null ()
     procedure(binary_int),  nopass, pointer :: op2_int  => null ()
     procedure(binary_real), nopass, pointer :: op2_real => null ()
     procedure(binary_cmplx), nopass, pointer :: op2_cmplx => null ()
     procedure(binary_pdg),  nopass, pointer :: op2_pdg  => null ()
     procedure(binary_sev),  nopass, pointer :: op2_sev  => null ()
     procedure(binary_str),  nopass, pointer :: op2_str  => null ()
     procedure(binary_cut),  nopass, pointer :: op2_cut  => null ()
     procedure(binary_evi),  nopass, pointer :: op2_evi  => null ()
     procedure(binary_evr),  nopass, pointer :: op2_evr  => null ()
  end type eval_node_t

@ %def eval_node_t
@ Finalize a node recursively.  Allocated constants are deleted,
pointers are ignored.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_final_rec (node)
    type(eval_node_t), intent(inout) :: node
    select case (node%type)
    case (EN_UNARY)
       call eval_node_final_rec (node%arg1)
    case (EN_BINARY)
       call eval_node_final_rec (node%arg1)
       call eval_node_final_rec (node%arg2)
    case (EN_CONDITIONAL)
       call eval_node_final_rec (node%arg0)
       call eval_node_final_rec (node%arg1)
       call eval_node_final_rec (node%arg2)
    case (EN_BLOCK)
       call eval_node_final_rec (node%arg0)
       call eval_node_final_rec (node%arg1)
    case (EN_PRT_FUN_UNARY, EN_EVAL_FUN_UNARY, &
          EN_LOG_FUN_UNARY, EN_INT_FUN_UNARY, EN_REAL_FUN_UNARY)
       if (associated (node%arg0))  call eval_node_final_rec (node%arg0)
       call eval_node_final_rec (node%arg1)
       deallocate (node%index)
       deallocate (node%prt1)
    case (EN_PRT_FUN_BINARY, EN_EVAL_FUN_BINARY, &
          EN_LOG_FUN_BINARY, EN_INT_FUN_BINARY, EN_REAL_FUN_BINARY)
       if (associated (node%arg0))  call eval_node_final_rec (node%arg0)
       call eval_node_final_rec (node%arg1)
       call eval_node_final_rec (node%arg2)
       deallocate (node%index)
       deallocate (node%prt1)
       deallocate (node%prt2)
    case (EN_FORMAT_STR)
       if (associated (node%arg0))  call eval_node_final_rec (node%arg0)
       if (associated (node%arg1))  call eval_node_final_rec (node%arg1)
       deallocate (node%ival)
    case (EN_RECORD_CMD)
       if (associated (node%arg0))  call eval_node_final_rec (node%arg0)
       if (associated (node%arg1))  call eval_node_final_rec (node%arg1)
       if (associated (node%arg2))  call eval_node_final_rec (node%arg2)
       if (associated (node%arg3))  call eval_node_final_rec (node%arg3)
       if (associated (node%arg4))  call eval_node_final_rec (node%arg4)
    end select
    select case (node%type)
    case (EN_UNARY, EN_BINARY, EN_CONDITIONAL, EN_CONSTANT, EN_BLOCK, &
          EN_PRT_FUN_UNARY, EN_PRT_FUN_BINARY, &
          EN_EVAL_FUN_UNARY, EN_EVAL_FUN_BINARY, &
          EN_LOG_FUN_UNARY, EN_LOG_FUN_BINARY, &
          EN_INT_FUN_UNARY, EN_INT_FUN_BINARY, &
          EN_REAL_FUN_UNARY, EN_REAL_FUN_BINARY, &
          EN_FORMAT_STR, EN_RECORD_CMD)
       select case (node%result_type)
       case (V_LOG);  deallocate (node%lval)
       case (V_INT);  deallocate (node%ival)
       case (V_REAL); deallocate (node%rval)
       case (V_CMPLX); deallocate (node%cval)
       case (V_SEV);  deallocate (node%pval)
       case (V_PDG);  deallocate (node%aval)
       case (V_STR);  deallocate (node%sval)
       end select
       deallocate (node%value_is_known)
    end select
  end subroutine eval_node_final_rec

@ %def eval_node_final_rec
@ 
\subsubsection{Leaf nodes}
Initialize a leaf node with a literal constant.
<<Eval trees: procedures>>=
  subroutine eval_node_init_log (node, lval)
    type(eval_node_t), intent(out) :: node
    logical, intent(in) :: lval
    node%type = EN_CONSTANT
    node%result_type = V_LOG
    allocate (node%lval, node%value_is_known)
    node%lval = lval
    node%value_is_known = .true.
  end subroutine eval_node_init_log

  subroutine eval_node_init_int (node, ival)
    type(eval_node_t), intent(out) :: node
    integer, intent(in) :: ival
    node%type = EN_CONSTANT
    node%result_type = V_INT
    allocate (node%ival, node%value_is_known)
    node%ival = ival
    node%value_is_known = .true.
  end subroutine eval_node_init_int

  subroutine eval_node_init_real (node, rval)
    type(eval_node_t), intent(out) :: node
    real(default), intent(in) :: rval
    node%type = EN_CONSTANT
    node%result_type = V_REAL
    allocate (node%rval, node%value_is_known)
    node%rval = rval
    node%value_is_known = .true.
  end subroutine eval_node_init_real
    
  subroutine eval_node_init_cmplx (node, cval)
    type(eval_node_t), intent(out) :: node
    complex(default), intent(in) :: cval
    node%type = EN_CONSTANT
    node%result_type = V_CMPLX
    allocate (node%cval, node%value_is_known)
    node%cval = cval
    node%value_is_known = .true.
  end subroutine eval_node_init_cmplx

  subroutine eval_node_init_subevt (node, pval)
    type(eval_node_t), intent(out) :: node
    type(subevt_t), intent(in) :: pval
    node%type = EN_CONSTANT
    node%result_type = V_SEV
    allocate (node%pval, node%value_is_known)
    node%pval = pval
    node%value_is_known = .true.
  end subroutine eval_node_init_subevt

  subroutine eval_node_init_pdg_array (node, aval)
    type(eval_node_t), intent(out) :: node
    type(pdg_array_t), intent(in) :: aval
    node%type = EN_CONSTANT
    node%result_type = V_PDG
    allocate (node%aval, node%value_is_known)
    node%aval = aval
    node%value_is_known = .true.
  end subroutine eval_node_init_pdg_array

  subroutine eval_node_init_string (node, sval)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: sval
    node%type = EN_CONSTANT
    node%result_type = V_STR
    allocate (node%sval, node%value_is_known)
    node%sval = sval
    node%value_is_known = .true.
  end subroutine eval_node_init_string

@ %def eval_node_init_log eval_node_init_int eval_node_init_real
@ %def eval_node_init_cmplx eval_node_init_prt eval_node_init_subevt 
@ %def eval_node_init_pdg_array eval_node_init_string
@ Initialize a leaf node with a pointer to a named parameter
<<Eval trees: procedures>>=
  subroutine eval_node_init_log_ptr (node, name, lval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    logical, intent(in), target :: lval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_LOG
    node%lval => lval
    node%value_is_known => is_known
  end subroutine eval_node_init_log_ptr

  subroutine eval_node_init_int_ptr (node, name, ival, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    integer, intent(in), target :: ival
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_INT
    node%ival => ival
    node%value_is_known => is_known
  end subroutine eval_node_init_int_ptr

  subroutine eval_node_init_real_ptr (node, name, rval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    real(default), intent(in), target :: rval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_REAL
    node%rval => rval
    node%value_is_known => is_known
  end subroutine eval_node_init_real_ptr
  
  subroutine eval_node_init_cmplx_ptr (node, name, cval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    complex(default), intent(in), target :: cval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_CMPLX
    node%cval => cval
    node%value_is_known => is_known
  end subroutine eval_node_init_cmplx_ptr

  subroutine eval_node_init_subevt_ptr (node, name, pval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    type(subevt_t), intent(in), target :: pval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_SEV
    node%pval => pval
    node%value_is_known => is_known
  end subroutine eval_node_init_subevt_ptr

  subroutine eval_node_init_pdg_array_ptr (node, name, aval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    type(pdg_array_t), intent(in), target :: aval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_PDG
    node%aval => aval
    node%value_is_known => is_known
  end subroutine eval_node_init_pdg_array_ptr

  subroutine eval_node_init_string_ptr (node, name, sval, is_known)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: name
    type(string_t), intent(in), target :: sval
    logical, intent(in), target :: is_known
    node%type = EN_VARIABLE
    node%tag = name
    node%result_type = V_STR
    node%sval => sval
    node%value_is_known => is_known
  end subroutine eval_node_init_string_ptr

@ %def eval_node_init_log_ptr eval_node_init_int_ptr 
@ %def eval_node_init_real_ptr eval_node_init_cmplx_ptr
@ %def eval_node_init_subevt_ptr eval_node_init_string_ptr
@ 
\subsubsection{Branch nodes}
Initialize a branch node, sub-nodes are given.
<<Eval trees: procedures>>=
  subroutine eval_node_init_branch (node, tag, result_type, arg1, arg2)
    type(eval_node_t), intent(out) :: node
    type(string_t), intent(in) :: tag
    integer, intent(in) :: result_type
    type(eval_node_t), intent(in), target :: arg1
    type(eval_node_t), intent(in), target, optional :: arg2
    if (present (arg2)) then
       node%type = EN_BINARY
    else
       node%type = EN_UNARY
    end if
    node%tag = tag
    node%result_type = result_type
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    if (present (arg2))  node%arg2 => arg2
  end subroutine eval_node_init_branch

@ %def eval_node_init_branch
@ Allocate the node value according to the result type.
<<Eval trees: procedures>>=
  subroutine eval_node_allocate_value (node)
    type(eval_node_t), intent(inout) :: node
    select case (node%result_type)
    case (V_LOG);  allocate (node%lval)
    case (V_INT);  allocate (node%ival)
    case (V_REAL); allocate (node%rval)
    case (V_CMPLX); allocate (node%cval)
    case (V_PDG);  allocate (node%aval)
    case (V_SEV);  allocate (node%pval)
       call subevt_init (node%pval)
    case (V_STR);  allocate (node%sval)
    end select
    allocate (node%value_is_known)
    node%value_is_known = .false.
  end subroutine eval_node_allocate_value

@ %def eval_node_allocate_value
@ Initialize a node with an observable.  This includes a
procedure pointer.  The input is a variable entry from the stack
which holds the necessary information.

The user-observable version does not contain a pointer.  The
appropriate procedure is called directly at evaluation time.
Furthermore, this is a branch node with a reference to the
string-expression node which determines the name of the user
procedure.
<<Eval trees: procedures>>=
  subroutine eval_node_init_obs (node, var, arg)
    type(eval_node_t), intent(out) :: node
    type(var_entry_t), intent(in), target :: var
    type(eval_node_t), intent(in), target, optional :: arg
    integer :: var_type
    node%tag = var_entry_get_name (var)
    var_type = var_entry_get_type (var)
    select case (var_type)
    case (V_OBS1_INT)
       node%type = EN_OBS1_INT
       call var_entry_assign_obs1_int_ptr (node%obs1_int, var)
    case (V_OBS2_INT)
       node%type = EN_OBS2_INT
       call var_entry_assign_obs2_int_ptr (node%obs2_int, var)
    case (V_OBS1_REAL)
       node%type = EN_OBS1_REAL
       call var_entry_assign_obs1_real_ptr (node%obs1_real, var)
    case (V_OBS2_REAL)
       node%type = EN_OBS2_REAL
       call var_entry_assign_obs2_real_ptr (node%obs2_real, var)
    case (V_UOBS1_INT)
       node%type = EN_UOBS1_INT
    case (V_UOBS2_INT)
       node%type = EN_UOBS2_INT
    case (V_UOBS1_REAL)
       node%type = EN_UOBS1_REAL
    case (V_UOBS2_REAL)
       node%type = EN_UOBS2_REAL
    end select
    select case (var_type)
    case (V_OBS1_INT, V_OBS2_INT, V_UOBS1_INT, V_UOBS2_INT)
       node%result_type = V_INT
       allocate (node%ival, node%value_is_known)
       node%value_is_known = .false.
    case (V_OBS1_REAL, V_OBS2_REAL, V_UOBS1_REAL, V_UOBS2_REAL)
       node%result_type = V_REAL
       allocate (node%rval, node%value_is_known)
       node%value_is_known = .false.
    end select
    select case (var_type)
    case (V_OBS1_INT, V_OBS1_REAL, V_UOBS1_INT, V_UOBS1_REAL)
       node%prt1 => var_entry_get_prt1_ptr (var)
    case (V_OBS2_INT, V_OBS2_REAL, V_UOBS2_INT, V_UOBS2_REAL)
       node%prt1 => var_entry_get_prt1_ptr (var)
       node%prt2 => var_entry_get_prt2_ptr (var)
    end select
    select case (var_type)
    case (V_UOBS1_INT, V_UOBS1_REAL, V_UOBS2_INT, V_UOBS2_REAL)
       if (present (arg))  node%arg0 => arg
    end select
  end subroutine eval_node_init_obs

@ %def eval_node_init_obs
@ Initialize a block node which contains, in addition to the
expression to be evaluated, a variable definition.  The result type is
not yet assigned, because we can compile the enclosed expression only
after the var list is set up.

Note that the node always allocates a new variable list and appends it to the
current one.  Thus, if the variable redefines an existing one, it only shadows
it but does not reset it.  Any side-effects are therefore absent and need not
be undone outside the block.

If the flag [[new]] is set, a variable is (re)declared.  This must not be done
for intrinsic variables.  Vice versa, if the variable is not existent, the
[[new]] flag is required.
<<Eval trees: procedures>>=
  subroutine eval_node_init_block (node, name, type, var_def, var_list)
    type(eval_node_t), intent(out), target :: node
    type(string_t), intent(in) :: name
    integer, intent(in) :: type
    type(eval_node_t), intent(in), target :: var_def
    type(var_list_t), intent(in), target :: var_list
    node%type = EN_BLOCK
    node%tag = "var_def"
    node%var_name = name
    node%arg1 => var_def
    allocate (node%var_list)
    call var_list_link (node%var_list, var_list)
    if (var_def%type == EN_CONSTANT) then
       select case (type)
       case (V_LOG)
          call var_list_append_log  (node%var_list, name, var_def%lval)
       case (V_INT)
          call var_list_append_int  (node%var_list, name, var_def%ival)
       case (V_REAL)
          call var_list_append_real (node%var_list, name, var_def%rval)
       case (V_CMPLX)
          call var_list_append_cmplx (node%var_list, name, var_def%cval)
       case (V_PDG)
          call var_list_append_pdg_array &
               (node%var_list, name, var_def%aval)
       case (V_SEV)
          call var_list_append_subevt &
               (node%var_list, name, var_def%pval)
       case (V_STR)
          call var_list_append_string (node%var_list, name, var_def%sval)
       end select
    else
       select case (type)
       case (V_LOG);  call var_list_append_log_ptr &
            (node%var_list, name, var_def%lval, var_def%value_is_known)
       case (V_INT);  call var_list_append_int_ptr &
            (node%var_list, name, var_def%ival, var_def%value_is_known)
       case (V_REAL); call var_list_append_real_ptr &
            (node%var_list, name, var_def%rval, var_def%value_is_known)
       case (V_CMPLX); call var_list_append_cmplx_ptr &
            (node%var_list, name, var_def%cval, var_def%value_is_known)
       case (V_PDG);  call var_list_append_pdg_array_ptr &
            (node%var_list, name, var_def%aval, var_def%value_is_known)
       case (V_SEV); call var_list_append_subevt_ptr &
            (node%var_list, name, var_def%pval, var_def%value_is_known)
       case (V_STR); call var_list_append_string_ptr &
            (node%var_list, name, var_def%sval, var_def%value_is_known)
       end select
    end if
  end subroutine eval_node_init_block

@ %def eval_node_init_block
@ Complete block initialization by assigning the expression to
evaluate to [[arg0]].
<<Eval trees: procedures>>=
  subroutine eval_node_set_expr (node, arg, result_type)
    type(eval_node_t), intent(inout) :: node
    type(eval_node_t), intent(in), target :: arg
    integer, intent(in), optional :: result_type
    if (present (result_type)) then
       node%result_type = result_type
    else
       node%result_type = arg%result_type
    end if
    call eval_node_allocate_value (node)
    node%arg0 => arg
  end subroutine eval_node_set_expr

@ %def eval_node_set_block_expr
@ Initialize a conditional.  There are three branches: the condition
(evaluates to logical) and the two alternatives (evaluate both to the
same arbitrary type).
<<Eval trees: procedures>>=
  subroutine eval_node_init_conditional (node, result_type, cond, arg1, arg2)
    type(eval_node_t), intent(out) :: node
    integer, intent(in) :: result_type
    type(eval_node_t), intent(in), target :: cond, arg1, arg2
    node%type = EN_CONDITIONAL
    node%tag = "cond"
    node%result_type = result_type
    call eval_node_allocate_value (node)
    node%arg0 => cond
    node%arg1 => arg1
    node%arg2 => arg2
  end subroutine eval_node_init_conditional

@ %def eval_node_init_conditional
@ Initialize a recording command (which evaluates to a logical
constant).  The first branch is the ID of the analysis object to be
filled, the optional branches 1 to 4 are the values to be recorded.

If the event-weight pointer is null, we record values with unit weight.
Otherwise, we use the value pointed to as event weight.

There can be up to four arguments which represent $x$, $y$, $\Delta y$,
$\Delta x$.  Therefore, this is the only node type that may fill four
sub-nodes.
<<Eval trees: procedures>>=
  subroutine eval_node_init_record_cmd &
      (node, event_weight, id, arg1, arg2, arg3, arg4)
    type(eval_node_t), intent(out) :: node
    real(default), pointer :: event_weight
    type(eval_node_t), intent(in), target :: id
    type(eval_node_t), intent(in), optional, target :: arg1, arg2, arg3, arg4
    call eval_node_init_log (node, .true.)
    node%type = EN_RECORD_CMD
    node%rval => event_weight
    node%tag = "record_cmd"
    node%arg0 => id
    if (present (arg1)) then
       node%arg1 => arg1
       if (present (arg2)) then
          node%arg2 => arg2
          if (present (arg3)) then
             node%arg3 => arg3
             if (present (arg4)) then
                node%arg4 => arg4
             end if
          end if
       end if
    end if
  end subroutine eval_node_init_record_cmd
    
@ %def eval_node_init_record_cmd
@ Initialize a node for operations on subevents.  The particle
lists (one or two) are inserted as [[arg1]] and [[arg2]].  We
allocated particle pointers as temporaries for iterating over particle
lists.  The procedure pointer which holds the function to evaluate for
the subevents (e.g., combine, select) is also initialized.  
<<Eval trees: procedures>>=
  subroutine eval_node_init_prt_fun_unary (node, arg1, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1
    type(string_t), intent(in) :: name
    procedure(unary_sev) :: proc
    node%type = EN_PRT_FUN_UNARY
    node%tag = name
    node%result_type = V_SEV
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    allocate (node%index, source = 0)
    allocate (node%prt1)
    node%op1_sev => proc
  end subroutine eval_node_init_prt_fun_unary

  subroutine eval_node_init_prt_fun_binary (node, arg1, arg2, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1, arg2
    type(string_t), intent(in) :: name
    procedure(binary_sev) :: proc
    node%type = EN_PRT_FUN_BINARY
    node%tag = name
    node%result_type = V_SEV
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    node%arg2 => arg2
    allocate (node%index, source = 0)
    allocate (node%prt1)
    allocate (node%prt2)
    node%op2_sev => proc
  end subroutine eval_node_init_prt_fun_binary

@ %def eval_node_init_prt_fun_unary eval_node_init_prt_fun_binary
@ Similar, but for particle-list functions that evaluate to a real
value.
<<Eval trees: procedures>>=
  subroutine eval_node_init_eval_fun_unary (node, arg1, name)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1
    type(string_t), intent(in) :: name
    node%type = EN_EVAL_FUN_UNARY
    node%tag = name
    node%result_type = V_REAL
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    allocate (node%index, source = 0)
    allocate (node%prt1)
  end subroutine eval_node_init_eval_fun_unary

  subroutine eval_node_init_eval_fun_binary (node, arg1, arg2, name)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1, arg2
    type(string_t), intent(in) :: name
    node%type = EN_EVAL_FUN_BINARY
    node%tag = name
    node%result_type = V_REAL
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    node%arg2 => arg2
    allocate (node%index, source = 0)
    allocate (node%prt1)
    allocate (node%prt2)
  end subroutine eval_node_init_eval_fun_binary

@ %def eval_node_init_eval_fun_unary eval_node_init_eval_fun_binary
@ These are for particle-list functions that evaluate to a logical
value.
<<Eval trees: procedures>>=
  subroutine eval_node_init_log_fun_unary (node, arg1, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1
    type(string_t), intent(in) :: name
    procedure(unary_cut) :: proc
    node%type = EN_LOG_FUN_UNARY
    node%tag = name
    node%result_type = V_LOG
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    allocate (node%index, source = 0)
    allocate (node%prt1)
    node%op1_cut => proc
  end subroutine eval_node_init_log_fun_unary

  subroutine eval_node_init_log_fun_binary (node, arg1, arg2, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1, arg2
    type(string_t), intent(in) :: name
    procedure(binary_cut) :: proc
    node%type = EN_LOG_FUN_BINARY
    node%tag = name
    node%result_type = V_LOG
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    node%arg2 => arg2
    allocate (node%index, source = 0)
    allocate (node%prt1)
    allocate (node%prt2)
    node%op2_cut => proc
  end subroutine eval_node_init_log_fun_binary

@ %def eval_node_init_log_fun_unary eval_node_init_log_fun_binary
@ These are for particle-list functions that evaluate to an integer
value.
<<Eval trees: procedures>>=
  subroutine eval_node_init_int_fun_unary (node, arg1, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1
    type(string_t), intent(in) :: name
    procedure(unary_evi) :: proc
    node%type = EN_INT_FUN_UNARY
    node%tag = name
    node%result_type = V_INT
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    allocate (node%index, source = 0)
    allocate (node%prt1)
    node%op1_evi => proc
  end subroutine eval_node_init_int_fun_unary

  subroutine eval_node_init_int_fun_binary (node, arg1, arg2, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1, arg2
    type(string_t), intent(in) :: name
    procedure(binary_evi) :: proc
    node%type = EN_INT_FUN_BINARY
    node%tag = name
    node%result_type = V_INT
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    node%arg2 => arg2
    allocate (node%index, source = 0)
    allocate (node%prt1)
    allocate (node%prt2)
    node%op2_evi => proc
  end subroutine eval_node_init_int_fun_binary

@ %def eval_node_init_int_fun_unary eval_node_init_int_fun_binary
@ These are for particle-list functions that evaluate to a real
value.
<<Eval trees: procedures>>=
  subroutine eval_node_init_real_fun_unary (node, arg1, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1
    type(string_t), intent(in) :: name
    procedure(unary_evr) :: proc
    node%type = EN_REAL_FUN_UNARY
    node%tag = name
    node%result_type = V_INT
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    allocate (node%index, source = 0)
    allocate (node%prt1)
    node%op1_evr => proc
  end subroutine eval_node_init_real_fun_unary

  subroutine eval_node_init_real_fun_binary (node, arg1, arg2, name, proc)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), intent(in), target :: arg1, arg2
    type(string_t), intent(in) :: name
    procedure(binary_evr) :: proc
    node%type = EN_REAL_FUN_BINARY
    node%tag = name
    node%result_type = V_INT
    call eval_node_allocate_value (node)
    node%arg1 => arg1
    node%arg2 => arg2
    allocate (node%index, source = 0)
    allocate (node%prt1)
    allocate (node%prt2)
    node%op2_evr => proc
  end subroutine eval_node_init_real_fun_binary

@ %def eval_node_init_real_fun_unary eval_node_init_real_fun_binary
@ Initialize a node for a string formatting function (sprintf).
<<Eval trees: procedures>>=
  subroutine eval_node_init_format_string (node, fmt, arg, name, n_args)
    type(eval_node_t), intent(out) :: node
    type(eval_node_t), pointer :: fmt, arg
    type(string_t), intent(in) :: name
    integer, intent(in) :: n_args
    node%type = EN_FORMAT_STR
    node%tag = name
    node%result_type = V_STR
    call eval_node_allocate_value (node)
    node%arg0 => fmt
    node%arg1 => arg
    allocate (node%ival)
    node%ival = n_args
  end subroutine eval_node_init_format_string

@ %def eval_node_init_format_string
@ If particle functions depend upon a condition (or an expression is
evaluated), the observables that can be evaluated for the given
particles have to be thrown on the local variable stack.  This is done
here.  Each observable is initialized with the particle pointers which
have been allocated for the node.

The integer variable that is referred to by the [[Index]]
pseudo-observable is always known when it is referred to.
<<Eval trees: procedures>>=
  subroutine eval_node_set_observables (node, var_list)
    type(eval_node_t), intent(inout) :: node
    type(var_list_t), intent(in), target :: var_list
    logical, save, target :: known = .true.
    allocate (node%var_list)
    call var_list_link (node%var_list, var_list)
    allocate (node%index, source = 0)
    call var_list_append_int_ptr &
         (node%var_list, var_str ("Index"), node%index, known, intrinsic=.true.)
    if (.not. associated (node%prt2)) then
       call var_list_set_observables_unary &
            (node%var_list, node%prt1)
    else
       call var_list_set_observables_binary &
            (node%var_list, node%prt1, node%prt2)
    end if
  end subroutine eval_node_set_observables

@ %def eval_node_set_observables
@ 
\subsubsection{Output}
<<Eval trees: procedures>>=
  subroutine eval_node_write (node, unit, indent)
    type(eval_node_t), intent(in) :: node
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, ind
    u = given_output_unit (unit);  if (u < 0)  return
    ind = 0;  if (present (indent)) ind = indent
    write (u, "(A)", advance="no")  repeat ("|  ", ind) // "o "
    select case (node%type)
    case (EN_UNARY, EN_BINARY, EN_CONDITIONAL, &
          EN_PRT_FUN_UNARY, EN_PRT_FUN_BINARY, &
          EN_EVAL_FUN_UNARY, EN_EVAL_FUN_BINARY, &
          EN_LOG_FUN_UNARY, EN_LOG_FUN_BINARY, &
          EN_INT_FUN_UNARY, EN_INT_FUN_BINARY, &
          EN_REAL_FUN_UNARY, EN_REAL_FUN_BINARY)
       write (u, "(A)", advance="no")  "[" // char (node%tag) // "] ="
    case (EN_CONSTANT)
       write (u, "(A)", advance="no")  "[const] ="
    case (EN_VARIABLE)
       write (u, "(A)", advance="no")  char (node%tag) // " =>"
    case (EN_OBS1_INT, EN_OBS2_INT, EN_OBS1_REAL, EN_OBS2_REAL, &
         EN_UOBS1_INT, EN_UOBS2_INT, EN_UOBS1_REAL, EN_UOBS2_REAL)
       write (u, "(A)", advance="no")  char (node%tag) // " ="
    case (EN_BLOCK)
       write (u, "(A)", advance="no")  "[" // char (node%tag) // "]" // &
            char (node%var_name) // " [expr] = "
    case default
       write (u, "(A)", advance="no")  "[???] ="
    end select
    select case (node%result_type)
    case (V_LOG)
       if (node%value_is_known) then
          if (node%lval) then
             write (u, "(1x,A)") "true"
          else
             write (u, "(1x,A)") "false"
          end if
       else
          write (u, "(1x,A)") "[unknown logical]"
       end if
    case (V_INT)
       if (node%value_is_known) then
          write (u, "(1x,I0)")  node%ival
       else
          write (u, "(1x,A)") "[unknown integer]"
       end if
    case (V_REAL)
       if (node%value_is_known) then
          write (u, "(1x," // FMT_19 // ")") node%rval
       else
          write (u, "(1x,A)") "[unknown real]"
       end if
   case (V_CMPLX)
       if (node%value_is_known) then
          write (u, "(1x,'('," // FMT_19 // ",','," // &
               FMT_19 // ",')')") node%cval
       else
          write (u, "(1x,A)") "[unknown complex]"
       end if
    case (V_SEV)
       if (char (node%tag) == "@evt") then
          write (u, "(1x,A)") "[event subevent]"
       else if (node%value_is_known) then
          call subevt_write &
               (node%pval, unit, prefix = repeat ("|  ", ind + 1))
       else
          write (u, "(1x,A)") "[unknown subevent]"
       end if
    case (V_PDG)
       write (u, "(1x)", advance="no")
       call pdg_array_write (node%aval, u);  write (u, *)
    case (V_STR)
       if (node%value_is_known) then
          write (u, "(A)")  '"' // char (node%sval) // '"'
       else
          write (u, "(1x,A)") "[unknown string]"
       end if
    case default
       write (u, "(1x,A)") "[empty]"
    end select
    select case (node%type)
    case (EN_OBS1_INT, EN_OBS1_REAL, EN_UOBS1_INT, EN_UOBS1_REAL)
       write (u, "(A,6x,A)", advance="no")  repeat ("|  ", ind), "prt1 ="
       call prt_write (node%prt1, unit)
    case (EN_OBS2_INT, EN_OBS2_REAL, EN_UOBS2_INT, EN_UOBS2_REAL)
       write (u, "(A,6x,A)", advance="no")  repeat ("|  ", ind), "prt1 ="
       call prt_write (node%prt1, unit)
       write (u, "(A,6x,A)", advance="no")  repeat ("|  ", ind), "prt2 ="
       call prt_write (node%prt2, unit)
    end select
  end subroutine eval_node_write

  recursive subroutine eval_node_write_rec (node, unit, indent)
    type(eval_node_t), intent(in) :: node
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, ind
    u = given_output_unit (unit);  if (u < 0)  return
    ind = 0;  if (present (indent))  ind = indent
    call eval_node_write (node, unit, indent)
    select case (node%type)
    case (EN_UNARY)
       if (associated (node%arg0)) &
            call eval_node_write_rec (node%arg0, unit, ind+1)
       call eval_node_write_rec (node%arg1, unit, ind+1)
    case (EN_BINARY)
       if (associated (node%arg0)) &
            call eval_node_write_rec (node%arg0, unit, ind+1)
       call eval_node_write_rec (node%arg1, unit, ind+1)
       call eval_node_write_rec (node%arg2, unit, ind+1)
    case (EN_BLOCK)
       call eval_node_write_rec (node%arg1, unit, ind+1)
       call eval_node_write_rec (node%arg0, unit, ind+1)
    case (EN_CONDITIONAL)
       call eval_node_write_rec (node%arg0, unit, ind+1)
       call eval_node_write_rec (node%arg1, unit, ind+1)
       call eval_node_write_rec (node%arg2, unit, ind+1)
    case (EN_PRT_FUN_UNARY, EN_EVAL_FUN_UNARY, &
          EN_LOG_FUN_UNARY, EN_INT_FUN_UNARY, EN_REAL_FUN_UNARY)
       if (associated (node%arg0)) &
            call eval_node_write_rec (node%arg0, unit, ind+1)
       call eval_node_write_rec (node%arg1, unit, ind+1)
    case (EN_PRT_FUN_BINARY, EN_EVAL_FUN_BINARY, &
          EN_LOG_FUN_BINARY, EN_INT_FUN_BINARY, EN_REAL_FUN_BINARY)
       if (associated (node%arg0)) &
            call eval_node_write_rec (node%arg0, unit, ind+1)
       call eval_node_write_rec (node%arg1, unit, ind+1)
       call eval_node_write_rec (node%arg2, unit, ind+1)
    case (EN_RECORD_CMD)
       if (associated (node%arg1)) then
          call eval_node_write_rec (node%arg1, unit, ind+1)
          if (associated (node%arg2)) then
             call eval_node_write_rec (node%arg2, unit, ind+1)
             if (associated (node%arg3)) then
                call eval_node_write_rec (node%arg3, unit, ind+1)
                if (associated (node%arg4)) then
                   call eval_node_write_rec (node%arg4, unit, ind+1)
                end if
             end if
          end if
       end if
    end select
  end subroutine eval_node_write_rec

@ %def eval_node_write eval_node_write_rec
@ 
\subsection{Operation types}
For the operations associated to evaluation tree nodes, we define
abstract interfaces for all cases.

Particles/subevents are transferred by-reference, to avoid
unnecessary copying.  Therefore, subroutines instead of functions.
(Furthermore, the function version of [[unary_prt]] triggers an obscure
bug in nagfor 5.2(649) [invalid C code].)
<<Eval trees: interfaces>>=
  abstract interface
     logical function unary_log (arg)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg
     end function unary_log
  end interface
  abstract interface
     integer function unary_int (arg)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg
     end function unary_int
  end interface
  abstract interface
     real(default) function unary_real (arg)
       import default
       import eval_node_t
       type(eval_node_t), intent(in) :: arg
     end function unary_real
  end interface
  abstract interface
     complex(default) function unary_cmplx (arg)
       import default
       import eval_node_t
       type(eval_node_t), intent(in) :: arg
     end function unary_cmplx
  end interface
  abstract interface
     subroutine unary_pdg (pdg_array, arg)
       import pdg_array_t
       import eval_node_t
       type(pdg_array_t), intent(out) :: pdg_array
       type(eval_node_t), intent(in) :: arg
     end subroutine unary_pdg
  end interface
  abstract interface
     subroutine unary_sev (subevt, arg, arg0)
       import subevt_t
       import eval_node_t
       type(subevt_t), intent(inout) :: subevt
       type(eval_node_t), intent(in) :: arg
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine unary_sev
  end interface
  abstract interface
     subroutine unary_str (string, arg)
       import string_t
       import eval_node_t
       type(string_t), intent(out) :: string
       type(eval_node_t), intent(in) :: arg
     end subroutine unary_str
  end interface
  abstract interface
     logical function unary_cut (arg1, arg0)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1
       type(eval_node_t), intent(inout) :: arg0
     end function unary_cut
  end interface
  abstract interface
     subroutine unary_evi (ival, arg1, arg0)
       import eval_node_t
       integer, intent(out) :: ival
       type(eval_node_t), intent(in) :: arg1
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine unary_evi
  end interface
  abstract interface
     subroutine unary_evr (rval, arg1, arg0)
       import eval_node_t, default
       real(default), intent(out) :: rval
       type(eval_node_t), intent(in) :: arg1
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine unary_evr
  end interface
  abstract interface
     logical function binary_log (arg1, arg2)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1, arg2
     end function binary_log
  end interface
  abstract interface
     integer function binary_int (arg1, arg2)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1, arg2
     end function binary_int
  end interface
  abstract interface
     real(default) function binary_real (arg1, arg2)
       import default
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1, arg2
     end function binary_real
  end interface
  abstract interface
     complex(default) function binary_cmplx (arg1, arg2)
       import default
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1, arg2
     end function binary_cmplx
  end interface
  abstract interface
     subroutine binary_pdg (pdg_array, arg1, arg2)
       import pdg_array_t
       import eval_node_t
       type(pdg_array_t), intent(out) :: pdg_array
       type(eval_node_t), intent(in) :: arg1, arg2
     end subroutine binary_pdg
  end interface
  abstract interface
     subroutine binary_sev (subevt, arg1, arg2, arg0)
       import subevt_t
       import eval_node_t
       type(subevt_t), intent(inout) :: subevt
       type(eval_node_t), intent(in) :: arg1, arg2
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine binary_sev
  end interface
  abstract interface
     subroutine binary_str (string, arg1, arg2)
       import string_t
       import eval_node_t
       type(string_t), intent(out) :: string
       type(eval_node_t), intent(in) :: arg1, arg2
     end subroutine binary_str
  end interface
  abstract interface
     logical function binary_cut (arg1, arg2, arg0)
       import eval_node_t
       type(eval_node_t), intent(in) :: arg1, arg2
       type(eval_node_t), intent(inout) :: arg0
     end function binary_cut
  end interface
  abstract interface
     subroutine binary_evi (ival, arg1, arg2, arg0)
       import eval_node_t
       integer, intent(out) :: ival
       type(eval_node_t), intent(in) :: arg1, arg2
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine binary_evi
  end interface
  abstract interface
     subroutine binary_evr (rval, arg1, arg2, arg0)
       import eval_node_t, default
       real(default), intent(out) :: rval
       type(eval_node_t), intent(in) :: arg1, arg2
       type(eval_node_t), intent(inout), optional :: arg0
     end subroutine binary_evr
  end interface

@ The following subroutines set the procedure pointer:
<<Eval trees: procedures>>=
  subroutine eval_node_set_op1_log (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_log) :: op
    en%op1_log => op
    end subroutine eval_node_set_op1_log
  
  subroutine eval_node_set_op1_int (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_int) :: op
    en%op1_int => op
  end subroutine eval_node_set_op1_int

  subroutine eval_node_set_op1_real (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_real) :: op
    en%op1_real => op
  end subroutine eval_node_set_op1_real
  
  subroutine eval_node_set_op1_cmplx (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_cmplx) :: op
    en%op1_cmplx => op
  end subroutine eval_node_set_op1_cmplx

  subroutine eval_node_set_op1_pdg (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_pdg) :: op
    en%op1_pdg => op
  end subroutine eval_node_set_op1_pdg

  subroutine eval_node_set_op1_sev (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_sev) :: op
    en%op1_sev => op
  end subroutine eval_node_set_op1_sev

  subroutine eval_node_set_op1_str (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(unary_str) :: op
    en%op1_str => op
  end subroutine eval_node_set_op1_str

  subroutine eval_node_set_op2_log (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_log) :: op
    en%op2_log => op
  end subroutine eval_node_set_op2_log

  subroutine eval_node_set_op2_int (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_int) :: op
    en%op2_int => op
  end subroutine eval_node_set_op2_int

  subroutine eval_node_set_op2_real (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_real) :: op
    en%op2_real => op
  end subroutine eval_node_set_op2_real
  
  subroutine eval_node_set_op2_cmplx (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_cmplx) :: op
    en%op2_cmplx => op
  end subroutine eval_node_set_op2_cmplx

  subroutine eval_node_set_op2_pdg (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_pdg) :: op
    en%op2_pdg => op
  end subroutine eval_node_set_op2_pdg

  subroutine eval_node_set_op2_sev (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_sev) :: op
    en%op2_sev => op
  end subroutine eval_node_set_op2_sev

  subroutine eval_node_set_op2_str (en, op)
    type(eval_node_t), intent(inout) :: en
    procedure(binary_str) :: op
    en%op2_str => op
  end subroutine eval_node_set_op2_str

@ %def eval_node_set_operator
@ 
\subsection{Specific operators}

Our expression syntax contains all Fortran functions that make sense.
These functions have to be provided in a form that they can be used in
procedures pointers, and have the abstract interfaces above.
For some intrinsic functions, we could use specific versions provided
by Fortran directly.  However, this has two drawbacks: (i) We should
work with the values instead of the eval-nodes as argument, which
complicates the interface; (ii) more importantly, the [[default]] real
type need not be equivalent to double precision.  This would, at
least, introduce system dependencies.  Finally, for operators there
are no specific versions.

Therefore, we write wrappers for all possible functions, at the
expense of some overhead.
\subsubsection{Binary numerical functions}
<<Eval trees: procedures>>=
  integer function add_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival + en2%ival
  end function add_ii
  real(default) function add_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival + en2%rval
  end function add_ir
  complex(default) function add_ic (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival + en2%cval
  end function add_ic
  real(default) function add_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval + en2%ival
  end function add_ri
  complex(default) function add_ci (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval + en2%ival
  end function add_ci
  complex(default) function add_cr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval + en2%rval
  end function add_cr
  complex(default) function add_rc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval + en2%cval
  end function add_rc
  real(default) function add_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval + en2%rval
  end function add_rr
  complex(default) function add_cc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval + en2%cval
  end function add_cc

  integer function sub_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival - en2%ival
  end function sub_ii
  real(default) function sub_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival - en2%rval
  end function sub_ir
  real(default) function sub_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval - en2%ival
  end function sub_ri  
  complex(default) function sub_ic (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival - en2%cval
  end function sub_ic
  complex(default) function sub_ci (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval - en2%ival
  end function sub_ci  
  complex(default) function sub_cr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval - en2%rval
  end function sub_cr
  complex(default) function sub_rc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval - en2%cval
  end function sub_rc
  real(default) function sub_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval - en2%rval
  end function sub_rr
  complex(default) function sub_cc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval - en2%cval
  end function sub_cc

  integer function mul_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival * en2%ival
  end function mul_ii
  real(default) function mul_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival * en2%rval
  end function mul_ir
  real(default) function mul_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval * en2%ival
  end function mul_ri
  complex(default) function mul_ic (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival * en2%cval
  end function mul_ic
  complex(default) function mul_ci (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval * en2%ival
  end function mul_ci
  complex(default) function mul_rc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval * en2%cval
  end function mul_rc
  complex(default) function mul_cr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval * en2%rval
  end function mul_cr
  real(default) function mul_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval * en2%rval
  end function mul_rr
  complex(default) function mul_cc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval * en2%cval
  end function mul_cc

  integer function div_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (en2%ival == 0) then
       if (en1%ival >= 0) then
          call msg_warning ("division by zero: " // int2char (en1%ival) // &
             " / 0 ; result set to 0")
       else
          call msg_warning ("division by zero: (" // int2char (en1%ival) // &
             ") / 0 ; result set to 0")
       end if
       y = 0
       return
    end if
    y = en1%ival / en2%ival
  end function div_ii
  real(default) function div_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival / en2%rval
  end function div_ir
  real(default) function div_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval / en2%ival
  end function div_ri
  complex(default) function div_ic (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival / en2%cval
  end function div_ic
  complex(default) function div_ci (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval / en2%ival
  end function div_ci
  complex(default) function div_rc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval / en2%cval
  end function div_rc
  complex(default) function div_cr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval / en2%rval
  end function div_cr
  real(default) function div_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval / en2%rval
  end function div_rr
  complex(default) function div_cc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval / en2%cval
  end function div_cc

  integer function pow_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    integer :: a, b
    real(default) :: rres
    a = en1%ival
    b = en2%ival
    if ((a == 0) .and. (b < 0)) then
       call msg_warning ("division by zero: " // int2char (a) // &
          " ^ (" // int2char (b) // ") ; result set to 0")
       y = 0
       return
    end if
    rres = real(a, default) ** b
    y = rres
    if (real(y, default) /= rres) then
       if (b < 0) then
          call msg_warning ("result of all-integer operation " // &
                int2char (a) // " ^ (" // int2char (b) // &
                ") has been trucated to "// int2char (y), &
             [  var_str ("Chances are that you want to use " // &
                "reals instead of integers at this point.") ])
       else
          call msg_warning ("integer overflow in " // int2char (a) // &
                " ^ " // int2char (b) // " ; result is " // int2char (y), &
             [  var_str ("Using reals instead of integers might help.")])
       end if
    end if
  end function pow_ii
  real(default) function pow_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval ** en2%ival
  end function pow_ri
  complex(default) function pow_ci (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval ** en2%ival
  end function pow_ci
  real(default) function pow_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival ** en2%rval
  end function pow_ir
  real(default) function pow_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval ** en2%rval
  end function pow_rr
  complex(default) function pow_cr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval ** en2%rval
  end function pow_cr
  complex(default) function pow_ic (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival ** en2%cval
  end function pow_ic
  complex(default) function pow_rc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval ** en2%cval
  end function pow_rc
  complex(default) function pow_cc (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%cval ** en2%cval
  end function pow_cc

  integer function max_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = max (en1%ival, en2%ival)
  end function max_ii
  real(default) function max_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = max (real (en1%ival, default), en2%rval)
  end function max_ir
  real(default) function max_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = max (en1%rval, real (en2%ival, default))
  end function max_ri
  real(default) function max_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = max (en1%rval, en2%rval)
  end function max_rr
  integer function min_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = min (en1%ival, en2%ival)
  end function min_ii
  real(default) function min_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = min (real (en1%ival, default), en2%rval)
  end function min_ir
  real(default) function min_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = min (en1%rval, real (en2%ival, default))
  end function min_ri
  real(default) function min_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = min (en1%rval, en2%rval)
  end function min_rr

  integer function mod_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = mod (en1%ival, en2%ival)
  end function mod_ii
  real(default) function mod_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = mod (real (en1%ival, default), en2%rval)
  end function mod_ir
  real(default) function mod_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = mod (en1%rval, real (en2%ival, default))
  end function mod_ri
  real(default) function mod_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = mod (en1%rval, en2%rval)
  end function mod_rr
  integer function modulo_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = modulo (en1%ival, en2%ival)
  end function modulo_ii
  real(default) function modulo_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = modulo (real (en1%ival, default), en2%rval)
  end function modulo_ir
  real(default) function modulo_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = modulo (en1%rval, real (en2%ival, default))
  end function modulo_ri
  real(default) function modulo_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = modulo (en1%rval, en2%rval)
  end function modulo_rr

@ 
\subsubsection{Unary numeric functions}
<<Eval trees: procedures>>=
  real(default) function real_i (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%ival
  end function real_i
  real(default) function real_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%cval
  end function real_c
  integer function int_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%rval
  end function int_r
  complex(default) function cmplx_i (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%ival
  end function cmplx_i
  integer function int_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%cval
  end function int_c 
  complex(default) function cmplx_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = en%rval
  end function cmplx_r  
  integer function nint_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = nint (en%rval)
  end function nint_r
  integer function floor_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = floor (en%rval)
  end function floor_r
  integer function ceiling_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = ceiling (en%rval)
  end function ceiling_r

  integer function neg_i (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = - en%ival
  end function neg_i
  real(default) function neg_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = - en%rval
  end function neg_r
  complex(default) function neg_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = - en%cval
  end function neg_c
  integer function abs_i (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = abs (en%ival)
  end function abs_i
  real(default) function abs_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = abs (en%rval)
  end function abs_r
  real(default) function abs_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = abs (en%cval)
  end function abs_c
  integer function sgn_i (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sign (1, en%ival)
  end function sgn_i
  real(default) function sgn_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sign (1._default, en%rval)
  end function sgn_r

  real(default) function sqrt_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sqrt (en%rval)
  end function sqrt_r
  real(default) function exp_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = exp (en%rval)
  end function exp_r
  real(default) function log_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = log (en%rval)
  end function log_r
  real(default) function log10_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = log10 (en%rval)
  end function log10_r
  
  complex(default) function sqrt_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sqrt (en%cval)
  end function sqrt_c
  complex(default) function exp_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = exp (en%cval)
  end function exp_c
  complex(default) function log_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = log (en%cval)
  end function log_c

  real(default) function sin_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sin (en%rval)
  end function sin_r
  real(default) function cos_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = cos (en%rval)
  end function cos_r
  real(default) function tan_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = tan (en%rval)
  end function tan_r
  real(default) function asin_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = asin (en%rval)
  end function asin_r
  real(default) function acos_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = acos (en%rval)
  end function acos_r
  real(default) function atan_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = atan (en%rval)
  end function atan_r
  
  complex(default) function sin_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sin (en%cval)
  end function sin_c
  complex(default) function cos_c (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = cos (en%cval)
  end function cos_c
  
  real(default) function sinh_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = sinh (en%rval)
  end function sinh_r
  real(default) function cosh_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = cosh (en%rval)
  end function cosh_r
  real(default) function tanh_r (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = tanh (en%rval)
  end function tanh_r
!!! These are F2008 additions but accepted by nagfor 5.3 and gfortran 4.6+
!!! Currently not used.
!   real(default) function asinh_r (en) result (y)
!     type(eval_node_t), intent(in) :: en
!     y = asinh (en%rval)
!   end function asinh_r
!   real(default) function acosh_r (en) result (y)
!     type(eval_node_t), intent(in) :: en
!     y = acosh (en%rval)
!   end function acosh_r
!   real(default) function atanh_r (en) result (y)
!     type(eval_node_t), intent(in) :: en
!     y = atanh (en%rval)
!   end function atanh_r
  
@
\subsubsection{Binary logical functions}
Logical expressions:
<<Eval trees: procedures>>=
  logical function ignore_first_ll (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en2%lval
  end function ignore_first_ll
  logical function or_ll (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%lval .or. en2%lval
  end function or_ll
  logical function and_ll (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%lval .and. en2%lval
  end function and_ll

@ Comparisons:
<<Eval trees: procedures>>=
  logical function comp_lt_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival < en2%ival
  end function comp_lt_ii
  logical function comp_lt_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival < en2%rval
  end function comp_lt_ir
  logical function comp_lt_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval < en2%ival
  end function comp_lt_ri
  logical function comp_lt_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval < en2%rval
  end function comp_lt_rr
  
  logical function comp_gt_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival > en2%ival
  end function comp_gt_ii
  logical function comp_gt_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival > en2%rval
  end function comp_gt_ir
  logical function comp_gt_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval > en2%ival
  end function comp_gt_ri
  logical function comp_gt_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval > en2%rval
  end function comp_gt_rr
  
  logical function comp_le_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival <= en2%ival
  end function comp_le_ii
  logical function comp_le_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival <= en2%rval
  end function comp_le_ir
  logical function comp_le_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval <= en2%ival
  end function comp_le_ri
  logical function comp_le_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval <= en2%rval
  end function comp_le_rr
  
  logical function comp_ge_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival >= en2%ival
  end function comp_ge_ii
  logical function comp_ge_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival >= en2%rval
  end function comp_ge_ir
  logical function comp_ge_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval >= en2%ival
  end function comp_ge_ri
  logical function comp_ge_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval >= en2%rval
  end function comp_ge_rr
  
  logical function comp_eq_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival == en2%ival
  end function comp_eq_ii
  logical function comp_eq_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival == en2%rval
  end function comp_eq_ir
  logical function comp_eq_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval == en2%ival
  end function comp_eq_ri
  logical function comp_eq_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval == en2%rval
  end function comp_eq_rr
  logical function comp_eq_ss (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%sval == en2%sval
  end function comp_eq_ss
  
  logical function comp_ne_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival /= en2%ival
  end function comp_ne_ii
  logical function comp_ne_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%ival /= en2%rval
  end function comp_ne_ir
  logical function comp_ne_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval /= en2%ival
  end function comp_ne_ri
  logical function comp_ne_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%rval /= en2%rval
  end function comp_ne_rr
  logical function comp_ne_ss (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    y = en1%sval /= en2%sval
  end function comp_ne_ss
  
@ Comparisons with tolerance:
<<Eval trees: procedures>>=
  logical function comp_se_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%ival - en2%ival) <= en1%tolerance
    else
       y = en1%ival == en2%ival
    end if
  end function comp_se_ii
  logical function comp_se_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%rval - en2%ival) <= en1%tolerance
    else
       y = en1%rval == en2%ival
    end if
  end function comp_se_ri
  logical function comp_se_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%ival - en2%rval) <= en1%tolerance
    else
       y = en1%ival == en2%rval
    end if
  end function comp_se_ir
  logical function comp_se_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%rval - en2%rval) <= en1%tolerance
    else
       y = en1%rval == en2%rval
    end if
  end function comp_se_rr
  logical function comp_ns_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%ival - en2%ival) > en1%tolerance
    else
       y = en1%ival /= en2%ival
    end if
  end function comp_ns_ii
  logical function comp_ns_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%rval - en2%ival) > en1%tolerance
    else
       y = en1%rval /= en2%ival
    end if
  end function comp_ns_ri
  logical function comp_ns_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%ival - en2%rval) > en1%tolerance
    else
       y = en1%ival /= en2%rval
    end if
  end function comp_ns_ir
  logical function comp_ns_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = abs (en1%rval - en2%rval) > en1%tolerance
    else
       y = en1%rval /= en2%rval
    end if
  end function comp_ns_rr
  
  logical function comp_ls_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival <= en2%ival + en1%tolerance
    else
       y = en1%ival <= en2%ival
    end if
  end function comp_ls_ii
  logical function comp_ls_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval <= en2%ival + en1%tolerance
    else
       y = en1%rval <= en2%ival
    end if
  end function comp_ls_ri
  logical function comp_ls_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival <= en2%rval + en1%tolerance
    else
       y = en1%ival <= en2%rval
    end if
  end function comp_ls_ir
  logical function comp_ls_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval <= en2%rval + en1%tolerance
    else
       y = en1%rval <= en2%rval
    end if
  end function comp_ls_rr

  logical function comp_ll_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival < en2%ival - en1%tolerance
    else
       y = en1%ival < en2%ival
    end if
  end function comp_ll_ii
  logical function comp_ll_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval < en2%ival - en1%tolerance
    else
       y = en1%rval < en2%ival
    end if
  end function comp_ll_ri
  logical function comp_ll_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival < en2%rval - en1%tolerance
    else
       y = en1%ival < en2%rval
    end if
  end function comp_ll_ir
  logical function comp_ll_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval < en2%rval - en1%tolerance
    else
       y = en1%rval < en2%rval
    end if
  end function comp_ll_rr

  logical function comp_gs_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival >= en2%ival - en1%tolerance
    else
       y = en1%ival >= en2%ival
    end if
  end function comp_gs_ii
  logical function comp_gs_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval >= en2%ival - en1%tolerance
    else
       y = en1%rval >= en2%ival
    end if
  end function comp_gs_ri
  logical function comp_gs_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival >= en2%rval - en1%tolerance
    else
       y = en1%ival >= en2%rval
    end if
  end function comp_gs_ir
  logical function comp_gs_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval >= en2%rval - en1%tolerance
    else
       y = en1%rval >= en2%rval
    end if
  end function comp_gs_rr

  logical function comp_gg_ii (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival > en2%ival + en1%tolerance
    else
       y = en1%ival > en2%ival
    end if
  end function comp_gg_ii
  logical function comp_gg_ri (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval > en2%ival + en1%tolerance
    else
       y = en1%rval > en2%ival
    end if
  end function comp_gg_ri
  logical function comp_gg_ir (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%ival > en2%rval + en1%tolerance
    else
       y = en1%ival > en2%rval
    end if
  end function comp_gg_ir
  logical function comp_gg_rr (en1, en2) result (y)
    type(eval_node_t), intent(in) :: en1, en2
    if (associated (en1%tolerance)) then
       y = en1%rval > en2%rval + en1%tolerance
    else
       y = en1%rval > en2%rval
    end if
  end function comp_gg_rr

@ 
\subsubsection{Unary logical functions}
<<Eval trees: procedures>>=
  logical function not_l (en) result (y)
    type(eval_node_t), intent(in) :: en
    y = .not. en%lval
  end function not_l

@
\subsubsection{Unary PDG-array functions}
Make a PDG-array object from an integer.
<<Eval trees: procedures>>=
  subroutine pdg_i (pdg_array, en)
    type(pdg_array_t), intent(out) :: pdg_array
    type(eval_node_t), intent(in) :: en
    pdg_array = en%ival
  end subroutine pdg_i

@ 
\subsubsection{Binary PDG-array functions}
Concatenate two PDG-array objects.
<<Eval trees: procedures>>=
  subroutine concat_cc (pdg_array, en1, en2)
    type(pdg_array_t), intent(out) :: pdg_array
    type(eval_node_t), intent(in) :: en1, en2
    pdg_array = en1%aval // en2%aval
  end subroutine concat_cc

@
\subsubsection{Unary particle-list functions}
Combine all particles of the first argument.  If [[en0]] is present,
create a mask which is true only for those particles that pass the
test.
<<Eval trees: procedures>>=
  subroutine collect_p (subevt, en1, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask1
    integer :: n, i
    n = subevt_get_length (en1%pval)
    allocate (mask1 (n))
    if (present (en0)) then
       do i = 1, n
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          call eval_node_evaluate (en0)
          mask1(i) = en0%lval
       end do
    else
       mask1 = .true.
    end if
    call subevt_collect (subevt, en1%pval, mask1)
  end subroutine collect_p

@ %def collect_p
@ Cluster the particles of the first argument.  If [[en0]] is present,
create a mask which is true only for those particles that pass the
test.
<<Eval trees: procedures>>=
  subroutine cluster_p (subevt, en1, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask1
    integer :: n, i
    ! Should not be hardcoded!
    type(jet_definition_t) :: jet_def
    call jet_def%init (en1%jet_algorithm, en1%jet_r)
    n = subevt_get_length (en1%pval)
    allocate (mask1 (n))
    if (present (en0)) then
       do i = 1, n
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          call eval_node_evaluate (en0)
          mask1(i) = en0%lval
       end do
    else
       mask1 = .true.
    end if
    call subevt_cluster (subevt, en1%pval, mask1, jet_def)
    call jet_def%final ()
  end subroutine cluster_p

@ %def cluster_p
@ Select all particles of the first argument.  If [[en0]] is present,
create a mask which is true only for those particles that pass the
test.
<<Eval trees: procedures>>=
  subroutine select_p (subevt, en1, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask1
    integer :: n, i
    n = subevt_get_length (en1%pval)
    allocate (mask1 (n))
    if (present (en0)) then
       do i = 1, subevt_get_length (en1%pval)
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          call eval_node_evaluate (en0)
          mask1(i) = en0%lval
       end do
    else
       mask1 = .true.
    end if
    call subevt_select (subevt, en1%pval, mask1)
  end subroutine select_p

@ %def select_p
@ Extract the particle with index given by [[en0]] from the argument
list.  Negative indices count from the end.  If [[en0]] is absent,
extract the first particle.  The result is a list with a single entry,
or no entries if the original list was empty or if the index is out of
range.

This function has no counterpart with two arguments.
<<Eval trees: procedures>>=
  subroutine extract_p (subevt, en1, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    integer :: index
    if (present (en0)) then
       call eval_node_evaluate (en0)
       select case (en0%result_type)
       case (V_INT);  index = en0%ival
       case default
          call eval_node_write (en0)
          call msg_fatal (" Index parameter of 'extract' must be integer.")
       end select
    else
       index = 1
    end if
    call subevt_extract (subevt, en1%pval, index)
  end subroutine extract_p

@ %def extract_p
@ Sort the subevent according to the result of evaluating
[[en0]].  If [[en0]] is absent, sort by default method (PDG code,
particles before antiparticles).
<<Eval trees: procedures>>=
  subroutine sort_p (subevt, en1, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    integer, dimension(:), allocatable :: ival
    real(default), dimension(:), allocatable :: rval
    integer :: i, n
    n = subevt_get_length (en1%pval)
    if (present (en0)) then
       select case (en0%result_type)
       case (V_INT);  allocate (ival (n))
       case (V_REAL); allocate (rval (n))
       end select
       do i = 1, n
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          call eval_node_evaluate (en0)
          select case (en0%result_type)
          case (V_INT);  ival(i) = en0%ival
          case (V_REAL); rval(i) = en0%rval
          end select
       end do
       select case (en0%result_type)
       case (V_INT);  call subevt_sort (subevt, en1%pval, ival)
       case (V_REAL); call subevt_sort (subevt, en1%pval, rval)
       end select
    else
       call subevt_sort (subevt, en1%pval)
    end if
  end subroutine sort_p

@ %def sort_p
@ The following functions return a logical value.  [[all]] evaluates
to true if the condition [[en0]] is true for all elements of the
subevent.  [[any]] and [[no]] are analogous.
<<Eval trees: procedures>>=
  function all_p (en1, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout) :: en0
    integer :: i, n
    n = subevt_get_length (en1%pval)
    lval = .true.
    do i = 1, n
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       call eval_node_evaluate (en0)
       lval = en0%lval
       if (.not. lval)  exit
    end do
  end function all_p
       
  function any_p (en1, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout) :: en0
    integer :: i, n
    n = subevt_get_length (en1%pval)
    lval = .false.
    do i = 1, n
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       call eval_node_evaluate (en0)
       lval = en0%lval
       if (lval)  exit
    end do
  end function any_p
       
  function no_p (en1, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout) :: en0
    integer :: i, n
    n = subevt_get_length (en1%pval)
    lval = .true.
    do i = 1, n
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       call eval_node_evaluate (en0)
       lval = .not. en0%lval
       if (lval)  exit
    end do
  end function no_p
       
@ %def all_p any_p no_p
@ This is the interface to user-supplied observables.  The node [[en0]]
evaluates to a string that indicates the procedure name.  We search for the
procedure in the dynamic library and load it into the procedure pointer which
is then called.  [[en1]] is the subevent on which the external code
operates.  The external function returns a [[c_int]], which we translate
into a real value.
<<Eval trees: procedures>>=
  function user_obs_int_p (en0, prt1) result (ival)
    integer :: ival
    type(eval_node_t), intent(inout) :: en0
    type(prt_t), intent(in) :: prt1
    type(string_t) :: name
    procedure(user_obs_int_unary), pointer :: user_obs
    call eval_node_evaluate (en0)
    if (en0%value_is_known) then
       select case (en0%result_type)
       case (V_STR);  name = en0%sval
       case default
          call msg_bug ("user_obs: procedure name must be a string")
          name = ""
       end select
       call c_f_procpointer (user_code_find_proc (name), user_obs)
       ival = user_obs (c_prt (prt1))
    else
       call eval_node_write_rec (en0)
       call msg_fatal ("User observable name is undefined")
    end if
  end function user_obs_int_p

  function user_obs_real_p (en0, prt1) result (rval)
    real(default) :: rval
    type(eval_node_t), intent(inout) :: en0
    type(prt_t), intent(in) :: prt1
    type(string_t) :: name
    procedure(user_obs_real_unary), pointer :: user_obs
    call eval_node_evaluate (en0)
    if (en0%value_is_known) then
       select case (en0%result_type)
       case (V_STR);  name = en0%sval
       case default
          call msg_bug ("user_obs: procedure name must be a string")
          name = ""
       end select
       call c_f_procpointer (user_code_find_proc (name), user_obs)
       rval = user_obs (c_prt (prt1))
    else
       call eval_node_write_rec (en0)
       call msg_fatal ("User observable name is undefined")
    end if
  end function user_obs_real_p

@ %def user_obs_int_p
@ %def user_obs_real_p
@ This is the interface to user-supplied cut code.  The node [[en0]]
evaluates to a string that indicates the procedure name.
<<Eval trees: procedures>>=
  function user_cut_p (en1, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout) :: en0
    type(string_t) :: name
    procedure(user_cut_fun), pointer :: user_cut
    call eval_node_evaluate (en0)
    select case (en0%result_type)
    case (V_STR);  name = en0%sval
    case default
       call msg_bug ("user_cut: procedure name must be a string")
       name = ""
    end select
    call c_f_procpointer (user_code_find_proc (name), user_cut)
    lval = user_cut (c_prt (en1%pval), &
                     int (subevt_get_length (en1%pval), kind=c_int)) &
           /= 0
  end function user_cut_p

@ %def user_cut_p
@ The following function returns an integer value, namely the number
of particles for which the condition is true.  If there is no
condition, it returns simply the length of the subevent.

A function would be more natural.  Making it a subroutine avoids
another compiler bug (internal error in nagfor 5.2 (649)).  (See the
interface [[unary_evi]].)
<<Eval trees: procedures>>=
  subroutine count_a (ival, en1, en0)
    integer, intent(out) :: ival
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    integer :: i, n, count
    n = subevt_get_length (en1%pval)
    if (present (en0)) then
       count = 0
       do i = 1, n
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          call eval_node_evaluate (en0)
          if (en0%lval)  count = count + 1
       end do
       ival = count
    else
       ival = n
    end if
  end subroutine count_a
       
@ %def count_a
@ This evaluates a user-defined event-shape observable for the current
subevent.
<<Eval trees: procedures>>=
  subroutine user_event_shape_a (rval, en1, en0)
    real(default), intent(out) :: rval
    type(eval_node_t), intent(in) :: en1
    type(eval_node_t), intent(inout), optional :: en0
    type(string_t) :: name
    procedure(user_event_shape_fun), pointer :: user_event_shape
    if (.not. present (en0))  call msg_bug &
         ("user_event_shape called without procedure name")
    call eval_node_evaluate (en0)
    select case (en0%result_type)
    case (V_STR);  name = en0%sval
    case default
       call msg_bug ("user_event_shape: procedure name must be a string")
       name = ""
    end select
    call c_f_procpointer (user_code_find_proc (name), user_event_shape)
    rval = user_event_shape (c_prt (en1%pval), &
                             int (subevt_get_length (en1%pval), kind=c_int))
  end subroutine user_event_shape_a
       
@ %def user_event_shape_a
@
\subsubsection{Binary particle-list functions}
This joins two subevents, stored in the evaluation nodes [[en1]]
and [[en2]].  If [[en0]] is also present, it amounts to a logical test
returning true or false for every pair of particles.  A particle of
the second list gets a mask entry only if it passes the test for all
particles of the first list.
<<Eval trees: procedures>>= 
  subroutine join_pp (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask2
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    allocate (mask2 (n2))
    mask2 = .true.
    if (present (en0)) then
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          do j = 1, n2
             en0%prt2 = subevt_get_prt (en2%pval, j)
             call eval_node_evaluate (en0)
             mask2(j) = mask2(j) .and. en0%lval
          end do
       end do
    end if
    call subevt_join (subevt, en1%pval, en2%pval, mask2)
  end subroutine join_pp

@ %def join_pp
@ Combine two subevents, i.e., make a list of composite particles
built from all possible particle pairs from the two lists.  If [[en0]]
is present, create a mask which is true only for those pairs that pass
the test.
<<Eval trees: procedures>>= 
  subroutine combine_pp (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:,:), allocatable :: mask12
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    if (present (en0)) then
       allocate (mask12 (n1, n2))
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          do j = 1, n2
             en0%prt2 = subevt_get_prt (en2%pval, j)
             call eval_node_evaluate (en0)
             mask12(i,j) = en0%lval
          end do
       end do
       call subevt_combine (subevt, en1%pval, en2%pval, mask12)
    else
       call subevt_combine (subevt, en1%pval, en2%pval)
    end if
  end subroutine combine_pp

@ %def combine_pp
@ Combine all particles of the first argument.  If [[en0]] is present,
create a mask which is true only for those particles that pass the
test w.r.t. all particles in the second argument.  If [[en0]] is
absent, the second argument is ignored.
<<Eval trees: procedures>>=
  subroutine collect_pp (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask1
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    allocate (mask1 (n1))
    mask1 = .true.
    if (present (en0)) then
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          do j = 1, n2
             en0%prt2 = subevt_get_prt (en2%pval, j)
             call eval_node_evaluate (en0)
             mask1(i) = mask1(i) .and. en0%lval
          end do
       end do
    end if
    call subevt_collect (subevt, en1%pval, mask1)
  end subroutine collect_pp

@ %def collect_pp
@ Select all particles of the first argument.  If [[en0]] is present,
create a mask which is true only for those particles that pass the
test w.r.t. all particles in the second argument.  If [[en0]] is
absent, the second argument is ignored, and the first argument is
transferred unchanged.  (This case is not very useful, of course.)
<<Eval trees: procedures>>=
  subroutine select_pp (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    logical, dimension(:), allocatable :: mask1
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    allocate (mask1 (n1))
    mask1 = .true.
    if (present (en0)) then
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          do j = 1, n2
             en0%prt2 = subevt_get_prt (en2%pval, j)
             call eval_node_evaluate (en0)
             mask1(i) = mask1(i) .and. en0%lval
          end do
       end do
    end if
    call subevt_select (subevt, en1%pval, mask1)
  end subroutine select_pp

@ %def select_pp
@ Sort the first subevent according to the result of evaluating
[[en0]].  From the second subevent, only the first element is
taken as reference.  If [[en0]] is absent, we sort by default method
(PDG code, particles before antiparticles).
<<Eval trees: procedures>>=
  subroutine sort_pp (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    integer, dimension(:), allocatable :: ival
    real(default), dimension(:), allocatable :: rval
    integer :: i, n1
    n1 = subevt_get_length (en1%pval)
    if (present (en0)) then
       select case (en0%result_type)
       case (V_INT);  allocate (ival (n1))
       case (V_REAL); allocate (rval (n1))
       end select
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          en0%prt2 = subevt_get_prt (en2%pval, 1)
          call eval_node_evaluate (en0)
          select case (en0%result_type)
          case (V_INT);  ival(i) = en0%ival
          case (V_REAL); rval(i) = en0%rval
          end select
       end do
       select case (en0%result_type)
       case (V_INT);  call subevt_sort (subevt, en1%pval, ival)
       case (V_REAL); call subevt_sort (subevt, en1%pval, rval)
       end select
    else
       call subevt_sort (subevt, en1%pval)
    end if
  end subroutine sort_pp

@ %def sort_pp
@ The following functions return a logical value.  [[all]] evaluates
to true if the condition [[en0]] is true for all valid element pairs
of both subevents.  Invalid pairs (with common [[src]] entry) are
ignored.

[[any]] and [[no]] are analogous.
<<Eval trees: procedures>>=
  function all_pp (en1, en2, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout) :: en0
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    lval = .true.
    LOOP1: do i = 1, n1
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       do j = 1, n2
          en0%prt2 = subevt_get_prt (en2%pval, j)
          if (are_disjoint (en0%prt1, en0%prt2)) then
             call eval_node_evaluate (en0)
             lval = en0%lval
             if (.not. lval)  exit LOOP1
          end if
       end do
    end do LOOP1
  end function all_pp
       
  function any_pp (en1, en2, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout) :: en0
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    lval = .false.
    LOOP1: do i = 1, n1
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       do j = 1, n2
          en0%prt2 = subevt_get_prt (en2%pval, j)
          if (are_disjoint (en0%prt1, en0%prt2)) then
             call eval_node_evaluate (en0)
             lval = en0%lval
             if (lval)  exit LOOP1
          end if
       end do
    end do LOOP1
  end function any_pp
       
  function no_pp (en1, en2, en0) result (lval)
    logical :: lval
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout) :: en0
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    lval = .true.
    LOOP1: do i = 1, n1
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       do j = 1, n2
          en0%prt2 = subevt_get_prt (en2%pval, j)
          if (are_disjoint (en0%prt1, en0%prt2)) then
             call eval_node_evaluate (en0)
             lval = .not. en0%lval
             if (lval)  exit LOOP1
          end if
       end do
    end do LOOP1
  end function no_pp
       
@ %def all_pp any_pp no_pp
@ This function evaluates an observable for a pair of particles.  From the two
particle lists, we take the first pair without [[src]] overlap.  If there is
no valid pair, we revert the status of the value to unknown.
<<Eval trees: procedures>>=
  subroutine eval_pp (en1, en2, en0, rval, is_known)
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout) :: en0
    real(default), intent(out) :: rval
    logical, intent(out) :: is_known
    integer :: i, j, n1, n2
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    rval = 0
    is_known = .false.
    LOOP1: do i = 1, n1
       en0%index = i
       en0%prt1 = subevt_get_prt (en1%pval, i)
       do j = 1, n2
          en0%prt2 = subevt_get_prt (en2%pval, j)
          if (are_disjoint (en0%prt1, en0%prt2)) then
             call eval_node_evaluate (en0)
             rval = en0%rval
             is_known = .true.
             exit LOOP1
          end if
       end do
    end do LOOP1
  end subroutine eval_pp

@ %def eval_pp
@ This is the interface to user-supplied observables.  The node [[en0]]
evaluates to a string that indicates the procedure name.  We search for the
procedure in the dynamic library and load it into the procedure pointer which
is then called.  [[en1]] is the subevent on which the external code
operates.  The external function returns a [[c_int]], which we translate
into a real value.
<<Eval trees: procedures>>=
  function user_obs_int_pp (en0, prt1, prt2) result (ival)
    integer :: ival
    type(eval_node_t), intent(inout) :: en0
    type(prt_t), intent(in) :: prt1, prt2
    type(string_t) :: name
    procedure(user_obs_int_binary), pointer :: user_obs
    call eval_node_evaluate (en0)
    if (en0%value_is_known) then
       select case (en0%result_type)
       case (V_STR);  name = en0%sval
       case default
          call msg_bug ("user_obs: procedure name must be a string")
          name = ""
       end select
       call c_f_procpointer (user_code_find_proc (name), user_obs)
       ival = user_obs (c_prt (prt1), c_prt (prt2))
    else
       call eval_node_write_rec (en0)
       call msg_fatal ("User observable name is undefined")
    end if
  end function user_obs_int_pp

  function user_obs_real_pp (en0, prt1, prt2) result (rval)
    real(default) :: rval
    type(eval_node_t), intent(inout) :: en0
    type(prt_t), intent(in) :: prt1, prt2
    type(string_t) :: name
    procedure(user_obs_real_binary), pointer :: user_obs
    call eval_node_evaluate (en0)
    if (en0%value_is_known) then
       select case (en0%result_type)
       case (V_STR);  name = en0%sval
       case default
          call msg_bug ("user_obs: procedure name must be a string")
          name = ""
       end select
       call c_f_procpointer (user_code_find_proc (name), user_obs)
       rval = user_obs (c_prt (prt1), c_prt (prt2))
    else
       call eval_node_write_rec (en0)
       call msg_fatal ("User observable name is undefined")
    end if
  end function user_obs_real_pp

@ %def user_obs_int_pp
@ %def user_obs_real_pp
@ The following function returns an integer value, namely the number
of valid particle-pairs from both lists for which the condition is
true.  Invalid pairs (with common [[src]] entry) are ignored.  If
there is no condition, it returns the number of valid particle pairs.

A function would be more natural.  Making it a subroutine avoids
another compiler bug (internal error in nagfor 5.2 (649)).  (See the
interface [[binary_num]].)
<<Eval trees: procedures>>=
  subroutine count_pp (ival, en1, en2, en0)
    integer, intent(out) :: ival
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    integer :: i, j, n1, n2, count
    n1 = subevt_get_length (en1%pval)
    n2 = subevt_get_length (en2%pval)
    if (present (en0)) then
       count = 0
       do i = 1, n1
          en0%index = i
          en0%prt1 = subevt_get_prt (en1%pval, i)
          do j = 1, n2
             en0%prt2 = subevt_get_prt (en2%pval, j)
             if (are_disjoint (en0%prt1, en0%prt2)) then
                call eval_node_evaluate (en0)
                if (en0%lval)  count = count + 1
             end if
          end do
       end do
    else
       count = 0
       do i = 1, n1
          do j = 1, n2
             if (are_disjoint (subevt_get_prt (en1%pval, i), &
                               subevt_get_prt (en2%pval, j))) then
                count = count + 1
             end if
          end do
       end do
    end if
    ival = count
  end subroutine count_pp
       
@ %def count_pp
@ This function makes up a subevent from the second argument
which consists only of particles which match the PDG code array (first
argument).
<<Eval trees: procedures>>=
  subroutine select_pdg_ca (subevt, en1, en2, en0)
    type(subevt_t), intent(inout) :: subevt
    type(eval_node_t), intent(in) :: en1, en2
    type(eval_node_t), intent(inout), optional :: en0
    if (present (en0)) then
       call subevt_select_pdg_code (subevt, en1%aval, en2%pval, en0%ival)
    else
       call subevt_select_pdg_code (subevt, en1%aval, en2%pval)
    end if
  end subroutine select_pdg_ca

@ %def select_pdg_ca
@ 
\subsubsection{Binary string functions}
Currently, the only string operation is concatenation.
<<Eval trees: procedures>>=
  subroutine concat_ss (string, en1, en2)
    type(string_t), intent(out) :: string
    type(eval_node_t), intent(in) :: en1, en2
    string = en1%sval // en2%sval
  end subroutine concat_ss

@ %def concat_ss
@
\subsection{Compiling the parse tree}
The evaluation tree is built recursively by following a parse tree.
Debug option:
<<Eval trees: variables>>=
  logical, parameter :: debug = .false.

@ %def debug
@ Evaluate an expression.  The requested type is given as an optional
argument; default is numeric (integer or real).
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_genexpr &
       (en, pn, var_list, result_type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in), optional :: result_type
    if (debug) then
       print *, "read genexpr";  call parse_node_write (pn)
    end if
    if (present (result_type)) then
       select case (result_type)
       case (V_INT, V_REAL, V_CMPLX)
          call eval_node_compile_expr  (en, pn, var_list)
       case (V_LOG)
          call eval_node_compile_lexpr (en, pn, var_list)
       case (V_SEV)
          call eval_node_compile_pexpr (en, pn, var_list)
       case (V_PDG)
          call eval_node_compile_cexpr (en, pn, var_list)
       case (V_STR)
          call eval_node_compile_sexpr (en, pn, var_list)
       end select
    else
       call eval_node_compile_expr  (en, pn, var_list)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done genexpr"
    end if
  end subroutine eval_node_compile_genexpr
  
@ %def eval_node_compile_genexpr
@
\subsubsection{Numeric expressions}
This procedure compiles a numerical expression.  This is a single term
or a sum or difference of terms.  We have to account for all
combinations of integer and real arguments.  If both are constant, we
immediately do the calculation and allocate a constant node.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_expr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_term, pn_addition, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(string_t) :: key
    integer :: t1, t2, t
    if (debug) then
       print *, "read expr";  call parse_node_write (pn)
    end if
    pn_term => parse_node_get_sub_ptr (pn)
    select case (char (parse_node_get_rule_key (pn_term)))
    case ("term")
       call eval_node_compile_term (en, pn_term, var_list)
       pn_addition => parse_node_get_next_ptr (pn_term, tag="addition")
    case ("addition")
       en => null ()
       pn_addition => pn_term
    case default
       call parse_node_mismatch ("term|addition", pn)
    end select
    do while (associated (pn_addition))
       pn_op => parse_node_get_sub_ptr (pn_addition)
       pn_arg => parse_node_get_next_ptr (pn_op, tag="term")
       call eval_node_compile_term (en2, pn_arg, var_list)
       t2 = en2%result_type
       if (associated (en)) then
          en1 => en
          t1 = en1%result_type
       else
          allocate (en1)
          select case (t2)
          case (V_INT);  call eval_node_init_int  (en1, 0)
          case (V_REAL); call eval_node_init_real (en1, 0._default)
          case (V_CMPLX); call eval_node_init_cmplx (en1, cmplx &
                         (0._default, 0._default, kind=default))
          end select
          t1 = t2
       end if
       t = numeric_result_type (t1, t2)
       allocate (en)
       key = parse_node_get_key (pn_op)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          select case (char (key))
          case ("+")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);  call eval_node_init_int  (en, add_ii (en1, en2))
                case (V_REAL); call eval_node_init_real (en, add_ir (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, add_ic (en1, en2))
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);  call eval_node_init_real (en, add_ri (en1, en2))
                case (V_REAL); call eval_node_init_real (en, add_rr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, add_rc (en1, en2))
                end select
              case (V_CMPLX)
                select case (t2)
                case (V_INT);  call eval_node_init_cmplx (en, add_ci (en1, en2))
                case (V_REAL); call eval_node_init_cmplx (en, add_cr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, add_cc (en1, en2))
                end select
             end select
          case ("-")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);  call eval_node_init_int  (en, sub_ii (en1, en2))
                case (V_REAL); call eval_node_init_real (en, sub_ir (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, sub_ic (en1, en2))                
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);  call eval_node_init_real (en, sub_ri (en1, en2))
                case (V_REAL); call eval_node_init_real (en, sub_rr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, sub_rc (en1, en2))                
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);  call eval_node_init_cmplx (en, sub_ci (en1, en2))
                case (V_REAL); call eval_node_init_cmplx (en, sub_cr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, sub_cc (en1, en2))                
                end select
             end select
          end select
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch (en, key, t, en1, en2)
          select case (char (key))
          case ("+")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_int  (en, add_ii)
                case (V_REAL);  call eval_node_set_op2_real (en, add_ir)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, add_ic)
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_real (en, add_ri)
                case (V_REAL);  call eval_node_set_op2_real (en, add_rr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, add_rc)
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_cmplx (en, add_ci)
                case (V_REAL);  call eval_node_set_op2_cmplx (en, add_cr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, add_cc)
                end select
             end select
          case ("-")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_int  (en, sub_ii)
                case (V_REAL);  call eval_node_set_op2_real (en, sub_ir)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, sub_ic)
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_real (en, sub_ri)
                case (V_REAL);  call eval_node_set_op2_real (en, sub_rr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, sub_rc)
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_cmplx (en, sub_ci)
                case (V_REAL);  call eval_node_set_op2_cmplx (en, sub_cr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, sub_cc)
                end select
             end select
          end select
       end if
       pn_addition => parse_node_get_next_ptr (pn_addition)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done expr"
    end if
  end subroutine eval_node_compile_expr

@ %def eval_node_compile_expr
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_term (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_factor, pn_multiplication, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(string_t) :: key
    integer :: t1, t2, t
    if (debug) then
       print *, "read term";  call parse_node_write (pn)
    end if
    pn_factor => parse_node_get_sub_ptr (pn, tag="factor")
    call eval_node_compile_factor (en, pn_factor, var_list)
    pn_multiplication => &
         parse_node_get_next_ptr (pn_factor, tag="multiplication")
    do while (associated (pn_multiplication))
       pn_op => parse_node_get_sub_ptr (pn_multiplication)
       pn_arg => parse_node_get_next_ptr (pn_op, tag="factor")
       en1 => en
       call eval_node_compile_factor (en2, pn_arg, var_list)
       t1 = en1%result_type
       t2 = en2%result_type
       t = numeric_result_type (t1, t2)
       allocate (en)
       key = parse_node_get_key (pn_op)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          select case (char (key))
          case ("*")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);  call eval_node_init_int  (en, mul_ii (en1, en2))
                case (V_REAL); call eval_node_init_real (en, mul_ir (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, mul_ic (en1, en2))
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);  call eval_node_init_real (en, mul_ri (en1, en2))
                case (V_REAL); call eval_node_init_real (en, mul_rr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, mul_rc (en1, en2))
                end select
              case (V_CMPLX)
                select case (t2)
                case (V_INT);  call eval_node_init_cmplx (en, mul_ci (en1, en2))
                case (V_REAL); call eval_node_init_cmplx (en, mul_cr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, mul_cc (en1, en2))
                end select
             end select
          case ("/")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);  call eval_node_init_int  (en, div_ii (en1, en2))
                case (V_REAL); call eval_node_init_real (en, div_ir (en1, en2))
                case (V_CMPLX); call eval_node_init_real (en, div_ir (en1, en2))
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);  call eval_node_init_real (en, div_ri (en1, en2))
                case (V_REAL); call eval_node_init_real (en, div_rr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, div_rc (en1, en2))
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);  call eval_node_init_cmplx (en, div_ci (en1, en2))
                case (V_REAL); call eval_node_init_cmplx (en, div_cr (en1, en2))
                case (V_CMPLX); call eval_node_init_cmplx (en, div_cc (en1, en2))
                end select
             end select
          end select
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else
          call eval_node_init_branch (en, key, t, en1, en2)
          select case (char (key))
          case ("*")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_int  (en, mul_ii)
                case (V_REAL);  call eval_node_set_op2_real (en, mul_ir)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, mul_ic)
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_real (en, mul_ri)
                case (V_REAL);  call eval_node_set_op2_real (en, mul_rr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, mul_rc)                
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_cmplx (en, mul_ci)
                case (V_REAL);  call eval_node_set_op2_cmplx (en, mul_cr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, mul_cc)                
                end select
             end select
          case ("/")
             select case (t1)
             case (V_INT)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_int  (en, div_ii)
                case (V_REAL);  call eval_node_set_op2_real (en, div_ir)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, div_ic)                
                end select
             case (V_REAL)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_real (en, div_ri)
                case (V_REAL);  call eval_node_set_op2_real (en, div_rr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, div_rc)                
                end select
             case (V_CMPLX)
                select case (t2)
                case (V_INT);   call eval_node_set_op2_cmplx (en, div_ci)
                case (V_REAL);  call eval_node_set_op2_cmplx (en, div_cr)
                case (V_CMPLX);  call eval_node_set_op2_cmplx (en, div_cc)                
                end select
             end select
          end select
       end if
       pn_multiplication => parse_node_get_next_ptr (pn_multiplication)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done term"
    end if
  end subroutine eval_node_compile_term

@ %def eval_node_compile_term
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_factor (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_value, pn_exponentiation, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(string_t) :: key
    integer :: t1, t2, t
    if (debug) then
       print *, "read factor";  call parse_node_write (pn)
    end if
    pn_value => parse_node_get_sub_ptr (pn)
    call eval_node_compile_signed_value (en, pn_value, var_list)
    pn_exponentiation => &
         parse_node_get_next_ptr (pn_value, tag="exponentiation")
    if (associated (pn_exponentiation)) then
       pn_op => parse_node_get_sub_ptr (pn_exponentiation)
       pn_arg => parse_node_get_next_ptr (pn_op)
       en1 => en
       call eval_node_compile_signed_value (en2, pn_arg, var_list)
       t1 = en1%result_type
       t2 = en2%result_type
       t = numeric_result_type (t1, t2)
       allocate (en)
       key = parse_node_get_key (pn_op)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);   call eval_node_init_int   (en, pow_ii (en1, en2))
             case (V_REAL);  call eval_node_init_real  (en, pow_ir (en1, en2))
             case (V_CMPLX); call eval_node_init_cmplx (en, pow_ic (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);   call eval_node_init_real  (en, pow_ri (en1, en2))
             case (V_REAL);  call eval_node_init_real  (en, pow_rr (en1, en2))
             case (V_CMPLX); call eval_node_init_cmplx (en, pow_rc (en1, en2))
             end select
          case (V_CMPLX)
             select case (t2)
             case (V_INT);   call eval_node_init_cmplx (en, pow_ci (en1, en2))
             case (V_REAL);  call eval_node_init_cmplx (en, pow_cr (en1, en2))
             case (V_CMPLX); call eval_node_init_cmplx (en, pow_cc (en1, en2))
             end select
          end select
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else
          call eval_node_init_branch (en, key, t, en1, en2)
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);   call eval_node_set_op2_int  (en, pow_ii)
             case (V_REAL,V_CMPLX);  call eval_type_error (pn, "exponentiation", t1)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);   call eval_node_set_op2_real (en, pow_ri)
             case (V_REAL);  call eval_node_set_op2_real (en, pow_rr)
             case (V_CMPLX);  call eval_type_error (pn, "exponentiation", t1)
             end select
          case (V_CMPLX)
             select case (t2)
             case (V_INT);   call eval_node_set_op2_cmplx (en, pow_ci)
             case (V_REAL);  call eval_node_set_op2_cmplx (en, pow_cr)
             case (V_CMPLX);  call eval_node_set_op2_cmplx (en, pow_cc)
             end select
          end select
       end if
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done factor"
    end if
  end subroutine eval_node_compile_factor

@ %def eval_node_compile_factor
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_signed_value (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_arg
    type(eval_node_t), pointer :: en1
    integer :: t
    if (debug) then
       print *, "read signed value";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("signed_value")
       pn_arg => parse_node_get_sub_ptr (pn, 2)
       call eval_node_compile_value (en1, pn_arg, var_list)
       t = en1%result_type
       allocate (en)
       if (en1%type == EN_CONSTANT) then
          select case (t)
          case (V_INT);  call eval_node_init_int  (en, neg_i (en1))
          case (V_REAL); call eval_node_init_real (en, neg_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, neg_c (en1))          
          end select
          call eval_node_final_rec (en1)
          deallocate (en1)
       else
          call eval_node_init_branch (en, var_str ("-"), t, en1)
          select case (t)
          case (V_INT);  call eval_node_set_op1_int  (en, neg_i)
          case (V_REAL); call eval_node_set_op1_real (en, neg_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, neg_c)          
          end select
       end if
    case default
       call eval_node_compile_value (en, pn, var_list)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done signed value"
    end if
  end subroutine eval_node_compile_signed_value

@ %def eval_node_compile_signed_value
@ Integer, real and complex values have an optional unit.  The unit is
extracted and applied immediately.  An integer with unit evaluates to
a real constant.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_value (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    if (debug) then
       print *, "read value";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("integer_value", "real_value", "complex_value")
       call eval_node_compile_numeric_value (en, pn)
    case ("pi")
       call eval_node_compile_constant (en, pn)
    case ("I")
       call eval_node_compile_constant (en, pn)       
    case ("variable")
       call eval_node_compile_variable (en, pn, var_list)
    case ("result")
       call eval_node_compile_result (en, pn, var_list)
    case ("user_observable")
       call eval_node_compile_user_observable (en, pn, var_list)
    case ("expr")
       call eval_node_compile_expr (en, pn, var_list)
    case ("block_expr")
       call eval_node_compile_block_expr (en, pn, var_list)
    case ("conditional_expr")
       call eval_node_compile_conditional (en, pn, var_list)
    case ("unary_function")
       call eval_node_compile_unary_function (en, pn, var_list)
    case ("binary_function")
       call eval_node_compile_binary_function (en, pn, var_list)
    case ("eval_fun")
       call eval_node_compile_eval_function (en, pn, var_list)
    case ("count_fun", "user_event_fun")
       call eval_node_compile_numeric_function (en, pn, var_list)
    case default
       call parse_node_mismatch &
            ("integer|real|complex|constant|variable|" // &
             "expr|block_expr|conditional_expr|" // &
             "unary_function|binary_function|numeric_pexpr", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done value"
    end if
  end subroutine eval_node_compile_value

@ %def eval_node_compile_value
@ Real, complex and integer values are numeric literals with an
optional unit attached.  In case of an integer, the unit actually
makes it a real value in disguise.  The signed version of real values
is not possible in generic expressions; it is a special case for
numeric constants in model files (see below). We do not introduce
signed versions of complex values.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_numeric_value (en, pn)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_val, pn_unit
    allocate (en)
    pn_val => parse_node_get_sub_ptr (pn)
    pn_unit => parse_node_get_next_ptr (pn_val)
    select case (char (parse_node_get_rule_key (pn)))
    case ("integer_value")
       if (associated (pn_unit)) then
          call eval_node_init_real (en, &
               parse_node_get_integer (pn_val) * parse_node_get_unit (pn_unit))
       else
          call eval_node_init_int (en, parse_node_get_integer (pn_val))
       end if
    case ("real_value")
       if (associated (pn_unit)) then
          call eval_node_init_real (en, &
               parse_node_get_real (pn_val) * parse_node_get_unit (pn_unit))
       else
          call eval_node_init_real (en, parse_node_get_real (pn_val))
       end if
    case ("complex_value")
       if (associated (pn_unit)) then
          call eval_node_init_cmplx (en, &
               parse_node_get_cmplx (pn_val) * parse_node_get_unit (pn_unit))
       else
          call eval_node_init_cmplx (en, parse_node_get_cmplx (pn_val))
       end if
    case ("neg_real_value")
       pn_val => parse_node_get_sub_ptr (parse_node_get_sub_ptr (pn, 2))
       pn_unit => parse_node_get_next_ptr (pn_val)
       if (associated (pn_unit)) then
          call eval_node_init_real (en, &
               - parse_node_get_real (pn_val) * parse_node_get_unit (pn_unit))
       else
          call eval_node_init_real (en, - parse_node_get_real (pn_val))
       end if
    case ("pos_real_value")
       pn_val => parse_node_get_sub_ptr (parse_node_get_sub_ptr (pn, 2))
       pn_unit => parse_node_get_next_ptr (pn_val)
       if (associated (pn_unit)) then
          call eval_node_init_real (en, &
               parse_node_get_real (pn_val) * parse_node_get_unit (pn_unit))
       else
          call eval_node_init_real (en, parse_node_get_real (pn_val))
       end if
    case default
       call parse_node_mismatch &
       ("integer_value|real_value|complex_value|neg_real_value|pos_real_value", pn)
    end select
  end subroutine eval_node_compile_numeric_value
    
@ %def eval_node_compile_numeric_value
@ These are the units, predefined and hardcoded.  The default energy
unit is GeV, the default angular unit is radians.  We include units
for observables of dimension energy squared.  Luminosities are
normalized in inverse femtobarns.
<<Eval trees: procedures>>=
  function parse_node_get_unit (pn) result (factor)
    real(default) :: factor
    real(default) :: unit
    type(parse_node_t), intent(in) :: pn
    type(parse_node_t), pointer :: pn_unit, pn_unit_power 
    type(parse_node_t), pointer :: pn_frac, pn_num, pn_int, pn_div, pn_den
    integer :: num, den
    pn_unit => parse_node_get_sub_ptr (pn)
    select case (char (parse_node_get_key (pn_unit)))
    case ("TeV");  unit = 1.e3_default
    case ("GeV");  unit = 1
    case ("MeV");  unit = 1.e-3_default
    case ("keV");  unit = 1.e-6_default
    case ("eV");   unit = 1.e-9_default
    case ("meV");   unit = 1.e-12_default
    case ("nbarn");  unit = 1.e6_default
    case ("pbarn");  unit = 1.e3_default
    case ("fbarn");  unit = 1
    case ("abarn");  unit = 1.e-3_default
    case ("rad");     unit = 1
    case ("mrad");    unit = 1.e-3_default
    case ("degree");  unit = degree
    case ("%");  unit = 1.e-2_default
    case default
       call msg_bug (" Unit '" // &
            char (parse_node_get_key (pn)) // "' is undefined.")
    end select
    pn_unit_power => parse_node_get_next_ptr (pn_unit)
    if (associated (pn_unit_power)) then
       pn_frac => parse_node_get_sub_ptr (pn_unit_power, 2)
       pn_num => parse_node_get_sub_ptr (pn_frac)
       select case (char (parse_node_get_rule_key (pn_num)))
       case ("neg_int")
          pn_int => parse_node_get_sub_ptr (pn_num, 2)
          num = - parse_node_get_integer (pn_int)
       case ("pos_int")
          pn_int => parse_node_get_sub_ptr (pn_num, 2)
          num = parse_node_get_integer (pn_int)
       case ("integer_literal")
          num = parse_node_get_integer (pn_num)
       case default
          call parse_node_mismatch ("neg_int|pos_int|integer_literal", pn_num)
       end select
       pn_div => parse_node_get_next_ptr (pn_num)
       if (associated (pn_div)) then
          pn_den => parse_node_get_sub_ptr (pn_div, 2)
          den = parse_node_get_integer (pn_den)
       else
          den = 1
       end if
    else
       num = 1
       den = 1
    end if
    factor = unit ** (real (num, default) / den)
  end function parse_node_get_unit

@ %def parse_node_get_unit
@ There are only two predefined constants, but more can be added easily.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_constant (en, pn)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    if (debug) then
       print *, "read constant";  call parse_node_write (pn)
    end if
    allocate (en)
    select case (char (parse_node_get_key (pn)))
    case ("pi");     call eval_node_init_real (en, pi)
    case ("I");      call eval_node_init_cmplx (en, imago)    
    case default
       call parse_node_mismatch ("pi or I", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done constant"
    end if
  end subroutine eval_node_compile_constant

@ %def eval_node_compile_constant
@ Compile a variable, with or without a specified type.
Take the list of variables, look for the name and make a node with a
pointer to the value.  If no type is provided, the variable is
numeric, and the stored value determines whether it is real or integer.

We explicitly demand that the variable is defined, so we do not accidentally
point to variables that are declared only later in the script but have come
into existence in a previous compilation pass.

Variables may actually be anonymous, these are expressions in disguise.  In
that case, the expression replaces the variable name in the parse tree, and we
allocate an ordinary expression node in the eval tree.

Variables of type [[V_PDG]] (pdg-code array) are not treated here.
They are handled by [[eval_node_compile_cvariable]].
<<Eval trees: procedures>>=    
  recursive subroutine eval_node_compile_variable (en, pn, var_list, var_type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in), optional :: var_type
    type(parse_node_t), pointer :: pn_name
    type(string_t) :: var_name
    type(var_entry_t), pointer :: var
    logical, target, save :: no_lval
    real(default), target, save :: no_rval
    type(subevt_t), target, save :: no_pval
    type(string_t), target, save :: no_sval
    logical, target, save :: unknown = .false.
    if (debug) then
       print *, "read variable";  call parse_node_write (pn)
    end if
    if (present (var_type)) then
       select case (var_type)
       case (V_REAL, V_OBS1_REAL, V_OBS2_REAL, V_INT, V_OBS1_INT, &
                V_OBS2_INT, V_CMPLX)
          pn_name => pn
       case default
          pn_name => parse_node_get_sub_ptr (pn, 2)
       end select
    else
       pn_name => pn
    end if
    select case (char (parse_node_get_rule_key (pn_name)))
    case ("expr")
       call eval_node_compile_expr (en, pn_name, var_list)
    case ("lexpr")
       call eval_node_compile_lexpr (en, pn_name, var_list)
    case ("sexpr")
       call eval_node_compile_sexpr (en, pn_name, var_list)
    case ("pexpr")
       call eval_node_compile_pexpr (en, pn_name, var_list)
    case ("variable")
       var_name = parse_node_get_string (pn_name)
       if (present (var_type)) then
          select case (var_type)
          case (V_LOG);  var_name = "?" // var_name
          case (V_SEV);  var_name = "@" // var_name
          case (V_STR);  var_name = "$" // var_name   ! $ sign
          end select
       end if
       var => var_list_get_var_ptr &
            (var_list, var_name, var_type, defined=.true.)
       allocate (en)
       if (associated (var)) then
          select case (var_entry_get_type (var))
          case (V_LOG)
             call eval_node_init_log_ptr &
                  (en, var_entry_get_name (var), var_entry_get_lval_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_INT)
             call eval_node_init_int_ptr &
                  (en, var_entry_get_name (var), var_entry_get_ival_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_REAL)
             call eval_node_init_real_ptr &
                  (en, var_entry_get_name (var), var_entry_get_rval_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_CMPLX)
             call eval_node_init_cmplx_ptr &
                  (en, var_entry_get_name (var), var_entry_get_cval_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_SEV)
             call eval_node_init_subevt_ptr &
                  (en, var_entry_get_name (var), var_entry_get_pval_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_STR)
             call eval_node_init_string_ptr &
                  (en, var_entry_get_name (var), var_entry_get_sval_ptr (var), &
                   var_entry_get_known_ptr (var))
          case (V_OBS1_INT, V_OBS2_INT, V_OBS1_REAL, V_OBS2_REAL)
             call eval_node_init_obs  (en, var)
          case default
             call parse_node_write (pn)
             call msg_fatal ("Variable of this type " // &
                  "is not allowed in the present context")
             if (present (var_type)) then
                select case (var_type)
                case (V_LOG)
                   call eval_node_init_log_ptr (en, var_name, no_lval, unknown)
                case (V_SEV)
                   call eval_node_init_subevt_ptr &
                        (en, var_name, no_pval, unknown)
                case (V_STR)
                   call eval_node_init_string_ptr &
                        (en, var_name, no_sval, unknown)
                end select
             else
                call eval_node_init_real_ptr (en, var_name, no_rval, unknown)
             end if
          end select
       else
          call parse_node_write (pn)
          call msg_error ("This variable is undefined at this point")
          if (present (var_type)) then
             select case (var_type)
             case (V_LOG)
                call eval_node_init_log_ptr (en, var_name, no_lval, unknown)
             case (V_SEV)
                call eval_node_init_subevt_ptr &
                     (en, var_name, no_pval, unknown)
             case (V_STR)
                call eval_node_init_string_ptr (en, var_name, no_sval, unknown)
             end select
          else
             call eval_node_init_real_ptr (en, var_name, no_rval, unknown)
          end if
       end if
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done variable"
    end if
  end subroutine eval_node_compile_variable

@ %def eval_node_compile_variable
@ In a given context, a variable has to have a certain type.
<<Eval trees: procedures>>=
  subroutine check_var_type (pn, ok, type_actual, type_requested)
    type(parse_node_t), intent(in) :: pn
    logical, intent(out) :: ok
    integer, intent(in) :: type_actual
    integer, intent(in), optional :: type_requested
    if (present (type_requested)) then
       select case (type_requested)
       case (V_LOG)
          select case (type_actual)
          case (V_LOG)
          case default
             call parse_node_write (pn)
             call msg_fatal ("Variable type is invalid (should be logical)")
             ok = .false.
          end select
       case (V_SEV)
          select case (type_actual)
          case (V_SEV)
          case default
             call parse_node_write (pn)
             call msg_fatal &
                  ("Variable type is invalid (should be particle set)")
             ok = .false.
          end select
       case (V_PDG)
          select case (type_actual)
          case (V_PDG)
          case default
             call parse_node_write (pn)
             call msg_fatal &
                  ("Variable type is invalid (should be PDG array)")
             ok = .false.
          end select
       case (V_STR)
          select case (type_actual)
          case (V_STR)
          case default
             call parse_node_write (pn)
             call msg_fatal &
                  ("Variable type is invalid (should be string)")
             ok = .false.
          end select
       case default
          call parse_node_write (pn)
          call msg_bug ("Variable type is unknown")
       end select
    else
       select case (type_actual)
       case (V_REAL, V_OBS1_REAL, V_OBS2_REAL, V_INT, V_OBS1_INT, &
                V_OBS2_INT, V_CMPLX)
       case default
          call parse_node_write (pn)
          call msg_fatal ("Variable type is invalid (should be numeric)")
          ok = .false.
       end select
    end if
    ok = .true.
  end subroutine check_var_type

@ %def check_var_type
@ Retrieve the result of an integration.  If the requested process has
been integrated, the results are available as special variables.  (The
variables cannot be accessed in the usual way since they contain
brackets in their names.)

Since this compilation step may occur before the processes have been
loaded, we have to initialize the required variables before they are
used.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_result (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_key, pn_prc_id
    type(string_t) :: key, prc_id, var_name
    type(var_entry_t), pointer :: var
    if (debug) then
       print *, "read result";  call parse_node_write (pn)
    end if
    pn_key => parse_node_get_sub_ptr (pn)
    pn_prc_id => parse_node_get_next_ptr (pn_key)
    key = parse_node_get_key (pn_key)
    prc_id = parse_node_get_string (pn_prc_id)
    var_name = key // "(" // prc_id // ")"
    var => var_list_get_var_ptr (var_list, var_name)
    if (associated (var)) then
       allocate (en)
       select case (char(key))
       case ("num_id", "n_calls")
          call eval_node_init_int_ptr &
               (en, var_name, var_entry_get_ival_ptr (var), &
               var_entry_get_known_ptr (var))
       case ("integral", "error")
          call eval_node_init_real_ptr &
               (en, var_name, var_entry_get_rval_ptr (var), &
            var_entry_get_known_ptr (var))
       end select
    else
       call msg_fatal ("Result variable '" // char (var_name) &
            // "' is undefined (call 'integrate' before use)")
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done result"
    end if
  end subroutine eval_node_compile_result

@ %def eval_node_compile_result
@ This user observable behaves like a variable.  We link the node to
the generic user-observable entry in the variable list.  The syntax
element has an argument which provides the name of the user variable,
this is stored as an eval-node alongside with the variable.  When the
variable value is used, the user-supplied external function is called
and provides the (real) result value.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_user_observable (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_key, pn_arg, pn_obs
    type(eval_node_t), pointer :: en0
    integer :: res_type
    type(string_t) :: var_name
    type(var_entry_t), pointer :: var
    if (debug) then
       print *, "read user observable";  call parse_node_write (pn)
    end if
    pn_key => parse_node_get_sub_ptr (pn)
    select case (char (parse_node_get_key (pn_key)))
    case ("user_obs")
       res_type = V_REAL
    case default
       call parse_node_write (pn_key)
       call msg_bug ("user_observable: wrong keyword")
    end select
    pn_arg => parse_node_get_next_ptr (pn_key)
    pn_obs => parse_node_get_sub_ptr (pn_arg)
    call eval_node_compile_sexpr (en0, pn_obs, var_list)
    select case (res_type)
    case (V_INT);  var_name = "_User_obs_int"
    case (V_REAL); var_name = "_User_obs_real"
    end select
    var => var_list_get_var_ptr (var_list, var_name, defined=.true.)
    allocate (en)
    if (associated (var)) then
       call eval_node_init_obs  (en, var, en0)
    else
       call parse_node_write (pn)
       call msg_error ("This variable is undefined at this point")
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done user observable"
    end if
  end subroutine eval_node_compile_user_observable

@ %def eval_node_compile_user_observable
@ Functions with a single argument.  For non-constant arguments, watch
for functions which convert their argument to a different type.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_unary_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_fname, pn_arg
    type(eval_node_t), pointer :: en1
    type(string_t) :: key
    integer :: t
    if (debug) then
       print *, "read unary function";  call parse_node_write (pn)
    end if
    pn_fname => parse_node_get_sub_ptr (pn)
    pn_arg => parse_node_get_next_ptr (pn_fname, tag="function_arg1")
    call eval_node_compile_expr &
         (en1, parse_node_get_sub_ptr (pn_arg, tag="expr"), var_list)
    t = en1%result_type
    allocate (en)
    key = parse_node_get_key (pn_fname)
    if (en1%type == EN_CONSTANT) then
       select case (char (key))
       case ("complex")
          select case (t)
          case (V_INT);  call eval_node_init_cmplx (en, cmplx_i (en1))
          case (V_REAL); call eval_node_init_cmplx (en, cmplx_r (en1))
          case (V_CMPLX); deallocate (en);  en => en1;  en1 => null ()
          case default;  call eval_type_error (pn, char (key), t)          
          end select
       case ("real")
          select case (t)
          case (V_INT);  call eval_node_init_real (en, real_i (en1))
          case (V_REAL); deallocate (en);  en => en1;  en1 => null ()
          case (V_CMPLX); call eval_node_init_real (en, real_c (en1))
          case default;  call eval_type_error (pn, char (key), t)          
          end select
       case ("int")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1;  en1 => null ()
          case (V_REAL); call eval_node_init_int  (en, int_r (en1))
          case (V_CMPLX); call eval_node_init_int  (en, int_c (en1))
          end select
       case ("nint")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1;  en1 => null ()
          case (V_REAL); call eval_node_init_int  (en, nint_r (en1))          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("floor")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1;  en1 => null ()
          case (V_REAL); call eval_node_init_int  (en, floor_r (en1))
          case default;  call eval_type_error (pn, char (key), t)          
          end select
       case ("ceiling")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1;  en1 => null ()
          case (V_REAL); call eval_node_init_int  (en, ceiling_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("abs")
          select case (t)
          case (V_INT);  call eval_node_init_int  (en, abs_i (en1))
          case (V_REAL); call eval_node_init_real (en, abs_r (en1))
          case (V_CMPLX); call eval_node_init_real (en, abs_c (en1))          
          end select
       case ("sgn")
          select case (t)
          case (V_INT);  call eval_node_init_int  (en, sgn_i (en1))
          case (V_REAL); call eval_node_init_real (en, sgn_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sqrt")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, sqrt_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, sqrt_c (en1))          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("exp")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, exp_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, exp_c (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("log")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, log_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, log_c (en1))          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("log10")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, log10_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sin")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, sin_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, sin_c (en1))          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("cos")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, cos_r (en1))
          case (V_CMPLX); call eval_node_init_cmplx (en, cos_c (en1))          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("tan")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, tan_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("asin")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, asin_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("acos")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, acos_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("atan")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, atan_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sinh")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, sinh_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("cosh")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, cosh_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("tanh")
          select case (t)
          case (V_REAL); call eval_node_init_real (en, tanh_r (en1))
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case default
          call parse_node_mismatch ("function name", pn_fname)
       end select
       if (associated (en1)) then
          call eval_node_final_rec (en1)
          deallocate (en1)
       end if
    else
       select case (char (key))
       case ("complex")
          call eval_node_init_branch (en, key, V_CMPLX, en1)
       case ("real")
          call eval_node_init_branch (en, key, V_REAL, en1)
       case ("int", "nint", "floor", "ceiling")
          call eval_node_init_branch (en, key, V_INT, en1)
       case default
          call eval_node_init_branch (en, key, t, en1)
       end select
       select case (char (key))
       case ("complex")
          select case (t)
          case (V_INT);  call eval_node_set_op1_cmplx (en, cmplx_i)
          case (V_REAL); call eval_node_set_op1_cmplx (en, cmplx_r)
          case (V_CMPLX); deallocate (en);  en => en1
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("real")
          select case (t)
          case (V_INT);  call eval_node_set_op1_real (en, real_i)
          case (V_REAL); deallocate (en);  en => en1
          case (V_CMPLX); call eval_node_set_op1_real (en, real_c)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("int")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1
          case (V_REAL); call eval_node_set_op1_int (en, int_r)
          case (V_CMPLX); call eval_node_set_op1_int (en, int_c)          
          end select
       case ("nint")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1
          case (V_REAL); call eval_node_set_op1_int (en, nint_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("floor")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1
          case (V_REAL); call eval_node_set_op1_int (en, floor_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("ceiling")
          select case (t)
          case (V_INT);  deallocate (en);  en => en1
          case (V_REAL); call eval_node_set_op1_int (en, ceiling_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("abs")
          select case (t)
          case (V_INT);  call eval_node_set_op1_int  (en, abs_i)
          case (V_REAL); call eval_node_set_op1_real (en, abs_r)
          case (V_CMPLX); 
             call eval_node_init_branch (en, key, V_REAL, en1)
             call eval_node_set_op1_real (en, abs_c)
          end select
       case ("sgn")
          select case (t)
          case (V_INT);  call eval_node_set_op1_int  (en, sgn_i)
          case (V_REAL); call eval_node_set_op1_real (en, sgn_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sqrt")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, sqrt_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, sqrt_c)          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("exp")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, exp_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, exp_c)          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("log")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, log_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, log_c)          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("log10")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, log10_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sin")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, sin_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, sin_c)          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("cos")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, cos_r)
          case (V_CMPLX); call eval_node_set_op1_cmplx (en, cos_c)          
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("tan")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, tan_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("asin")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, asin_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("acos")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, acos_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("atan")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, atan_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("sinh")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, sinh_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("cosh")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, cosh_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case ("tanh")
          select case (t)
          case (V_REAL); call eval_node_set_op1_real (en, tanh_r)
          case default;  call eval_type_error (pn, char (key), t)
          end select
       case default
          call parse_node_mismatch ("function name", pn_fname)
       end select
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done function"
    end if
  end subroutine eval_node_compile_unary_function

@ %def eval_node_compile_unary_function
@ Functions with two arguments.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_binary_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_fname, pn_arg, pn_arg1, pn_arg2
    type(eval_node_t), pointer :: en1, en2
    type(string_t) :: key
    integer :: t1, t2
    if (debug) then
       print *, "read binary function";  call parse_node_write (pn)
    end if
    pn_fname => parse_node_get_sub_ptr (pn)
    pn_arg => parse_node_get_next_ptr (pn_fname, tag="function_arg2")
    pn_arg1 => parse_node_get_sub_ptr (pn_arg, tag="expr")
    pn_arg2 => parse_node_get_next_ptr (pn_arg1, tag="expr")
    call eval_node_compile_expr (en1, pn_arg1, var_list)
    call eval_node_compile_expr (en2, pn_arg2, var_list)
    t1 = en1%result_type
    t2 = en2%result_type
    allocate (en)
    key = parse_node_get_key (pn_fname)
    if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
       select case (char (key))
       case ("max")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_int  (en, max_ii (en1, en2))
             case (V_REAL); call eval_node_init_real (en, max_ir (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)      
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_real (en, max_ri (en1, en2))
             case (V_REAL); call eval_node_init_real (en, max_rr (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2) 
             end select
           case default;  call eval_type_error (pn, char (key), t1)             
         end select
       case ("min")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_int  (en, min_ii (en1, en2))
             case (V_REAL); call eval_node_init_real (en, min_ir (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)             
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_real (en, min_ri (en1, en2))
             case (V_REAL); call eval_node_init_real (en, min_rr (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t1)             
         end select
       case ("mod")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_int  (en, mod_ii (en1, en2))
             case (V_REAL); call eval_node_init_real (en, mod_ir (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)             
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_real (en, mod_ri (en1, en2))
             case (V_REAL); call eval_node_init_real (en, mod_rr (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t1)             
          end select
       case ("modulo")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_int  (en, modulo_ii (en1, en2))
             case (V_REAL); call eval_node_init_real (en, modulo_ir (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)             
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_real (en, modulo_ri (en1, en2))
             case (V_REAL); call eval_node_init_real (en, modulo_rr (en1, en2))
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t2)             
         end select
       case default
          call parse_node_mismatch ("function name", pn_fname)
       end select
       call eval_node_final_rec (en1)
       deallocate (en1)
    else
       call eval_node_init_branch (en, key, t1, en1, en2)
       select case (char (key))
       case ("max")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_int  (en, max_ii)
             case (V_REAL); call eval_node_set_op2_real (en, max_ir)
             case default;  call eval_type_error (pn, char (key), t2)             
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_real (en, max_ri)
             case (V_REAL); call eval_node_set_op2_real (en, max_rr)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t2)               
         end select
       case ("min")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_int  (en, min_ii)
             case (V_REAL); call eval_node_set_op2_real (en, min_ir)
             case default;  call eval_type_error (pn, char (key), t2)             
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_real (en, min_ri)
             case (V_REAL); call eval_node_set_op2_real (en, min_rr)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t2)            
         end select
       case ("mod")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_int  (en, mod_ii)
             case (V_REAL); call eval_node_set_op2_real (en, mod_ir)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_real (en, mod_ri)
             case (V_REAL); call eval_node_set_op2_real (en, mod_rr)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t2)                          
        end select
       case ("modulo")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_int  (en, modulo_ii)
             case (V_REAL); call eval_node_set_op2_real (en, modulo_ir)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_real (en, modulo_ri)
             case (V_REAL); call eval_node_set_op2_real (en, modulo_rr)
             case default;  call eval_type_error (pn, char (key), t2)                          
             end select
           case default;  call eval_type_error (pn, char (key), t2)                          
         end select
       case default
          call parse_node_mismatch ("function name", pn_fname)
       end select
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done function"
    end if
  end subroutine eval_node_compile_binary_function

@ %def eval_node_compile_binary_function
@ 
\subsubsection{Variable definition}
A block expression contains a variable definition (first argument) and
an expression where the definition can be used (second argument).  The
[[result_type]] decides which type of expression is expected for the
second argument.  For numeric variables, if there is a mismatch
between real and integer type, insert an extra node for type
conversion.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_block_expr &
       (en, pn, var_list, result_type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in), optional :: result_type
    type(parse_node_t), pointer :: pn_var_spec, pn_var_subspec
    type(parse_node_t), pointer :: pn_var_type, pn_var_name, pn_var_expr
    type(parse_node_t), pointer :: pn_expr
    type(string_t) :: var_name
    type(eval_node_t), pointer :: en1, en2
    integer :: var_type
    logical :: new
    if (debug) then
       print *, "read block expr";  call parse_node_write (pn)
    end if
    new = .false.
    pn_var_spec => parse_node_get_sub_ptr (pn, 2)
    select case (char (parse_node_get_rule_key (pn_var_spec)))
    case ("var_num");      var_type = V_NONE
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec)
    case ("var_int");      var_type = V_INT
       new = .true.
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_real");     var_type = V_REAL
       new = .true.
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_cmplx");     var_type = V_CMPLX
       new = .true.
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_logical_new");  var_type = V_LOG
       new = .true.
       pn_var_subspec => parse_node_get_sub_ptr (pn_var_spec, 2)
       pn_var_name => parse_node_get_sub_ptr (pn_var_subspec, 2)
    case ("var_logical_spec");  var_type = V_LOG
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_plist_new");    var_type = V_SEV
       new = .true.
       pn_var_subspec => parse_node_get_sub_ptr (pn_var_spec, 2)
       pn_var_name => parse_node_get_sub_ptr (pn_var_subspec, 2)
    case ("var_plist_spec");    var_type = V_SEV
       new = .true.
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_alias");    var_type = V_PDG
       new = .true.
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case ("var_string_new");   var_type = V_STR
       new = .true.
       pn_var_subspec => parse_node_get_sub_ptr (pn_var_spec, 2)
       pn_var_name => parse_node_get_sub_ptr (pn_var_subspec, 2)
    case ("var_string_spec");   var_type = V_STR
       pn_var_name => parse_node_get_sub_ptr (pn_var_spec, 2)
    case default
       call parse_node_mismatch &
            ("logical|int|real|plist|alias", pn_var_type)
    end select
    pn_var_expr => parse_node_get_next_ptr (pn_var_name, 2)
    pn_expr => parse_node_get_next_ptr (pn_var_spec, 2)
    var_name = parse_node_get_string (pn_var_name)
    select case (var_type)
    case (V_LOG);  var_name = "?" // var_name
    case (V_SEV);  var_name = "@" // var_name
    case (V_STR);  var_name = "$" // var_name    ! $ sign
    end select
    call var_list_check_user_var (var_list, var_name, var_type, new)
    call eval_node_compile_genexpr (en1, pn_var_expr, var_list, var_type)
    call insert_conversion_node (en1, var_type)
    allocate (en)
    call eval_node_init_block (en, var_name, var_type, en1, var_list)
    call eval_node_compile_genexpr (en2, pn_expr, en%var_list, result_type)
    call eval_node_set_expr (en, en2)
    if (debug) then
       call eval_node_write (en)
       print *, "done block expr"
    end if
  end subroutine eval_node_compile_block_expr
    
@ %def eval_node_compile_block_expr
@ Insert a conversion node for integer/real/complex transformation if necessary.
What shall we do for the complex to integer/real conversion?
<<Eval trees: procedures>>=
  subroutine insert_conversion_node (en, result_type)
    type(eval_node_t), pointer :: en
    integer, intent(in) :: result_type
    type(eval_node_t), pointer :: en_conv
    select case (en%result_type)
    case (V_INT)
       select case (result_type)
       case (V_REAL)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("real"), V_REAL, en)
          call eval_node_set_op1_real (en_conv, real_i)
          en => en_conv
       case (V_CMPLX)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("complex"), V_CMPLX, en)
          call eval_node_set_op1_cmplx (en_conv, cmplx_i)
          en => en_conv          
       end select
    case (V_REAL)
       select case (result_type)
       case (V_INT)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("int"), V_INT, en)
          call eval_node_set_op1_int (en_conv, int_r)
          en => en_conv
       case (V_CMPLX)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("complex"), V_CMPLX, en)
          call eval_node_set_op1_cmplx (en_conv, cmplx_r)
          en => en_conv
       end select          
    case (V_CMPLX)
       select case (result_type)
       case (V_INT)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("int"), V_INT, en)
          call eval_node_set_op1_int (en_conv, int_c)
          en => en_conv
       case (V_REAL)
          allocate (en_conv)
          call eval_node_init_branch (en_conv, var_str ("real"), V_REAL, en)
          call eval_node_set_op1_real (en_conv, real_c)
          en => en_conv
       end select          
     case default     
     end select    
  end subroutine insert_conversion_node

@ %def insert_conversion_node
@ 
\subsubsection{Conditionals}
A conditional has the structure if lexpr then expr else expr.  So we
first evaluate the logical expression, then depending on the result
the first or second expression.  Note that the second expression is
mandatory.

The [[result_type]], if present, defines the requested type of the
[[then]] and [[else]] clauses.  Default is numeric (int/real).  If
there is a mismatch between real and integer result types, insert
conversion nodes.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_conditional &
       (en, pn, var_list, result_type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in), optional :: result_type
    type(parse_node_t), pointer :: pn_condition, pn_expr
    type(parse_node_t), pointer :: pn_maybe_elsif, pn_elsif_branch
    type(parse_node_t), pointer :: pn_maybe_else, pn_else_branch, pn_else_expr
    type(eval_node_t), pointer :: en0, en1, en2
    integer :: restype
    if (debug) then
       print *, "read conditional";  call parse_node_write (pn)
    end if
    pn_condition => parse_node_get_sub_ptr (pn, 2, tag="lexpr")
    pn_expr => parse_node_get_next_ptr (pn_condition, 2)
    call eval_node_compile_lexpr (en0, pn_condition, var_list)
    call eval_node_compile_genexpr (en1, pn_expr, var_list, result_type)
    if (present (result_type)) then
       restype = major_result_type (result_type, en1%result_type)
    else
       restype = en1%result_type
    end if
    pn_maybe_elsif => parse_node_get_next_ptr (pn_expr)
    select case (char (parse_node_get_rule_key (pn_maybe_elsif)))
    case ("maybe_elsif_expr", &
          "maybe_elsif_lexpr", &
          "maybe_elsif_pexpr", &
          "maybe_elsif_cexpr", &
          "maybe_elsif_sexpr")
       pn_elsif_branch => parse_node_get_sub_ptr (pn_maybe_elsif)
       pn_maybe_else => parse_node_get_next_ptr (pn_maybe_elsif)
       select case (char (parse_node_get_rule_key (pn_maybe_else)))
       case ("maybe_else_expr", &
          "maybe_else_lexpr", &
          "maybe_else_pexpr", &
          "maybe_else_cexpr", &
          "maybe_else_sexpr")
          pn_else_branch => parse_node_get_sub_ptr (pn_maybe_else)
          pn_else_expr => parse_node_get_sub_ptr (pn_else_branch, 2)
       case default
          pn_else_expr => null ()
       end select
       call eval_node_compile_elsif &
            (en2, pn_elsif_branch, pn_else_expr, var_list, restype)
    case ("maybe_else_expr", &
          "maybe_else_lexpr", &
          "maybe_else_pexpr", &
          "maybe_else_cexpr", &
          "maybe_else_sexpr")
       pn_maybe_else => pn_maybe_elsif
       pn_maybe_elsif => null ()
       pn_else_branch => parse_node_get_sub_ptr (pn_maybe_else)
       pn_else_expr => parse_node_get_sub_ptr (pn_else_branch, 2)
       call eval_node_compile_genexpr &
            (en2, pn_else_expr, var_list, restype)
    case ("endif")
       call eval_node_compile_default_else (en2, restype)
    case default
       call msg_bug ("Broken conditional: unexpected " &
            // char (parse_node_get_rule_key (pn_maybe_elsif)))
    end select
    call eval_node_create_conditional (en, en0, en1, en2, restype)
    call conditional_insert_conversion_nodes (en, restype)
    if (debug) then
       call eval_node_write (en)
       print *, "done conditional"
    end if
  end subroutine eval_node_compile_conditional

@ %def eval_node_compile_conditional
@ This recursively generates 'elsif' conditionals as a chain of sub-nodes of
the main conditional.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_elsif &
       (en, pn, pn_else_expr, var_list, result_type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_else_expr
    type(var_list_t), intent(in), target :: var_list
    integer, intent(inout) :: result_type
    type(parse_node_t), pointer :: pn_next, pn_condition, pn_expr
    type(eval_node_t), pointer :: en0, en1, en2
    pn_condition => parse_node_get_sub_ptr (pn, 2, tag="lexpr")
    pn_expr => parse_node_get_next_ptr (pn_condition, 2)
    call eval_node_compile_lexpr (en0, pn_condition, var_list)
    call eval_node_compile_genexpr (en1, pn_expr, var_list, result_type)
    result_type = major_result_type (result_type, en1%result_type)
    pn_next => parse_node_get_next_ptr (pn)
    if (associated (pn_next)) then
       call eval_node_compile_elsif &
            (en2, pn_next, pn_else_expr, var_list, result_type)
       result_type = major_result_type (result_type, en2%result_type)
    else if (associated (pn_else_expr)) then
       call eval_node_compile_genexpr &
            (en2, pn_else_expr, var_list, result_type)
       result_type = major_result_type (result_type, en2%result_type)
    else
       call eval_node_compile_default_else (en2, result_type)
    end if
    call eval_node_create_conditional (en, en0, en1, en2, result_type)
  end subroutine eval_node_compile_elsif       

@ %def eval_node_compile_elsif
@ This makes a default 'else' branch in case it was omitted.  The default value
just depends on the expected type.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_default_else (en, result_type)
    type(eval_node_t), pointer :: en
    integer, intent(in) :: result_type
    type(subevt_t) :: pval_empty
    type(pdg_array_t) :: aval_undefined
    allocate (en)
    select case (result_type)
    case (V_LOG);  call eval_node_init_log (en, .false.)
    case (V_INT);  call eval_node_init_int (en, 0)
    case (V_REAL);  call eval_node_init_real (en, 0._default)
    case (V_CMPLX)
         call eval_node_init_cmplx (en, (0._default, 0._default))
    case (V_SEV)
       call subevt_init (pval_empty)
       call eval_node_init_subevt (en, pval_empty)
    case (V_PDG)
       call eval_node_init_pdg_array  (en, aval_undefined)
    case (V_STR)
       call eval_node_init_string (en, var_str (""))
    case default
       call msg_bug ("Undefined type for 'else' branch in conditional")
    end select
  end subroutine eval_node_compile_default_else

@ %def eval_node_compile_default_else
@ If the logical expression is constant, we can simplify the conditional node
by replacing it with the selected branch.  Otherwise, we initialize a true
branching.
<<Eval trees: procedures>>=
  subroutine eval_node_create_conditional (en, en0, en1, en2, result_type)
    type(eval_node_t), pointer :: en, en0, en1, en2
    integer, intent(in) :: result_type
    if (en0%type == EN_CONSTANT) then
       if (en0%lval) then
          en => en1
          call eval_node_final_rec (en2)
          deallocate (en2)
       else
          en => en2
          call eval_node_final_rec (en1)
          deallocate (en1)
       end if
    else
       allocate (en)
       call eval_node_init_conditional (en, result_type, en0, en1, en2)
    end if
  end subroutine eval_node_create_conditional

@ %def eval_node_create_conditional    
@ Return the numerical result type which should be used for the combination of
the two result types.
<<Eval trees: procedures>>=
  function major_result_type (t1, t2) result (t)
    integer :: t
    integer, intent(in) :: t1, t2
    select case (t1)
    case (V_INT)
       select case (t2)
       case (V_INT, V_REAL, V_CMPLX)
          t = t2
       case default
          call type_mismatch ()
       end select
    case (V_REAL)
       select case (t2)
       case (V_INT)
          t = t1
       case (V_REAL, V_CMPLX)
          t = t2
       case default
          call type_mismatch ()
       end select
    case (V_CMPLX)
       select case (t2)
       case (V_INT, V_REAL, V_CMPLX)
          t = t1
       case default
          call type_mismatch ()
       end select
    case default
       if (t1 == t2) then
          t = t1
       else
          call type_mismatch ()
       end if
    end select
  contains
    subroutine type_mismatch ()
      call msg_bug ("Type mismatch in branches of a conditional expression")
    end subroutine type_mismatch
  end function major_result_type

@ %def major_result_type
@ Recursively insert conversion nodes where necessary.
<<Eval trees: procedures>>=
  recursive subroutine conditional_insert_conversion_nodes (en, result_type)
    type(eval_node_t), intent(inout), target :: en
    integer, intent(in) :: result_type
    select case (result_type)
    case (V_INT, V_REAL, V_CMPLX)
       call insert_conversion_node (en%arg1, result_type)
       if (en%arg2%type == EN_CONDITIONAL) then
          call conditional_insert_conversion_nodes (en%arg2, result_type)
       else
          call insert_conversion_node (en%arg2, result_type)
       end if
    end select
  end subroutine conditional_insert_conversion_nodes

@ %def conditional_insert_conversion_nodes
@ 
\subsubsection{Logical expressions}
A logical expression consists of one or more singlet logical expressions
concatenated by [[;]].  This is for allowing side-effects, only the last value
is used.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_lexpr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_term, pn_sequel, pn_arg
    type(eval_node_t), pointer :: en1, en2
    if (debug) then
       print *, "read lexpr";  call parse_node_write (pn)
    end if
    pn_term => parse_node_get_sub_ptr (pn, tag="lsinglet")
    call eval_node_compile_lsinglet (en, pn_term, var_list)
    pn_sequel => parse_node_get_next_ptr (pn_term, tag="lsequel")
    do while (associated (pn_sequel))
       pn_arg => parse_node_get_sub_ptr (pn_sequel, 2, tag="lsinglet")
       en1 => en
       call eval_node_compile_lsinglet (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call eval_node_init_log (en, ignore_first_ll (en1, en2))
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("lsequel"), V_LOG, en1, en2)
          call eval_node_set_op2_log (en, ignore_first_ll)
       end if
       pn_sequel => parse_node_get_next_ptr (pn_sequel)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done lexpr"
    end if
  end subroutine eval_node_compile_lexpr

@ %def eval_node_compile_lexpr
@ A logical singlet expression consists of one or more logical terms
concatenated by [[or]].
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_lsinglet (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_term, pn_alternative, pn_arg
    type(eval_node_t), pointer :: en1, en2
    if (debug) then
       print *, "read lsinglet";  call parse_node_write (pn)
    end if
    pn_term => parse_node_get_sub_ptr (pn, tag="lterm")
    call eval_node_compile_lterm (en, pn_term, var_list)
    pn_alternative => parse_node_get_next_ptr (pn_term, tag="alternative")
    do while (associated (pn_alternative))
       pn_arg => parse_node_get_sub_ptr (pn_alternative, 2, tag="lterm")
       en1 => en
       call eval_node_compile_lterm (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call eval_node_init_log (en, or_ll (en1, en2))
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("alternative"), V_LOG, en1, en2)
          call eval_node_set_op2_log (en, or_ll)
       end if
       pn_alternative => parse_node_get_next_ptr (pn_alternative)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done lsinglet"
    end if
  end subroutine eval_node_compile_lsinglet

@ %def eval_node_compile_lsinglet
@ A logical term consists of one or more logical values
concatenated by [[and]].
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_lterm (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_term, pn_coincidence, pn_arg
    type(eval_node_t), pointer :: en1, en2
    if (debug) then
       print *, "read lterm";  call parse_node_write (pn)
    end if
    pn_term => parse_node_get_sub_ptr (pn)
    call eval_node_compile_lvalue (en, pn_term, var_list)
    pn_coincidence => parse_node_get_next_ptr (pn_term, tag="coincidence")
    do while (associated (pn_coincidence))
       pn_arg => parse_node_get_sub_ptr (pn_coincidence, 2)
       en1 => en
       call eval_node_compile_lvalue (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call eval_node_init_log (en, and_ll (en1, en2))
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("coincidence"), V_LOG, en1, en2)
          call eval_node_set_op2_log (en, and_ll)
       end if
       pn_coincidence => parse_node_get_next_ptr (pn_coincidence)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done lterm"
    end if
  end subroutine eval_node_compile_lterm

@ %def eval_node_compile_lterm
@ Logical variables are disabled, because they are confused with the
l.h.s.\ of compared expressions.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_lvalue (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    if (debug) then
       print *, "read lvalue";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("true")
       allocate (en)
       call eval_node_init_log (en, .true.)
    case ("false")
       allocate (en)
       call eval_node_init_log (en, .false.)
    case ("negation")
       call eval_node_compile_negation (en, pn, var_list)
    case ("lvariable")
       call eval_node_compile_variable (en, pn, var_list, V_LOG)
    case ("lexpr")
       call eval_node_compile_lexpr (en, pn, var_list)
    case ("block_lexpr")
       call eval_node_compile_block_expr (en, pn, var_list, V_LOG)
    case ("conditional_lexpr")
       call eval_node_compile_conditional (en, pn, var_list, V_LOG)
    case ("compared_expr")
       call eval_node_compile_compared_expr (en, pn, var_list, V_REAL)
    case ("compared_sexpr")
       call eval_node_compile_compared_expr (en, pn, var_list, V_STR)
    case ("all_fun", "any_fun", "no_fun", "user_cut_fun")
       call eval_node_compile_log_function (en, pn, var_list)
    case ("record_cmd")
       call eval_node_compile_record_cmd (en, pn, var_list)
    case default
       call parse_node_mismatch &
            ("true|false|negation|lvariable|" // &
             "lexpr|block_lexpr|conditional_lexpr|" // &
             "compared_expr|compared_sexpr|logical_pexpr", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done lvalue"
    end if
  end subroutine eval_node_compile_lvalue

@ %def eval_node_compile_lvalue
@ A negation consists of the keyword [[not]] and a logical value.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_negation (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_arg
    type(eval_node_t), pointer :: en1
    if (debug) then
       print *, "read negation";  call parse_node_write (pn)
    end if
    pn_arg => parse_node_get_sub_ptr (pn, 2)
    call eval_node_compile_lvalue (en1, pn_arg, var_list)
    allocate (en)
    if (en1%type == EN_CONSTANT) then
       call eval_node_init_log (en, not_l (en1))
       call eval_node_final_rec (en1)
       deallocate (en1)
    else
       call eval_node_init_branch (en, var_str ("not"), V_LOG, en1)
       call eval_node_set_op1_log (en, not_l)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done negation"
    end if
  end subroutine eval_node_compile_negation

@ %def eval_node_compile_negation
@
\subsubsection{Comparisons}
Up to the loop, this is easy.  There is always at least one
comparison.  This is evaluated, and the result is the logical node
[[en]].  If it is constant, we keep its second sub-node as [[en2]].
(Thus, at the very end [[en2]] has to be deleted if [[en]] is (still)
constant.)

If there is another comparison, we first check if the first comparison
was constant.  In that case, there are two possibilities: (i) it was
true.  Then, its right-hand side is compared with the new right-hand
side, and the result replaces the previous one which is deleted.  (ii)
it was false.  In this case, the result of the whole comparison is
false, and we can exit the loop without evaluating anything else.

Now assume that the first comparison results in a valid branch, its
second sub-node kept as [[en2]].  We first need a copy of this, which
becomes the new left-hand side.  If [[en2]] is constant, we make an
identical constant node [[en1]].  Otherwise, we make [[en1]] an
appropriate pointer node.  Next, the first branch is saved as [[en0]]
and we evaluate the comparison between [[en1]] and the a right-hand
side.  If this turns out to be constant, there are again two
possibilities: (i) true, then we revert to the previous result.  (ii)
false, then the wh
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_compared_expr (en, pn, var_list, type)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in) :: type
    type(parse_node_t), pointer :: pn_comparison, pn_expr1
    type(eval_node_t), pointer :: en0, en1, en2
    if (debug) then
       print *, "read comparison";  call parse_node_write (pn)
    end if
    select case (type)
    case (V_INT, V_REAL)
       pn_expr1 => parse_node_get_sub_ptr (pn, tag="expr")
       call eval_node_compile_expr (en1, pn_expr1, var_list)
       pn_comparison => parse_node_get_next_ptr (pn_expr1, tag="comparison")
    case (V_STR)
       pn_expr1 => parse_node_get_sub_ptr (pn, tag="sexpr")
       call eval_node_compile_sexpr (en1, pn_expr1, var_list)
       pn_comparison => parse_node_get_next_ptr (pn_expr1, tag="str_comparison")
    end select
    call eval_node_compile_comparison &
         (en, en1, en2, pn_comparison, var_list, type)
    pn_comparison => parse_node_get_next_ptr (pn_comparison)
    SCAN_FURTHER: do while (associated (pn_comparison))
       if (en%type == EN_CONSTANT) then
          if (en%lval) then
             en1 => en2
             call eval_node_final_rec (en);  deallocate (en)
             call eval_node_compile_comparison &
                  (en, en1, en2, pn_comparison, var_list, type)
          else
             exit SCAN_FURTHER
          end if
       else
          allocate (en1)
          if (en2%type == EN_CONSTANT) then
             select case (en2%result_type)
             case (V_INT);  call eval_node_init_int    (en1, en2%ival)
             case (V_REAL); call eval_node_init_real   (en1, en2%rval)
             case (V_STR);  call eval_node_init_string (en1, en2%sval)
             end select
          else
             select case (en2%result_type)
             case (V_INT);  call eval_node_init_int_ptr &
                  (en1, var_str ("(previous)"), en2%ival, en2%value_is_known)
             case (V_REAL); call eval_node_init_real_ptr &
                  (en1, var_str ("(previous)"), en2%rval, en2%value_is_known)
             case (V_STR);  call eval_node_init_string_ptr &
                  (en1, var_str ("(previous)"), en2%sval, en2%value_is_known)
             end select
          end if
          en0 => en
          call eval_node_compile_comparison &
               (en, en1, en2, pn_comparison, var_list, type)
          if (en%type == EN_CONSTANT) then
             if (en%lval) then
                call eval_node_final_rec (en);  deallocate (en)
                en => en0
             else
                call eval_node_final_rec (en0);  deallocate (en0)
                exit SCAN_FURTHER
             end if
          else
             en1 => en
             allocate (en)
             call eval_node_init_branch (en, var_str ("and"), V_LOG, en0, en1)
             call eval_node_set_op2_log (en, and_ll)
          end if
       end if
       pn_comparison => parse_node_get_next_ptr (pn_comparison)
    end do SCAN_FURTHER
    if (en%type == EN_CONSTANT .and. associated (en2)) then
       call eval_node_final_rec (en2);  deallocate (en2)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done compared_expr"
    end if
  end subroutine eval_node_compile_compared_expr

@ %dev eval_node_compile_compared_expr
@ This takes two extra arguments: [[en1]], the left-hand-side of the
comparison, is already allocated and evaluated.  [[en2]] (the
right-hand side) and [[en]] (the result) are allocated by the
routine.  [[pn]] is the parse node which contains the operator and the
right-hand side as subnodes.

If the result of the comparison is constant, [[en1]] is deleted but
[[en2]] is kept, because it may be used in a subsequent comparison.
[[en]] then becomes a constant.  If the result is variable, [[en]]
becomes a branch node which refers to [[en1]] and [[en2]].
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_comparison &
       (en, en1, en2, pn, var_list, type)
    type(eval_node_t), pointer :: en, en1, en2
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(in) :: type
    type(parse_node_t), pointer :: pn_op, pn_arg
    type(string_t) :: key
    integer :: t1, t2
    type(var_entry_t), pointer :: var
    pn_op => parse_node_get_sub_ptr (pn)
    key = parse_node_get_key (pn_op)
    select case (type)
    case (V_INT, V_REAL)
       pn_arg => parse_node_get_next_ptr (pn_op, tag="expr")
       call eval_node_compile_expr (en2, pn_arg, var_list)
    case (V_STR)
       pn_arg => parse_node_get_next_ptr (pn_op, tag="sexpr")
       call eval_node_compile_sexpr (en2, pn_arg, var_list)
    end select
    t1 = en1%result_type
    t2 = en2%result_type
    allocate (en)
    if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
       var => var_list_get_var_ptr (var_list, var_str ("tolerance"))
       en1%tolerance => var_entry_get_rval_ptr (var)
       select case (char (key))
       case ("<")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_lt_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ll_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_ll_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ll_rr (en1, en2))
             end select
          end select
       case (">")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_gt_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_gg_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_gg_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_gg_rr (en1, en2))
             end select
          end select
       case ("<=")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_le_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ls_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_ls_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ls_rr (en1, en2))
             end select
          end select
       case (">=")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_ge_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_gs_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_gs_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_gs_rr (en1, en2))
             end select
          end select
       case ("==")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_eq_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_se_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_se_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_se_rr (en1, en2))
             end select
          case (V_STR)
             select case (t2)
             case (V_STR);  call eval_node_init_log (en, comp_eq_ss (en1, en2))
             end select
          end select
       case ("<>")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_ne_ii (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ns_ir (en1, en2))
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_init_log (en, comp_ns_ri (en1, en2))
             case (V_REAL); call eval_node_init_log (en, comp_ns_rr (en1, en2))
             end select
          case (V_STR)
             select case (t2)
             case (V_STR);  call eval_node_init_log (en, comp_ne_ss (en1, en2))
             end select
          end select
       end select
       call eval_node_final_rec (en1)
       deallocate (en1)
    else
       call eval_node_init_branch (en, key, V_LOG, en1, en2)
       select case (char (key))
       case ("<")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_lt_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ll_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_ll_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ll_rr)
             end select
          end select
       case (">")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_gt_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_gg_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_gg_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_gg_rr)
             end select
          end select
       case ("<=")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_le_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ls_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_ls_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ls_rr)
             end select
          end select
       case (">=")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_ge_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_gs_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_gs_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_gs_rr)
             end select
          end select
       case ("==")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_eq_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_se_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_se_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_se_rr)
             end select
          case (V_STR)
             select case (t2)
             case (V_STR);  call eval_node_set_op2_log (en, comp_eq_ss)
             end select
          end select
       case ("<>")
          select case (t1)
          case (V_INT)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_ne_ii)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ns_ir)
             end select
          case (V_REAL)
             select case (t2)
             case (V_INT);  call eval_node_set_op2_log (en, comp_ns_ri)
             case (V_REAL); call eval_node_set_op2_log (en, comp_ns_rr)
             end select
          case (V_STR)
             select case (t2)
             case (V_STR);  call eval_node_set_op2_log (en, comp_ne_ss)
             end select
          end select
       end select
       var => var_list_get_var_ptr (var_list, var_str ("tolerance"))
       en1%tolerance => var_entry_get_rval_ptr (var)
    end if
  end subroutine eval_node_compile_comparison

@ %def eval_node_compile_comparison
@ 
\subsubsection{Recording analysis data}
The [[record]] command is actually a logical expression which always
evaluates [[true]].
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_record_cmd (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_key, pn_tag, pn_arg
    type(parse_node_t), pointer :: pn_arg1, pn_arg2, pn_arg3, pn_arg4
    type(eval_node_t), pointer :: en0, en1, en2, en3, en4
    type(var_entry_t), pointer :: var
    real(default), pointer :: event_weight
    if (debug) then
       print *, "read record_cmd";  call parse_node_write (pn)
    end if
    pn_key => parse_node_get_sub_ptr (pn)
    pn_tag => parse_node_get_next_ptr (pn_key)
    pn_arg => parse_node_get_next_ptr (pn_tag)
    select case (char (parse_node_get_key (pn_key)))
    case ("record")
       var => var_list_get_var_ptr (var_list, var_str ("event_weight"))
       if (associated (var)) then
          event_weight => var_entry_get_rval_ptr (var)
       else
          event_weight => null ()
       end if
    case ("record_unweighted")
       event_weight => null ()
    case ("record_excess")
       var => var_list_get_var_ptr (var_list, var_str ("event_excess"))
       if (associated (var)) then
          event_weight => var_entry_get_rval_ptr (var)
       else
          event_weight => null ()
       end if
    end select
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       allocate (en0)
       call eval_node_init_string (en0, parse_node_get_string (pn_tag))
    case default
       call eval_node_compile_sexpr (en0, pn_tag, var_list)
    end select
    allocate (en)
    if (associated (pn_arg)) then
       pn_arg1 => parse_node_get_sub_ptr (pn_arg)
       call eval_node_compile_expr (en1, pn_arg1, var_list)
       if (en1%result_type == V_INT) &
            call insert_conversion_node (en1, V_REAL)
       pn_arg2 => parse_node_get_next_ptr (pn_arg1)
       if (associated (pn_arg2)) then
          call eval_node_compile_expr (en2, pn_arg2, var_list)
          if (en2%result_type == V_INT) &
               call insert_conversion_node (en2, V_REAL)
          pn_arg3 => parse_node_get_next_ptr (pn_arg2)
          if (associated (pn_arg3)) then
             call eval_node_compile_expr (en3, pn_arg3, var_list)
             if (en3%result_type == V_INT) &
                  call insert_conversion_node (en3, V_REAL)
             pn_arg4 => parse_node_get_next_ptr (pn_arg3)
             if (associated (pn_arg4)) then
                call eval_node_compile_expr (en4, pn_arg4, var_list)
                if (en4%result_type == V_INT) &
                     call insert_conversion_node (en4, V_REAL)
                call eval_node_init_record_cmd &
                     (en, event_weight, en0, en1, en2, en3, en4)
             else
                call eval_node_init_record_cmd &
                     (en, event_weight, en0, en1, en2, en3)
             end if
          else
             call eval_node_init_record_cmd (en, event_weight, en0, en1, en2)
          end if
       else
          call eval_node_init_record_cmd (en, event_weight, en0, en1)
       end if
    else
       call eval_node_init_record_cmd (en, event_weight, en0)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done record_cmd"
    end if
  end subroutine eval_node_compile_record_cmd

@ %def eval_node_compile_record_cmd
@ 
\subsubsection{Particle-list expressions}
A particle expression is a subevent or a concatenation of
particle-list terms (using \verb|join|).
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_pexpr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_pterm, pn_concatenation, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(subevt_t) :: subevt
    if (debug) then
       print *, "read pexpr";  call parse_node_write (pn)
    end if
    pn_pterm => parse_node_get_sub_ptr (pn)
    call eval_node_compile_pterm (en, pn_pterm, var_list)
    pn_concatenation => &
         parse_node_get_next_ptr (pn_pterm, tag="pconcatenation")
    do while (associated (pn_concatenation))
       pn_op => parse_node_get_sub_ptr (pn_concatenation)
       pn_arg => parse_node_get_next_ptr (pn_op)
       en1 => en
       call eval_node_compile_pterm (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call subevt_join (subevt, en1%pval, en2%pval)
          call eval_node_init_subevt (en, subevt)
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("join"), V_SEV, en1, en2)
          call eval_node_set_op2_sev (en, join_pp)
       end if
       pn_concatenation => parse_node_get_next_ptr (pn_concatenation)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done pexpr"
    end if
  end subroutine eval_node_compile_pexpr

@ %def eval_node_compile_pexpr
@ A particle term is a subevent or a combination of
particle-list values (using \verb|combine|).
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_pterm (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_pvalue, pn_combination, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(subevt_t) :: subevt
    if (debug) then
       print *, "read pterm";  call parse_node_write (pn)
    end if
    pn_pvalue => parse_node_get_sub_ptr (pn)
    call eval_node_compile_pvalue (en, pn_pvalue, var_list)
    pn_combination => &
         parse_node_get_next_ptr (pn_pvalue, tag="pcombination")
    do while (associated (pn_combination))
       pn_op => parse_node_get_sub_ptr (pn_combination)
       pn_arg => parse_node_get_next_ptr (pn_op)
       en1 => en
       call eval_node_compile_pvalue (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call subevt_combine (subevt, en1%pval, en2%pval)
          call eval_node_init_subevt (en, subevt)
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("combine"), V_SEV, en1, en2)
          call eval_node_set_op2_sev (en, combine_pp)
       end if
       pn_combination => parse_node_get_next_ptr (pn_combination)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done pterm"
    end if
  end subroutine eval_node_compile_pterm

@ %def eval_node_compile_pterm
@ A particle-list value is a PDG-code array, a particle identifier, a
variable, a (grouped) pexpr, a block pexpr, a conditional, or a
particle-list function.

The [[cexpr]] node is responsible for transforming a constant PDG-code
array into a subevent.  It takes the code array as its first
argument, the event subevent as its second argument, and the
requested particle type (incoming/outgoing) as its zero-th argument.
The result is the list of particles in the event that match the code
array.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_pvalue (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_prefix_cexpr
    type(eval_node_t), pointer :: en1, en2, en0
    type(string_t) :: key
    type(var_entry_t), pointer :: var
    logical, save, target :: known = .true.
    if (debug) then
       print *, "read pvalue";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("pexpr_src")
       call eval_node_compile_prefix_cexpr (en1, pn, var_list)
       allocate (en2)
       var => var_list_get_var_ptr (var_list, var_str ("@evt"))
       if (associated (var)) then
          call eval_node_init_subevt_ptr &
               (en2, var_str ("@evt"), var_entry_get_pval_ptr (var), known)
          allocate (en)
          call eval_node_init_branch &
               (en, var_str ("prt_selection"), V_SEV, en1, en2)
          call eval_node_set_op2_sev (en, select_pdg_ca)
          allocate (en0)
          pn_prefix_cexpr => parse_node_get_sub_ptr (pn)
          key = parse_node_get_rule_key (pn_prefix_cexpr)
          select case (char (key))
          case ("incoming_prt")
             call eval_node_init_int (en0, PRT_INCOMING)
             en%arg0 => en0
          case ("outgoing_prt")
             call eval_node_init_int (en0, PRT_OUTGOING)
             en%arg0 => en0
          end select
       else
          call parse_node_write (pn)
          call msg_bug (" Missing event data while compiling pvalue")
       end if
    case ("pvariable")
       call eval_node_compile_variable (en, pn, var_list, V_SEV)
    case ("pexpr")
       call eval_node_compile_pexpr (en, pn, var_list)
    case ("block_pexpr")
       call eval_node_compile_block_expr (en, pn, var_list, V_SEV)
    case ("conditional_pexpr")
       call eval_node_compile_conditional (en, pn, var_list, V_SEV)
    case ("join_fun", "combine_fun", "collect_fun", "cluster_fun", &
          "select_fun", "extract_fun", "sort_fun")
       call eval_node_compile_prt_function (en, pn, var_list)
    case default
       call parse_node_mismatch &
            ("prefix_cexpr|pvariable|" // &
             "grouped_pexpr|block_pexpr|conditional_pexpr|" // &
             "prt_function", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done pvalue"
    end if
  end subroutine eval_node_compile_pvalue

@ %def eval_node_compile_pvalue
@ 
\subsubsection{Particle functions}
This combines the treatment of 'join', 'combine', 'collect', 'cluster',
'select', 
and 'extract' which all have the same syntax.  The one or two argument
nodes are allocated.  If there is a condition, the condition node is
also allocated as a logical expression, for which the variable list is
augmented by the appropriate (unary/binary) observables.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_prt_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_clause, pn_key, pn_cond, pn_args
    type(parse_node_t), pointer :: pn_arg0, pn_arg1, pn_arg2
    type(eval_node_t), pointer :: en0, en1, en2
    type(string_t) :: key
    type(var_entry_t), pointer :: var
    if (debug) then
       print *, "read prt_function";  call parse_node_write (pn)
    end if
    pn_clause => parse_node_get_sub_ptr (pn)
    pn_key  => parse_node_get_sub_ptr (pn_clause)
    pn_cond => parse_node_get_next_ptr (pn_key)
    if (associated (pn_cond)) &
         pn_arg0 => parse_node_get_sub_ptr (pn_cond, 2)
    pn_args => parse_node_get_next_ptr (pn_clause)
    pn_arg1 => parse_node_get_sub_ptr (pn_args)
    pn_arg2 => parse_node_get_next_ptr (pn_arg1)
    key = parse_node_get_key (pn_key)
    call eval_node_compile_pexpr (en1, pn_arg1, var_list)
    allocate (en)
    if (.not. associated (pn_arg2)) then
       select case (char (key))
       case ("collect")
          call eval_node_init_prt_fun_unary (en, en1, key, collect_p)
       case ("cluster")
          if (fastjet_available ()) then
             call fastjet_init ()
          else
             call msg_fatal &
               ("'cluster' function requires FastJet, which is not enabled")
          end if
          call eval_node_init_prt_fun_unary (en, en1, key, cluster_p)
          var => var_list_get_var_ptr (var_list, var_str ("jet_algorithm"))
          en1%jet_algorithm => var_entry_get_ival_ptr (var)
          var => var_list_get_var_ptr (var_list, var_str ("jet_r"))
          en1%jet_r => var_entry_get_rval_ptr (var)
       case ("select")
          call eval_node_init_prt_fun_unary (en, en1, key, select_p)
       case ("extract")
          call eval_node_init_prt_fun_unary (en, en1, key, extract_p)
       case ("sort")
          call eval_node_init_prt_fun_unary (en, en1, key, sort_p)
       case default
          call msg_bug (" Unary particle function '" // char (key) // &
               "' undefined")
       end select
    else
       call eval_node_compile_pexpr (en2, pn_arg2, var_list)
       select case (char (key))
       case ("join")
          call eval_node_init_prt_fun_binary (en, en1, en2, key, join_pp)
       case ("combine")
          call eval_node_init_prt_fun_binary (en, en1, en2, key, combine_pp)
       case ("collect")
          call eval_node_init_prt_fun_binary (en, en1, en2, key, collect_pp)
       case ("select")
          call eval_node_init_prt_fun_binary (en, en1, en2, key, select_pp)
       case ("sort")
          call eval_node_init_prt_fun_binary (en, en1, en2, key, sort_pp)
       case default
          call msg_bug (" Binary particle function '" // char (key) // &
               "' undefined")
       end select
    end if
    if (associated (pn_cond)) then
       call eval_node_set_observables (en, var_list)
       select case (char (key))
       case ("extract", "sort")
          call eval_node_compile_expr (en0, pn_arg0, en%var_list)
       case default
          call eval_node_compile_lexpr (en0, pn_arg0, en%var_list)
       end select
       en%arg0 => en0
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done prt_function"
    end if
  end subroutine eval_node_compile_prt_function

@ %def eval_node_compile_prt_function
@ The [[eval]] expression is similar, but here the expression [[arg0]]
is mandatory, and the whole thing evaluates to a numeric value.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_eval_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_key, pn_arg0, pn_args, pn_arg1, pn_arg2
    type(eval_node_t), pointer :: en0, en1, en2
    type(string_t) :: key
    if (debug) then
       print *, "read eval_function";  call parse_node_write (pn)
    end if
    pn_key => parse_node_get_sub_ptr (pn)
    pn_arg0 => parse_node_get_next_ptr (pn_key)
    pn_args => parse_node_get_next_ptr (pn_arg0)
    pn_arg1 => parse_node_get_sub_ptr (pn_args)
    pn_arg2 => parse_node_get_next_ptr (pn_arg1)
    key = parse_node_get_key (pn_key)
    call eval_node_compile_pexpr (en1, pn_arg1, var_list)
    allocate (en)
    if (.not. associated (pn_arg2)) then
       call eval_node_init_eval_fun_unary (en, en1, key)
    else
       call eval_node_compile_pexpr (en2, pn_arg2, var_list)
       call eval_node_init_eval_fun_binary (en, en1, en2, key)
    end if
    call eval_node_set_observables (en, var_list)
    call eval_node_compile_expr (en0, pn_arg0, en%var_list)
    if (en0%result_type /= V_REAL) &
         call msg_fatal (" 'eval' function does not result in real value")
    call eval_node_set_expr (en, en0)
    if (debug) then
       call eval_node_write (en)
       print *, "done eval_function"
    end if
  end subroutine eval_node_compile_eval_function

@ %def eval_node_compile_eval_function
@ Logical functions of subevents.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_log_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_key, pn_str
    type(parse_node_t), pointer :: pn_arg0, pn_args, pn_arg1, pn_arg2
    type(eval_node_t), pointer :: en0, en1, en2
    type(string_t) :: key
    if (debug) then
       print *, "read log_function";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("all_fun", "any_fun", "no_fun")
       pn_key => parse_node_get_sub_ptr (pn)
       pn_arg0 => parse_node_get_next_ptr (pn_key)
       pn_args => parse_node_get_next_ptr (pn_arg0)
    case ("user_cut_fun")
       pn_key => parse_node_get_sub_ptr (pn)
       pn_str => parse_node_get_next_ptr (pn_key)
       pn_arg0 => parse_node_get_sub_ptr (pn_str)
       pn_args => parse_node_get_next_ptr (pn_str)
    case default
       call parse_node_mismatch &
            ("all_fun|any_fun|no_fun|user_cut_fun", &
            pn)
    end select
    pn_arg1 => parse_node_get_sub_ptr (pn_args)
    pn_arg2 => parse_node_get_next_ptr (pn_arg1)
    key = parse_node_get_key (pn_key)
    call eval_node_compile_pexpr (en1, pn_arg1, var_list)
    allocate (en)
    if (.not. associated (pn_arg2)) then
       select case (char (key))
       case ("all")
          call eval_node_init_log_fun_unary (en, en1, key, all_p)
       case ("any")
          call eval_node_init_log_fun_unary (en, en1, key, any_p)
       case ("no")
          call eval_node_init_log_fun_unary (en, en1, key, no_p)
       case ("user_cut")
          call eval_node_init_log_fun_unary (en, en1, key, user_cut_p)
       case default
          call msg_bug ("Unary logical particle function '" // char (key) // &
               "' undefined")
       end select
    else
       call eval_node_compile_pexpr (en2, pn_arg2, var_list)
       select case (char (key))
       case ("all")
          call eval_node_init_log_fun_binary (en, en1, en2, key, all_pp)
       case ("any")
          call eval_node_init_log_fun_binary (en, en1, en2, key, any_pp)
       case ("no")
          call eval_node_init_log_fun_binary (en, en1, en2, key, no_pp)
       case default
          call msg_bug ("Binary logical particle function '" // char (key) // &
               "' undefined")
       end select
    end if
    if (associated (pn_arg0)) then
       call eval_node_set_observables (en, var_list)
       select case (char (key))
       case ("all", "any", "no")
          call eval_node_compile_lexpr (en0, pn_arg0, en%var_list)
       case ("user_cut")
          call eval_node_compile_sexpr (en0, pn_arg0, en%var_list)
       case default		       
          call msg_bug ("Compiling logical particle function: missing mode")
       end select
       call eval_node_set_expr (en, en0, V_LOG)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done log_function"
    end if
  end subroutine eval_node_compile_log_function

@ %def eval_node_compile_log_function
@ Numeric functions of subevents.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_numeric_function (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_clause, pn_key, pn_cond, pn_args
    type(parse_node_t), pointer :: pn_arg0, pn_arg1, pn_arg2
    type(eval_node_t), pointer :: en0, en1, en2
    type(string_t) :: key
    if (debug) then
       print *, "read numeric_function";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("count_fun")
       pn_clause => parse_node_get_sub_ptr (pn)
       pn_key  => parse_node_get_sub_ptr (pn_clause)
       pn_cond => parse_node_get_next_ptr (pn_key)
       if (associated (pn_cond)) then
          pn_arg0 => parse_node_get_sub_ptr (pn_cond, 2)
       else
          pn_arg0 => null ()
       end if
       pn_args => parse_node_get_next_ptr (pn_clause)
    case ("user_event_fun")
       pn_key => parse_node_get_sub_ptr (pn)
       pn_cond => parse_node_get_next_ptr (pn_key)
       pn_arg0 => parse_node_get_sub_ptr (pn_cond)
       pn_args => parse_node_get_next_ptr (pn_cond)
    end select
    pn_arg1 => parse_node_get_sub_ptr (pn_args)
    pn_arg2 => parse_node_get_next_ptr (pn_arg1)
    key = parse_node_get_key (pn_key)
    call eval_node_compile_pexpr (en1, pn_arg1, var_list)
    allocate (en)
    if (.not. associated (pn_arg2)) then
       select case (char (key))
       case ("count")
          call eval_node_init_int_fun_unary (en, en1, key, count_a)
       case ("user_event_shape")
          call eval_node_init_real_fun_unary (en, en1, key, user_event_shape_a)
       case default
          call msg_bug ("Unary subevent function '" // char (key) // &
               "' undefined")
       end select
    else
       call eval_node_compile_pexpr (en2, pn_arg2, var_list)
       select case (char (key))
       case ("count")
          call eval_node_init_int_fun_binary (en, en1, en2, key, count_pp)
       case default
          call msg_bug ("Binary subevent function '" // char (key) // &
               "' undefined")
       end select
    end if
    if (associated (pn_arg0)) then
       call eval_node_set_observables (en, var_list)
       select case (char (key))
       case ("count")
          call eval_node_compile_lexpr (en0, pn_arg0, en%var_list)
          call eval_node_set_expr (en, en0, V_INT)
       case ("user_event_shape")
          call eval_node_compile_sexpr (en0, pn_arg0, en%var_list)
          call eval_node_set_expr (en, en0, V_REAL)
       end select
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done numeric_function"
    end if
  end subroutine eval_node_compile_numeric_function

@ %def eval_node_compile_numeric_function
@ 
\subsubsection{PDG-code arrays}
A PDG-code expression is either prefixed by [[incoming]] or
[[outgoing]], a block, or a conditional.  In any case, it evaluates to
a constant.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_prefix_cexpr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_avalue, pn_prt
    type(string_t) :: key
    if (debug) then
       print *, "read prefix_cexpr";  call parse_node_write (pn)
    end if
    pn_avalue => parse_node_get_sub_ptr (pn)
    key = parse_node_get_rule_key (pn_avalue)
    select case (char (key))
    case ("incoming_prt")
       pn_prt => parse_node_get_sub_ptr (pn_avalue, 2)
       call eval_node_compile_cexpr (en, pn_prt, var_list)
    case ("outgoing_prt")
       pn_prt => parse_node_get_sub_ptr (pn_avalue, 1)
       call eval_node_compile_cexpr (en, pn_prt, var_list)
    case default
       call parse_node_mismatch &
            ("incoming_prt|outgoing_prt", &
             pn_avalue)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done prefix_cexpr"
    end if
  end subroutine eval_node_compile_prefix_cexpr

@ %def eval_node_compile_prefix_cexpr
@ A PDG array is a string of PDG code definitions (or aliases),
concatenated by ':'.  The code definitions may be variables which are
not defined at compile time, so we have to allocate sub-nodes.  This
analogous to [[eval_node_compile_term]].
<<Eval trees: procedures>>=
   recursive subroutine eval_node_compile_cexpr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_prt, pn_concatenation
    type(eval_node_t), pointer :: en1, en2
    type(pdg_array_t) :: aval
    if (debug) then
       print *, "read cexpr";  call parse_node_write (pn)
    end if
    pn_prt => parse_node_get_sub_ptr (pn)
    call eval_node_compile_avalue (en, pn_prt, var_list)
    pn_concatenation => parse_node_get_next_ptr (pn_prt)
    do while (associated (pn_concatenation))
       pn_prt => parse_node_get_sub_ptr (pn_concatenation, 2)
       en1 => en
       call eval_node_compile_avalue (en2, pn_prt, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call concat_cc (aval, en1, en2)
          call eval_node_init_pdg_array (en, aval)
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else
          call eval_node_init_branch (en, var_str (":"), V_PDG, en1, en2)
          call eval_node_set_op2_pdg (en, concat_cc)
       end if
       pn_concatenation => parse_node_get_next_ptr (pn_concatenation)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done cexpr"
    end if
  end subroutine eval_node_compile_cexpr

@ %def eval_node_compile_cexpr
@ Compile a PDG-code type value.  It may be either an integer expression
or a variable of type PDG array, optionally quoted.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_avalue (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    if (debug) then
       print *, "read avalue";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("pdg_code")
       call eval_node_compile_pdg_code (en, pn, var_list)
    case ("cvariable", "variable", "prt_name")
       call eval_node_compile_cvariable (en, pn, var_list)
    case ("cexpr")
       call eval_node_compile_cexpr (en, pn, var_list)
    case ("block_cexpr")
       call eval_node_compile_block_expr (en, pn, var_list, V_PDG)
    case ("conditional_cexpr")
       call eval_node_compile_conditional (en, pn, var_list, V_PDG)
    case default
       call parse_node_mismatch &
            ("grouped_cexpr|block_cexpr|conditional_cexpr|" // &
             "pdg_code|cvariable|prt_name", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done avalue"
    end if
  end subroutine eval_node_compile_avalue

@ %def eval_node_compile_avalue
@ Compile a PDG-code expression, which is the key [[PDG]] with an
integer expression as argument.  The procedure is analogous to
[[eval_node_compile_unary_function]].
<<Eval trees: procedures>>=
  subroutine eval_node_compile_pdg_code (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_arg
    type(eval_node_t), pointer :: en1
    type(string_t) :: key
    type(pdg_array_t) :: aval
    integer :: t
    if (debug) then
       print *, "read PDG code";  call parse_node_write (pn)
    end if
    pn_arg => parse_node_get_sub_ptr (pn, 2)
    call eval_node_compile_expr &
         (en1, parse_node_get_sub_ptr (pn_arg, tag="expr"), var_list)
    t = en1%result_type
    allocate (en)
    key = "PDG"
    if (en1%type == EN_CONSTANT) then
       select case (t)
       case (V_INT)
          call pdg_i (aval, en1)
          call eval_node_init_pdg_array (en, aval)
       case default;  call eval_type_error (pn, char (key), t)
       end select
       call eval_node_final_rec (en1)
       deallocate (en1)
    else
       select case (t)
       case (V_INT);  call eval_node_set_op1_pdg (en, pdg_i)
       case default;  call eval_type_error (pn, char (key), t)
       end select
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done function"
    end if
  end subroutine eval_node_compile_pdg_code

@ %def eval_node_compile_pdg_code
@ This is entirely analogous to [[eval_node_compile_variable]].
However, PDG-array variables occur in different contexts.

To avoid name clashes between PDG-array variables and ordinary
variables, we prepend a character ([[*]]).  This is not visible to the
user.
<<Eval trees: procedures>>=
  subroutine eval_node_compile_cvariable (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_name
    type(string_t) :: var_name
    type(var_entry_t), pointer :: var
    type(pdg_array_t), target, save :: no_aval
    logical, target, save :: unknown = .false.
    if (debug) then
       print *, "read cvariable";  call parse_node_write (pn)
    end if
    pn_name => pn
    var_name = parse_node_get_string (pn_name)
    var => var_list_get_var_ptr (var_list, var_name, V_PDG, defined=.true.)
    allocate (en)
    if (associated (var)) then
       call eval_node_init_pdg_array_ptr &
            (en, var_entry_get_name (var), var_entry_get_aval_ptr (var), &
             var_entry_get_known_ptr (var))
    else
       call parse_node_write (pn)
       call msg_error ("This PDG-array variable is undefined at this point")
       call eval_node_init_pdg_array_ptr (en, var_name, no_aval, unknown)
    end if
    if (debug) then
       call eval_node_write (en)
       print *, "done cvariable"
    end if
  end subroutine eval_node_compile_cvariable

@ %def eval_node_compile_cvariable
@ 
\subsubsection{String expressions}
A string expression is either a string value or a concatenation of
string values. 
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_sexpr (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_svalue, pn_concatenation, pn_op, pn_arg
    type(eval_node_t), pointer :: en1, en2
    type(string_t) :: string
    if (debug) then
       print *, "read sexpr";  call parse_node_write (pn)
    end if
    pn_svalue => parse_node_get_sub_ptr (pn)
    call eval_node_compile_svalue (en, pn_svalue, var_list)
    pn_concatenation => &
         parse_node_get_next_ptr (pn_svalue, tag="str_concatenation")
    do while (associated (pn_concatenation))
       pn_op => parse_node_get_sub_ptr (pn_concatenation)
       pn_arg => parse_node_get_next_ptr (pn_op)
       en1 => en
       call eval_node_compile_svalue (en2, pn_arg, var_list)
       allocate (en)
       if (en1%type == EN_CONSTANT .and. en2%type == EN_CONSTANT) then
          call concat_ss (string, en1, en2)
          call eval_node_init_string (en, string)
          call eval_node_final_rec (en1)
          call eval_node_final_rec (en2)
          deallocate (en1, en2)
       else   
          call eval_node_init_branch &
               (en, var_str ("concat"), V_STR, en1, en2)
          call eval_node_set_op2_str (en, concat_ss)
       end if
       pn_concatenation => parse_node_get_next_ptr (pn_concatenation)
    end do
    if (debug) then
       call eval_node_write (en)
       print *, "done sexpr"
    end if
  end subroutine eval_node_compile_sexpr

@ %def eval_node_compile_sexpr
@ A string value is a string literal, a 
variable, a (grouped) sexpr, a block sexpr, or a conditional.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_svalue (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    if (debug) then
       print *, "read svalue";  call parse_node_write (pn)
    end if
    select case (char (parse_node_get_rule_key (pn)))
    case ("svariable")
       call eval_node_compile_variable (en, pn, var_list, V_STR)
    case ("sexpr")
       call eval_node_compile_sexpr (en, pn, var_list)
    case ("block_sexpr")
       call eval_node_compile_block_expr (en, pn, var_list, V_STR)
    case ("conditional_sexpr")
       call eval_node_compile_conditional (en, pn, var_list, V_STR)
    case ("sprintf_fun")
       call eval_node_compile_sprintf (en, pn, var_list)
    case ("string_literal")
       allocate (en)
       call eval_node_init_string (en, parse_node_get_string (pn))
    case default
       call parse_node_mismatch &
            ("svariable|" // &
             "grouped_sexpr|block_sexpr|conditional_sexpr|" // &
             "string_function|string_literal", pn)
    end select
    if (debug) then
       call eval_node_write (en)
       print *, "done svalue"
    end if
  end subroutine eval_node_compile_svalue

@ %def eval_node_compile_svalue
@ There is currently one string function, [[sprintf]].  For
[[sprintf]], the first argument (no brackets) is the format string, the
optional arguments in brackets are the expressions or variables to be
formatted.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_compile_sprintf (en, pn, var_list)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_clause, pn_key, pn_args
    type(parse_node_t), pointer :: pn_arg0
    type(eval_node_t), pointer :: en0, en1
    integer :: n_args
    type(string_t) :: key
    if (debug) then
       print *, "read sprintf_fun";  call parse_node_write (pn)
    end if
    pn_clause => parse_node_get_sub_ptr (pn)
    pn_key  => parse_node_get_sub_ptr (pn_clause)
    pn_arg0 => parse_node_get_next_ptr (pn_key)
    pn_args => parse_node_get_next_ptr (pn_clause)
    call eval_node_compile_sexpr (en0, pn_arg0, var_list)
    if (associated (pn_args)) then
       call eval_node_compile_sprintf_args (en1, pn_args, var_list, n_args)
    else
       n_args = 0
       en1 => null ()
    end if
    allocate (en)
    key = parse_node_get_key (pn_key)
    call eval_node_init_format_string (en, en0, en1, key, n_args)
    if (debug) then
       call eval_node_write (en)
       print *, "done sprintf_fun"
    end if
  end subroutine eval_node_compile_sprintf

@ %def eval_node_compile_sprintf
<<Eval trees: procedures>>=
  subroutine eval_node_compile_sprintf_args (en, pn, var_list, n_args)
    type(eval_node_t), pointer :: en
    type(parse_node_t), intent(in) :: pn
    type(var_list_t), intent(in), target :: var_list
    integer, intent(out) :: n_args
    type(parse_node_t), pointer :: pn_arg
    integer :: i
    type(eval_node_t), pointer :: en1, en2
    n_args = parse_node_get_n_sub (pn)
    en => null ()
    do i = n_args, 1, -1
       pn_arg => parse_node_get_sub_ptr (pn, i)
       select case (char (parse_node_get_rule_key (pn_arg)))
       case ("lvariable")
          call eval_node_compile_variable (en1, pn_arg, var_list, V_LOG)
       case ("svariable")
          call eval_node_compile_variable (en1, pn_arg, var_list, V_STR)
       case ("expr")
          call eval_node_compile_expr (en1, pn_arg, var_list)
       case default
          call parse_node_mismatch ("variable|svariable|lvariable|expr", pn_arg)
       end select
       if (associated (en)) then
          en2 => en
          allocate (en)
          call eval_node_init_branch &
               (en, var_str ("sprintf_arg"), V_NONE, en1, en2)
       else
          allocate (en)
          call eval_node_init_branch &
               (en, var_str ("sprintf_arg"), V_NONE, en1)
       end if
    end do
  end subroutine eval_node_compile_sprintf_args

@ %def eval_node_compile_sprintf_args
@ Evaluation.  We allocate the argument list and apply the Fortran wrapper for
the [[sprintf]] function. 
<<Eval trees: procedures>>=
  subroutine evaluate_sprintf (string, n_args, en_fmt, en_arg)
    type(string_t), intent(out) :: string
    integer, intent(in) :: n_args
    type(eval_node_t), pointer :: en_fmt
    type(eval_node_t), intent(in), optional, target :: en_arg
    type(eval_node_t), pointer :: en_branch, en_var
    type(sprintf_arg_t), dimension(:), allocatable :: arg
    type(string_t) :: fmt
    logical :: autoformat
    integer :: i, j, sprintf_argc
    autoformat = .not. associated (en_fmt)
    if (autoformat) fmt = ""
    if (present (en_arg)) then
       sprintf_argc = 0
       en_branch => en_arg
       do i = 1, n_args
          select case (en_branch%arg1%result_type)
             case (V_CMPLX); sprintf_argc = sprintf_argc + 2
             case default  ; sprintf_argc = sprintf_argc + 1
          end select
          en_branch => en_branch%arg2
       end do
       allocate (arg (sprintf_argc))
       j = 1
       en_branch => en_arg
       do i = 1, n_args
          en_var => en_branch%arg1
          select case (en_var%result_type)
          case (V_LOG)
             call sprintf_arg_init (arg(j), en_var%lval)
             if (autoformat) fmt = fmt // "%s "
          case (V_INT);
             call sprintf_arg_init (arg(j), en_var%ival)
             if (autoformat) fmt = fmt // "%i "
          case (V_REAL);
             call sprintf_arg_init (arg(j), en_var%rval)
             if (autoformat) fmt = fmt // "%g "
          case (V_STR)
             call sprintf_arg_init (arg(j), en_var%sval)
             if (autoformat) fmt = fmt // "%s "
          case (V_CMPLX)
             call sprintf_arg_init (arg(j), real (en_var%cval, default))
             j = j + 1
             call sprintf_arg_init (arg(j), aimag (en_var%cval))
             if (autoformat) fmt = fmt // "(%g + %g * I) "
          case default
             call eval_node_write (en_var)
             call msg_error ("sprintf is implemented " &
                  // "for logical, integer, real, and string values only")
          end select
          j = j + 1
          en_branch => en_branch%arg2
       end do
    else
       allocate (arg(0))
    end if
    if (autoformat) then
       string = sprintf (trim (fmt), arg)
    else
       string = sprintf (en_fmt%sval, arg)
    end if
  end subroutine evaluate_sprintf

@ %def evaluate_sprintf
@ 
\subsection{Auxiliary functions for the compiler}
Issue an error that the current node could not be compiled because of
type mismatch:
<<Eval trees: procedures>>=
  subroutine eval_type_error (pn, string, t)
    type(parse_node_t), intent(in) :: pn
    character(*), intent(in) :: string
    integer, intent(in) :: t
    type(string_t) :: type
    select case (t)
    case (V_NONE); type = "(none)"
    case (V_LOG);  type = "'logical'"
    case (V_INT);  type = "'integer'"
    case (V_REAL); type = "'real'"
    case (V_CMPLX); type = "'complex'"    
    case default;  type = "(unknown)"
    end select
    call parse_node_write (pn)
    call msg_fatal (" The " // string // &
         " operation is not defined for the given argument type " // &
         char (type))
  end subroutine eval_type_error

@ %def eval_type_error
@
If two numerics are combined, the result is integer if both
arguments are integer, if one is integer and the other real or both
are real, than its argument is real, otherwise complex.
<<Eval trees: procedures>>=
  function numeric_result_type (t1, t2) result (t)
    integer, intent(in) :: t1, t2
    integer :: t
    if (t1 == V_INT .and. t2 == V_INT) then
       t = V_INT
    else if (t1 == V_INT .and. t2 == V_REAL) then
       t = V_REAL
    else if (t1 == V_REAL .and. t2 == V_INT) then
       t = V_REAL
    else if (t1 == V_REAL .and. t2 == V_REAL) then
       t = V_REAL   
    else
       t = V_CMPLX
    end if
  end function numeric_result_type

@ %def numeric_type
@
\subsection{Evaluation}
Evaluation is done recursively.  For leaf nodes nothing is to be done.

Evaluating particle-list functions: First, we evaluate the particle
lists.  If a condition is present, we assign the particle pointers of
the condition node to the allocated particle entries in the parent
node, keeping in mind that the observables in the variable stack used
for the evaluation of the condition also contain pointers to these
entries.  Then, the assigned procedure is evaluated, which sets the
subevent in the parent node.  If required, the procedure
evaluates the condition node once for each (pair of) particles to
determine the result.
<<Eval trees: procedures>>=
  recursive subroutine eval_node_evaluate (en)
    type(eval_node_t), intent(inout) :: en
    logical :: exist
    select case (en%type)
    case (EN_UNARY)
       if (associated (en%arg1)) then
          call eval_node_evaluate (en%arg1)
          en%value_is_known = en%arg1%value_is_known
       else
          en%value_is_known = .false.
       end if
       if (en%value_is_known) then
          select case (en%result_type)
          case (V_LOG);  en%lval = en% op1_log  (en%arg1)
          case (V_INT);  en%ival = en% op1_int  (en%arg1)
          case (V_REAL); en%rval = en% op1_real (en%arg1)
          case (V_CMPLX); en%cval = en% op1_cmplx (en%arg1)          
          case (V_PDG);  
             call en% op1_pdg  (en%aval, en%arg1)
          case (V_SEV)
             if (associated (en%arg0)) then
                call en% op1_sev (en%pval, en%arg1, en%arg0)
             else
                call en% op1_sev (en%pval, en%arg1)
             end if
          case (V_STR)
             call en% op1_str (en%sval, en%arg1)
          end select
       end if
    case (EN_BINARY)
       if (associated (en%arg1) .and. associated (en%arg2)) then
          call eval_node_evaluate (en%arg1)
          call eval_node_evaluate (en%arg2)
          en%value_is_known = &
               en%arg1%value_is_known .and. en%arg2%value_is_known
       else
          en%value_is_known = .false.
       end if
       if (en%value_is_known) then
          select case (en%result_type)
          case (V_LOG);  en%lval = en% op2_log  (en%arg1, en%arg2)
          case (V_INT);  en%ival = en% op2_int  (en%arg1, en%arg2)
          case (V_REAL); en%rval = en% op2_real (en%arg1, en%arg2)
          case (V_CMPLX); en%cval = en% op2_cmplx (en%arg1, en%arg2)          
          case (V_PDG)
             call en% op2_pdg  (en%aval, en%arg1, en%arg2)
          case (V_SEV)
             if (associated (en%arg0)) then
                call en% op2_sev (en%pval, en%arg1, en%arg2, en%arg0)
             else
                call en% op2_sev (en%pval, en%arg1, en%arg2)
             end if
          case (V_STR)
             call en% op2_str (en%sval, en%arg1, en%arg2)
          end select
       end if
    case (EN_BLOCK)
       if (associated (en%arg1) .and. associated (en%arg0)) then
          call eval_node_evaluate (en%arg1)
          call eval_node_evaluate (en%arg0)
          en%value_is_known = en%arg0%value_is_known
       else
          en%value_is_known = .false.
       end if
       if (en%value_is_known) then
          select case (en%result_type)
          case (V_LOG);  en%lval = en%arg0%lval
          case (V_INT);  en%ival = en%arg0%ival
          case (V_REAL); en%rval = en%arg0%rval
          case (V_CMPLX); en%cval = en%arg0%cval          
          case (V_PDG);  en%aval = en%arg0%aval
          case (V_SEV);  en%pval = en%arg0%pval
          case (V_STR);  en%sval = en%arg0%sval
          end select
       end if
    case (EN_CONDITIONAL)
       if (associated (en%arg0)) then
          call eval_node_evaluate (en%arg0)
          en%value_is_known = en%arg0%value_is_known
       else
          en%value_is_known = .false.
       end if
       if (en%arg0%value_is_known) then
          if (en%arg0%lval) then
             call eval_node_evaluate (en%arg1)
             en%value_is_known = en%arg1%value_is_known
             if (en%value_is_known) then
                select case (en%result_type)
                case (V_LOG);  en%lval = en%arg1%lval
                case (V_INT);  en%ival = en%arg1%ival
                case (V_REAL); en%rval = en%arg1%rval
                case (V_CMPLX); en%cval = en%arg1%cval                
                case (V_PDG);  en%aval = en%arg1%aval
                case (V_SEV);  en%pval = en%arg1%pval
                case (V_STR);  en%sval = en%arg1%sval
                end select
             end if
          else
             call eval_node_evaluate (en%arg2)
             en%value_is_known = en%arg2%value_is_known
             if (en%value_is_known) then
                select case (en%result_type)
                case (V_LOG);  en%lval = en%arg2%lval
                case (V_INT);  en%ival = en%arg2%ival
                case (V_REAL); en%rval = en%arg2%rval
                case (V_CMPLX); en%cval = en%arg2%cval                
                case (V_PDG);  en%aval = en%arg2%aval
                case (V_SEV);  en%pval = en%arg2%pval
                case (V_STR);  en%sval = en%arg2%sval
                end select
             end if
          end if
       end if
       ! call eval_node_write_rec (en)   !!! Debugging
    case (EN_RECORD_CMD)
       exist = .true.
       en%lval = .false.
       call eval_node_evaluate (en%arg0)
       if (en%arg0%value_is_known) then
          if (associated (en%arg1)) then
             call eval_node_evaluate (en%arg1)
             if (en%arg1%value_is_known) then
                if (associated (en%arg2)) then
                   call eval_node_evaluate (en%arg2)
                   if (en%arg2%value_is_known) then
                      if (associated (en%arg3)) then
                         call eval_node_evaluate (en%arg3)
                         if (en%arg3%value_is_known) then
                            if (associated (en%arg4)) then
                               call eval_node_evaluate (en%arg4)
                               if (en%arg4%value_is_known) then
                                  if (associated (en%rval)) then
                                     call analysis_record_data (en%arg0%sval, &
                                          en%arg1%rval, en%arg2%rval, &
                                          en%arg3%rval, en%arg4%rval, &
                                          weight=en%rval, exist=exist, &
                                          success=en%lval)
                                  else
                                     call analysis_record_data (en%arg0%sval, &
                                          en%arg1%rval, en%arg2%rval, &
                                          en%arg3%rval, en%arg4%rval, &
                                          exist=exist, success=en%lval)
                                  end if
                               end if
                            else                                   
                               if (associated (en%rval)) then
                                  call analysis_record_data (en%arg0%sval, &
                                       en%arg1%rval, en%arg2%rval, &
                                       en%arg3%rval, &
                                       weight=en%rval, exist=exist, &
                                       success=en%lval)
                               else
                                  call analysis_record_data (en%arg0%sval, &
                                       en%arg1%rval, en%arg2%rval, &
                                       en%arg3%rval, &
                                       exist=exist, success=en%lval)
                               end if
                            end if
                         end if
                      else
                         if (associated (en%rval)) then
                            call analysis_record_data (en%arg0%sval, &
                                 en%arg1%rval, en%arg2%rval, &
                                 weight=en%rval, exist=exist, &
                                 success=en%lval)
                         else
                            call analysis_record_data (en%arg0%sval, &
                                 en%arg1%rval, en%arg2%rval, &
                                 exist=exist, success=en%lval)
                         end if
                      end if
                   end if
                else
                   if (associated (en%rval)) then
                      call analysis_record_data (en%arg0%sval, &
                           en%arg1%rval, &
                           weight=en%rval, exist=exist, success=en%lval)
                   else
                      call analysis_record_data (en%arg0%sval, &
                           en%arg1%rval, &
                           exist=exist, success=en%lval)
                   end if
                end if
             end if
          else
             if (associated (en%rval)) then
                call analysis_record_data (en%arg0%sval, 1._default, &
                     weight=en%rval, exist=exist, success=en%lval)
             else
                call analysis_record_data (en%arg0%sval, 1._default, &
                     exist=exist, success=en%lval)
             end if
          end if
          if (.not. exist) then
             call msg_error ("Analysis object '" // char (en%arg0%sval) &
                  // "' is undefined")
             en%arg0%value_is_known = .false.
          end if
       end if
    case (EN_OBS1_INT)
       en%ival = en% obs1_int (en%prt1)
       en%value_is_known = .true.
    case (EN_OBS2_INT)
       en%ival = en% obs2_int (en%prt1, en%prt2)
       en%value_is_known = .true.
    case (EN_OBS1_REAL)
       en%rval = en% obs1_real (en%prt1)
       en%value_is_known = .true.
    case (EN_OBS2_REAL)
       en%rval = en% obs2_real (en%prt1, en%prt2)
       en%value_is_known = .true.
    case (EN_UOBS1_INT)
       en%ival = user_obs_int_p (en%arg0, en%prt1)
       en%value_is_known = .true.
    case (EN_UOBS2_INT)
       en%ival = user_obs_int_pp (en%arg0, en%prt1, en%prt2)
       en%value_is_known = .true.
    case (EN_UOBS1_REAL)
       en%rval = user_obs_real_p (en%arg0, en%prt1)
       en%value_is_known = .true.
    case (EN_UOBS2_REAL)
       en%rval = user_obs_real_pp (en%arg0, en%prt1, en%prt2)
       en%value_is_known = .true.
    case (EN_PRT_FUN_UNARY)
       call eval_node_evaluate (en%arg1)
       en%value_is_known = en%arg1%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             call en% op1_sev (en%pval, en%arg1, en%arg0)
          else
             call en% op1_sev (en%pval, en%arg1)
          end if
       end if
    case (EN_PRT_FUN_BINARY)
       call eval_node_evaluate (en%arg1)
       call eval_node_evaluate (en%arg2)
       en%value_is_known = &
            en%arg1%value_is_known .and. en%arg2%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             en%arg0%prt2 => en%prt2
             call en% op2_sev (en%pval, en%arg1, en%arg2, en%arg0)
          else
             call en% op2_sev (en%pval, en%arg1, en%arg2)
          end if
       end if
    case (EN_EVAL_FUN_UNARY)
       call eval_node_evaluate (en%arg1)
       en%value_is_known = subevt_is_nonempty (en%arg1%pval)
       if (en%value_is_known) then
          en%arg0%index => en%index
          en%index = 1
          en%arg0%prt1 => en%prt1
          en%prt1 = subevt_get_prt (en%arg1%pval, 1)
          call eval_node_evaluate (en%arg0)
          en%rval = en%arg0%rval
       end if
    case (EN_EVAL_FUN_BINARY)
       call eval_node_evaluate (en%arg1)
       call eval_node_evaluate (en%arg2)
       en%value_is_known = &
            subevt_is_nonempty (en%arg1%pval) .and. &
            subevt_is_nonempty (en%arg2%pval)
       if (en%value_is_known) then
          en%arg0%index => en%index
          en%arg0%prt1 => en%prt1
          en%arg0%prt2 => en%prt2
          en%index = 1
          call eval_pp (en%arg1, en%arg2, en%arg0, en%rval, en%value_is_known)
       end if
    case (EN_LOG_FUN_UNARY)
       call eval_node_evaluate (en%arg1)
       en%value_is_known = .true.
       if (en%value_is_known) then
          en%arg0%index => en%index
          en%arg0%prt1 => en%prt1
          en%lval = en% op1_cut (en%arg1, en%arg0)
       end if
    case (EN_LOG_FUN_BINARY)
       call eval_node_evaluate (en%arg1)
       call eval_node_evaluate (en%arg2)
       en%value_is_known = .true.
       if (en%value_is_known) then
          en%arg0%index => en%index
          en%arg0%prt1 => en%prt1
          en%arg0%prt2 => en%prt2
          en%lval = en% op2_cut (en%arg1, en%arg2, en%arg0)
       end if
    case (EN_INT_FUN_UNARY)
       call eval_node_evaluate (en%arg1)
       en%value_is_known = en%arg1%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             call en% op1_evi (en%ival, en%arg1, en%arg0)
          else
             call en% op1_evi (en%ival, en%arg1)
          end if
       end if
    case (EN_INT_FUN_BINARY)
       call eval_node_evaluate (en%arg1)
       call eval_node_evaluate (en%arg2)
       en%value_is_known = &
            en%arg1%value_is_known .and. &
            en%arg2%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             en%arg0%prt2 => en%prt2
             call en% op2_evi (en%ival, en%arg1, en%arg2, en%arg0)
          else
             call en% op2_evi (en%ival, en%arg1, en%arg2) 
          end if
       end if
    case (EN_REAL_FUN_UNARY)
       call eval_node_evaluate (en%arg1)
       en%value_is_known = en%arg1%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             call en% op1_evr (en%rval, en%arg1, en%arg0)
          else
             call en% op1_evr (en%rval, en%arg1)
          end if
       end if
    case (EN_REAL_FUN_BINARY)
       call eval_node_evaluate (en%arg1)
       call eval_node_evaluate (en%arg2)
       en%value_is_known = &
            en%arg1%value_is_known .and. &
            en%arg2%value_is_known
       if (en%value_is_known) then
          if (associated (en%arg0)) then
             en%arg0%index => en%index
             en%arg0%prt1 => en%prt1
             en%arg0%prt2 => en%prt2
             call en% op2_evr (en%rval, en%arg1, en%arg2, en%arg0)
          else
             call en% op2_evr (en%rval, en%arg1, en%arg2) 
          end if
       end if
    case (EN_FORMAT_STR)
       if (associated (en%arg0)) then
          call eval_node_evaluate (en%arg0)
          en%value_is_known = en%arg0%value_is_known
       else
          en%value_is_known = .true.
       end if
       if (associated (en%arg1)) then
          call eval_node_evaluate (en%arg1)
          en%value_is_known = &
               en%value_is_known .and. en%arg1%value_is_known
          if (en%value_is_known) then
             call evaluate_sprintf (en%sval, en%ival, en%arg0, en%arg1)
          end if
       else
          if (en%value_is_known) then
             call evaluate_sprintf (en%sval, en%ival, en%arg0)
          end if
       end if
    end select
    if (debug) then
       print *, "evaluated"
       call eval_node_write (en)
    end if
  end subroutine eval_node_evaluate

@ %def eval_node_evaluate
@ 
\subsection{Evaluation syntax}
We have two different flavors of the syntax: with and without particles.
<<Eval trees: variables>>=
  type(syntax_t), target, save :: syntax_expr
  type(syntax_t), target, save :: syntax_pexpr

@ %def syntax_expr syntax_pexpr
@ These are for testing only and may be removed:
<<Eval trees: public>>=
  public :: syntax_expr_init
  public :: syntax_pexpr_init
<<Eval trees: procedures>>=
  subroutine syntax_expr_init ()
    type(ifile_t) :: ifile
    call define_expr_syntax (ifile, particles=.false., analysis=.false.)
    call syntax_init (syntax_expr, ifile)
    call ifile_final (ifile)
  end subroutine syntax_expr_init

  subroutine syntax_pexpr_init ()
    type(ifile_t) :: ifile
    call define_expr_syntax (ifile, particles=.true., analysis=.false.)
    call syntax_init (syntax_pexpr, ifile)
    call ifile_final (ifile)
  end subroutine syntax_pexpr_init

@ %def syntax_expr_init syntax_pexpr_init
<<Eval trees: public>>=
  public :: syntax_expr_final
  public :: syntax_pexpr_final
<<Eval trees: procedures>>=
  subroutine syntax_expr_final ()
    call syntax_final (syntax_expr)
  end subroutine syntax_expr_final

  subroutine syntax_pexpr_final ()
    call syntax_final (syntax_pexpr)
  end subroutine syntax_pexpr_final

@ %def syntax_expr_final syntax_pexpr_final
<<Eval trees: public>>=
  public :: syntax_pexpr_write
<<Eval trees: procedures>>=
  subroutine syntax_pexpr_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_pexpr, unit)
  end subroutine syntax_pexpr_write

@ %def syntax_pexpr_write
<<Eval trees: public>>=
  public :: define_expr_syntax
@ Numeric expressions.
<<Eval trees: procedures>>=
  subroutine define_expr_syntax (ifile, particles, analysis)
    type(ifile_t), intent(inout) :: ifile
    logical, intent(in) :: particles, analysis
    type(string_t) :: numeric_pexpr
    type(string_t) :: var_plist, var_alias
    if (particles) then
       numeric_pexpr = " | numeric_pexpr"
       var_plist = " | var_plist"
       var_alias = " | var_alias"
    else
       numeric_pexpr = ""
       var_plist = ""
       var_alias = ""
    end if
    call ifile_append (ifile, "SEQ expr = subexpr addition*")
    call ifile_append (ifile, "ALT subexpr = addition | term")
    call ifile_append (ifile, "SEQ addition = plus_or_minus term")
    call ifile_append (ifile, "SEQ term = factor multiplication*")
    call ifile_append (ifile, "SEQ multiplication = times_or_over factor")
    call ifile_append (ifile, "SEQ factor = value exponentiation?")
    call ifile_append (ifile, "SEQ exponentiation = to_the value")
    call ifile_append (ifile, "ALT plus_or_minus = '+' | '-'")
    call ifile_append (ifile, "ALT times_or_over = '*' | '/'")
    call ifile_append (ifile, "ALT to_the = '^' | '**'")
    call ifile_append (ifile, "KEY '+'")
    call ifile_append (ifile, "KEY '-'")
    call ifile_append (ifile, "KEY '*'")
    call ifile_append (ifile, "KEY '/'")
    call ifile_append (ifile, "KEY '^'")
    call ifile_append (ifile, "KEY '**'")
    call ifile_append (ifile, "ALT value = signed_value | unsigned_value")
    call ifile_append (ifile, "SEQ signed_value = '-' unsigned_value")
    call ifile_append (ifile, "ALT unsigned_value = " // &
         "numeric_value | constant | variable | " // &
         "result | user_observable | " // &
         "grouped_expr | block_expr | conditional_expr | " // &
         "unary_function | binary_function" // &
         numeric_pexpr)
    call ifile_append (ifile, "ALT numeric_value = integer_value | " &
         // "real_value | complex_value")
    call ifile_append (ifile, "SEQ integer_value = integer_literal unit_expr?")
    call ifile_append (ifile, "SEQ real_value = real_literal unit_expr?")
    call ifile_append (ifile, "SEQ complex_value = complex_literal unit_expr?")    
    call ifile_append (ifile, "INT integer_literal")
    call ifile_append (ifile, "REA real_literal")
    call ifile_append (ifile, "COM complex_literal")
    call ifile_append (ifile, "SEQ unit_expr = unit unit_power?")
    call ifile_append (ifile, "ALT unit = " // &
         "TeV | GeV | MeV | keV | eV | meV | " // &
         "nbarn | pbarn | fbarn | abarn | " // &
         "rad | mrad | degree | '%'")
    call ifile_append (ifile, "KEY TeV")
    call ifile_append (ifile, "KEY GeV")
    call ifile_append (ifile, "KEY MeV")
    call ifile_append (ifile, "KEY keV")
    call ifile_append (ifile, "KEY eV")
    call ifile_append (ifile, "KEY meV")
    call ifile_append (ifile, "KEY nbarn")
    call ifile_append (ifile, "KEY pbarn")
    call ifile_append (ifile, "KEY fbarn")
    call ifile_append (ifile, "KEY abarn")
    call ifile_append (ifile, "KEY rad")
    call ifile_append (ifile, "KEY mrad")
    call ifile_append (ifile, "KEY degree")
    call ifile_append (ifile, "KEY '%'")
    call ifile_append (ifile, "SEQ unit_power = '^' frac_expr")
    call ifile_append (ifile, "ALT frac_expr = frac | grouped_frac")
    call ifile_append (ifile, "GRO grouped_frac = ( frac_expr )")
    call ifile_append (ifile, "SEQ frac = signed_int div?")
    call ifile_append (ifile, "ALT signed_int = " &
         // "neg_int | pos_int | integer_literal")
    call ifile_append (ifile, "SEQ neg_int = '-' integer_literal")
    call ifile_append (ifile, "SEQ pos_int = '+' integer_literal")
    call ifile_append (ifile, "SEQ div = '/' integer_literal")
    call ifile_append (ifile, "ALT constant = pi | I")
    call ifile_append (ifile, "KEY pi")
    call ifile_append (ifile, "KEY I")
    call ifile_append (ifile, "IDE variable")
    call ifile_append (ifile, "SEQ result = result_key result_arg")
    call ifile_append (ifile, "ALT result_key = " // &
         "num_id | integral | error")
    call ifile_append (ifile, "SEQ user_observable = user_obs user_arg")
    call ifile_append (ifile, "KEY user_obs")
    call ifile_append (ifile, "ARG user_arg = ( sexpr )")
    call ifile_append (ifile, "KEY num_id")
    call ifile_append (ifile, "KEY integral")
    call ifile_append (ifile, "KEY error")
    call ifile_append (ifile, "GRO result_arg = ( process_id )")
    call ifile_append (ifile, "IDE process_id")
    call ifile_append (ifile, "SEQ unary_function = fun_unary function_arg1")
    call ifile_append (ifile, "SEQ binary_function = fun_binary function_arg2")
    call ifile_append (ifile, "ALT fun_unary = " // &
         "complex | real | int | nint | floor | ceiling | abs | sgn | " // &
         "sqrt | exp | log | log10 | " // &
         "sin | cos | tan | asin | acos | atan | " // &
         "sinh | cosh | tanh")
    call ifile_append (ifile, "KEY complex")
    call ifile_append (ifile, "KEY real")
    call ifile_append (ifile, "KEY int")
    call ifile_append (ifile, "KEY nint")
    call ifile_append (ifile, "KEY floor")
    call ifile_append (ifile, "KEY ceiling")
    call ifile_append (ifile, "KEY abs")
    call ifile_append (ifile, "KEY sgn")
    call ifile_append (ifile, "KEY sqrt")
    call ifile_append (ifile, "KEY exp")
    call ifile_append (ifile, "KEY log")
    call ifile_append (ifile, "KEY log10")
    call ifile_append (ifile, "KEY sin")
    call ifile_append (ifile, "KEY cos")
    call ifile_append (ifile, "KEY tan")
    call ifile_append (ifile, "KEY asin")
    call ifile_append (ifile, "KEY acos")
    call ifile_append (ifile, "KEY atan")
    call ifile_append (ifile, "KEY sinh")
    call ifile_append (ifile, "KEY cosh")
    call ifile_append (ifile, "KEY tanh")
    call ifile_append (ifile, "ALT fun_binary = max | min | mod | modulo")
    call ifile_append (ifile, "KEY max")
    call ifile_append (ifile, "KEY min")
    call ifile_append (ifile, "KEY mod")
    call ifile_append (ifile, "KEY modulo")
    call ifile_append (ifile, "ARG function_arg1 = ( expr )")
    call ifile_append (ifile, "ARG function_arg2 = ( expr, expr )")
    call ifile_append (ifile, "GRO grouped_expr = ( expr )")
    call ifile_append (ifile, "SEQ block_expr = let var_spec in expr")
    call ifile_append (ifile, "KEY let")
    call ifile_append (ifile, "ALT var_spec = " // &
         "var_num | var_int | var_real | var_complex | " // &
         "var_logical" // var_plist // var_alias // " | var_string")
    call ifile_append (ifile, "SEQ var_num = var_name '=' expr")
    call ifile_append (ifile, "SEQ var_int = int var_name '=' expr")
    call ifile_append (ifile, "SEQ var_real = real var_name '=' expr")
    call ifile_append (ifile, "SEQ var_complex = complex var_name '=' complex_expr")
    call ifile_append (ifile, "ALT complex_expr = " // &
         "cexpr_real | cexpr_complex")
    call ifile_append (ifile, "ARG cexpr_complex = ( expr, expr )")
    call ifile_append (ifile, "SEQ cexpr_real = expr")
    call ifile_append (ifile, "IDE var_name")
    call ifile_append (ifile, "KEY '='")
    call ifile_append (ifile, "KEY in")
    call ifile_append (ifile, "SEQ conditional_expr = " // &
         "if lexpr then expr maybe_elsif_expr maybe_else_expr endif")
    call ifile_append (ifile, "SEQ maybe_elsif_expr = elsif_expr*")
    call ifile_append (ifile, "SEQ maybe_else_expr = else_expr?")
    call ifile_append (ifile, "SEQ elsif_expr = elsif lexpr then expr")
    call ifile_append (ifile, "SEQ else_expr = else expr")
    call ifile_append (ifile, "KEY if")
    call ifile_append (ifile, "KEY then")
    call ifile_append (ifile, "KEY elsif")
    call ifile_append (ifile, "KEY else")
    call ifile_append (ifile, "KEY endif")
    call define_lexpr_syntax (ifile, particles, analysis)
    call define_sexpr_syntax (ifile)
    if (particles) then
       call define_pexpr_syntax (ifile)
       call define_cexpr_syntax (ifile)
       call define_var_plist_syntax (ifile)
       call define_var_alias_syntax (ifile)
       call define_numeric_pexpr_syntax (ifile)
       call define_logical_pexpr_syntax (ifile)
    end if

  end subroutine define_expr_syntax

@ %def define_expr_syntax
@ Logical expressions.
<<Eval trees: procedures>>=
  subroutine define_lexpr_syntax (ifile, particles, analysis)
    type(ifile_t), intent(inout) :: ifile
    logical, intent(in) :: particles, analysis
    type(string_t) :: logical_pexpr, record_cmd
    if (particles) then
       logical_pexpr = " | logical_pexpr"
    else
       logical_pexpr = ""
    end if
    if (analysis) then
       record_cmd = " | record_cmd"
    else
       record_cmd = ""
    end if
    call ifile_append (ifile, "SEQ lexpr = lsinglet lsequel*")
    call ifile_append (ifile, "SEQ lsequel = ';' lsinglet")
    call ifile_append (ifile, "SEQ lsinglet = lterm alternative*")
    call ifile_append (ifile, "SEQ alternative = or lterm")
    call ifile_append (ifile, "SEQ lterm = lvalue coincidence*")
    call ifile_append (ifile, "SEQ coincidence = and lvalue")
    call ifile_append (ifile, "KEY ';'")
    call ifile_append (ifile, "KEY or")
    call ifile_append (ifile, "KEY and")
    call ifile_append (ifile, "ALT lvalue = " // &
         "true | false | lvariable | negation | " // &
         "grouped_lexpr | block_lexpr | conditional_lexpr | " // &
         "compared_expr | compared_sexpr" // &
         logical_pexpr //  record_cmd)
    call ifile_append (ifile, "KEY true")
    call ifile_append (ifile, "KEY false")
    call ifile_append (ifile, "SEQ lvariable = '?' alt_lvariable")
    call ifile_append (ifile, "KEY '?'")
    call ifile_append (ifile, "ALT alt_lvariable = variable | grouped_lexpr")
    call ifile_append (ifile, "SEQ negation = not lvalue")
    call ifile_append (ifile, "KEY not")
    call ifile_append (ifile, "GRO grouped_lexpr = ( lexpr )")
    call ifile_append (ifile, "SEQ block_lexpr = let var_spec in lexpr")
    call ifile_append (ifile, "ALT var_logical = " // &
         "var_logical_new | var_logical_spec")
    call ifile_append (ifile, "SEQ var_logical_new = logical var_logical_spec")
    call ifile_append (ifile, "KEY logical")
    call ifile_append (ifile, "SEQ var_logical_spec = '?' var_name = lexpr")
    call ifile_append (ifile, "SEQ conditional_lexpr = " // &
         "if lexpr then lexpr maybe_elsif_lexpr maybe_else_lexpr endif")
    call ifile_append (ifile, "SEQ maybe_elsif_lexpr = elsif_lexpr*")
    call ifile_append (ifile, "SEQ maybe_else_lexpr = else_lexpr?")
    call ifile_append (ifile, "SEQ elsif_lexpr = elsif lexpr then lexpr")
    call ifile_append (ifile, "SEQ else_lexpr = else lexpr")
    call ifile_append (ifile, "SEQ compared_expr = expr comparison+")
    call ifile_append (ifile, "SEQ comparison = compare expr")
    call ifile_append (ifile, "ALT compare = " // &
         "'<' | '>' | '<=' | '>=' | '==' | '<>'")
    call ifile_append (ifile, "KEY '<'")
    call ifile_append (ifile, "KEY '>'")
    call ifile_append (ifile, "KEY '<='")
    call ifile_append (ifile, "KEY '>='")
    call ifile_append (ifile, "KEY '=='")
    call ifile_append (ifile, "KEY '<>'")
    call ifile_append (ifile, "SEQ compared_sexpr = sexpr str_comparison+")
    call ifile_append (ifile, "SEQ str_comparison = str_compare sexpr")
    call ifile_append (ifile, "ALT str_compare = '==' | '<>'")
    if (analysis) then
       call ifile_append (ifile, "SEQ record_cmd = " // &
            "record_key analysis_tag record_arg?")
       call ifile_append (ifile, "ALT record_key = " // &
            "record | record_unweighted | record_excess")
       call ifile_append (ifile, "KEY record")
       call ifile_append (ifile, "KEY record_unweighted")
       call ifile_append (ifile, "KEY record_excess")
       call ifile_append (ifile, "ALT analysis_tag = analysis_id | sexpr")
       call ifile_append (ifile, "IDE analysis_id")
       call ifile_append (ifile, "ARG record_arg = ( expr+ )")
    end if
  end subroutine define_lexpr_syntax

@ %def define_lexpr_syntax
@ String expressions.
<<Eval trees: procedures>>=
  subroutine define_sexpr_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ sexpr = svalue str_concatenation*")
    call ifile_append (ifile, "SEQ str_concatenation = '&' svalue")
    call ifile_append (ifile, "KEY '&'")
    call ifile_append (ifile, "ALT svalue = " // &
         "grouped_sexpr | block_sexpr | conditional_sexpr | " // &
         "svariable | string_function | string_literal")
    call ifile_append (ifile, "GRO grouped_sexpr = ( sexpr )")
    call ifile_append (ifile, "SEQ block_sexpr = let var_spec in sexpr")
    call ifile_append (ifile, "SEQ conditional_sexpr = " // &
         "if lexpr then sexpr maybe_elsif_sexpr maybe_else_sexpr endif")
    call ifile_append (ifile, "SEQ maybe_elsif_sexpr = elsif_sexpr*")
    call ifile_append (ifile, "SEQ maybe_else_sexpr = else_sexpr?")
    call ifile_append (ifile, "SEQ elsif_sexpr = elsif lexpr then sexpr")
    call ifile_append (ifile, "SEQ else_sexpr = else sexpr")
    call ifile_append (ifile, "SEQ svariable = '$' alt_svariable")
    call ifile_append (ifile, "KEY '$'")
    call ifile_append (ifile, "ALT alt_svariable = variable | grouped_sexpr")
    call ifile_append (ifile, "ALT var_string = " // &
         "var_string_new | var_string_spec")
    call ifile_append (ifile, "SEQ var_string_new = string var_string_spec")
    call ifile_append (ifile, "KEY string")
    call ifile_append (ifile, "SEQ var_string_spec = '$' var_name = sexpr") ! $
    call ifile_append (ifile, "ALT string_function = sprintf_fun")
    call ifile_append (ifile, "SEQ sprintf_fun = sprintf_clause sprintf_args?")
    call ifile_append (ifile, "SEQ sprintf_clause = sprintf sexpr")
    call ifile_append (ifile, "KEY sprintf")
    call ifile_append (ifile, "ARG sprintf_args = ( sprintf_arg* )")
    call ifile_append (ifile, "ALT sprintf_arg = " &
         // "lvariable | svariable | expr")
    call ifile_append (ifile, "QUO string_literal = '""'...'""'")
  end subroutine define_sexpr_syntax

@ %def define_sexpr_syntax
@ Eval trees that evaluate to subevents.
<<Eval trees: procedures>>=
  subroutine define_pexpr_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ pexpr = pterm pconcatenation*")
    call ifile_append (ifile, "SEQ pconcatenation = '&' pterm")
    ! call ifile_append (ifile, "KEY '&'")   !!! (Key exists already)
    call ifile_append (ifile, "SEQ pterm = pvalue pcombination*")
    call ifile_append (ifile, "SEQ pcombination = '+' pvalue")
    ! call ifile_append (ifile, "KEY '+'")   !!! (Key exists already)
    call ifile_append (ifile, "ALT pvalue = " // &
         "pexpr_src | pvariable | " // &
         "grouped_pexpr | block_pexpr | conditional_pexpr | " // &
         "prt_function")
    call ifile_append (ifile, "SEQ pexpr_src = prefix_cexpr")
    call ifile_append (ifile, "ALT prefix_cexpr = " // &
         "incoming_prt | outgoing_prt")
    call ifile_append (ifile, "SEQ incoming_prt = incoming cexpr")
    call ifile_append (ifile, "KEY incoming")
    call ifile_append (ifile, "SEQ outgoing_prt = cexpr")
    call ifile_append (ifile, "SEQ pvariable = '@' alt_pvariable")
    call ifile_append (ifile, "KEY '@'")
    call ifile_append (ifile, "ALT alt_pvariable = variable | grouped_pexpr")
    call ifile_append (ifile, "GRO grouped_pexpr = '[' pexpr ']'")
    call ifile_append (ifile, "SEQ block_pexpr = let var_spec in pexpr")
    call ifile_append (ifile, "SEQ conditional_pexpr = " // &
         "if lexpr then pexpr maybe_elsif_pexpr maybe_else_pexpr endif")
    call ifile_append (ifile, "SEQ maybe_elsif_pexpr = elsif_pexpr*")
    call ifile_append (ifile, "SEQ maybe_else_pexpr = else_pexpr?")
    call ifile_append (ifile, "SEQ elsif_pexpr = elsif lexpr then pexpr")
    call ifile_append (ifile, "SEQ else_pexpr = else pexpr")
    call ifile_append (ifile, "ALT prt_function = " // &
         "join_fun | combine_fun | collect_fun | cluster_fun | " // &
         "select_fun | extract_fun | sort_fun")
    call ifile_append (ifile, "SEQ join_fun = join_clause pargs2")
    call ifile_append (ifile, "SEQ combine_fun = combine_clause pargs2")
    call ifile_append (ifile, "SEQ collect_fun = collect_clause pargs1")
    call ifile_append (ifile, "SEQ cluster_fun = cluster_clause pargs1")
    call ifile_append (ifile, "SEQ select_fun = select_clause pargs1")
    call ifile_append (ifile, "SEQ extract_fun = extract_clause pargs1")
    call ifile_append (ifile, "SEQ sort_fun = sort_clause pargs1")
    call ifile_append (ifile, "SEQ join_clause = join condition?")
    call ifile_append (ifile, "SEQ combine_clause = combine condition?")
    call ifile_append (ifile, "SEQ collect_clause = collect condition?")
    call ifile_append (ifile, "SEQ cluster_clause = cluster condition?")
    call ifile_append (ifile, "SEQ select_clause = select condition?")
    call ifile_append (ifile, "SEQ extract_clause = extract position?")
    call ifile_append (ifile, "SEQ sort_clause = sort criterion?")
    call ifile_append (ifile, "KEY join")
    call ifile_append (ifile, "KEY combine")
    call ifile_append (ifile, "KEY collect")
    call ifile_append (ifile, "KEY cluster")
    call ifile_append (ifile, "KEY select")
    call ifile_append (ifile, "SEQ condition = if lexpr")
    call ifile_append (ifile, "KEY extract")
    call ifile_append (ifile, "SEQ position = index expr")
    call ifile_append (ifile, "KEY sort")
    call ifile_append (ifile, "SEQ criterion = by expr")
    call ifile_append (ifile, "KEY index")
    call ifile_append (ifile, "KEY by")
    call ifile_append (ifile, "ARG pargs2 = '[' pexpr, pexpr ']'")
    call ifile_append (ifile, "ARG pargs1 = '[' pexpr, pexpr? ']'")
  end subroutine define_pexpr_syntax

@ %def define_pexpr_syntax
@ Eval trees that evaluate to PDG-code arrays.
<<Eval trees: procedures>>=
  subroutine define_cexpr_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ cexpr = avalue concatenation*")
    call ifile_append (ifile, "SEQ concatenation = ':' avalue")
    call ifile_append (ifile, "KEY ':'")
    call ifile_append (ifile, "ALT avalue = " // &
         "grouped_cexpr | block_cexpr | conditional_cexpr | " // &
         "variable | pdg_code | prt_name")
    call ifile_append (ifile, "GRO grouped_cexpr = ( cexpr )")
    call ifile_append (ifile, "SEQ block_cexpr = let var_spec in cexpr")
    call ifile_append (ifile, "SEQ conditional_cexpr = " // &
         "if lexpr then cexpr maybe_elsif_cexpr maybe_else_cexpr endif")
    call ifile_append (ifile, "SEQ maybe_elsif_cexpr = elsif_cexpr*")
    call ifile_append (ifile, "SEQ maybe_else_cexpr = else_cexpr?")
    call ifile_append (ifile, "SEQ elsif_cexpr = elsif lexpr then cexpr")
    call ifile_append (ifile, "SEQ else_cexpr = else cexpr")
    call ifile_append (ifile, "SEQ pdg_code = pdg pdg_arg")
    call ifile_append (ifile, "KEY pdg")
    call ifile_append (ifile, "ARG pdg_arg = ( expr )")
    call ifile_append (ifile, "QUO prt_name = '""'...'""'")
  end subroutine define_cexpr_syntax

@ %def define_cexpr_syntax
@ Extra variable types.
<<Eval trees: procedures>>=
  subroutine define_var_plist_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "ALT var_plist = var_plist_new | var_plist_spec")
    call ifile_append (ifile, "SEQ var_plist_new = subevt var_plist_spec")
    call ifile_append (ifile, "KEY subevt")
    call ifile_append (ifile, "SEQ var_plist_spec = '@' var_name '=' pexpr")
  end subroutine define_var_plist_syntax

  subroutine define_var_alias_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ var_alias = alias var_name '=' cexpr")
    call ifile_append (ifile, "KEY alias")
  end subroutine define_var_alias_syntax

@ %def define_var_plist_syntax define_var_alias_syntax
@ Particle-list expressions that evaluate to numeric values
<<Eval trees: procedures>>=
  subroutine define_numeric_pexpr_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "ALT numeric_pexpr = " &
         // "eval_fun | count_fun | event_shape_fun")
    call ifile_append (ifile, "SEQ eval_fun = eval expr pargs1")
    call ifile_append (ifile, "SEQ count_fun = count_clause pargs1")
    call ifile_append (ifile, "SEQ count_clause = count condition?")
    call ifile_append (ifile, "KEY eval")
    call ifile_append (ifile, "KEY count")
    call ifile_append (ifile, "ALT event_shape_fun = user_event_fun")
    call ifile_append (ifile, "SEQ user_event_fun = " &
         // "user_event_shape user_arg pargs1")
    call ifile_append (ifile, "KEY user_event_shape")
  end subroutine define_numeric_pexpr_syntax

@ %def define_numeric_pexpr_syntax
@ Particle-list functions that evaluate to logical values.
<<Eval trees: procedures>>=
  subroutine define_logical_pexpr_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "ALT logical_pexpr = " // &
         "all_fun | any_fun | no_fun | user_cut_fun")
    call ifile_append (ifile, "SEQ all_fun = all lexpr pargs1")
    call ifile_append (ifile, "SEQ any_fun = any lexpr pargs1")
    call ifile_append (ifile, "SEQ no_fun = no lexpr pargs1")
    call ifile_append (ifile, "KEY all")
    call ifile_append (ifile, "KEY any")
    call ifile_append (ifile, "KEY no")
    call ifile_append (ifile, "SEQ user_cut_fun = user_cut user_arg pargs1")
    call ifile_append (ifile, "KEY user_cut")
  end subroutine define_logical_pexpr_syntax

@ %def define_logical_pexpr_syntax
@ All characters that can occur in expressions (apart from alphanumeric).
<<Eval trees: procedures>>=
  subroutine lexer_init_eval_tree (lexer, particles)
    type(lexer_t), intent(out) :: lexer
    logical, intent(in) :: particles
    type(keyword_list_t), pointer :: keyword_list
    if (particles) then
       keyword_list => syntax_get_keyword_list_ptr (syntax_pexpr)
    else
       keyword_list => syntax_get_keyword_list_ptr (syntax_expr)
    end if
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "()[],;:&%?$@", &
         special_class = [ "+-*/^", "<>=~ " ] , &
         keyword_list = keyword_list)
  end subroutine lexer_init_eval_tree

@ %def lexer_init_eval_tree
@ 
\subsection{Set up appropriate parse trees}
Parse an input stream as a specific flavor of expression.  The
appropriate expression syntax has to be available.
<<Eval trees: public>>=
  public :: parse_tree_init_expr
  public :: parse_tree_init_lexpr
  public :: parse_tree_init_pexpr
  public :: parse_tree_init_cexpr
  public :: parse_tree_init_sexpr
<<Eval trees: procedures>>=
  subroutine parse_tree_init_expr (parse_tree, stream, particles)
    type(parse_tree_t), intent(out) :: parse_tree
    type(stream_t), intent(inout), target :: stream
    logical, intent(in) :: particles
    type(lexer_t) :: lexer
    call lexer_init_eval_tree (lexer, particles)
    call lexer_assign_stream (lexer, stream)
    if (particles) then
       call parse_tree_init &
            (parse_tree, syntax_pexpr, lexer, var_str ("expr"))
    else
       call parse_tree_init &
            (parse_tree, syntax_expr, lexer, var_str ("expr"))
    end if
    call lexer_final (lexer)
  end subroutine parse_tree_init_expr

  subroutine parse_tree_init_lexpr (parse_tree, stream, particles)
    type(parse_tree_t), intent(out) :: parse_tree
    type(stream_t), intent(inout), target :: stream
    logical, intent(in) :: particles
    type(lexer_t) :: lexer
    call lexer_init_eval_tree (lexer, particles)
    call lexer_assign_stream (lexer, stream)
    if (particles) then
       call parse_tree_init &
            (parse_tree, syntax_pexpr, lexer, var_str ("lexpr"))
    else
       call parse_tree_init &
            (parse_tree, syntax_expr, lexer, var_str ("lexpr"))
    end if
    call lexer_final (lexer)
  end subroutine parse_tree_init_lexpr

  subroutine parse_tree_init_pexpr (parse_tree, stream)
    type(parse_tree_t), intent(out) :: parse_tree
    type(stream_t), intent(inout), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_eval_tree (lexer, .true.)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init &
         (parse_tree, syntax_pexpr, lexer, var_str ("pexpr"))
    call lexer_final (lexer)
  end subroutine parse_tree_init_pexpr

  subroutine parse_tree_init_cexpr (parse_tree, stream)
    type(parse_tree_t), intent(out) :: parse_tree
    type(stream_t), intent(inout), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_eval_tree (lexer, .true.)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init &
         (parse_tree, syntax_pexpr, lexer, var_str ("cexpr"))
    call lexer_final (lexer)
  end subroutine parse_tree_init_cexpr

  subroutine parse_tree_init_sexpr (parse_tree, stream, particles)
    type(parse_tree_t), intent(out) :: parse_tree
    type(stream_t), intent(inout), target :: stream
    logical, intent(in) :: particles
    type(lexer_t) :: lexer
    call lexer_init_eval_tree (lexer, particles)
    call lexer_assign_stream (lexer, stream)
    if (particles) then
       call parse_tree_init &
            (parse_tree, syntax_pexpr, lexer, var_str ("sexpr"))
    else
       call parse_tree_init &
            (parse_tree, syntax_expr, lexer, var_str ("sexpr"))
    end if
    call lexer_final (lexer)
  end subroutine parse_tree_init_sexpr

@ %def parse_tree_init_expr
@ %def parse_tree_init_lexpr
@ %def parse_tree_init_pexpr
@ %def parse_tree_init_cexpr
@ %def parse_tree_init_sexpr
@
\subsection{The evaluation tree}
The evaluation tree contains the initial variable list and the root node.
<<Eval trees: public>>=
  public :: eval_tree_t
<<Eval trees: types>>=
  type, extends (expr_t) :: eval_tree_t
     private
     type(parse_node_t), pointer :: pn => null ()
     type(var_list_t) :: var_list
     type(eval_node_t), pointer :: root => null ()
   contains
   <<Eval trees: eval tree: TBP>>
  end type eval_tree_t

@ %def eval_tree_t
@ Init from stream, using a temporary parse tree.
<<Eval trees: procedures>>=
  subroutine eval_tree_init_stream &
       (eval_tree, stream, var_list, subevt, result_type)
    type(eval_tree_t), intent(out), target :: eval_tree
    type(stream_t), intent(inout), target :: stream
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), target, optional :: subevt
    integer, intent(in), optional :: result_type
    type(parse_tree_t) :: parse_tree
    type(parse_node_t), pointer :: nd_root
    integer :: type
    type = V_REAL;  if (present (result_type))  type = result_type
    select case (type)
    case (V_INT, V_REAL, V_CMPLX)
       call parse_tree_init_expr (parse_tree, stream, present (subevt))
    case (V_LOG)
       call parse_tree_init_lexpr (parse_tree, stream, present (subevt))
    case (V_SEV)
       call parse_tree_init_pexpr (parse_tree, stream)
    case (V_PDG)
       call parse_tree_init_cexpr (parse_tree, stream)
    case (V_STR)
       call parse_tree_init_sexpr (parse_tree, stream, present (subevt))
    end select
    nd_root => parse_tree_get_root_ptr (parse_tree)
    if (associated (nd_root)) then
       select case (type)
       case (V_INT, V_REAL, V_CMPLX)
          call eval_tree_init_expr (eval_tree, nd_root, var_list, subevt)
       case (V_LOG)
          call eval_tree_init_lexpr (eval_tree, nd_root, var_list, subevt)
       case (V_SEV)
          call eval_tree_init_pexpr (eval_tree, nd_root, var_list, subevt)
       case (V_PDG)
          call eval_tree_init_cexpr (eval_tree, nd_root, var_list, subevt)
       case (V_STR)
          call eval_tree_init_sexpr (eval_tree, nd_root, var_list, subevt)
       end select
    end if
    call parse_tree_final (parse_tree)
  end subroutine eval_tree_init_stream

@ %def eval_tree_init_stream
@ API (to be superseded by the methods below): Init from a given parse-tree
node.  If we evaluate an expression that contains particle-list references,
the original subevent has to be supplied.  The initial variable list is
optional.
<<Eval trees: public>>=
  public :: eval_tree_init_expr
  public :: eval_tree_init_lexpr
  public :: eval_tree_init_pexpr
  public :: eval_tree_init_cexpr
  public :: eval_tree_init_sexpr
<<Eval trees: procedures>>=
  subroutine eval_tree_init_expr &
      (expr, parse_node, var_list, subevt)
    class(eval_tree_t), intent(out), target :: expr
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_expr &
         (expr%root, parse_node, expr%var_list)
  end subroutine eval_tree_init_expr
    
  subroutine eval_tree_init_lexpr &
      (expr, parse_node, var_list, subevt)
    class(eval_tree_t), intent(out), target :: expr
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_lexpr &
         (expr%root, parse_node, expr%var_list)
  end subroutine eval_tree_init_lexpr

  subroutine eval_tree_init_pexpr &
      (expr, parse_node, var_list, subevt)
    class(eval_tree_t), intent(out), target :: expr
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_pexpr &
         (expr%root, parse_node, expr%var_list)
  end subroutine eval_tree_init_pexpr

  subroutine eval_tree_init_cexpr &
      (expr, parse_node, var_list, subevt)
    class(eval_tree_t), intent(out), target :: expr
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_cexpr &
         (expr%root, parse_node, expr%var_list)
  end subroutine eval_tree_init_cexpr

  subroutine eval_tree_init_sexpr &
      (expr, parse_node, var_list, subevt)
    class(eval_tree_t), intent(out), target :: expr
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_sexpr &
         (expr%root, parse_node, expr%var_list)
  end subroutine eval_tree_init_sexpr

@ %def eval_tree_init_expr    
@ %def eval_tree_init_lexpr    
@ %def eval_tree_init_pexpr    
@ %def eval_tree_init_cexpr
@ %def eval_tree_init_sexpr
@ Alternative: set up the expression using the parse node that has already
been stored.
<<Eval trees: eval tree: TBP>>=
  procedure :: setup_expr  => eval_tree_setup_expr
  procedure :: setup_lexpr => eval_tree_setup_lexpr
  procedure :: setup_pexpr => eval_tree_setup_pexpr
  procedure :: setup_cexpr => eval_tree_setup_cexpr
  procedure :: setup_sexpr => eval_tree_setup_sexpr
<<Eval trees: procedures>>=
  subroutine eval_tree_setup_expr (expr, var_list, subevt)
    class(eval_tree_t), intent(inout), target :: expr
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_expr (expr%root, expr%pn, expr%var_list)
  end subroutine eval_tree_setup_expr
    
  subroutine eval_tree_setup_lexpr (expr, var_list, subevt)
    class(eval_tree_t), intent(inout), target :: expr
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_lexpr (expr%root, expr%pn, expr%var_list)
  end subroutine eval_tree_setup_lexpr

  subroutine eval_tree_setup_pexpr (expr, var_list, subevt)
    class(eval_tree_t), intent(inout), target :: expr
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_pexpr (expr%root, expr%pn, expr%var_list)
  end subroutine eval_tree_setup_pexpr

  subroutine eval_tree_setup_cexpr (expr, var_list, subevt)
    class(eval_tree_t), intent(inout), target :: expr
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_cexpr (expr%root, expr%pn, expr%var_list)
  end subroutine eval_tree_setup_cexpr

  subroutine eval_tree_setup_sexpr (expr, var_list, subevt)
    class(eval_tree_t), intent(inout), target :: expr
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    call eval_tree_set_var_list (expr, var_list, subevt)
    call eval_node_compile_sexpr (expr%root, expr%pn, expr%var_list)
  end subroutine eval_tree_setup_sexpr

@ %def eval_tree_setup_expr    
@ %def eval_tree_setup_lexpr    
@ %def eval_tree_setup_pexpr    
@ %def eval_tree_setup_cexpr
@ %def eval_tree_setup_sexpr
@ This extra API function handles numerical constant expressions only.
The only nontrivial part is the optional unit.
<<Eval trees: public>>=
  public :: eval_tree_init_numeric_value
<<Eval trees: procedures>>=
  subroutine eval_tree_init_numeric_value (eval_tree, parse_node)
    type(eval_tree_t), intent(out), target :: eval_tree
    type(parse_node_t), intent(in), target :: parse_node
    call eval_node_compile_numeric_value (eval_tree%root, parse_node)
  end subroutine eval_tree_init_numeric_value

@ %def eval_tree_init_numeric_value
@ Initialize the variable list with the initial one; if a particle
list is provided, add a pointer to this as variable [[@evt]].  If the event
weight is provided as a real-valued target, add a pointer to it as well.
<<Eval trees: procedures>>=
  subroutine eval_tree_set_var_list &
      (eval_tree, var_list, subevt)
    type(eval_tree_t), intent(inout), target :: eval_tree
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, save, target :: known = .true.
    call var_list_link (eval_tree%var_list, var_list)
    if (present (subevt))  call var_list_append_subevt_ptr &
         (eval_tree%var_list, var_str ("@evt"), subevt, known, &
         intrinsic=.true.)
  end subroutine eval_tree_set_var_list

@ %def eval_tree_set_var_list
<<Eval trees: public>>=
  public :: eval_tree_final
<<Eval trees: eval tree: TBP>>=
  procedure :: final => eval_tree_final
<<Eval trees: procedures>>=
  subroutine eval_tree_final (expr)
    class(eval_tree_t), intent(inout) :: expr
    call var_list_final (expr%var_list)
    if (associated (expr%root)) then
       call eval_node_final_rec (expr%root)
       deallocate (expr%root)
    end if
  end subroutine eval_tree_final

@ %def eval_tree_final
@ 
<<Eval trees: public>>=
  public :: eval_tree_evaluate
<<Eval trees: eval tree: TBP>>=
  procedure :: evaluate => eval_tree_evaluate
<<Eval trees: procedures>>=
  subroutine eval_tree_evaluate (expr)
    class(eval_tree_t), intent(inout) :: expr
    if (associated (expr%root)) then
       call eval_node_evaluate (expr%root)
    end if
  end subroutine eval_tree_evaluate

@ %def eval_tree_evaluate
@ Check if the eval tree is allocated.
<<Eval trees: public>>=
  public :: eval_tree_is_defined
<<Eval trees: procedures>>=
  function eval_tree_is_defined (eval_tree) result (flag)
    logical :: flag
    type(eval_tree_t), intent(in) :: eval_tree
    flag = associated (eval_tree%root)
  end function eval_tree_is_defined

@ %def eval_tree_is_defined
@ Check if the eval tree result is constant.
<<Eval trees: public>>=
  public :: eval_tree_is_constant
<<Eval trees: procedures>>=
  function eval_tree_is_constant (eval_tree) result (flag)
    logical :: flag
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       flag = eval_tree%root%type == EN_CONSTANT
    else
       flag = .false.
    end if
  end function eval_tree_is_constant

@ %def eval_tree_is_constant
@ Insert a conversion node at the root, if necessary (only for
real/int conversion)
<<Eval trees: public>>=
  public :: eval_tree_convert_result
<<Eval trees: procedures>>=
  subroutine eval_tree_convert_result (eval_tree, result_type)
    type(eval_tree_t), intent(inout) :: eval_tree
    integer, intent(in) :: result_type
    if (associated (eval_tree%root)) then
       call insert_conversion_node (eval_tree%root, result_type)
    end if
  end subroutine eval_tree_convert_result

@ %def eval_tree_convert_result
@ Return the value of the top node, after evaluation.  If the tree is
empty, return the type of [[V_NONE]].  When extracting the value, no
check for existence is done.  For numeric values, the functions are
safe against real/integer mismatch.
<<Eval trees: public>>=
  public :: eval_tree_get_result_type
  public :: eval_tree_result_is_known
  public :: eval_tree_result_is_known_ptr
  public :: eval_tree_get_log
  public :: eval_tree_get_int
  public :: eval_tree_get_real
  public :: eval_tree_get_cmplx
  public :: eval_tree_get_pdg_array
  public :: eval_tree_get_subevt
  public :: eval_tree_get_string
<<Eval trees: eval tree: TBP>>=
  procedure :: is_known => eval_tree_result_is_known
  procedure :: get_log => eval_tree_get_log
  procedure :: get_int => eval_tree_get_int
  procedure :: get_real => eval_tree_get_real
  procedure :: get_cmplx => eval_tree_get_cmplx
  procedure :: get_pdg_array => eval_tree_get_pdg_array
  procedure :: get_subevt => eval_tree_get_subevt
  procedure :: get_string => eval_tree_get_string
<<Eval trees: procedures>>=
  function eval_tree_get_result_type (expr) result (type)
    integer :: type
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       type = expr%root%result_type
    else
       type = V_NONE
    end if
  end function eval_tree_get_result_type
    
  function eval_tree_result_is_known (expr) result (flag)
    logical :: flag
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       select case (expr%root%result_type)
       case (V_LOG, V_INT, V_REAL)
          flag = expr%root%value_is_known
       case default
          flag = .true.
       end select
    else
       flag = .false.
    end if
  end function eval_tree_result_is_known

  function eval_tree_result_is_known_ptr (expr) result (ptr)
    logical, pointer :: ptr
    class(eval_tree_t), intent(in) :: expr
    logical, target, save :: known = .true.
    if (associated (expr%root)) then
       select case (expr%root%result_type)
       case (V_LOG, V_INT, V_REAL)
          ptr => expr%root%value_is_known
       case default
          ptr => known
       end select
    else
       ptr => null ()
    end if
  end function eval_tree_result_is_known_ptr

  function eval_tree_get_log (expr) result (lval)
    logical :: lval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root))  lval = expr%root%lval
  end function eval_tree_get_log
    
  function eval_tree_get_int (expr) result (ival)
    integer :: ival
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       select case (expr%root%result_type)
       case (V_INT);  ival = expr%root%ival
       case (V_REAL); ival = expr%root%rval
       case (V_CMPLX); ival = expr%root%cval       
       end select
    end if
  end function eval_tree_get_int
    
  function eval_tree_get_real (expr) result (rval)
    real(default) :: rval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       select case (expr%root%result_type)
       case (V_REAL); rval = expr%root%rval
       case (V_INT);  rval = expr%root%ival
       case (V_CMPLX);  rval = expr%root%cval       
       end select
    end if
  end function eval_tree_get_real
      
  function eval_tree_get_cmplx (expr) result (cval)
    complex(default) :: cval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       select case (expr%root%result_type)
       case (V_CMPLX); cval = expr%root%cval
       case (V_REAL); cval = expr%root%rval
       case (V_INT);  cval = expr%root%ival
       end select
    end if
  end function eval_tree_get_cmplx

  function eval_tree_get_pdg_array (expr) result (aval)
    type(pdg_array_t) :: aval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       aval = expr%root%aval
    end if
  end function eval_tree_get_pdg_array

  function eval_tree_get_subevt (expr) result (pval)
    type(subevt_t) :: pval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       pval = expr%root%pval
    end if
  end function eval_tree_get_subevt

  function eval_tree_get_string (expr) result (sval)
    type(string_t) :: sval
    class(eval_tree_t), intent(in) :: expr
    if (associated (expr%root)) then
       sval = expr%root%sval
    end if
  end function eval_tree_get_string

@ %def eval_tree_get_result_type
@ %def eval_tree_result_is_known
@ %def eval_tree_get_log eval_tree_get_int eval_tree_get_real 
@ %def eval_tree_get_cmplx
@ %def eval_tree_get_pdg_expr
@ %def eval_tree_get_pdg_array 
@ %def eval_tree_get_subevt
@ %def eval_tree_get_string
@ Return a pointer to the value of the top node.
<<Eval trees: public>>=
  public :: eval_tree_get_log_ptr
  public :: eval_tree_get_int_ptr
  public :: eval_tree_get_real_ptr
  public :: eval_tree_get_cmplx_ptr  
  public :: eval_tree_get_subevt_ptr
  public :: eval_tree_get_pdg_array_ptr
  public :: eval_tree_get_string_ptr
<<Eval trees: procedures>>=
  function eval_tree_get_log_ptr (eval_tree) result (lval)
    logical, pointer :: lval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       lval => eval_tree%root%lval
    else
       lval => null ()
    end if
  end function eval_tree_get_log_ptr
    
  function eval_tree_get_int_ptr (eval_tree) result (ival)
    integer, pointer :: ival
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       ival => eval_tree%root%ival
    else
       ival => null ()
    end if
  end function eval_tree_get_int_ptr
    
  function eval_tree_get_real_ptr (eval_tree) result (rval)
    real(default), pointer :: rval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       rval => eval_tree%root%rval
    else
       rval => null ()
    end if
  end function eval_tree_get_real_ptr
    
  function eval_tree_get_cmplx_ptr (eval_tree) result (cval)
    complex(default), pointer :: cval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       cval => eval_tree%root%cval
    else
       cval => null ()
    end if
  end function eval_tree_get_cmplx_ptr

  function eval_tree_get_subevt_ptr (eval_tree) result (pval)
    type(subevt_t), pointer :: pval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       pval => eval_tree%root%pval
    else
       pval => null ()
    end if
  end function eval_tree_get_subevt_ptr
    
  function eval_tree_get_pdg_array_ptr (eval_tree) result (aval)
    type(pdg_array_t), pointer :: aval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       aval => eval_tree%root%aval
    else
       aval => null ()
    end if
  end function eval_tree_get_pdg_array_ptr
    
  function eval_tree_get_string_ptr (eval_tree) result (sval)
    type(string_t), pointer :: sval
    type(eval_tree_t), intent(in) :: eval_tree
    if (associated (eval_tree%root)) then
       sval => eval_tree%root%sval
    else
       sval => null ()
    end if
  end function eval_tree_get_string_ptr
    
@ %def eval_tree_get_log_ptr eval_tree_get_int_ptr eval_tree_get_real_ptr
@ %def eval_tree_get_cmplx_ptr
@ %def eval_tree_get_subevt_ptr eval_tree_get_pdg_array_ptr
@ %def eval_tree_get_string_ptr
<<Eval trees: public>>=
  public :: eval_tree_write
<<Eval trees: eval tree: TBP>>=
  procedure :: write => eval_tree_write
<<Eval trees: procedures>>=
  subroutine eval_tree_write (expr, unit, write_var_list)
    class(eval_tree_t), intent(in) :: expr
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: write_var_list
    integer :: u
    logical :: vl
    u = given_output_unit (unit);  if (u < 0)  return
    vl = .false.;  if (present (write_var_list))  vl = write_var_list
    write (u, "(1x,A)") "Evaluation tree:"
    if (associated (expr%root)) then
       call eval_node_write_rec (expr%root, unit)
    else
       write (u, "(3x,A)") "[empty]"
    end if
    if (vl)  call var_list_write (expr%var_list, unit)
  end subroutine eval_tree_write

@ %def eval_tree_write
@ Use the written representation for generating an MD5 sum:
<<Eval trees: public>>=
  public :: eval_tree_get_md5sum
<<Eval trees: procedures>>=
  function eval_tree_get_md5sum (eval_tree) result (md5sum_et)
    character(32) :: md5sum_et
    type(eval_tree_t), intent(in) :: eval_tree
    integer :: u
    u = free_unit ()
    open (unit = u, status = "scratch", action = "readwrite")
    call eval_tree_write (eval_tree, unit=u)
    rewind (u)
    md5sum_et = md5sum (u)
    close (u)
  end function eval_tree_get_md5sum

@ %def eval_tree_get_md5sum
@
\subsection{Direct evaluation}
These procedures create an eval tree and evaluate it on-the-fly, returning
only the final value.  The evaluation must yield a well-defined value, unless
the [[is_known]] flag is present, which will be set accordingly.
<<Eval trees: public>>=
  public :: eval_log
  public :: eval_int
  public :: eval_real
  public :: eval_cmplx
  public :: eval_subevt
  public :: eval_pdg_array
  public :: eval_string
<<Eval trees: procedures>>=
  function eval_log &
       (parse_node, var_list, subevt, is_known) result (lval)
    logical :: lval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_lexpr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       lval = eval_tree_get_log (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
       lval = .false.
    end if
    call eval_tree_final (eval_tree)
  end function eval_log

  function eval_int &
       (parse_node, var_list, subevt, is_known) result (ival)
    integer :: ival
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_expr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       ival = eval_tree_get_int (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
       ival = 0
    end if
    call eval_tree_final (eval_tree)
  end function eval_int

  function eval_real &
       (parse_node, var_list, subevt, is_known) result (rval)
    real(default) :: rval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_expr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       rval = eval_tree_get_real (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else 
       call eval_tree_unknown (eval_tree, parse_node)
       rval = 0
    end if
    call eval_tree_final (eval_tree)
  end function eval_real

  function eval_cmplx &
       (parse_node, var_list, subevt, is_known) result (cval)
    complex(default) :: cval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_expr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       cval = eval_tree_get_cmplx (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
       cval = 0
    end if
    call eval_tree_final (eval_tree)
  end function eval_cmplx

  function eval_subevt &
       (parse_node, var_list, subevt, is_known) result (pval)
    type(subevt_t) :: pval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_pexpr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       pval = eval_tree_get_subevt (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
    end if
    call eval_tree_final (eval_tree)
  end function eval_subevt

  function eval_pdg_array &
       (parse_node, var_list, subevt, is_known) result (aval)
    type(pdg_array_t) :: aval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_cexpr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       aval = eval_tree_get_pdg_array (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
    end if
    call eval_tree_final (eval_tree)
  end function eval_pdg_array

  function eval_string &
       (parse_node, var_list, subevt, is_known) result (sval)
    type(string_t) :: sval
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    logical, intent(out), optional :: is_known
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_sexpr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (is_known))  is_known = .true.
       sval = eval_tree_get_string (eval_tree)
    else if (present (is_known)) then
       is_known = .false.
    else
       call eval_tree_unknown (eval_tree, parse_node)
       sval = ""
    end if
    call eval_tree_final (eval_tree)
  end function eval_string

@ %def eval_log eval_int eval_real eval_cmplx
@ %def eval_subevt eval_pdg_array eval_string
@ %def eval_tree_unknown
@ Here is a variant that returns numeric values of all possible kinds, the
appropriate kind to be selected later:
<<Eval trees: public>>=
  public :: eval_numeric
<<Eval trees: procedures>>=
  subroutine eval_numeric &
       (parse_node, var_list, subevt, ival, rval, cval, &
        is_known, result_type)
    type(parse_node_t), intent(in), target :: parse_node
    type(var_list_t), intent(in), target :: var_list
    type(subevt_t), intent(in), optional, target :: subevt
    integer, intent(out), optional :: ival
    real(default), intent(out), optional :: rval
    complex(default), intent(out), optional :: cval
    logical, intent(out), optional :: is_known
    integer, intent(out), optional :: result_type
    type(eval_tree_t), target :: eval_tree
    call eval_tree_init_expr &
         (eval_tree, parse_node, var_list, subevt)
    call eval_tree_evaluate (eval_tree)
    if (eval_tree_result_is_known (eval_tree)) then
       if (present (ival))  ival = eval_tree_get_int (eval_tree)
       if (present (rval))  rval = eval_tree_get_real (eval_tree)
       if (present (cval))  cval = eval_tree_get_cmplx (eval_tree)
       if (present (is_known))  is_known = .true.
    else
       call eval_tree_unknown (eval_tree, parse_node)
       if (present (ival))  ival = 0
       if (present (rval))  rval = 0
       if (present (cval))  cval = 0
       if (present (is_known))  is_known = .false.
    end if
    if (present (result_type))  &
         result_type = eval_tree_get_result_type (eval_tree)
    call eval_tree_final (eval_tree)
  end subroutine eval_numeric

@ %def eval_numeric
@ Error message with debugging info:
<<Eval trees: procedures>>=
  subroutine eval_tree_unknown (eval_tree, parse_node)
    type(eval_tree_t), intent(in) :: eval_tree
    type(parse_node_t), intent(in) :: parse_node
    call parse_node_write_rec (parse_node)
    call eval_tree_write (eval_tree)
    call msg_error ("Evaluation yields an undefined result, inserting default")
  end subroutine eval_tree_unknown

@ %def eval_tree_unknown
@
\subsection{Factory Type}
Since [[eval_tree_t]] is an implementation of [[expr_t]], we also need a
matching factory type and build method.
<<Eval trees: public>>=
  public :: eval_tree_factory_t
<<Eval trees: types>>=
  type, extends (expr_factory_t) :: eval_tree_factory_t
     private
     type(parse_node_t), pointer :: pn => null ()
   contains
  <<Eval trees: eval tree factory: TBP>>
  end type eval_tree_factory_t
  
@ %def eval_tree_factory_t
@ Output: delegate to the output of the embedded parse node.
<<Eval trees: eval tree factory: TBP>>=
  procedure :: write => eval_tree_factory_write
<<Eval trees: procedures>>=
  subroutine eval_tree_factory_write (expr_factory, unit)
    class(eval_tree_factory_t), intent(in) :: expr_factory
    integer, intent(in), optional :: unit
    if (associated (expr_factory%pn)) then
       call parse_node_write_rec (expr_factory%pn, unit)
    end if
  end subroutine eval_tree_factory_write
       
@ %def eval_tree_factory_write
@ Initializer: take a parse node and hide it thus from the environment.
<<Eval trees: eval tree factory: TBP>>=
  procedure :: init => eval_tree_factory_init
<<Eval trees: procedures>>=
  subroutine eval_tree_factory_init (expr_factory, pn)
    class(eval_tree_factory_t), intent(out) :: expr_factory
    type(parse_node_t), intent(in), pointer :: pn
    expr_factory%pn => pn
  end subroutine eval_tree_factory_init
  
@ %def eval_tree_factory_init
@ Factory method: allocate expression with correct eval tree type.  If the
stored parse node is not associate, don't allocate.
<<Eval trees: eval tree factory: TBP>>=
  procedure :: build => eval_tree_factory_build
<<Eval trees: procedures>>=
  subroutine eval_tree_factory_build (expr_factory, expr)
    class(eval_tree_factory_t), intent(in) :: expr_factory
    class(expr_t), intent(out), allocatable :: expr
    if (associated (expr_factory%pn)) then
       allocate (eval_tree_t :: expr)
       select type (expr)
       type is (eval_tree_t)
          expr%pn => expr_factory%pn
       end select
    end if
  end subroutine eval_tree_factory_build
  
@ %def eval_tree_factory_build
@ 
\subsection{Unit tests}
<<Eval trees: public>>=
  public :: expressions_test
<<Eval trees: procedures>>=
  subroutine expressions_test (u, results)
    integer, intent(in) :: u
    type (test_results_t), intent(inout) :: results
  <<Eval trees: execute tests>>  
  end subroutine expressions_test

@ %def expressions_test
@ Testing the routines of the expressions module. First a simple unary
observable and the node evaluation.
<<Eval trees: execute tests>>=
  call test (expressions_1, "expressions_1", &
       "check simple observable", &
       u, results) 
<<Eval trees: tests>>=     
  subroutine expressions_1 (u)
    integer, intent(in) :: u
    type(var_list_t), pointer :: var_list => null ()
    type(eval_node_t), pointer :: node => null ()
    type(prt_t), pointer :: prt => null ()
    type(var_entry_t), pointer :: var => null ()

    write (u, "(A)")  "* Test output: Expressions"
    write (u, "(A)")  "*   Purpose: test simple observable and node evaluation"
    write (u, "(A)")       

    write (u, "(A)")  "* Setting a unary observable:"
    write (u, "(A)")    
    
    allocate (var_list)
    allocate (prt)
    call var_list_set_observables_unary (var_list, prt)
    call var_list_write (var_list, u)
    var => var_list_get_var_ptr (var_list, var_str ("PDG"))

    write (u, "(A)")  "* Evaluating the observable node:"
    write (u, "(A)")        
    
    allocate (node)
    call eval_node_init_obs (node, var)
    call eval_node_write (node, u)

    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")        
    
    call eval_node_final_rec (node)
    deallocate (node)
    call var_list_final (var_list)
    deallocate (var_list)
    deallocate (prt)
       
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: expressions_1"        
    
  end subroutine expressions_1
  
@  %def expressions_1
@ Parse a complicated expression, transfer it to a parse tree and evaluate.
<<Eval trees: execute tests>>=
  call test (expressions_2, "expressions_2", &
       "check expression transfer to parse tree", &
       u, results) 
<<Eval trees: tests>>=  
  subroutine expressions_2 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(eval_tree_t) :: eval_tree
    type(string_t) :: expr_text
    type(var_list_t), pointer :: var_list => null ()
    
    write (u, "(A)")  "* Test output: Expressions"
    write (u, "(A)")  "*   Purpose: test parse routines"
    write (u, "(A)")       
    
    call syntax_expr_init ()
    call syntax_write (syntax_expr, u)     
    allocate (var_list)
    call var_list_append_real (var_list, var_str ("tolerance"), 0._default)
    call var_list_append_real (var_list, var_str ("x"), -5._default)
    call var_list_append_int  (var_list, var_str ("foo"), -27)
    call var_list_append_real (var_list, var_str ("mb"), 4._default)
    expr_text = &
         "let real twopi = 2 * pi in" // &
         "  twopi * sqrt (25.d0 - mb^2)" // &
         "  / (let int mb_or_0 = max (mb, 0) in" // &
         "       1 + (if -1 TeV <= x < mb_or_0 then abs(x) else x endif))"
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call var_list_write (var_list, unit = u)
    call eval_tree_init_stream (eval_tree, stream, var_list=var_list)
    call eval_tree_evaluate (eval_tree)
    call eval_tree_write (eval_tree, u)
    
    write (u, "(A)")  "* Input string:"
    write (u, "(A,A)")  "     ", char (expr_text)
    write (u, "(A)") 
    write (u, "(A)")  "* Cleanup"
    
    call stream_final (stream) 
    call ifile_final (ifile)
    call eval_tree_final (eval_tree)
    call var_list_final (var_list)
    deallocate (var_list)
    call syntax_expr_final ()     
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: expressions_2"        
    
  end subroutine expressions_2 
  
@  %def expressions_2
@ Test a subevent expression.
<<Eval trees: execute tests>>=
  call test (expressions_3, "expressions_3", &
       "check subevent expressions", &
       u, results) 
<<Eval trees: tests>>=       
  subroutine expressions_3 (u)
    integer, intent(in) :: u
    type(subevt_t) :: subevt

    write (u, "(A)")  "* Test output: Expressions"
    write (u, "(A)")  "*   Purpose: test subevent expressions"
    write (u, "(A)")       

    write (u, "(A)")  "* Initialize subevent:"
    write (u, "(A)")       
            
    call subevt_init (subevt)
    call subevt_reset (subevt, 1)
    call subevt_set_incoming (subevt, 1, &
         22, vector4_moving (1.e3_default, 1.e3_default, 1), &
         0._default, [2])
    call subevt_write (subevt, u)
    call subevt_reset (subevt, 4)
    call subevt_reset (subevt, 3)
    call subevt_set_incoming (subevt, 1, &
         21, vector4_moving (1.e3_default, 1.e3_default, 3), &
         0._default, [1])
    call subevt_polarize (subevt, 1, -1)
    call subevt_set_outgoing (subevt, 2, &
         1, vector4_moving (0._default, 1.e3_default, 3), &
         -1.e6_default, [7])
    call subevt_set_composite (subevt, 3, &
         vector4_moving (-1.e3_default, 0._default, 3), &
         [2, 7])
    call subevt_write (subevt, u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: expressions_3"        
    
  end subroutine expressions_3
  
@  %def expressions_3
@ Test expressions from a PDG array.
<<Eval trees: execute tests>>=
  call test (expressions_4, "expressions_4", &
       "check pdg array expressions", &
       u, results) 
<<Eval trees: tests>>=          
  subroutine expressions_4 (u)
    integer, intent(in) :: u
    type(subevt_t), target :: subevt
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(eval_tree_t) :: eval_tree
    type(var_list_t), pointer :: var_list => null ()
    type(pdg_array_t) :: aval

    write (u, "(A)")  "* Test output: Expressions"
    write (u, "(A)")  "*   Purpose: test pdg array expressions"
    write (u, "(A)")       

    write (u, "(A)")  "* Initialization:"
    write (u, "(A)")       
    
    call syntax_pexpr_init ()
    call syntax_write (syntax_pexpr, u)
    allocate (var_list)
    call var_list_append_real (var_list, var_str ("tolerance"), 0._default)
    aval = 0
    call var_list_append_pdg_array (var_list, var_str ("particle"), aval)
    aval = [11,-11]
    call var_list_append_pdg_array (var_list, var_str ("lepton"), aval)
    aval = 22
    call var_list_append_pdg_array (var_list, var_str ("photon"), aval)
    aval = 1
    call var_list_append_pdg_array (var_list, var_str ("u"), aval)
    call subevt_init (subevt)
    call subevt_reset (subevt, 6)
    call subevt_set_incoming (subevt, 1, &
         1, vector4_moving (1._default, 1._default, 1), 0._default)
    call subevt_set_incoming (subevt, 2, &
         -1, vector4_moving (2._default, 2._default, 1), 0._default)
    call subevt_set_outgoing (subevt, 3, &
         22, vector4_moving (3._default, 3._default, 1), 0._default)
    call subevt_set_outgoing (subevt, 4, &
         22, vector4_moving (4._default, 4._default, 1), 0._default)
    call subevt_set_outgoing (subevt, 5, &
         11, vector4_moving (5._default, 5._default, 1), 0._default)
    call subevt_set_outgoing (subevt, 6, &
         -11, vector4_moving (6._default, 6._default, 1), 0._default)
    write (u, "(A)")
    write (u, "(A)")  "* Expression:"
    expr_text = &
         "let alias quark = pdg(1):pdg(2):pdg(3) in" // &
         "  any E > 3 GeV " // &
         "    [sort by - Pt " // &
         "       [select if Index < 6 " // &
         "          [photon:pdg(-11):pdg(3):quark " // &
         "           & incoming particle]]]" // &
         "  and" // &
         "  eval Theta [extract index -1 [photon]] > 45 degree" // &
         "  and" // &
         "  count [incoming photon] * 3 > 0"
    write (u, "(A,A)")  "     ", char (expr_text)
    write (u, "(A)")
    
    write (u, "(A)")
    write (u, "(A)")  "* Extract the evaluation tree:"
    write (u, "(A)")
    
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call eval_tree_init_stream (eval_tree, stream, var_list, subevt, V_LOG)
    call eval_tree_write (eval_tree, u)
    call eval_tree_evaluate (eval_tree)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate the tree:"
    write (u, "(A)")

    call eval_tree_write (eval_tree, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")
    
    call stream_final (stream)
    call ifile_final (ifile)
    call eval_tree_final (eval_tree)
    call var_list_final (var_list)
    deallocate (var_list)
    call syntax_pexpr_final ()  
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: expressions_4"        
        
  end subroutine expressions_4

@ %def expressions_4
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Physics Models}

A model object represents a physics model.  It contains a table of particle
data, a list of parameters, and a vertex table.  The list of parameters is a
variable list which includes the real parameters (which are pointers to the
particle data table) and PDG array variables for the particles themselves.
The vertex list is used for phase-space generation, not for calculating the
matrix element.

The actual numeric model data are in the base type [[model_data_t]],
as part of the [[qft]] section.  We implement the [[model_t]] as an
extension of this, for convenient direct access to the base-type
methods via inheritance.  (Alternatively, we could delegate these calls
explicitly.)  The extension contains administrative additions, such as
the methods for recalculating derived data and keeping the parameter
set consistent.  It thus acts as a proxy of the actual model-data
object towards the \whizard\ package.  There are further proxy
objects, such as the [[parameter_t]] array which provides the
interface to the actual numeric parameters.

Model definitions are read from model files.  Therefore, this module contains
a parser for model files.  The parameter definitions (derived parameters) are
Sindarin expressions.

The models, as read from file, are stored in a model library which is a simple
list of model definitions.  For setting up a process object we should make a
copy (an instance) of a model, which gets the current parameter values from
the global variable list.

\section{Model module}
<<[[models.f90]]>>=
<<File header>>

module models

  use, intrinsic :: iso_c_binding !NODEP!
  
<<Use kinds>>
  use kinds, only: i8, i32
  use kinds, only: c_default_float
<<Use strings>>
  use format_defs, only: FMT_19
  use io_units
  use unit_tests
  use diagnostics
  use md5
  use os_interface
  use physics_defs, only: UNDEFINED, SCALAR, SPINOR
  use model_data
  
  use ifiles
  use syntax_rules
  use lexers
  use parser
  use pdg_arrays
  use variables
  use eval_trees

<<Standard module head>>

<<Models: public>>

<<Models: parameters>>

<<Models: types>>

<<Models: interfaces>>

<<Models: variables>>

contains

<<Models: procedures>>

<<Models: tests>>

end module models
@ %def models
@
\subsection{Physics Parameters}
A parameter has a name, a value.  Derived parameters also have a
definition in terms of other parameters, which is stored as an
[[eval_tree]].  External parameters are set by an external program.

This parameter object should be considered as a proxy object.  The
parameter name and value are stored in a corresponding
[[modelpar_data_t]] object which is located in a [[model_data_t]]
object.  The latter is a component of the [[model_t]] handler.
Methods of [[parameter_t]] can be delegated to the [[par_data_t]]
component.

The [[pn]] component is a pointer to the parameter definition inside the
model parse tree.  It allows us to recreate the [[eval_tree]] when making
copies (instances) of the parameter object.
<<Models: parameters>>=
  integer, parameter :: PAR_NONE = 0
  integer, parameter :: PAR_INDEPENDENT = 1, PAR_DERIVED = 2
  integer, parameter :: PAR_EXTERNAL = 3

@ %def PAR_NONE PAR_INDEPENDENT PAR_DERIVED PAR_EXTERNAL
<<Models: types>>= 
  type :: parameter_t
     private
     integer :: type  = PAR_NONE
     class(modelpar_data_t), pointer :: data => null ()
     type(parse_node_t), pointer :: pn => null ()
     type(eval_tree_t) :: eval_tree
   contains
   <<Models: parameter: TBP>>
  end type parameter_t

@ %def parameter_t
@ Initialization depends on parameter type.  Independent parameters
are initialized by a constant value or a constant numerical expression
(which may contain a unit).  Derived parameters are initialized by an
arbitrary numerical expression, which makes use of the current
variable list.  The expression is evaluated by the function
[[parameter_reset]].

This implementation supports only real parameters and real values.
<<Models: parameter: TBP>>=
  procedure :: init_independent_value => parameter_init_independent_value
  procedure :: init_independent => parameter_init_independent
  procedure :: init_derived => parameter_init_derived
  procedure :: init_external => parameter_init_external
<<Models: procedures>>=
  subroutine parameter_init_independent_value (par, par_data, name, value)
    class(parameter_t), intent(out) :: par
    class(modelpar_data_t), intent(in), target :: par_data
    type(string_t), intent(in) :: name
    real(default), intent(in) :: value
    par%type = PAR_INDEPENDENT
    par%data => par_data
    call par%data%init (name, value)
  end subroutine parameter_init_independent_value

  subroutine parameter_init_independent (par, par_data, name, pn)
    class(parameter_t), intent(out) :: par
    class(modelpar_data_t), intent(in), target :: par_data
    type(string_t), intent(in) :: name
    type(parse_node_t), intent(in), target :: pn
    par%type = PAR_INDEPENDENT
    par%pn => pn
    call eval_tree_init_numeric_value (par%eval_tree, pn)
    par%data => par_data
    call par%data%init (name, eval_tree_get_real (par%eval_tree))
  end subroutine parameter_init_independent

  subroutine parameter_init_derived (par, par_data, name, pn, var_list)
    class(parameter_t), intent(out) :: par
    class(modelpar_data_t), intent(in), target :: par_data
    type(string_t), intent(in) :: name
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    par%type = PAR_DERIVED
    par%pn => pn
    call eval_tree_init_expr (par%eval_tree, pn, var_list=var_list)
    par%data => par_data
    call eval_tree_evaluate (par%eval_tree)
    call par%data%init (name, eval_tree_get_real (par%eval_tree))
  end subroutine parameter_init_derived

  subroutine parameter_init_external (par, par_data, name)
    class(parameter_t), intent(out) :: par
    class(modelpar_data_t), intent(in), target :: par_data
    type(string_t), intent(in) :: name
    par%type = PAR_EXTERNAL
    par%data => par_data
    call par%data%init (name, 0._default)
  end subroutine parameter_init_external

@ %def parameter_init_independent_value
@ %def parameter_init_independent
@ %def parameter_init_derived
@ %def parameter_init_external
@ The finalizer is needed for the evaluation tree in the definition.
<<Models: parameter: TBP>>=
  procedure :: final => parameter_final
<<Models: procedures>>=
  subroutine parameter_final (par)
    class(parameter_t), intent(inout) :: par
    call eval_tree_final (par%eval_tree)
  end subroutine parameter_final

@ %def parameter_final
@ All derived parameters should be recalculated if some independent
parameters have changed:
<<Models: parameter: TBP>>=
  procedure :: reset_derived => parameter_reset_derived
<<Models: procedures>>=
  subroutine parameter_reset_derived (par)
    class(parameter_t), intent(inout) :: par
    select case (par%type)
    case (PAR_DERIVED)
       call eval_tree_evaluate (par%eval_tree)
       par%data = eval_tree_get_real (par%eval_tree)
    end select
  end subroutine parameter_reset_derived

@ %def parameter_reset_derived parameter_reset_external
@ Output.  [We should have a formula format for the eval tree,
suitable for input and output!]
<<Models: parameter: TBP>>=
  procedure :: write => parameter_write
<<Models: procedures>>=
  subroutine parameter_write (par, unit, write_defs)
    class(parameter_t), intent(in) :: par
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: write_defs
    logical :: defs
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    defs = .false.;  if (present (write_defs))  defs = write_defs
    select case (par%type)
    case (PAR_INDEPENDENT)
       write (u, "(3x,A)", advance="no")  "parameter"
    case (PAR_DERIVED)
       write (u, "(3x,A)", advance="no")  "derived"
    case (PAR_EXTERNAL)
       write (u, "(3x,A)", advance="no")  "external"
    end select
    call par%data%write (u)
    select case (par%type)
    case (PAR_DERIVED)
       if (defs) then
          call eval_tree_write (par%eval_tree, unit)
       else
          write (u, *)
       end if
    case default
       write (u, *)
    end select
  end subroutine parameter_write

@ %def parameter_write
@ Screen output variant.  Restrict output to the given parameter type.
<<Models: parameter: TBP>>=
  procedure :: show => parameter_show
<<Models: procedures>>=
  subroutine parameter_show (par, l, u, partype)
    class(parameter_t), intent(in) :: par
    integer, intent(in) :: l, u
    integer, intent(in) :: partype
    if (par%type == partype) then
       call par%data%show (l, u)
    end if
  end subroutine parameter_show
    
@ %def parameter_show
@ 
\subsection{Model Object}
A model object holds all information about parameters, particles,
and vertices.  For models that require an external program for
parameter calculation, there is the pointer to a function that does
this calculation, given the set of independent and derived parameters.

As explained above, the type inherits from [[model_data_t]], which is
the actual storage for the model data.

When reading a model, we create a parse tree.  Parameter definitions are
available via parse nodes.  Since we may need those later when making model
instances, we keep the whole parse tree in the model definition (but not in
the instances).
<<Models: public>>=
  public :: model_t
<<Models: types>>=
  type, extends (model_data_t) :: model_t
     private
     character(32) :: md5sum = ""
     type(parameter_t), dimension(:), allocatable :: par
     integer :: max_par_name_length = 0
     integer :: max_field_name_length = 0
     type(var_list_t) :: var_list
     type(string_t) :: dlname
     procedure(model_init_external_parameters), nopass, pointer :: &
          init_external_parameters => null ()
     type(dlaccess_t) :: dlaccess
     type(parse_tree_t) :: parse_tree
   contains
   <<Models: model: TBP>>
  end type model_t

@ %def model_t
@ This is the interface for a procedure that initializes the
calculation of external parameters, given the array of all
parameters.
<<Models: interfaces>>=
  abstract interface
     subroutine model_init_external_parameters (par) bind (C)
       import
       real(c_default_float), dimension(*), intent(inout) :: par
     end subroutine model_init_external_parameters
  end interface

@ %def model_init_external_parameters
@ Initialization: Specify the number of parameters, particles,
vertices and allocate memory.  If an associated DL library is
specified, load this library.
<<Models: model: TBP>>=
  generic :: init => model_init
  procedure, private :: model_init
<<Models: procedures>>=
  subroutine model_init &
       (model, name, libname, os_data, n_par, n_prt, n_vtx)
    class(model_t), intent(inout) :: model
    type(string_t), intent(in) :: name, libname
    type(os_data_t), intent(in) :: os_data
    integer, intent(in) :: n_par, n_prt, n_vtx
    type(c_funptr) :: c_fptr
    type(string_t) :: libpath
    call model%basic_init (name, n_par, n_prt, n_vtx)
    if (libname /= "") then
       if (.not. os_data%use_testfiles) then
          libpath = os_data%whizard_models_libpath_local
          model%dlname = os_get_dlname ( &
            libpath // "/" // libname, os_data, ignore=.true.)
       end if
       if (model%dlname == "") then
          libpath = os_data%whizard_models_libpath
          model%dlname = os_get_dlname (libpath // "/" // libname, os_data)
       end if
    else
       model%dlname = ""
    end if
    if (model%dlname /= "") then
       if (.not. dlaccess_is_open (model%dlaccess)) then
          if (logging) &
               call msg_message ("Loading model auxiliary library '" &
               // char (libpath) // "/" // char (model%dlname) // "'")
          call dlaccess_init (model%dlaccess, os_data%whizard_models_libpath, &
               model%dlname, os_data)
          if (dlaccess_has_error (model%dlaccess)) then
             call msg_message (char (dlaccess_get_error (model%dlaccess)))
             call msg_fatal ("Loading model auxiliary library '" &
                  // char (model%dlname) // "' failed")
             return
          end if
          c_fptr = dlaccess_get_c_funptr (model%dlaccess, &
               var_str ("init_external_parameters"))
          if (dlaccess_has_error (model%dlaccess)) then
             call msg_message (char (dlaccess_get_error (model%dlaccess)))
             call msg_fatal ("Loading function from auxiliary library '" &
                  // char (model%dlname) // "' failed")
             return
          end if
          call c_f_procpointer (c_fptr, model% init_external_parameters)
       end if
    end if
  end subroutine model_init

@ %def model_init
@ For a model instance, we do not attempt to load a DL library.  This is the
core of the full initializer above.
<<Models: model: TBP>>=
  procedure, private :: basic_init => model_basic_init
<<Models: procedures>>=
  subroutine model_basic_init (model, name, n_par, n_prt, n_vtx)
    class(model_t), intent(inout) :: model
    type(string_t), intent(in) :: name
    integer, intent(in) :: n_par, n_prt, n_vtx
    allocate (model%par (n_par))
    call model%model_data_t%init (name, n_par, 0, n_prt, n_vtx)
  end subroutine model_basic_init
    
@ %def model_basic_init
@ Finalization: The variable list contains allocated pointers, also the parse
tree.  We also close the DL access object, if any, that enables external
parameter calculation.
<<Models: model: TBP>>=
  procedure :: final => model_final
<<Models: procedures>>=
  subroutine model_final (model)
    class(model_t), intent(inout) :: model
    integer :: i
    if (allocated (model%par)) then
       do i = 1, size (model%par)
          call model%par(i)%final ()
       end do
    end if
    call var_list_final (model%var_list)
    if (model%dlname /= "")  call dlaccess_final (model%dlaccess)
    call parse_tree_final (model%parse_tree)
    call model%model_data_t%final ()
  end subroutine model_final

@ %def model_final
@ Output.  By default, the output is in the form of an input file.  If
[[verbose]] is true, for each derived parameter the definition (eval
tree) is displayed, and the vertex hash table is shown.
<<Models: model: TBP>>=
  procedure :: write => model_write
<<Models: procedures>>=
  subroutine model_write (model, unit, verbose, &
       show_md5sum, show_variables, show_parameters, &
       show_particles, show_vertices)
    class(model_t), intent(in) :: model
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: show_md5sum
    logical, intent(in), optional :: show_variables
    logical, intent(in), optional :: show_parameters
    logical, intent(in), optional :: show_particles
    logical, intent(in), optional :: show_vertices
    logical :: verb, show_md5, show_par, show_var
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    verb = .false.;  if (present (verbose))  verb = verbose
    show_md5 = .true.;  if (present (show_md5sum)) &
         show_md5 = show_md5sum
    show_par = .true.;  if (present (show_parameters)) &
         show_par = show_parameters
    show_var = verb;  if (present (show_variables)) &
         show_var = show_variables
    write (u, "(A,A,A)") 'model "', char (model%get_name ()), '"'
    if (show_md5 .and. model%md5sum /= "") &
         write (u, "(1x,A,A,A)") "! md5sum = '", model%md5sum, "'"
    if (show_par) then
       write (u, *)
       do i = 1, size (model%par)
          call model%par(i)%write (u, write_defs=verbose)
       end do
    end if
    call model%model_data_t%write (unit, verbose, &
         show_md5sum, show_variables, &
         show_parameters=.false., &
         show_particles=show_particles, &
         show_vertices=show_vertices)
    if (show_var) then
       write (u, *)
       call var_list_write (model%var_list, unit)
    end if
  end subroutine model_write

@ %def model_write
@ Screen output, condensed form.
<<Models: model: TBP>>=
  procedure :: show => model_show
<<Models: procedures>>=
  subroutine model_show (model, unit)
    class(model_t), intent(in) :: model
    integer, intent(in), optional :: unit
    integer :: i, u, l
    u = given_output_unit (unit)
    write (u, "(A,1x,A)")  "Model:", char (model%get_name ())
    l = model%max_field_name_length
    call model%show_fields (l, u)
    l = model%max_par_name_length
    if (any (model%par%type == PAR_INDEPENDENT)) then
       write (u, "(2x,A)")  "Independent parameters:"
       do i = 1, size (model%par)
          call model%par(i)%show (l, u, PAR_INDEPENDENT)
       end do
    end if
    if (any (model%par%type == PAR_DERIVED)) then
       write (u, "(2x,A)")  "Derived parameters:"
       do i = 1, size (model%par)
          call model%par(i)%show (l, u, PAR_DERIVED)
       end do
    end if
    if (any (model%par%type == PAR_EXTERNAL)) then
       write (u, "(2x,A)")  "External parameters:"
       do i = 1, size (model%par)
          call model%par(i)%show (l, u, PAR_EXTERNAL)
       end do
    end if
  end subroutine model_show

@ %def model_show
@ Show all fields/particles.
<<Models: model: TBP>>=
  procedure :: show_fields => model_show_fields
<<Models: procedures>>=
  subroutine model_show_fields (model, l, unit)
    class(model_t), intent(in), target :: model
    integer, intent(in) :: l
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: field
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(2x,A)")  "Particles:"
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       call field%show (l, u)
    end do
  end subroutine model_show_fields
  
@ %def model_data_show_fields
@ Show the list of stable, unstable, polarized, or unpolarized
particles, respectively.
<<Models: model: TBP>>=
  procedure :: show_stable => model_show_stable
  procedure :: show_unstable => model_show_unstable
  procedure :: show_polarized => model_show_polarized
  procedure :: show_unpolarized => model_show_unpolarized
<<Models: procedures>>=
  subroutine model_show_stable (model, unit)
    class(model_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: field
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(A,1x)", advance="no")  "Stable particles:"
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       if (field%is_stable (.false.)) then
          write (u, "(1x,A)", advance="no")  char (field%get_name (.false.))
       end if
       if (field%has_antiparticle ()) then
          if (field%is_stable (.true.)) then
             write (u, "(1x,A)", advance="no")  char (field%get_name (.true.))
          end if
       end if
    end do
    write (u, *)
  end subroutine model_show_stable
  
  subroutine model_show_unstable (model, unit)
    class(model_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: field
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(A,1x)", advance="no")  "Unstable particles:"
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       if (.not. field%is_stable (.false.)) then
          write (u, "(1x,A)", advance="no")  char (field%get_name (.false.))
       end if
       if (field%has_antiparticle ()) then
          if (.not. field%is_stable (.true.)) then
             write (u, "(1x,A)", advance="no")  char (field%get_name (.true.))
          end if
       end if
    end do
    write (u, *)
  end subroutine model_show_unstable
  
  subroutine model_show_polarized (model, unit)
    class(model_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: field
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(A,1x)", advance="no")  "Polarized particles:"
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       if (field%is_polarized (.false.)) then
          write (u, "(1x,A)", advance="no") char (field%get_name (.false.))
       end if
       if (field%has_antiparticle ()) then
          if (field%is_polarized (.true.)) then
             write (u, "(1x,A)", advance="no") char (field%get_name (.true.))
          end if
       end if
    end do
    write (u, *)
  end subroutine model_show_polarized
  
  subroutine model_show_unpolarized (model, unit)
    class(model_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: field
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(A,1x)", advance="no")  "Unpolarized particles:"
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       if (.not. field%is_polarized (.false.)) then
          write (u, "(1x,A)", advance="no") &
               char (field%get_name (.false.))
       end if
       if (field%has_antiparticle ()) then
          if (.not. field%is_polarized (.true.)) then
             write (u, "(1x,A)", advance="no") char (field%get_name (.true.))
          end if
       end if
    end do
    write (u, *)
  end subroutine model_show_unpolarized
  
@ %def model_show_stable
@ %def model_show_unstable
@ %def model_show_polarized
@ %def model_show_unpolarized
@ Retrieve the MD5 sum of a model (actually, of the model file).
<<Models: model: TBP>>=
  procedure :: get_md5sum => model_get_md5sum
<<Models: procedures>>=
  function model_get_md5sum (model) result (md5sum)
    character(32) :: md5sum
    class(model_t), intent(in) :: model
    md5sum = model%md5sum
  end function model_get_md5sum

@ %def model_get_md5sum
@ Parameters are defined by an expression which may be constant or
arbitrary.

Note: the auxiliary pointer [[value_ptr]] is a workaround for a bug in gfortran
4.8.1: the target of the function pointer is lost, if the pointer is provided
directly as argument.
<<Models: model: TBP>>=
  procedure, private :: &
       set_parameter_constant => model_set_parameter_constant
  procedure, private :: &
       set_parameter_parse_node => model_set_parameter_parse_node
  procedure, private :: &
       set_parameter_external => model_set_parameter_external
<<Models: procedures>>=
  subroutine model_set_parameter_constant (model, i, name, value)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(string_t), intent(in) :: name
    real(default), intent(in) :: value
    logical, save, target :: known = .true.
    class(modelpar_data_t), pointer :: par_data
    real(default), pointer :: value_ptr
    par_data => model%get_par_real_ptr (i)
    call model%par(i)%init_independent_value (par_data, name, value)
    value_ptr => par_data%get_real_ptr ()
    call var_list_append_real_ptr (model%var_list, &
         name, value_ptr, &
         is_known=known, intrinsic=.true.)
    model%max_par_name_length = max (model%max_par_name_length, len (name))
  end subroutine model_set_parameter_constant

  subroutine model_set_parameter_parse_node (model, i, name, pn, constant)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(string_t), intent(in) :: name
    type(parse_node_t), intent(in), target :: pn
    logical, intent(in) :: constant
    logical, save, target :: known = .true.
    class(modelpar_data_t), pointer :: par_data
    real(default), pointer :: value_ptr
    par_data => model%get_par_real_ptr (i)
    if (constant) then
       call model%par(i)%init_independent (par_data, name, pn)
    else
       call model%par(i)%init_derived (par_data, name, pn, model%var_list)
    end if
    value_ptr => par_data%get_real_ptr ()
    call var_list_append_real_ptr (model%var_list, &
         name, value_ptr, &
         is_known=known, locked=.not.constant, intrinsic=.true.)
    model%max_par_name_length = max (model%max_par_name_length, len (name))
  end subroutine model_set_parameter_parse_node

  subroutine model_set_parameter_external (model, i, name)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(string_t), intent(in) :: name
    logical, save, target :: known = .true.
    class(modelpar_data_t), pointer :: par_data
    real(default), pointer :: value_ptr
    par_data => model%get_par_real_ptr (i)
    call model%par(i)%init_external (par_data, name)
    value_ptr => par_data%get_real_ptr ()
    call var_list_append_real_ptr (model%var_list, &
         name, value_ptr, &
         is_known=known, locked=.true., intrinsic=.true.)
    model%max_par_name_length = max (model%max_par_name_length, len (name))
  end subroutine model_set_parameter_external

@ %def model_set_parameter
@ Make a copy of a parameter.  We assume that the [[model_data_t]]
parameter arrays have already been copied, so names and values are
available in the current model, and can be used as targets.  The eval
tree should not be copied, since it should refer to the new variable
list.  The safe solution is to make use of the above initializers,
which also take care of the building a new variable list.
<<Models: model: TBP>>=
  procedure, private :: copy_parameter => model_copy_parameter
<<Models: procedures>>=
  subroutine model_copy_parameter (model, i, par)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(parameter_t), intent(in) :: par
    type(string_t) :: name
    name = par%data%get_name ()
    select case (par%type)
    case (PAR_INDEPENDENT)
       if (associated (par%pn)) then
          call model%set_parameter_parse_node (i, name, par%pn, &
               constant = .true.)
       else
          call model%set_parameter_constant (i, name, &
               par%data%get_real ())
       end if
    case (PAR_DERIVED)
       call model%set_parameter_parse_node (i, name, par%pn, &
            constant = .false.)
    case (PAR_EXTERNAL)
       call model%set_parameter_external (i, name)
    end select
  end subroutine model_copy_parameter
  
@ %def model_copy_parameter
@ Rcalculate all derived parameters.
<<Models: model: TBP>>=
  procedure :: update_parameters => model_parameters_update
<<Models: procedures>>=
  subroutine model_parameters_update (model)
    class(model_t), intent(inout) :: model
    integer :: i
    real(default), dimension(:), allocatable :: par
    do i = 1, size (model%par)
       call model%par(i)%reset_derived ()
    end do
    if (associated (model%init_external_parameters)) then
       allocate (par (model%get_n_real ()))
       call model%real_parameters_to_c_array (par)
       call model%init_external_parameters (par)
       call model%real_parameters_from_c_array (par)
    end if
  end subroutine model_parameters_update

@ %def model_parameters_update
@ Initialize field data with PDG long name and PDG code.
<<Models: model: TBP>>=
  procedure, private :: init_field => model_init_field
<<Models: procedures>>=
  subroutine model_init_field (model, i, longname, pdg)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(string_t), intent(in) :: longname
    integer, intent(in) :: pdg
    type(field_data_t), pointer :: field
    field => model%get_field_ptr_by_index (i)
    call field%init (longname, pdg)
  end subroutine model_init_field
    
@ %def model_init_field
@ Copy field data for index [[i]] from another particle which serves
as a template.  The name should be the unique long name.
<<Models: model: TBP>>=
  procedure, private :: copy_field => model_copy_field
<<Models: procedures>>=
  subroutine model_copy_field (model, i, name_src)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(string_t), intent(in) :: name_src
    type(field_data_t), pointer :: field_src, field
    field_src => model%get_field_ptr (name_src)
    field => model%get_field_ptr_by_index (i)
    call field%copy_from (field_src)
  end subroutine model_copy_field

@ %def model_copy_field
@ Mark a particle as unstable and provide a list of names for its
decay processes.  In contrast with the previous subroutine which is
for internal use, we address the particle by its PDG code.  If the
index is negative, we address the antiparticle.
<<Models: model: TBP>>=
  procedure :: set_unstable => model_set_unstable
  procedure :: set_stable => model_set_stable
<<Models: procedures>>=
  subroutine model_set_unstable (model, pdg, decay, isotropic, diagonal)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: pdg
    type(string_t), dimension(:), intent(in) :: decay
    logical, intent(in), optional :: isotropic, diagonal
    type(field_data_t), pointer :: field
    field => model%get_field_ptr (pdg)
    if (pdg > 0) then
       call field%set ( &
            p_is_stable = .false., p_decay = decay, &
            p_decays_isotropically = isotropic, &
            p_decays_diagonal = diagonal)
    else
       call field%set ( &
            a_is_stable = .false., a_decay = decay, &
            a_decays_isotropically = isotropic, &
            a_decays_diagonal = diagonal)
    end if
  end subroutine model_set_unstable
       
  subroutine model_set_stable (model, pdg)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: pdg
    type(field_data_t), pointer :: field
    field => model%get_field_ptr (pdg)
    if (pdg > 0) then
       call field%set (p_is_stable = .true.)
    else
       call field%set (a_is_stable = .true.)
    end if
  end subroutine model_set_stable
       
@ %def model_set_unstable
@ %def model_set_stable
@ Mark a particle as polarized.
<<Models: model: TBP>>=
  procedure :: set_polarized => model_set_polarized
  procedure :: set_unpolarized => model_set_unpolarized
<<Models: procedures>>=
  subroutine model_set_polarized (model, pdg)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: pdg
    type(field_data_t), pointer :: field
    field => model%get_field_ptr (pdg)
    if (pdg > 0) then
       call field%set (p_polarized = .true.)
    else
       call field%set (a_polarized = .true.)
    end if
  end subroutine model_set_polarized
    
  subroutine model_set_unpolarized (model, pdg)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: pdg
    type(field_data_t), pointer :: field
    field => model%get_field_ptr (pdg)
    if (pdg > 0) then
       call field%set (p_polarized = .false.)
    else
       call field%set (a_polarized = .false.)
    end if
  end subroutine model_set_unpolarized
    
@ %def model_set_polarized
@ %def model_set_unpolarized
@ Revert all polarized (unstable) particles to unpolarized (stable)
status, respectively.
<<Models: model: TBP>>=
  procedure :: clear_unstable => model_clear_unstable
  procedure :: clear_polarized => model_clear_polarized
<<Models: procedures>>=
  subroutine model_clear_unstable (model)
    class(model_t), intent(inout), target :: model
    integer :: i
    type(field_data_t), pointer :: field
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       call field%set (p_is_stable = .true.)
       if (field%has_antiparticle ()) then
          call field%set (a_is_stable = .true.)
       end if
    end do
  end subroutine model_clear_unstable
  
  subroutine model_clear_polarized (model)
    class(model_t), intent(inout), target :: model
    integer :: i
    type(field_data_t), pointer :: field
    do i = 1, model%get_n_field ()
       field => model%get_field_ptr_by_index (i)
       call field%set (p_polarized = .false.)
       if (field%has_antiparticle ()) then
          call field%set (a_polarized = .false.)
       end if
    end do
  end subroutine model_clear_polarized
  
@ %def model_clear_unstable
@ %def model_clear_polarized
@ Return a pointer to the variable list.
<<Models: model: TBP>>=
  procedure :: get_var_list_ptr => model_get_var_list_ptr
<<Models: procedures>>=
  function model_get_var_list_ptr (model) result (var_list)
    type(var_list_t), pointer :: var_list
    class(model_t), intent(in), target :: model
    var_list => model%var_list
  end function model_get_var_list_ptr

@ %def model_get_var_list_ptr
@ 
\subsection{Reading models from file}
This procedure defines the model-file syntax for the parser, returning
an internal file (ifile).

Note that arithmetic operators are defined as keywords in the
expression syntax, so we exclude them here.
<<Models: procedures>>=
  subroutine define_model_file_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ model_def = model_name_def " // &
         "parameters derived_pars external_pars particles vertices")
    call ifile_append (ifile, "SEQ model_name_def = model model_name")
    call ifile_append (ifile, "KEY model")
    call ifile_append (ifile, "QUO model_name = '""'...'""'")
    call ifile_append (ifile, "SEQ parameters = parameter_def*")
    call ifile_append (ifile, "SEQ parameter_def = parameter par_name " // &
         "'=' any_real_value")
    call ifile_append (ifile, "ALT any_real_value = " &
         // "neg_real_value | pos_real_value | real_value")
    call ifile_append (ifile, "SEQ neg_real_value = '-' real_value")
    call ifile_append (ifile, "SEQ pos_real_value = '+' real_value")
    call ifile_append (ifile, "KEY parameter")
    call ifile_append (ifile, "IDE par_name")
    ! call ifile_append (ifile, "KEY '='")          !!! Key already exists
    call ifile_append (ifile, "SEQ derived_pars = derived_def*")
    call ifile_append (ifile, "SEQ derived_def = derived par_name " // &
         "'=' expr")
    call ifile_append (ifile, "KEY derived")
    call ifile_append (ifile, "SEQ external_pars = external_def*")
    call ifile_append (ifile, "SEQ external_def = external par_name")
    call ifile_append (ifile, "KEY external")
    call ifile_append (ifile, "SEQ particles = particle_def*")
    call ifile_append (ifile, "SEQ particle_def = particle prt_longname " // &
         "prt_pdg prt_details")
    call ifile_append (ifile, "KEY particle")
    call ifile_append (ifile, "IDE prt_longname")
    call ifile_append (ifile, "INT prt_pdg")
    call ifile_append (ifile, "ALT prt_details = prt_src | prt_properties")
    call ifile_append (ifile, "SEQ prt_src = like prt_longname prt_properties")
    call ifile_append (ifile, "KEY like")
    call ifile_append (ifile, "SEQ prt_properties = prt_property*")
    call ifile_append (ifile, "ALT prt_property = " // & 
         "parton | invisible | gauge | left | right | " // &
         "prt_name | prt_anti | prt_tex_name | prt_tex_anti | " // &
         "prt_spin | prt_isospin | prt_charge | " // &
         "prt_color | prt_mass | prt_width")
    call ifile_append (ifile, "KEY parton")
    call ifile_append (ifile, "KEY invisible")
    call ifile_append (ifile, "KEY gauge")
    call ifile_append (ifile, "KEY left")
    call ifile_append (ifile, "KEY right")
    call ifile_append (ifile, "SEQ prt_name = name name_def+")
    call ifile_append (ifile, "SEQ prt_anti = anti name_def+")
    call ifile_append (ifile, "SEQ prt_tex_name = tex_name name_def")
    call ifile_append (ifile, "SEQ prt_tex_anti = tex_anti name_def")
    call ifile_append (ifile, "KEY name")
    call ifile_append (ifile, "KEY anti")
    call ifile_append (ifile, "KEY tex_name")
    call ifile_append (ifile, "KEY tex_anti")
    call ifile_append (ifile, "ALT name_def = name_string | name_id")
    call ifile_append (ifile, "QUO name_string = '""'...'""'")
    call ifile_append (ifile, "IDE name_id")
    call ifile_append (ifile, "SEQ prt_spin = spin frac")
    call ifile_append (ifile, "KEY spin")
    call ifile_append (ifile, "SEQ prt_isospin = isospin frac")
    call ifile_append (ifile, "KEY isospin")
    call ifile_append (ifile, "SEQ prt_charge = charge frac")
    call ifile_append (ifile, "KEY charge")
    call ifile_append (ifile, "SEQ prt_color = color integer_literal")
    call ifile_append (ifile, "KEY color")
    call ifile_append (ifile, "SEQ prt_mass = mass par_name")
    call ifile_append (ifile, "KEY mass")
    call ifile_append (ifile, "SEQ prt_width = width par_name")
    call ifile_append (ifile, "KEY width")
    call ifile_append (ifile, "SEQ vertices = vertex_def*")
    call ifile_append (ifile, "SEQ vertex_def = vertex name_def+")
    call ifile_append (ifile, "KEY vertex")
    call define_expr_syntax (ifile, particles=.false., analysis=.false.)
  end subroutine define_model_file_syntax

@ %def define_model_file_syntax
@ The model-file syntax and lexer are fixed, therefore stored as
module variables:
<<Models: variables>>=
  type(syntax_t), target, save :: syntax_model_file

@ %def syntax_model_file
<<Models: public>>=
  public :: syntax_model_file_init
<<Models: procedures>>=
  subroutine syntax_model_file_init ()
    type(ifile_t) :: ifile
    call define_model_file_syntax (ifile)
    call syntax_init (syntax_model_file, ifile)
    call ifile_final (ifile)
  end subroutine syntax_model_file_init

@ %def syntax_model_file_init
<<Models: procedures>>=
  subroutine lexer_init_model_file (lexer)
    type(lexer_t), intent(out) :: lexer
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"{', &
         quote_match = '"}', &
         single_chars = ":()", &
         special_class = [ "+-*/^", "<>=  " ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_model_file))
  end subroutine lexer_init_model_file

@ %def lexer_init_model_file
<<Models: public>>=
  public :: syntax_model_file_final
<<Models: procedures>>=
  subroutine syntax_model_file_final ()
    call syntax_final (syntax_model_file)
  end subroutine syntax_model_file_final

@ %def syntax_model_file_final
<<Models: public>>=
  public :: syntax_model_file_write
<<Models: procedures>>=
  subroutine syntax_model_file_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_model_file, unit)
  end subroutine syntax_model_file_write

@ %def syntax_model_file_write
<<Models: model: TBP>>=
  procedure :: read => model_read
<<Models: procedures>>=
  subroutine model_read (model, filename, os_data, exist)
    class(model_t), intent(out), target :: model
    type(string_t), intent(in) :: filename
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: exist
    type(string_t) :: file
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    integer :: unit
    character(32) :: model_md5sum
    type(parse_node_t), pointer :: nd_model_def, nd_model_name_def
    type(parse_node_t), pointer :: nd_parameters, nd_derived_pars
    type(parse_node_t), pointer :: nd_external_pars
    type(parse_node_t), pointer :: nd_particles, nd_vertices
    type(string_t) :: model_name, lib_name
    integer :: n_par, n_der, n_ext, n_prt, n_vtx
    real(c_default_float), dimension(:), allocatable :: par
    integer :: i
    type(parse_node_t), pointer :: nd_par_def
    type(parse_node_t), pointer :: nd_der_def
    type(parse_node_t), pointer :: nd_ext_def
    type(parse_node_t), pointer :: nd_prt
    type(parse_node_t), pointer :: nd_vtx
    file = filename
    inquire (file=char(file), exist=exist)
    if ((.not. exist) .and. (.not. os_data%use_testfiles)) then
       file = os_data%whizard_modelpath_local // "/" // filename
       inquire (file = char (file), exist = exist)
    end if
    if (.not. exist) then
       file = os_data%whizard_modelpath // "/" // filename
       inquire (file = char (file), exist = exist)
    end if
    if (.not. exist) then
       call msg_fatal ("Model file '" // char (filename) // "' not found")
       return
    end if
    if (logging) call msg_message ("Reading model file '" // char (file) // "'")
    call lexer_init_model_file (lexer)
    unit = free_unit ()
    open (file=char(file), unit=unit, action="read", status="old")
    model_md5sum = md5sum (unit)
    close (unit)
    call stream_init (stream, char (file))
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (model%parse_tree, syntax_model_file, lexer)
    call stream_final (stream)
    call lexer_final (lexer)
    ! call parse_tree_write (parse_tree)    !!! Debugging 
    nd_model_def => parse_tree_get_root_ptr (model%parse_tree)
    nd_model_name_def => parse_node_get_sub_ptr (nd_model_def)
    model_name = parse_node_get_string &
         (parse_node_get_sub_ptr (nd_model_name_def, 2))
    nd_parameters => parse_node_get_next_ptr (nd_model_name_def)
    if (associated (nd_parameters)) then
       if (parse_node_get_rule_key (nd_parameters) == "parameters") then
          n_par = parse_node_get_n_sub (nd_parameters)
          nd_par_def => parse_node_get_sub_ptr (nd_parameters)
          nd_derived_pars => parse_node_get_next_ptr (nd_parameters)
       else
          n_par = 0
          nd_derived_pars => nd_parameters
          nd_parameters => null ()
       end if
    else
       n_par = 0
       nd_derived_pars => null ()
    end if
    if (associated (nd_derived_pars)) then
       if (parse_node_get_rule_key (nd_derived_pars) == "derived_pars") then
          n_der = parse_node_get_n_sub (nd_derived_pars)
          nd_der_def => parse_node_get_sub_ptr (nd_derived_pars)
          nd_external_pars => parse_node_get_next_ptr (nd_derived_pars)
       else
          n_der = 0
          nd_external_pars => nd_derived_pars
          nd_derived_pars => null ()
       end if
    else
       n_der = 0
       nd_external_pars => null ()
    end if
    if (associated (nd_external_pars)) then
       if (parse_node_get_rule_key (nd_external_pars) == "external_pars") then
          n_ext = parse_node_get_n_sub (nd_external_pars)
          lib_name = "external." // model_name
          nd_ext_def => parse_node_get_sub_ptr (nd_external_pars)
          nd_particles => parse_node_get_next_ptr (nd_external_pars)
       else
          n_ext = 0
          lib_name = ""
          nd_particles => nd_external_pars
          nd_external_pars => null ()
       end if
    else
       n_ext = 0
       lib_name = ""
       nd_particles => null ()
    end if
    if (associated (nd_particles)) then
       if (parse_node_get_rule_key (nd_particles) == "particles") then
          n_prt = parse_node_get_n_sub (nd_particles)
          nd_prt => parse_node_get_sub_ptr (nd_particles)
          nd_vertices => parse_node_get_next_ptr (nd_particles)
       else
          n_prt = 0
          nd_vertices => nd_particles
          nd_particles => null ()
       end if
    else
       n_prt = 0
       nd_vertices => null ()
    end if
    if (associated (nd_vertices)) then
       n_vtx = parse_node_get_n_sub (nd_vertices)
       nd_vtx => parse_node_get_sub_ptr (nd_vertices)
    else
       n_vtx = 0
    end if
    call model%init (model_name, lib_name, os_data, &
         n_par + n_der + n_ext, n_prt, n_vtx)
    model%md5sum = model_md5sum
    do i = 1, n_par
       call model%read_parameter (i, nd_par_def)
       nd_par_def => parse_node_get_next_ptr (nd_par_def)
    end do
    do i = n_par + 1, n_par + n_der
       call model%read_derived (i, nd_der_def)
       nd_der_def => parse_node_get_next_ptr (nd_der_def)
    end do
    do i = n_par + n_der + 1, n_par + n_der + n_ext
       call model%read_external (i, nd_ext_def)
       nd_ext_def => parse_node_get_next_ptr (nd_ext_def)
    end do
    if (associated (model% init_external_parameters)) then
       allocate (par (model%get_n_real ()))
       call model%real_parameters_to_c_array (par)
       call model%init_external_parameters (par)
       call model%real_parameters_from_c_array (par)
    end if
    do i = 1, n_prt
       call model%read_field (i, nd_prt)
       nd_prt => parse_node_get_next_ptr (nd_prt)
    end do
    do i = 1, n_vtx
       call model%read_vertex (i, nd_vtx)
       nd_vtx => parse_node_get_next_ptr (nd_vtx)
    end do
    call model%freeze_vertices ()
    call model%append_field_vars ()
  end subroutine model_read

@ %def model_read
@ Parameters are real values (literal) with an optional unit.
<<Models: model: TBP>>=
  procedure, private :: read_parameter => model_read_parameter
<<Models: procedures>>=
  subroutine model_read_parameter (model, i, node)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(parse_node_t), intent(in), target :: node
    type(parse_node_t), pointer :: node_name, node_val
    type(string_t) :: name
    node_name => parse_node_get_sub_ptr (node, 2)
    name = parse_node_get_string (node_name)
    node_val => parse_node_get_next_ptr (node_name, 2)
    call model%set_parameter_parse_node (i, name, node_val, constant=.true.)
  end subroutine model_read_parameter

@ %def model_read_parameter
@ Derived parameters have any numeric expression as their definition.
<<Models: model: TBP>>=
  procedure, private :: read_derived => model_read_derived
<<Models: procedures>>=
  subroutine model_read_derived (model, i, node)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(parse_node_t), intent(in), target :: node
    type(string_t) :: name
    type(parse_node_t), pointer :: pn_expr
    name = parse_node_get_string (parse_node_get_sub_ptr (node, 2))
    pn_expr => parse_node_get_sub_ptr (node, 4)
    call model%set_parameter_parse_node (i, name, pn_expr, constant=.false.)
  end subroutine model_read_derived

@ %def model_read_derived
@ External parameters have no definition; they are handled by an
external library. 
<<Models: model: TBP>>=
  procedure, private :: read_external => model_read_external
<<Models: procedures>>=
  subroutine model_read_external (model, i, node)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(parse_node_t), intent(in), target :: node
    type(string_t) :: name
    name = parse_node_get_string (parse_node_get_sub_ptr (node, 2))
    call model%set_parameter_external (i, name)
  end subroutine model_read_external

@ %def model_read_external
<<Models: model: TBP>>=
  procedure, private :: read_field => model_read_field
<<Models: procedures>>=
  subroutine model_read_field (model, i, node)
    class(model_t), intent(inout), target :: model
    integer, intent(in) :: i
    type(parse_node_t), intent(in) :: node
    type(parse_node_t), pointer :: nd_src, nd_props, nd_prop
    type(string_t) :: longname
    integer :: pdg
    type(string_t) :: name_src
    type(string_t), dimension(:), allocatable :: name
    type(field_data_t), pointer :: field, field_src
    longname = parse_node_get_string (parse_node_get_sub_ptr (node, 2))
    pdg = parse_node_get_integer (parse_node_get_sub_ptr (node, 3)) 
    field => model%get_field_ptr_by_index (i)
    call field%init (longname, pdg)
    nd_src => parse_node_get_sub_ptr (node, 4)
    if (associated (nd_src)) then
       if (parse_node_get_rule_key (nd_src) == "prt_src") then
          name_src = parse_node_get_string (parse_node_get_sub_ptr (nd_src, 2))
          field_src => model%get_field_ptr (name_src, check=.true.)
          call field%copy_from (field_src)
          nd_props => parse_node_get_sub_ptr (nd_src, 3)
       else
          nd_props => nd_src
       end if
       nd_prop => parse_node_get_sub_ptr (nd_props)
       do while (associated (nd_prop))
          select case (char (parse_node_get_rule_key (nd_prop)))
          case ("invisible")
             call field%set (is_visible=.false.)
          case ("parton")
             call field%set (is_parton=.true.)
          case ("gauge")
             call field%set (is_gauge=.true.)
          case ("left")
             call field%set (is_left_handed=.true.)
          case ("right")
             call field%set (is_right_handed=.true.)
          case ("prt_name")
             call read_names (nd_prop, name)
             call field%set (name=name)
          case ("prt_anti")
             call read_names (nd_prop, name)
             call field%set (anti=name)
          case ("prt_tex_name")
             call field%set ( &
                  tex_name = parse_node_get_string &
                  (parse_node_get_sub_ptr (nd_prop, 2)))
          case ("prt_tex_anti")
             call field%set ( &
                  tex_anti = parse_node_get_string &
                  (parse_node_get_sub_ptr (nd_prop, 2)))
          case ("prt_spin")
             call field%set ( &
                  spin_type = read_frac &
                  (parse_node_get_sub_ptr (nd_prop, 2), 2))
          case ("prt_isospin")
             call field%set ( &
                  isospin_type = read_frac &
                  (parse_node_get_sub_ptr (nd_prop, 2), 2))
          case ("prt_charge")
             call field%set ( &
                  charge_type = read_frac &
                  (parse_node_get_sub_ptr (nd_prop, 2), 3))
          case ("prt_color")
             call field%set ( &
                  color_type = parse_node_get_integer &
                  (parse_node_get_sub_ptr (nd_prop, 2)))
          case ("prt_mass")
             call field%set ( &
                  mass_data = model%get_par_data_ptr &
                  (parse_node_get_string &
                  (parse_node_get_sub_ptr (nd_prop, 2))))
          case ("prt_width")
             call field%set ( &
                  width_data = model%get_par_data_ptr &
                  (parse_node_get_string &
                  (parse_node_get_sub_ptr (nd_prop, 2))))
          case default
             call msg_bug (" Unknown particle property '" &
                  // char (parse_node_get_rule_key (nd_prop)) // "'")
          end select
          if (allocated (name))  deallocate (name)
          nd_prop => parse_node_get_next_ptr (nd_prop)
       end do
    end if
    call field%freeze ()
  end subroutine model_read_field

@ %def model_read_field
<<Models: model: TBP>>=
  procedure, private :: read_vertex => model_read_vertex
<<Models: procedures>>=
  subroutine model_read_vertex (model, i, node)
    class(model_t), intent(inout) :: model
    integer, intent(in) :: i
    type(parse_node_t), intent(in) :: node
    type(string_t), dimension(:), allocatable :: name
    call read_names (node, name)
    call model%set_vertex (i, name)
  end subroutine model_read_vertex

@ %def model_read_vertex
<<Models: procedures>>=
  subroutine read_names (node, name)
    type(parse_node_t), intent(in) :: node
    type(string_t), dimension(:), allocatable, intent(inout) :: name
    type(parse_node_t), pointer :: nd_name
    integer :: n_names, i
    n_names = parse_node_get_n_sub (node) - 1
    allocate (name (n_names))
    nd_name => parse_node_get_sub_ptr (node, 2)
    do i = 1, n_names
       name(i) = parse_node_get_string (nd_name)
       nd_name => parse_node_get_next_ptr (nd_name)
    end do
  end subroutine read_names

@ %def read_names
<<Models: procedures>>=
  function read_frac (nd_frac, base) result (qn_type)
    integer :: qn_type
    type(parse_node_t), intent(in) :: nd_frac
    integer, intent(in) :: base
    type(parse_node_t), pointer :: nd_num, nd_den
    integer :: num, den
    nd_num => parse_node_get_sub_ptr (nd_frac)
    nd_den => parse_node_get_next_ptr (nd_num)
    select case (char (parse_node_get_rule_key (nd_num)))
    case ("integer_literal")
       num = parse_node_get_integer (nd_num)
    case ("neg_int")
       num = - parse_node_get_integer (parse_node_get_sub_ptr (nd_num, 2))
    case ("pos_int")
       num = parse_node_get_integer (parse_node_get_sub_ptr (nd_num, 2))
    case default
       call parse_tree_bug (nd_num, "int|neg_int|pos_int")
    end select
    if (associated (nd_den)) then
       den = parse_node_get_integer (parse_node_get_sub_ptr (nd_den, 2))
    else
       den = 1
    end if
    if (den == 1) then
       qn_type = sign (1 + abs (num) * base, num)
    else if (den == base) then
       qn_type = sign (abs (num) + 1, num)
    else
       call parse_node_write_rec (nd_frac)
       call msg_fatal (" Fractional quantum number: wrong denominator")
    end if
  end function read_frac

@ %def read_frac
@ Append field (PDG-array) variables to the variable list, based on
the field content.
<<Models: model: TBP>>=
  procedure, private :: append_field_vars => model_append_field_vars
<<Models: procedures>>=
  subroutine model_append_field_vars (model)
    class(model_t), intent(inout) :: model
    type(pdg_array_t) :: aval
    type(field_data_t), dimension(:), pointer :: field_array
    type(field_data_t), pointer :: field
    type(string_t) :: name
    type(string_t), dimension(:), allocatable :: name_array
    integer, dimension(:), allocatable :: pdg
    logical, dimension(:), allocatable :: mask
    integer :: i, j
    field_array => model%get_field_array_ptr ()
    aval = UNDEFINED
    call var_list_append_pdg_array &
         (model%var_list, var_str ("particle"), &
          aval, locked = .true., intrinsic=.true.)
    do i = 1, size (field_array)
       aval = field_array(i)%get_pdg ()
       name = field_array(i)%get_longname ()
       call var_list_append_pdg_array &
            (model%var_list, name, aval, locked=.true., intrinsic=.true.)
       call field_array(i)%get_name_array (.false., name_array)
       do j = 1, size (name_array)
          call var_list_append_pdg_array &
               (model%var_list, name_array(j), &
               aval, locked=.true., intrinsic=.true.)
       end do
       model%max_field_name_length = &
            max (model%max_field_name_length, len (name_array(1)))
       aval = - field_array(i)%get_pdg ()
       call field_array(i)%get_name_array (.true., name_array)
       do j = 1, size (name_array)
          call var_list_append_pdg_array &
               (model%var_list, name_array(j), &
               aval, locked=.true., intrinsic=.true.)
       end do
       if (size (name_array) > 0) then
          model%max_field_name_length = &
               max (model%max_field_name_length, len (name_array(1)))
       end if
    end do
    call model%get_all_pdg (pdg)
    allocate (mask (size (pdg)))
    do i = 1, size (pdg)
       field => model%get_field_ptr (pdg(i))
       mask(i) = field%get_charge_type () /= 1
    end do
    aval = pack (pdg, mask)
    call var_list_append_pdg_array &
         (model%var_list, var_str ("charged"), &
          aval, locked = .true., intrinsic=.true.)
    do i = 1, size (pdg)
       field => model%get_field_ptr (pdg(i))
       mask(i) = field%get_color_type () /= 1
    end do
    aval = pack (pdg, mask)
    call var_list_append_pdg_array &
         (model%var_list, var_str ("colored"), &
          aval, locked = .true., intrinsic=.true.)
  end subroutine model_append_field_vars
    
@ %def model_append_field_vars
@ 
\subsection{Model list}
List of currently active models
<<Models: types>>=
  type, extends (model_t) :: model_entry_t
     type(model_entry_t), pointer :: next => null ()
  end type model_entry_t

@ %def model_entry_t
<<Models: public>>=
  public :: model_list_t
<<Models: types>>=
  type :: model_list_t
     type(model_entry_t), pointer :: first => null ()
     type(model_entry_t), pointer :: last => null ()
   contains
   <<Models: model list: TBP>>
  end type model_list_t

@ %def model_list_t
@ Write an account of the model list.
<<Models: model list: TBP>>=
  procedure :: write => model_list_write
<<Models: procedures>>=
  subroutine model_list_write (object, unit, verbose)
    class(model_list_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    type(model_entry_t), pointer :: current
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    current => object%first
    if (associated (current)) then
       do while (associated (current))
          call current%write (unit, verbose)
          current => current%next
          if (associated (current))  write (u, *)
       end do
    end if
  end subroutine model_list_write

@ %def model_list_write
@ Add a new model with given [[name]] to the list, if it does not yet
exist.  If successful, return a pointer to the new model.
<<Models: model list: TBP>>=
  procedure :: add => model_list_add
<<Models: procedures>>=
  subroutine model_list_add (model_list, &
       name, os_data, n_par, n_prt, n_vtx, model)
    class(model_list_t), intent(inout) :: model_list
    type(string_t), intent(in) :: name
    type(os_data_t), intent(in) :: os_data
    integer, intent(in) :: n_par, n_prt, n_vtx
    type(model_t), pointer :: model
    type(model_entry_t), pointer :: current
    if (model_list%model_exists (name)) then
       model => null ()
    else
       allocate (current)
       if (associated (model_list%first)) then
          model_list%last%next => current
       else
          model_list%first => current
       end if
       model_list%last => current
       call current%init (name, var_str (""), os_data, &
            n_par, n_prt, n_vtx)
       model => current%model_t
    end if
  end subroutine model_list_add

@ %def model_list_add
@ Read a new model from file and add to the list, if it does not yet
exist.  Finalize the model by allocating the vertex table.  Return a
pointer to the new model.  If unsuccessful, return the original
pointer.
<<Models: model list: TBP>>=
  procedure :: read_model => model_list_read_model
<<Models: procedures>>=
  subroutine model_list_read_model (model_list, name, filename, os_data, model)
    class(model_list_t), intent(inout) :: model_list
    type(string_t), intent(in) :: name, filename
    type(os_data_t), intent(in) :: os_data
    type(model_t), pointer :: model
    type(model_entry_t), pointer :: current
    logical :: exist
    if (.not. model_list%model_exists (name)) then
       allocate (current)
       call current%read (filename, os_data, exist)
       if (.not. exist)  return
       if (current%get_name () /= name) then
          call msg_fatal ("Model file '" // char (filename) // &
               "' contains model '" // char (current%get_name ()) // &
               "' instead of '" // char (name) // "'")
          call current%final ();  deallocate (current)
          return
       end if
       if (associated (model_list%first)) then
          model_list%last%next => current
       else
          model_list%first => current
       end if
       model_list%last => current
       model => current%model_t
    else
       model => model_list%get_model_ptr (name)
    end if
  end subroutine model_list_read_model

@ %def model_list_read_model
@ Check if a model exists by examining the list 
<<Models: model list: TBP>>=
  procedure :: model_exists => model_list_model_exists
<<Models: procedures>>=
  function model_list_model_exists (model_list, name) result (exists)
    class(model_list_t), intent(in) :: model_list
    logical :: exists
    type(string_t), intent(in) :: name
    type(model_entry_t), pointer :: current
    current => model_list%first
    do while (associated (current))
       if (current%get_name () == name) then
          exists = .true.
          return
       end if
       current => current%next
    end do
    exists = .false.
  end function model_list_model_exists

@ %def model_list_model_exists
@ Return a pointer to a named model 
<<Models: model list: TBP>>=
  procedure :: get_model_ptr => model_list_get_model_ptr
<<Models: procedures>>=
  function model_list_get_model_ptr (model_list, name) result (model)
    class(model_list_t), intent(in) :: model_list
    type(model_t), pointer :: model
    type(string_t), intent(in) :: name
    type(model_entry_t), pointer :: current
    current => model_list%first
    do while (associated (current))
       if (current%get_name () == name) then
          model => current%model_t
          return
       end if
       current => current%next
    end do
    model => null ()
  end function model_list_get_model_ptr

@ %def model_list_get_model_ptr
@ Delete the list of models
<<Models: model list: TBP>>=
  procedure :: final => model_list_final
<<Models: procedures>>=
  subroutine model_list_final (model_list)
    class(model_list_t), intent(inout) :: model_list
    type(model_entry_t), pointer :: current
    model_list%last => null ()
    do while (associated (model_list%first))
       current => model_list%first
       model_list%first => model_list%first%next
       call current%final ()
       deallocate (current)
    end do
  end subroutine model_list_final

@ %def model_list_final
@
\subsection{Model instances}
A model instance is a copy of a model object.  The parameters are true
copies.  The particle data and the variable list pointers should point to the
copy, so modifying the parameters has only a local effect.  Hence, we build
them up explicitly.  The vertex array is also rebuilt, it contains particle
pointers.  Finally, the vertex hash table can be copied directly since it
contains no pointers.

The [[multiplicity]] entry depends on the association of the [[mass_data]]
entry and therefore has to be set at the end.

The instance must carry the [[target]] attribute.

Parameters: the [[copy_parameter]] method essentially copies the parameter
decorations (parse node, expression etc.).  The current parameter values are
part of the [[model_data_t]] base type and are copied afterwards via its
[[copy_from]] method.
<<Models: model: TBP>>=
  procedure :: init_instance => model_copy
<<Models: procedures>>=
  subroutine model_copy (model, orig)
    class(model_t), intent(out), target :: model
    class(model_t), intent(in) :: orig
    integer :: n_par, n_prt, n_vtx
    integer :: i
    n_par = size (orig%par)
    n_prt = orig%get_n_field ()
    n_vtx = orig%get_n_vtx ()
    call model%basic_init (orig%get_name (), n_par, n_prt, n_vtx)
    model%md5sum = orig%md5sum
    do i = 1, n_par
       call model%copy_parameter (i, orig%par(i))
    end do
    model%init_external_parameters => orig%init_external_parameters
    call model%copy_from (orig)
    model%max_par_name_length = orig%max_par_name_length
    call model%append_field_vars ()
  end subroutine model_copy
  
@ %def model_copy
@ Turn a pointer to a model into a true copy, i.e., a new instance.
<<Models: public>>=
  public :: model_pointer_to_instance
<<Models: procedures>>=
  subroutine model_pointer_to_instance (model)
    type(model_t), pointer, intent(inout) :: model
    type(model_t), pointer :: model_tmp
    model_tmp => model
    allocate (model)
    call model%init_instance (model_tmp)
  end subroutine model_pointer_to_instance
    
@ %def model_pointer_to_instance
@
\subsection{Unit tests}
<<Models: public>>=
  public :: models_test
<<Models: tests>>=
  subroutine models_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Models: execute tests>>
  end subroutine models_test

@ %def models_tests
@
\subsubsection{Construct a Model}
Here, we construct a toy model explicitly without referring to a file.
<<Models: execute tests>>=
  call test (models_1, "models_1", &
       "construct model", &
       u, results)
<<Models: tests>>=
  subroutine models_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: model_name
    type(string_t) :: x_longname
    type(string_t), dimension(2) :: parname
    type(string_t), dimension(2) :: x_name
    type(string_t), dimension(1) :: x_anti
    type(string_t) :: x_tex_name, x_tex_anti
    type(string_t) :: y_longname
    type(string_t), dimension(2) :: y_name
    type(string_t) :: y_tex_name
    type(field_data_t), pointer :: field

    write (u, "(A)")  "* Test output: models_1"
    write (u, "(A)")  "*   Purpose: create a model"
    write (u, *)

    model_name = "Test model"
    call model_list%add (model_name, os_data, 2, 2, 3, model)
    parname(1) = "mx"
    parname(2) = "coup"
    call model%set_parameter_constant (1, parname(1), 10._default)
    call model%set_parameter_constant (2, parname(2), 1.3_default)
    x_longname = "X_LEPTON"
    x_name(1) = "X"
    x_name(2) = "x"
    x_anti(1) = "Xbar"
    x_tex_name = "X^+"
    x_tex_anti = "X^-"
    field => model%get_field_ptr_by_index (1)
    call field%init (x_longname, 99)
    call field%set ( &
         .true., .false., .false., .false., .false., &
         name=x_name, anti=x_anti, tex_name=x_tex_name, tex_anti=x_tex_anti, &
         spin_type=SPINOR, isospin_type=-3, charge_type=2, &
         mass_data=model%get_par_data_ptr (parname(1)))
    y_longname = "Y_COLORON"
    y_name(1) = "Y"
    y_name(2) = "yc"
    y_tex_name = "Y^0"
    field => model%get_field_ptr_by_index (2)
    call field%init (y_longname, 97)
    call field%set ( &
          .false., .false., .true., .false., .false., &
          name=y_name, tex_name=y_tex_name, &
          spin_type=SCALAR, isospin_type=2, charge_type=1, color_type=8)
    call model%set_vertex (1, [99, 99, 99])
    call model%set_vertex (2, [99, 99, 99, 99])
    call model%set_vertex (3, [99, 97, 99])
    call model_list%write (u)

    call model_list%final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: models_1"

  end subroutine models_1

@ %def models_1
@
\subsubsection{Read a Model}
Read a predefined model from file.
<<Models: execute tests>>=
  call test (models_2, "models_2", &
       "read model", &
       u, results)
<<Models: tests>>=
  subroutine models_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model

    write (u, "(A)")  "* Test output: models_2"
    write (u, "(A)")  "*   Purpose: read a model from file"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    call model_list%read_model (var_str ("Test"), var_str ("Test.mdl"), &
         os_data, model)
    call model_list%write (u)
    
    write (u, *)
    write (u, "(A)")  "* Variable list"
    write (u, *)
    
    call var_list_write (model%var_list, u)

    write (u, *)
    write (u, "(A)")  "* Cleanup"
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: models_2"

  end subroutine models_2

@ %def models_2
@
\subsubsection{Model Instance}
Read a predefined model from file and create an instance.
<<Models: execute tests>>=
  call test (models_3, "models_3", &
       "model instance", &
       u, results)
<<Models: tests>>=
  subroutine models_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(model_t), pointer :: instance

    write (u, "(A)")  "* Test output: models_3"
    write (u, "(A)")  "*   Purpose: create a model instance"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    call model_list%read_model (var_str ("Test"), var_str ("Test.mdl"), &
         os_data, model)
    allocate (instance)
    call instance%init_instance (model)
    
    call model%write (u)
    
    write (u, *)
    write (u, "(A)")  "* Variable list"
    write (u, *)
    
    call var_list_write (instance%var_list, u)

    write (u, *)
    write (u, "(A)")  "* Cleanup"
    
    call instance%final ()
    deallocate (instance)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: models_3"

  end subroutine models_3

@ %def models_test
@
\subsubsection{Unstable and Polarized Particles}
Read a predefined model from file and define decays and polarization.
<<Models: execute tests>>=
  call test (models_4, "models_4", &
       "handle decays and polarization", &
       u, results)
<<Models: tests>>=
  subroutine models_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model, model_instance
    character(32) :: md5sum

    write (u, "(A)")  "* Test output: models_4"
    write (u, "(A)")  "*   Purpose: set and unset decays and polarization"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    write (u, "(A)")  "* Read model from file"

    call model_list%read_model (var_str ("Test"), var_str ("Test.mdl"), &
         os_data, model)

    md5sum = model%get_parameters_md5sum ()
    write (u, *)
    write (u, "(1x,3A)")  "MD5 sum (parameters) = '", md5sum, "'"

    write (u, *)
    write (u, "(A)")  "* Set particle decays and polarization"
    write (u, *)

    call model%set_unstable (25, [var_str ("dec1"), var_str ("dec2")])
    call model%set_polarized (6)
    call model%set_unstable (-6, [var_str ("fdec")])

    call model%write (u)

    md5sum = model%get_parameters_md5sum ()
    write (u, *)
    write (u, "(1x,3A)")  "MD5 sum (parameters) = '", md5sum, "'"

    write (u, *)
    write (u, "(A)")  "* Create a model instance"

    allocate (model_instance)
    call model_instance%init_instance (model)

    write (u, *)
    write (u, "(A)")  "* Revert particle decays and polarization"
    write (u, *)

    call model%set_stable (25)
    call model%set_unpolarized (6)
    call model%set_stable (-6)

    call model%write (u)
    
    md5sum = model%get_parameters_md5sum ()
    write (u, *)
    write (u, "(1x,3A)")  "MD5 sum (parameters) = '", md5sum, "'"

    write (u, *)
    write (u, "(A)")  "* Show the model instance"
    write (u, *)

    call model_instance%write (u)

    md5sum = model_instance%get_parameters_md5sum ()
    write (u, *)
    write (u, "(1x,3A)")  "MD5 sum (parameters) = '", md5sum, "'"

    write (u, *)
    write (u, "(A)")  "* Cleanup"
    
    call model_instance%final ()
    deallocate (model_instance)
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: models_4"

  end subroutine models_4

@ %def models_4
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Automatic generation of process components}

This module provides the functionality for automatically generating radiation
corrections or decays, provided as lists of PDG codes.
<<[[auto_components.f90]]>>=
<<File header>>

module auto_components

<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use os_interface
  use model_data, only: field_data_t, vertex_iterator_t
  use models
  use pdg_arrays

<<Standard module head>>

<<Auto components: public>>

<<Auto components: types>>

<<Auto components: interfaces>>

contains

<<Auto components: procedures>>

<<Auto components: tests>>

end module auto_components
@ %def auto_components
@
\subsection{Constraints: Abstract types}
An abstract type that denotes a constraint on the automatically generated
states.  The concrete objects are applied as visitor objects at certain hooks
during the splitting algorithm.
<<Auto components: types>>=
  type, abstract :: split_constraint_t
   contains
   <<Auto components: split constraint: TBP>>
  end type split_constraint_t

@ %def split_constraint_t
@ By default, all checks return true.
<<Auto components: split constraint: TBP>>=
  procedure :: check_before_split  => split_constraint_check_before_split
  procedure :: check_before_insert => split_constraint_check_before_insert
  procedure :: check_before_record => split_constraint_check_before_record
<<Auto components: procedures>>=
  subroutine split_constraint_check_before_split (c, table, pl, k, passed)
    class(split_constraint_t), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: k
    logical, intent(out) :: passed
    passed = .true.
  end subroutine split_constraint_check_before_split
  
  subroutine split_constraint_check_before_insert (c, table, pa, pl, passed)
    class(split_constraint_t), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_array_t), intent(in) :: pa
    type(pdg_list_t), intent(inout) :: pl
    logical, intent(out) :: passed
    passed = .true.
  end subroutine split_constraint_check_before_insert
  
  subroutine split_constraint_check_before_record (c, table, pl, n_loop, passed)
    class(split_constraint_t), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    passed = .true.
  end subroutine split_constraint_check_before_record
  
@ %def check_before_split
@ %def check_before_insert
@ %def check_before_record
@ A transparent wrapper, so we can collect constraints of different type.
<<Auto components: types>>=
  type :: split_constraint_wrap_t
     class(split_constraint_t), allocatable :: c
  end type split_constraint_wrap_t
  
@ %def split_constraint_wrap_t
@ A collection of constraints.
<<Auto components: public>>=
  public :: split_constraints_t
<<Auto components: types>>=
  type :: split_constraints_t
     class(split_constraint_wrap_t), dimension(:), allocatable :: cc
   contains
   <<Auto components: split constraints: TBP>>
  end type split_constraints_t
  
@ %def split_constraints_t
@ Initialize the constraints set with a specific number of elements.
<<Auto components: split constraints: TBP>>=
  procedure :: init => split_constraints_init
<<Auto components: procedures>>=
  subroutine split_constraints_init (constraints, n)
    class(split_constraints_t), intent(out) :: constraints
    integer, intent(in) :: n
    allocate (constraints%cc (n))
  end subroutine split_constraints_init
  
@ %def split_constraints_init
@ Set a constraint.
<<Auto components: split constraints: TBP>>=
  procedure :: set => split_constraints_set
<<Auto components: procedures>>=
  subroutine split_constraints_set (constraints, i, c)
    class(split_constraints_t), intent(inout) :: constraints
    integer, intent(in) :: i
    class(split_constraint_t), intent(in) :: c
    allocate (constraints%cc(i)%c, source = c)
  end subroutine split_constraints_set
  
@ %def split_constraints_set
@ Apply checks.

[[check_before_split]] is applied to the particle list that we want
to split.

[[check_before_insert]] is applied to the particle list [[pl]] that is to
replace the particle [[pa]] that is split.  This check may transform the
particle list.

[[check_before_record]] is applied to the complete new particle list that
results from splitting before it is recorded.
<<Auto components: split constraints: TBP>>=
  procedure :: check_before_split  => split_constraints_check_before_split
  procedure :: check_before_insert => split_constraints_check_before_insert
  procedure :: check_before_record => split_constraints_check_before_record
<<Auto components: procedures>>=
  subroutine split_constraints_check_before_split &
       (constraints, table, pl, k, passed)
    class(split_constraints_t), intent(in) :: constraints
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: k
    logical, intent(out) :: passed
    integer :: i
    passed = .true.
    do i = 1, size (constraints%cc)
       call constraints%cc(i)%c%check_before_split (table, pl, k, passed)
       if (.not. passed)  return
    end do
  end subroutine split_constraints_check_before_split
    
  subroutine split_constraints_check_before_insert &
       (constraints, table, pa, pl, passed)
    class(split_constraints_t), intent(in) :: constraints
    class(ps_table_t), intent(in) :: table
    type(pdg_array_t), intent(in) :: pa
    type(pdg_list_t), intent(inout) :: pl
    logical, intent(out) :: passed
    integer :: i
    passed = .true.
    do i = 1, size (constraints%cc)
       call constraints%cc(i)%c%check_before_insert (table, pa, pl, passed)
       if (.not. passed)  return
    end do
  end subroutine split_constraints_check_before_insert
    
  subroutine split_constraints_check_before_record &
       (constraints, table, pl, n_loop, passed)
    class(split_constraints_t), intent(in) :: constraints
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    integer :: i
    passed = .true.
    do i = 1, size (constraints%cc)
       call constraints%cc(i)%c%check_before_record (table, pl, n_loop, passed)
       if (.not. passed)  return
    end do
  end subroutine split_constraints_check_before_record
    
@ %def split_constraints_check_before_split
@ %def split_constraints_check_before_insert
@ %def split_constraints_check_before_record
@ 
\subsection{Specific constraints}
\subsubsection{Number of particles}
Specific constraint: The number of particles plus the number of loops, if
any, must remain less than the given limit.  Note that the number of loops is
defined only when we are recording the entry.
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_n_tot
     private
     integer :: n_max = 0
   contains
     procedure :: check_before_split => constraint_n_tot_check_before_split
     procedure :: check_before_record => constraint_n_tot_check_before_record
  end type constraint_n_tot
  
@ %def constraint_n_tot
<<Auto components: public>>=
  public :: constrain_n_tot
<<Auto components: procedures>>=
  function constrain_n_tot (n_max) result (c)
    integer, intent(in) :: n_max
    type(constraint_n_tot) :: c
    c%n_max = n_max
  end function constrain_n_tot
  
  subroutine constraint_n_tot_check_before_split (c, table, pl, k, passed)
    class(constraint_n_tot), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: k
    logical, intent(out) :: passed
    passed = pl%get_size () < c%n_max
  end subroutine constraint_n_tot_check_before_split

  subroutine constraint_n_tot_check_before_record (c, table, pl, n_loop, passed)
    class(constraint_n_tot), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    passed = pl%get_size () + n_loop <= c%n_max
  end subroutine constraint_n_tot_check_before_record

@ %def constrain_n_tot
@ %def constraint_n_tot_check_before_insert
@ 
\subsubsection{Number of loops}
Specific constraint: The number of loops is limited, independent of the
total number of particles.
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_n_loop
     private
     integer :: n_loop_max = 0
   contains
     procedure :: check_before_record => constraint_n_loop_check_before_record
  end type constraint_n_loop
  
@ %def constraint_n_loop
<<Auto components: public>>=
  public :: constrain_n_loop
<<Auto components: procedures>>=
  function constrain_n_loop (n_loop_max) result (c)
    integer, intent(in) :: n_loop_max
    type(constraint_n_loop) :: c
    c%n_loop_max = n_loop_max
  end function constrain_n_loop

  subroutine constraint_n_loop_check_before_record &
       (c, table, pl, n_loop, passed)
    class(constraint_n_loop), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    passed = n_loop <= c%n_loop_max
  end subroutine constraint_n_loop_check_before_record

@ %def constrain_n_loop
@ %def constraint_n_loop_check_before_insert
@ 
\subsubsection{Particles allowed in splitting}
Specific constraint: The entries in the particle list ready for insertion
are matched to a given list of particle patterns.  If a match occurs, the
entry is replaced by the corresponding pattern.  If there is no match, the
check fails.
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_insert
     private
     type(pdg_list_t) :: pl_match
   contains
     procedure :: check_before_insert => constraint_insert_check_before_insert
  end type constraint_insert
  
@ %def constraint_insert
<<Auto components: public>>=
  public :: constrain_insert
<<Auto components: procedures>>=
  function constrain_insert (pl_match) result (c)
    type(pdg_list_t), intent(in) :: pl_match
    type(constraint_insert) :: c
    c%pl_match = pl_match
  end function constrain_insert
  
  subroutine constraint_insert_check_before_insert (c, table, pa, pl, passed)
    class(constraint_insert), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_array_t), intent(in) :: pa
    type(pdg_list_t), intent(inout) :: pl
    logical, intent(out) :: passed
    call pl%match_replace (c%pl_match, passed)
  end subroutine constraint_insert_check_before_insert

@ %def constrain_insert
@ %def constraint_insert_check_before_insert
@ 
\subsubsection{Particles required in final state}
Specific constraint: The entries in the recorded state must be a superset of
the entries in the given list (for instance, the lowest-order
state).
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_require
     private
     type(pdg_list_t) :: pl
   contains
     procedure :: check_before_record => constraint_require_check_before_record
  end type constraint_require
  
@ %def constraint_require
@ We check the current state by matching all particle entries against the
stored particle list, and crossing out the particles in the latter list when a
match is found.  The constraint passed if all entries have been crossed out.

For an [[if_table]] in particular, we check the final state only.
<<Auto components: public>>=
  public :: constrain_require
<<Auto components: procedures>>=
  function constrain_require (pl) result (c)
    type(pdg_list_t), intent(in) :: pl
    type(constraint_require) :: c
    c%pl = pl
  end function constrain_require
  
  subroutine constraint_require_check_before_record &
       (c, table, pl, n_loop, passed)
    class(constraint_require), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    logical, dimension(:), allocatable :: mask
    integer :: i, k, n_in
    select type (table)
    type is (if_table_t)
       n_in = 2
    class default
       n_in = 0
    end select
    allocate (mask (c%pl%get_size ()), source = .true.)
    do i = n_in + 1, pl%get_size ()
       k = c%pl%find_match (pl%get (i), mask)
       if (k /= 0)  mask(k) = .false.
    end do
    passed = .not. any (mask)
  end subroutine constraint_require_check_before_record

@ %def constrain_require
@ %def constraint_require_check_before_record
@ 
\subsubsection{Radiation}
Specific constraint: We have radiation pattern if the original particle
matches an entry in the list of particles that should replace it.  The
constraint prohibits this situation.
<<Auto components: public>>=
  public :: constrain_radiation
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_radiation
     private
   contains
     procedure :: check_before_insert => &
          constraint_radiation_check_before_insert
  end type constraint_radiation
  
@ %def constraint_radiation
<<Auto components: procedures>>=
  function constrain_radiation () result (c)
    type(constraint_radiation) :: c
  end function constrain_radiation
  
  subroutine constraint_radiation_check_before_insert (c, table, pa, pl, passed)
    class(constraint_radiation), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_array_t), intent(in) :: pa
    type(pdg_list_t), intent(inout) :: pl
    logical, intent(out) :: passed
    passed = .not. (pl .match. pa)
  end subroutine constraint_radiation_check_before_insert

@ %def constrain_radiation
@ %def constraint_radiation_check_before_insert
@ 
\subsubsection{Mass sum}
Specific constraint: The sum of masses within the particle list must not
exceed a given limit.  For in/out state combinations, we check initial and
final state separately.
<<Auto components: public>>=
  public :: constrain_mass_sum
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_mass_sum
     private
     real(default) :: mass_limit = 0
   contains
     procedure :: check_before_record => constraint_mass_sum_check_before_record
  end type constraint_mass_sum
  
@ %def contraint_mass_sum
<<Auto components: procedures>>=
  function constrain_mass_sum (mass_limit) result (c)
    real(default), intent(in) :: mass_limit
    type(constraint_mass_sum) :: c
    c%mass_limit = mass_limit
  end function constrain_mass_sum
  
  subroutine constraint_mass_sum_check_before_record &
       (c, table, pl, n_loop, passed)
    class(constraint_mass_sum), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    select type (table)
    type is (if_table_t)
       passed = mass_sum (pl, 1, 2, table%model) <= c%mass_limit &
            .and. mass_sum (pl, 3, pl%get_size (), table%model) <= c%mass_limit
    class default
       passed = mass_sum (pl, 1, pl%get_size (), table%model) <= c%mass_limit
    end select
  end subroutine constraint_mass_sum_check_before_record

@ %def constrain_mass_sum
@ %def constraint_mass_sum_check_before_record
@ 
\subsubsection{Initial state particles}
Specific constraint: The two incoming particles must both match the given
particle list.  This is checked for the generated particle list, just before
it is recorded.
<<Auto components: public>>=
  public :: constrain_in_state
<<Auto components: types>>=
  type, extends (split_constraint_t) :: constraint_in_state
     private
     type(pdg_list_t) :: pl
   contains
     procedure :: check_before_record => constraint_in_state_check_before_record
  end type constraint_in_state

@ %def constraint_in_state
<<Auto components: procedures>>=
  function constrain_in_state (pl) result (c)
    type(pdg_list_t), intent(in) :: pl
    type(constraint_in_state) :: c
    c%pl = pl
  end function constrain_in_state

  subroutine constraint_in_state_check_before_record &
       (c, table, pl, n_loop, passed)
    class(constraint_in_state), intent(in) :: c
    class(ps_table_t), intent(in) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop
    logical, intent(out) :: passed
    integer :: i
    select type (table)
    type is (if_table_t)
       passed = .false.
       do i = 1, 2
          if (.not. (c%pl .match. pl%get (i)))  return
       end do
    end select
    passed = .true.
  end subroutine constraint_in_state_check_before_record
  
@ %def constrain_in_state
@ %def constraint_in_state_check_before_record
@
\subsection{Tables of states}
Automatically generate a list of possible process components for a given
initial set (a single massive particle or a preset list of states).

The set of process components are generated by recursive splitting, applying
constraints on the fly that control and limit the process.  The generated
states are accumulated in a table that we can read out after completion.
<<Auto components: types>>=
  type, extends (pdg_list_t) :: ps_entry_t
     integer :: n_loop = 0
     integer :: n_rad = 0
     type(ps_entry_t), pointer :: previous => null ()
     type(ps_entry_t), pointer :: next => null ()
  end type ps_entry_t

@ %def ps_entry_t
@
This is the wrapper type for the decay tree for the list of final
states and the final array.  First, an abstract base type:
<<Auto components: public>>=
  public :: ps_table_t
<<Auto components: types>>=
  type, abstract :: ps_table_t
     private
     type(model_t), pointer :: model => null ()
     logical :: loops = .false.
     type(ps_entry_t), pointer :: first => null ()
     type(ps_entry_t), pointer :: last => null ()
   contains
   <<Auto components: ps table: TBP>>
  end type ps_table_t
     
@ %def ps_table_t
@ The extensions: one for decay, one for generic final states.  The decay-state
table stores the initial particle.  The final-state table is
indifferent, and the initial/final state table treats the first two
particles in its list as incoming antiparticles.
<<Auto components: public>>=
  public :: ds_table_t
  public :: if_table_t
<<Auto components: types>>=
  type, extends (ps_table_t) :: ds_table_t
     private
     integer :: pdg_in = 0
   contains
   <<Auto components: ds table: TBP>>
  end type ds_table_t

  type, extends (ps_table_t) :: fs_table_t
   contains
   <<Auto components: fs table: TBP>>
  end type fs_table_t

  type, extends (fs_table_t) :: if_table_t
   contains
   <<Auto components: if table: TBP>>
  end type if_table_t

@ %def ds_table_t fs_table_t if_table_t
@ Finalizer: we must deallocate the embedded list.
<<Auto components: ps table: TBP>>=
  procedure :: final => ps_table_final
<<Auto components: procedures>>=
  subroutine ps_table_final (object)
    class(ps_table_t), intent(inout) :: object
    type(ps_entry_t), pointer :: current
    do while (associated (object%first))
       current => object%first
       object%first => current%next
       deallocate (current)
    end do
    nullify (object%last)
  end subroutine ps_table_final
  
@ %def ps_table_final
@ Write the table.  A base writer for the body and specific writers
for the headers.
<<Auto components: ps table: TBP>>=
  procedure :: base_write => ps_table_base_write
  procedure (ps_table_write), deferred :: write
<<Auto components: interfaces>>=
  interface
     subroutine ps_table_write (object, unit)
       import
       class(ps_table_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine ps_table_write
  end interface
<<Auto components: ds table: TBP>>=
  procedure :: write => ds_table_write
<<Auto components: fs table: TBP>>=
  procedure :: write => fs_table_write
<<Auto components: if table: TBP>>=
  procedure :: write => if_table_write
@ The first [[n_in]] particles will be replaced by antiparticles in
the output, and we write an arrow if [[n_in]] is present.
<<Auto components: procedures>>=
  subroutine ps_table_base_write (object, unit, n_in)
    class(ps_table_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: n_in
    integer, dimension(:), allocatable :: pdg
    type(ps_entry_t), pointer :: entry
    type(field_data_t), pointer :: prt
    integer :: u, i, j, n0
    u = given_output_unit (unit)
    entry => object%first
    do while (associated (entry))
       write (u, "(2x)", advance = "no")
       if (present (n_in)) then
          do i = 1, n_in
             write (u, "(1x)", advance = "no")
             pdg = entry%get (i)
             do j = 1, size (pdg)
                prt => object%model%get_field_ptr (pdg(j))
                if (j > 1)  write (u, "(':')", advance = "no")
                write (u, "(A)", advance = "no") &
                     char (prt%get_name (pdg(j) >= 0))
             end do
          end do
          write (u, "(1x,A)", advance = "no")  "=>"
          n0 = n_in + 1
       else
          n0 = 1
       end if
       do i = n0, entry%get_size ()
          write (u, "(1x)", advance = "no")
          pdg = entry%get (i)
          do j = 1, size (pdg)
             prt => object%model%get_field_ptr (pdg(j))
             if (j > 1)  write (u, "(':')", advance = "no")
             write (u, "(A)", advance = "no") &
                  char (prt%get_name (pdg(j) < 0))
          end do
       end do
       if (object%loops) then
          write (u, "(2x,'[',I0,',',I0,']')")  entry%n_loop, entry%n_rad
       else
          write (u, *)
       end if
       entry => entry%next
    end do
  end subroutine ps_table_base_write
          
  subroutine ds_table_write (object, unit)
    class(ds_table_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(field_data_t), pointer :: prt
    integer :: u
    u = given_output_unit (unit)
    prt => object%model%get_field_ptr (object%pdg_in)
    write (u, "(1x,A,1x,A)")  "Decays for particle:", &
         char (prt%get_name (object%pdg_in < 0))
    call object%base_write (u)
  end subroutine ds_table_write
          
  subroutine fs_table_write (object, unit)
    class(fs_table_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Table of final states:"
    call object%base_write (u)
  end subroutine fs_table_write
          
  subroutine if_table_write (object, unit)
    class(if_table_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Table of in/out states:"
    call object%base_write (u, n_in = 2)
  end subroutine if_table_write
          
@ %def ps_table_write ds_table_write fs_table_write
@ Obtain a particle string for a given index in the pdg list
<<Auto components: ps table: TBP>>=
  procedure :: get_particle_string => ps_table_get_particle_string
<<Auto components: procedures>>=
  subroutine ps_table_get_particle_string (object, index, n_in, prt_in, prt_out)
    class(ps_table_t), intent(in) :: object
    integer, intent(in) :: index
    integer, intent(in) :: n_in
    type(string_t), intent(out), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: prt_tmp
    type(field_data_t), pointer :: prt
    type(ps_entry_t), pointer :: entry
    integer, dimension(:), allocatable :: pdg
    integer :: n0
    integer :: i, j 
    entry => object%first
    i = 1
    do while (i < index)
      if (associated (entry%next)) then
        entry => entry%next
        i=i+1
      else
        call msg_fatal ("ps_table: entry with requested index does not exist!")
      end if
    end do
    n0 = n_in + 1
    allocate (prt_in (n_in), prt_out (entry%get_size () - n_in))
    do i = 1, n_in
      prt_in(i) = ""
      pdg = entry%get(i)
      do j = 1, size(pdg)
        prt => object%model%get_field_ptr (pdg(j))
        prt_in(i) = prt_in(i) // prt%get_name (pdg(j) >= 0)
        if (j /= size(pdg)) &
           prt_in(i) = prt_in(i) // ":"
      end do
    end do
    do i = n0, entry%get_size ()
      prt_out(i-n_in) = ""
      pdg = entry%get(i)
      do j = 1, size(pdg)
         prt => object%model%get_field_ptr (pdg(j))
         prt_out(i-n_in) = prt_out(i-n_in) // prt%get_name (pdg(j) < 0)
         if (j /= size(pdg)) &
            prt_out(i-n_in) = prt_out(i-n_in) // ":"
      end do
    end do
  end subroutine ps_table_get_particle_string
                        
@ %def ps_table_get_particle_string
@ Initialize with a predefined set of final states, or in/out state lists.
<<Auto components: ps table: TBP>>=
  generic :: init => ps_table_init
  procedure, private :: ps_table_init
<<Auto components: if table: TBP>>=
  generic :: init => if_table_init
  procedure, private :: if_table_init
<<Auto components: procedures>>=
  subroutine ps_table_init (table, model, pl, constraints)
    class(ps_table_t), intent(out) :: table
    type(model_t), intent(in), target :: model
    type(pdg_list_t), dimension(:), intent(in) :: pl
    type(split_constraints_t), intent(in) :: constraints
    logical :: passed
    integer :: i
    table%model => model
    do i = 1, size (pl)
       call table%record (pl(i), 0, 0, constraints, passed)
       if (.not. passed) then
          call msg_fatal ("Registering process components: constraint failed")
       end if
    end do
  end subroutine ps_table_init
    
  subroutine if_table_init (table, model, pl_in, pl_out, constraints)
    class(if_table_t), intent(out) :: table
    type(model_t), intent(in), target :: model
    type(pdg_list_t), dimension(:), intent(in) :: pl_in, pl_out
    type(split_constraints_t), intent(in) :: constraints
    integer :: i, j, k, p, n_in, n_out
    type(pdg_array_t), dimension(:), allocatable :: pa_in
    type(pdg_list_t), dimension(:), allocatable :: pl
    allocate (pl (size (pl_in) * size (pl_out)))
    k = 0
    do i = 1, size (pl_in)
       n_in = pl_in(i)%get_size ()
       allocate (pa_in (n_in))
       do p = 1, n_in
          pa_in(p) = pl_in(i)%get (p)
       end do
       do j = 1, size (pl_out)
          n_out = pl_out(j)%get_size ()
          k = k + 1
          call pl(k)%init (n_in + n_out)
          do p = 1, n_in
             call pl(k)%set (p, invert_pdg_array (pa_in(p), model))
          end do
          do p = 1, n_out
             call pl(k)%set (n_in + p, pl_out(j)%get (p))
          end do
       end do
       deallocate (pa_in)
    end do
    call table%init (model, pl, constraints)
  end subroutine if_table_init
    
@ %def ps_table_init if_table_init
@ Enable loops for the table.  This affects both splitting and output.
<<Auto components: ps table: TBP>>=
  procedure :: enable_loops => ps_table_enable_loops
<<Auto components: procedures>>=
  subroutine ps_table_enable_loops (table)
    class(ps_table_t), intent(inout) :: table
    table%loops = .true.
  end subroutine ps_table_enable_loops
    
@ %def ps_table_enable_loops
@ 
\subsection{Top-level methods}
Create a table for a single-particle decay.  Construct all possible final
states from a single particle with PDG code [[pdg_in]].  The construction is
limited by the given [[constraints]].
<<Auto components: ds table: TBP>>=
  procedure :: make => ds_table_make
<<Auto components: procedures>>=
  subroutine ds_table_make (table, model, pdg_in, constraints)
    class(ds_table_t), intent(out) :: table
    type(model_t), intent(in), target :: model
    integer, intent(in) :: pdg_in
    type(split_constraints_t), intent(in) :: constraints
    type(pdg_list_t) :: pl_in
    type(pdg_list_t), dimension(0) :: pl
    logical :: passed
    call table%init (model, pl, constraints)
    table%pdg_in = pdg_in
    call pl_in%init (1)
    call pl_in%set (1, [pdg_in])
    call table%split (pl_in, 0, constraints)
  end subroutine ds_table_make
    
@ %def ds_table_make
@ Split all entries in a growing table, starting from a table that may already
contain states.  Add and record split states on the fly.
<<Auto components: fs table: TBP>>=
  procedure :: radiate => fs_table_radiate
<<Auto components: procedures>>=
  subroutine fs_table_radiate (table, constraints)
    class(fs_table_t), intent(inout) :: table
    type(split_constraints_t) :: constraints
    type(ps_entry_t), pointer :: current
    integer :: i, s
    logical :: passed
    current => table%first
    do while (associated (current))
       call table%split (current, 0, constraints, record = .true.)
       current => current%next
    end do
  end subroutine fs_table_radiate

@ %def fs_table_radiate
@ 
\subsection{Splitting algorithm}
Recursive splitting.  First of all, we record the current [[pdg_list]] in
the table, subject to [[constraints]], if requested.  We also record copies of
the list marked as loop corrections.

When we record a particle list, we sort it first.

If there is room for splitting, We take a PDG array list and the index of an
element, and split this element in all possible ways.  The split entry is
inserted into the list, which we split further.

The recursion terminates whenever the split array would have a length
greater than $n_\text{max}$.
<<Auto components: ps table: TBP>>=
  procedure :: split => ps_table_split
<<Auto components: procedures>>=
  recursive subroutine ps_table_split (table, pl, n_rad, constraints, &
        record)
    class(ps_table_t), intent(inout) :: table
    class(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_rad
    type(split_constraints_t), intent(in) :: constraints
    logical, intent(in), optional :: record
    integer :: n_loop, i
    logical :: passed
    type(vertex_iterator_t) :: vit
    integer, dimension(:), allocatable :: pdg1
    integer, dimension(:), allocatable :: pdg2
    if (present (record)) then
       if (record) then
          n_loop = 0
          INCR_LOOPS: do
             call table%record_sorted (pl, n_loop, n_rad, constraints, passed)
             if (.not. passed)  exit INCR_LOOPS
             if (.not. table%loops)  exit INCR_LOOPS
             n_loop = n_loop + 1
          end do INCR_LOOPS
       end if
    end if
    do i = 1, pl%get_size ()
       call constraints%check_before_split (table, pl, i, passed)
       if (passed) then
          pdg1 = pl%get (i)
          call vit%init (table%model, pdg1)
          SCAN_VERTICES: do
             call vit%get_next_match (pdg2)
             if (allocated (pdg2)) then
                call table%insert (pl, n_rad, i, pdg2, constraints)
             else
                exit SCAN_VERTICES
             end if
          end do SCAN_VERTICES
       end if
    end do
  end subroutine ps_table_split
    
@ %def ps_table_split
@ The worker part: insert the list of particles found by vertex matching in
place of entry [[i]] in the PDG list.  Then split/record further.

The [[n_in]] parameter tells the replacement routine to insert the new
particles after entry [[n_in]].  Otherwise, they follow index [[i]].
<<Auto components: ps table: TBP>>=
  procedure :: insert => ps_table_insert
<<Auto components: procedures>>=
  recursive subroutine ps_table_insert &
       (table, pl, n_rad, i, pdg, constraints, n_in)
    class(ps_table_t), intent(inout) :: table
    class(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_rad, i
    integer, dimension(:), intent(in) :: pdg
    type(split_constraints_t), intent(in) :: constraints
    integer, intent(in), optional :: n_in
    type(pdg_list_t) :: pl_insert
    logical :: passed
    integer :: k, s
    s = size (pdg)
    call pl_insert%init (s)
    do k = 1, s
       call pl_insert%set (k, pdg(k))
    end do
    call constraints%check_before_insert (table, pl%get (i), pl_insert, passed)
    if (passed) then
       call table%split (pl%replace (i, pl_insert, n_in), n_rad + s - 1, &
            constraints, record = .true.)
    end if
  end subroutine ps_table_insert
    
@ %def ps_table_insert
@ Special case:
If we are splitting an initial particle, there is slightly more to
do.  We loop over the particles from the vertex match and replace the
initial particle by each of them in turn.  The remaining particles
must be appended after the second initial particle, so they will end
up in the out state.  This is done by providing the [[n_in]] argument
to the base method as an optional argument.

Note that we must call the base-method procedure explicitly, so the
[[table]] argument keeps its dynamic type as [[if_table]] inside this
procedure.
<<Auto components: if table: TBP>>=
  procedure :: insert => if_table_insert
<<Auto components: procedures>>=
  recursive subroutine if_table_insert  &
       (table, pl, n_rad, i, pdg, constraints, n_in)
    class(if_table_t), intent(inout) :: table
    class(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_rad, i
    integer, dimension(:), intent(in) :: pdg
    type(split_constraints_t), intent(in) :: constraints
    integer, intent(in), optional :: n_in
    integer, dimension(:), allocatable :: pdg_work
    integer :: p
    if (i > 2) then
       call ps_table_insert (table, pl, n_rad, i, pdg, constraints)
    else
       allocate (pdg_work (size (pdg)))
       do p = 1, size (pdg)
          pdg_work(1) = pdg(p)
          pdg_work(2:p) = pdg(1:p-1)
          pdg_work(p+1:) = pdg(p+1:)
          call ps_table_insert (table, &
               pl, n_rad, i, pdg_work, constraints, n_in = 2)
       end do
    end if
  end subroutine if_table_insert

@ %def if_table_insert
@ Sort before recording.  In the case of the [[if_table]], we do not
sort the first [[n_in]] particle entries.  Instead, we check whether they are
allowed in the [[pl_beam]] PDG list, if that is provided.
<<Auto components: ps table: TBP>>=
  procedure :: record_sorted => ps_table_record_sorted
<<Auto components: if table: TBP>>=
  procedure :: record_sorted => if_table_record_sorted
<<Auto components: procedures>>=
  subroutine ps_table_record_sorted &
       (table, pl, n_loop, n_rad, constraints, passed)
    class(ps_table_t), intent(inout) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop, n_rad
    type(split_constraints_t), intent(in) :: constraints
    logical, intent(out) :: passed
    call table%record (pl%sort_abs (), n_loop, n_rad, constraints, passed)
  end subroutine ps_table_record_sorted
  
  subroutine if_table_record_sorted &
       (table, pl, n_loop, n_rad, constraints, passed)
    class(if_table_t), intent(inout) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop, n_rad
    type(split_constraints_t), intent(in) :: constraints
    logical, intent(out) :: passed
    integer :: i
    call table%record (pl%sort_abs (2), n_loop, n_rad, constraints, passed)
  end subroutine if_table_record_sorted

@ %def ps_table_record_sorted if_table_record_sorted
@ Record an entry: insert into the list.  Check the ordering and
insert it at the correct place, unless it is already there.

We record an array only if its mass sum is less than the total
available energy.  This restriction is removed by setting
[[constrained]] to false.
<<Auto components: ps table: TBP>>=
  procedure :: record => ps_table_record
<<Auto components: procedures>>=
  subroutine ps_table_record (table, pl, n_loop, n_rad, constraints, passed)
    class(ps_table_t), intent(inout) :: table
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n_loop, n_rad
    type(split_constraints_t), intent(in) :: constraints
    logical, intent(out) :: passed
    type(ps_entry_t), pointer :: current
    logical :: mass_limit
    if (.not. pl%is_regular ())  return
    call constraints%check_before_record (table, pl, n_loop, passed)
    if (.not. passed)  return
    current => table%first
    do while (associated (current))
       if (pl == current) then
          if (n_loop == current%n_loop)  return
       else if (pl < current) then
          call insert
          return
       end if
       current => current%next
    end do
    call insert
  contains
    subroutine insert ()
      type(ps_entry_t), pointer :: entry
      allocate (entry)
      entry%pdg_list_t = pl
      entry%n_loop = n_loop
      entry%n_rad = n_rad
      if (associated (current)) then
         if (associated (current%previous)) then
            current%previous%next => entry
            entry%previous => current%previous
         else
            table%first => entry
         end if
         entry%next => current
         current%previous => entry
      else
         if (associated (table%last)) then
            table%last%next => entry
            entry%previous => table%last
         else
            table%first => entry
         end if
         table%last => entry
      end if
    end subroutine insert
  end subroutine ps_table_record
    
@ %def ps_table_record
@
\subsection{Tools}
Compute the mass sum for a PDG list object, counting the entries with indices
between (including) [[n1]] and [[n2]].  Rely on the requirement that
if an entry is a PDG array, this array must be degenerate in mass.
<<Auto components: procedures>>=
  function mass_sum (pl, n1, n2, model) result (m)
    type(pdg_list_t), intent(in) :: pl
    integer, intent(in) :: n1, n2
    type(model_t), intent(in), target :: model
    integer, dimension(:), allocatable :: pdg
    real(default) :: m
    type(field_data_t), pointer :: prt
    integer :: i
    m = 0
    do i = n1, n2
       pdg = pl%get (i)
       prt => model%get_field_ptr (pdg(1))
       m = m + prt%get_mass ()
    end do
  end function mass_sum
  
@ %def mass_sum
@ Invert a PDG array, replacing particles by antiparticles.  This
depends on the model.
<<Auto components: procedures>>=
  function invert_pdg_array (pa, model) result (pa_inv)
    type(pdg_array_t), intent(in) :: pa
    type(model_t), intent(in), target :: model
    type(pdg_array_t) :: pa_inv
    type(field_data_t), pointer :: prt
    integer :: i, pdg
    pa_inv = pa
    do i = 1, pa_inv%get_length ()
       pdg = pa_inv%get (i)
       prt => model%get_field_ptr (pdg)
       if (prt%has_antiparticle ())  call pa_inv%set (i, -pdg)
    end do
  end function invert_pdg_array
          
@ %def invert_pdg_array
@ 
\subsection{Access results}
Return the number of generated decays.
<<Auto components: ps table: TBP>>=
  procedure :: get_length => ps_table_get_length
<<Auto components: procedures>>=
  function ps_table_get_length (ps_table) result (n)
    class(ps_table_t), intent(in) :: ps_table
    integer :: n
    type(ps_entry_t), pointer :: entry
    n = 0
    entry => ps_table%first
    do while (associated (entry))
       n = n + 1
       entry => entry%next
    end do
  end function ps_table_get_length

@ %def ps_table_get_length
@ Return an allocated array of decay products (PDG codes).  If
requested, return also the loop and radiation order count.
<<Auto components: ps table: TBP>>=
  procedure :: get_pdg_out => ps_table_get_pdg_out
<<Auto components: procedures>>=
  subroutine ps_table_get_pdg_out (ps_table, i, pa_out, n_loop, n_rad)
    class(ps_table_t), intent(in) :: ps_table
    integer, intent(in) :: i
    type(pdg_array_t), dimension(:), allocatable, intent(out) :: pa_out
    integer, intent(out), optional :: n_loop, n_rad
    type(ps_entry_t), pointer :: entry
    integer :: n, j
    n = 0
    entry => ps_table%first
    FIND_ENTRY: do while (associated (entry))
       n = n + 1
       if (n == i) then
          allocate (pa_out (entry%get_size ()))
          do j = 1, entry%get_size ()
             pa_out(j) = entry%get (j)
             if (present (n_loop))  n_loop = entry%n_loop
             if (present (n_rad))  n_rad = entry%n_rad
          end do
          exit FIND_ENTRY
       end if
       entry => entry%next
    end do FIND_ENTRY
  end subroutine ps_table_get_pdg_out
  
@ %def ps_table_get_pdg_out
@
\subsection{Unit tests}
<<Auto components: public>>=
  public :: auto_components_test
<<Auto components: tests>>=
  subroutine auto_components_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Auto components: execute tests>>
  end subroutine auto_components_test

@ %def auto_components_tests
@
\subsubsection{Generate Decay Table}
Determine all kinematically allowed decay channels for a Higgs boson,
using default parameter values.
<<Auto components: execute tests>>=
  call test (auto_components_1, "auto_components_1", &
       "generate decay table", &
       u, results)
<<Auto components: tests>>=
  subroutine auto_components_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(field_data_t), pointer :: prt
    type(ds_table_t) :: ds_table
    type(split_constraints_t) :: constraints

    write (u, "(A)")  "* Test output: auto_components_1"
    write (u, "(A)")  "*   Purpose: determine Higgs decay table"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    write (u, "(A)")  "* Read Standard Model"

    call model_list%read_model (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    prt => model%get_field_ptr (25)

    write (u, *)
    write (u, "(A)")  "* Higgs decays n = 2"
    write (u, *)

    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (2))
    call constraints%set (2, constrain_mass_sum (prt%get_mass ()))

    call ds_table%make (model, 25, constraints)
    call ds_table%write (u)
    call ds_table%final ()

    write (u, *)
    write (u, "(A)")  "* Higgs decays n = 3 (w/o radiative)"
    write (u, *)

    call constraints%init (3)
    call constraints%set (1, constrain_n_tot (3))
    call constraints%set (2, constrain_mass_sum (prt%get_mass ()))
    call constraints%set (3, constrain_radiation ())

    call ds_table%make (model, 25, constraints)
    call ds_table%write (u)
    call ds_table%final ()

    write (u, *)
    write (u, "(A)")  "* Higgs decays n = 3 (w/ radiative)"
    write (u, *)

    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (3))
    call constraints%set (2, constrain_mass_sum (prt%get_mass ()))

    call ds_table%make (model, 25, constraints)
    call ds_table%write (u)
    call ds_table%final ()

    write (u, *)
    write (u, "(A)")  "* Cleanup"
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: auto_components_1"

  end subroutine auto_components_1

@ %def auto_components_1
@
\subsubsection{Generate radiation}
Given a final state, add radiation (NLO and NNLO).  We provide a list
of particles that is allowed to occur in the generated final states.
<<Auto components: execute tests>>=
  call test (auto_components_2, "auto_components_2", &
       "generate NLO corrections, final state", &
       u, results)
<<Auto components: tests>>=
  subroutine auto_components_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(pdg_list_t), dimension(:), allocatable :: pl, pl_zzh
    type(pdg_list_t) :: pl_match
    type(fs_table_t) :: fs_table
    type(split_constraints_t) :: constraints
    real(default) :: sqrts
    integer :: i

    write (u, "(A)")  "* Test output: auto_components_2"
    write (u, "(A)")  "*   Purpose: generate radiation (NLO)"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    write (u, "(A)")  "* Read Standard Model"

    call model_list%read_model (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, *)
    write (u, "(A)")  "* LO final state"
    write (u, *)
    
    allocate (pl (2))
    call pl(1)%init (2)
    call pl(1)%set (1, 1)
    call pl(1)%set (2, -1)
    call pl(2)%init (2)
    call pl(2)%set (1, 21)
    call pl(2)%set (2, 21)
    do i = 1, 2
       call pl(i)%write (u);  write (u, *)
    end do

    write (u, *)
    write (u, "(A)")  "* Initialize FS table"
    write (u, *)
    
    call constraints%init (1)
    call constraints%set (1, constrain_n_tot (3))

    call fs_table%init (model, pl, constraints)
    call fs_table%write (u)
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, unconstrained"
    write (u, *)
    
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, &
         &complete but mass-constrained"
    write (u, *)
    
    sqrts = 50

    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (3))
    call constraints%set (2, constrain_mass_sum (sqrts))

    call fs_table%init (model, pl, constraints)
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, restricted"
    write (u, *)
    
    call pl_match%init ([1, -1, 21])
    
    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (3))
    call constraints%set (2, constrain_insert (pl_match))

    call fs_table%init (model, pl, constraints)
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NNLO corrections, restricted, with one loop"
    write (u, *)
    
    call pl_match%init ([1, -1, 21])
    
    call constraints%init (3)
    call constraints%set (1, constrain_n_tot (4))
    call constraints%set (2, constrain_n_loop (1))
    call constraints%set (3, constrain_insert (pl_match))

    call fs_table%init (model, pl, constraints)
    call fs_table%enable_loops ()
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NNLO corrections, restricted, with loops"
    write (u, *)
    
    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (4))
    call constraints%set (2, constrain_insert (pl_match))

    call fs_table%init (model, pl, constraints)
    call fs_table%enable_loops ()
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NNLO corrections, restricted, to Z Z H, &
         &no loops"
    write (u, *)
    
    allocate (pl_zzh (1))
    call pl_zzh(1)%init (3)
    call pl_zzh(1)%set (1, 23)
    call pl_zzh(1)%set (2, 23)
    call pl_zzh(1)%set (3, 25)

    call constraints%init (3)
    call constraints%set (1, constrain_n_tot (5))
    call constraints%set (2, constrain_mass_sum (500._default))
    call constraints%set (3, constrain_require (pl_zzh(1)))

    call fs_table%init (model, pl_zzh, constraints)
    call fs_table%radiate (constraints)
    call fs_table%write (u)
    call fs_table%final ()
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: auto_components_2"

  end subroutine auto_components_2

@ %def auto_components_2
@
\subsubsection{Generate radiation from initial and final state}
Given a process, add radiation (NLO and NNLO).  We provide a list
of particles that is allowed to occur in the generated final states.
<<Auto components: execute tests>>=
  call test (auto_components_3, "auto_components_3", &
       "generate NLO corrections, in and out", &
       u, results)
<<Auto components: tests>>=
  subroutine auto_components_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(pdg_list_t), dimension(:), allocatable :: pl_in, pl_out
    type(pdg_list_t) :: pl_match, pl_beam
    type(if_table_t) :: if_table
    type(split_constraints_t) :: constraints
    real(default) :: sqrts
    integer :: i

    write (u, "(A)")  "* Test output: auto_components_3"
    write (u, "(A)")  "*   Purpose: generate radiation (NLO)"
    write (u, *)

    call syntax_model_file_init ()
    call os_data_init (os_data)

    write (u, "(A)")  "* Read Standard Model"

    call model_list%read_model (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    write (u, *)
    write (u, "(A)")  "* LO initial state"
    write (u, *)
    
    allocate (pl_in (2))
    call pl_in(1)%init (2)
    call pl_in(1)%set (1, 1)
    call pl_in(1)%set (2, -1)
    call pl_in(2)%init (2)
    call pl_in(2)%set (1, -1)
    call pl_in(2)%set (2, 1)
    do i = 1, 2
       call pl_in(i)%write (u);  write (u, *)
    end do

    write (u, *)
    write (u, "(A)")  "* LO final state"
    write (u, *)
    
    allocate (pl_out (1))
    call pl_out(1)%init (1)
    call pl_out(1)%set (1, 23)
    call pl_out(1)%write (u);  write (u, *)

    write (u, *)
    write (u, "(A)")  "* Initialize FS table"
    write (u, *)
    
    call constraints%init (1)
    call constraints%set (1, constrain_n_tot (4))
    
    call if_table%init (model, pl_in, pl_out, constraints)
    call if_table%write (u)
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, unconstrained"
    write (u, *)
    
    call if_table%radiate (constraints)
    call if_table%write (u)
    call if_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, &
         &complete but mass-constrained"
    write (u, *)
    
    sqrts = 100
    call constraints%init (2)
    call constraints%set (1, constrain_n_tot (4))
    call constraints%set (2, constrain_mass_sum (sqrts))
    
    call if_table%init (model, pl_in, pl_out, constraints)
    call if_table%radiate (constraints)
    call if_table%write (u)
    call if_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, &
         &mass-constrained, restricted beams"
    write (u, *)
    
    call pl_beam%init (3)
    call pl_beam%set (1, 1)
    call pl_beam%set (2, -1)
    call pl_beam%set (3, 21)

    call constraints%init (3)
    call constraints%set (1, constrain_n_tot (4))
    call constraints%set (2, constrain_in_state (pl_beam))
    call constraints%set (3, constrain_mass_sum (sqrts))

    call if_table%init (model, pl_in, pl_out, constraints)
    call if_table%radiate (constraints)
    call if_table%write (u)
    call if_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NLO corrections, restricted"
    write (u, *)
    
    call pl_match%init ([1, -1, 21])
    
    call constraints%init (4)
    call constraints%set (1, constrain_n_tot (4))
    call constraints%set (2, constrain_in_state (pl_beam))
    call constraints%set (3, constrain_mass_sum (sqrts))
    call constraints%set (4, constrain_insert (pl_match)) 

    call if_table%init (model, pl_in, pl_out, constraints)
    call if_table%radiate (constraints)
    call if_table%write (u)
    call if_table%final ()
    
    write (u, *)
    write (u, "(A)")  "* Generate NNLO corrections, restricted, Z preserved, &
         &with loops"
    write (u, *)
    
    call constraints%init (5)
    call constraints%set (1, constrain_n_tot (5))
    call constraints%set (2, constrain_in_state (pl_beam))
    call constraints%set (3, constrain_mass_sum (sqrts))
    call constraints%set (4, constrain_insert (pl_match)) 
    call constraints%set (5, constrain_require (pl_out(1)))

    call if_table%init (model, pl_in, pl_out, constraints)
    call if_table%enable_loops ()
    call if_table%radiate (constraints)
    call if_table%write (u)
    call if_table%final ()
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: auto_components_3"

  end subroutine auto_components_3

@ %def auto_components_3
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------------------------------------------
\chapter{Structure Function Implementations}
\section{Photon radiation: ISR}

<<[[sf_isr.f90]]>>=
<<File header>>

module sf_isr
 
<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_12, FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use physics_defs, only: ELECTRON, PHOTON
  use lorentz
  use sm_physics, only: Li2
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use interactions
  use polarizations
  use sf_mappings
  use sf_aux
  use sf_base

<<Standard module head>>

<<SF isr: public>>

<<SF isr: parameters>>

<<SF isr: types>>

contains

<<SF isr: procedures>>

<<SF isr: tests>>

end module sf_isr
@ %def sf_isr
@ 
\subsection{Physics}
The ISR structure function is in the most crude approximation (LLA
without $\alpha$ corrections, i.e. $\epsilon^0$)
\begin{equation}
  f_0(x) = \epsilon (1-x)^{-1+\epsilon} \qquad\text{with}\qquad
  \epsilon = \frac{\alpha}{\pi}q_e^2\ln\frac{s}{m^2},
\end{equation}
where $m$ is the mass of the incoming (and outgoing) particle, which
is initially assumed on-shell.

Here, the form of $\epsilon$ results from the kinematical bounds for
the momentum squared of the outgoing particle, which in the limit
$m^2\ll s$ are given by
\begin{align}
  t_0 &= -2\bar xE(E+p) + m^2 \approx -\bar x s,
\\
  t_1 &= -2\bar xE(E-p) + m^2 \approx x m^2,
\end{align}
so the integration over the propagator $1/(t-m^2)$ yields
\begin{equation}
  \ln\frac{t_0-m^2}{t_1-m^2} = \ln\frac{s}{m^2}.
\end{equation}

In $f_0(x)$, there is an integrable singularity at $x=1$ which does
not spoil the integration, but would lead to an unbounded $f_{\rm
max}$.  Therefore, we map this singularity like
\begin{equation}\label{ISR-mapping}
  x = 1 - (1-x')^{1/\epsilon}
\end{equation}
such that
\begin{equation}
  \int dx\,f_0(x) = \int dx'
\end{equation}
The structure function has three parameters: $\alpha$, $m_{\rm in}$ of
the incoming particle and $s$, the hard scale.  Internally, we store
the exponent $\epsilon$ which is the relevant parameter.  (In
conventional notation, $\epsilon=\beta/2$.)  As defaults, we take the
actual values of $\alpha$ (which is probably $\alpha(s)$), the actual
mass $m_{\rm in}$ and the squared total c.m. energy $s$.

Including $\epsilon$, $\epsilon^2$, and $\epsilon^3$ corrections, the
successive approximation of the ISR structure function read
\begin{align}
  f_0(x) &= \epsilon(1-x)^{-1+\epsilon} \\
  f_1(x) &= g_1(\epsilon)\,f_0(x) - \frac{\epsilon}{2}(1+x) \\
\begin{split}
  f_2(x) &= g_2(\epsilon)\,f_0(x) - \frac{\epsilon}{2}(1+x) \\
  &\quad - \frac{\epsilon^2}{8}\left(
    \frac{1+3x^2}{1-x}\ln x + 4(1+x) \ln(1-x) + 5 + x \right) 
\end{split} \\
\begin{split}
  f_3(x) &= g_3(\epsilon)\,f_0(x) - \frac{\epsilon}{2}(1+x) \\
  &\quad - \frac{\epsilon^2}{8}\left(
    \frac{1+3x^2}{1-x}\ln x + 4(1+x) \ln(1-x) + 5 + x \right) \\
  &\quad - \frac{\epsilon^3}{48}\left( \vphantom{\frac{1}{1-x}}
    (1+x)\left[6\mathop{\rm Li_2}(x) + 12\ln^2(1-x) - 3\pi^2\right]\right.
     + 6(x+5)\ln(1-x) \\
  &\qquad\qquad + \frac{1}{1-x}\left[\frac32(1+8x+3x^2)\ln x
                               + 12(1+x^2)\ln x\ln(1-x) \right. \\
  &\qquad\qquad\qquad\qquad 
       \left.\left. - \frac12(1+7x^2)\ln^2x + \frac14(39-24x-15x^2)\right]
       \vphantom{\frac{1}{1-x}} \right)
\end{split}
\end{align}
where the successive approximations to the prefactor of the leading
singularity
\begin{equation}
  g(\epsilon) = \frac{\exp\left(\epsilon(-\gamma_E + \tfrac34)\right)}
              {\Gamma(1 + \epsilon)},
\end{equation}
are given by
\begin{align}
  g_0(\epsilon) &= 1 \\
  g_1(\epsilon) &= 1 + \frac34\epsilon \\
  g_2(\epsilon) &= 1 + \frac34\epsilon 
    + \frac{27 - 8\pi^2}{96}\epsilon^2 \\
  g_3(\epsilon) &= 1 + \frac34\epsilon 
    + \frac{27 - 8\pi^2}{96}\epsilon^2
    + \frac{27 - 24\pi^2 + 128 \zeta(3)}{384}\epsilon^3,
\end{align}
where, numerically
\begin{equation}
  \zeta(3) = 1.20205690315959428539973816151\ldots
\end{equation}
Although one could calculate the function $g(\epsilon)$ exactly,
truncating its Taylor expansion ensures the exact normalization of the
truncated structure function at each given order:
\begin{equation}
  \int_0^1 dx\,f_i(x) = 1 \qquad\text{for all $i$.}
\end{equation}

Effectively, the $O(\epsilon)$ correction reduces the low-$x$ tail of
the structure function by $50\%$ while increasing the coefficient of
the singularity by $O(\epsilon)$.  Relative to this, the
$O(\epsilon^2)$ correction slightly enhances $x>\frac12$ compared to
$x<\frac12$.  At $x=0$, $f_2(x)$ introduces a logarithmic singularity
which should be cut off at $x_0=O(e^{-1/\epsilon})$: for lower $x$ the
perturbative series breaks down.  The $f_3$ correction is slightly
positive for low $x$ values and negative near $x=1$, where the
$\mathop{\rm Li_2}$ piece slightly softens the singularity at $x=1$.

Instead of the definition for $\epsilon$ given above, it is customary
to include a universal nonlogarithmic piece:
\begin{equation}
  \epsilon = \frac{\alpha}{\pi}q_e^2\left(\ln\tfrac{s}{m^2} - 1\right)
\end{equation}


\subsection{Implementation}

In the concrete implementation, the zeroth order mapping
(\ref{ISR-mapping}) is implemented, and the Jacobian is equal to
$f_i(x)/f_0(x)$.  This can be written as
\begin{align}
  \frac{f_0(x)}{f_0(x)} &= 1 \\
  \frac{f_1(x)}{f_0(x)} &= 1 + \frac34\epsilon - \frac{1-x^2}{2(1-x')} \\
\begin{split}\label{ISR-f2}
  \frac{f_2(x)}{f_0(x)} &= 1 + \frac34\epsilon
    + \frac{27 - 8\pi^2}{96}\epsilon^2 
    - \frac{1-x^2}{2(1-x')} \\
  &\quad - \frac{(1+3x^2)\ln x 
    + (1-x)\left(4(1+x)\ln(1-x) + 5 + x\right)}{8(1-x')}\epsilon
\end{split}
\end{align}
%'
For $x=1$ (i.e., numerically indistinguishable from $1$), this reduces to
\begin{align}
  \frac{f_0(x)}{f_0(x)} &= 1 \\
  \frac{f_1(x)}{f_0(x)} &= 1 + \frac34\epsilon \\
  \frac{f_2(x)}{f_0(x)} &= 1 + \frac34\epsilon
    + \frac{27 - 8\pi^2}{96}\epsilon^2 
\end{align}
The last line in (\ref{ISR-f2}) is zero for
\begin{equation}
  x_{\rm min} = 0.00714053329734592839549879772019
\end{equation}
(Mathematica result), independent of $\epsilon$.  For $x$ values less
than this we ignore this correction because of the logarithmic
singularity which should in principle be resummed.


\subsection{The ISR data block}
<<SF isr: public>>=
  public :: isr_data_t
<<SF isr: types>>=
  type, extends (sf_data_t) :: isr_data_t
     private
     class(model_data_t), pointer :: model => null ()
     type(flavor_t), dimension(:), allocatable :: flv_in
     real(default) :: alpha = 0
     real(default) :: q_max = 0
     real(default) :: real_mass = 0
     real(default) :: mass = 0
     real(default) :: eps = 0
     real(default) :: log = 0
     logical :: recoil = .false.
     integer :: order = 3
     integer :: error = NONE
   contains
   <<SF isr: isr data: TBP>>  
  end type isr_data_t

@ %def isr_data_t
@ Error codes
<<SF isr: parameters>>=
  integer, parameter :: NONE = 0
  integer, parameter :: ZERO_MASS = 1
  integer, parameter :: Q_MAX_TOO_SMALL = 2
  integer, parameter :: EPS_TOO_LARGE = 3
  integer, parameter :: INVALID_ORDER = 4
  integer, parameter :: CHARGE_MIX = 5
  integer, parameter :: CHARGE_ZERO = 6
  integer, parameter :: MASS_MIX = 7
@ Generate flavor-dependent ISR data:
<<SF isr: isr data: TBP>>=
  procedure :: init => isr_data_init
<<SF isr: procedures>>=
  subroutine isr_data_init &
       (data, model, pdg_in, alpha, q_max, mass, order, recoil)
    class(isr_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    real(default), intent(in) :: alpha
    real(default), intent(in) :: q_max
    real(default), intent(in), optional :: mass
    integer, intent(in), optional :: order
    logical, intent(in), optional :: recoil
    integer :: i, n_flv
    real(default) :: charge
    data%model => model
    n_flv = pdg_array_get_length (pdg_in)
    allocate (data%flv_in (n_flv))
    do i = 1, n_flv
       call flavor_init (data%flv_in(i), pdg_array_get (pdg_in, i), model)
    end do
    data%alpha = alpha
    data%q_max = q_max
    if (present (order)) then
       call data%set_order (order)
    end if
    if (present (recoil)) then
       data%recoil = recoil
    end if
    data%real_mass = flavor_get_mass (data%flv_in(1))
    if (present (mass)) then
       if (mass > 0) then
          data%mass = mass
       else
          data%mass = data%real_mass
          if (any (flavor_get_mass (data%flv_in) /= data%mass)) then
             data%error = MASS_MIX;  return
          end if
       end if
    else
       data%mass = data%real_mass
       if (any (flavor_get_mass (data%flv_in) /= data%mass)) then
          data%error = MASS_MIX;  return
       end if
    end if
    if (data%mass == 0) then
       data%error = ZERO_MASS;  return
    else if (data%mass >= data%q_max) then
       data%error = Q_MAX_TOO_SMALL;  return
    end if
    data%log = log (1 + (data%q_max / data%mass)**2)
    charge = flavor_get_charge (data%flv_in(1))
    if (any (abs (flavor_get_charge (data%flv_in)) /= abs (charge))) then
       data%error = CHARGE_MIX;  return
    else if (charge == 0) then
       data%error = CHARGE_ZERO;  return
    end if
    data%eps = data%alpha / pi * charge ** 2 &
         * (2 * log (data%q_max / data%mass) - 1)
    if (data%eps > 1) then
       data%error = EPS_TOO_LARGE;  return
    end if
  end subroutine isr_data_init

@ %def isr_data_init
@ Explicitly set ISR order
<<SF isr: isr data: TBP>>=
  procedure :: set_order => isr_data_set_order
<<SF isr: procedures>>=
  elemental subroutine isr_data_set_order (data, order)
    class(isr_data_t), intent(inout) :: data
    integer, intent(in) :: order
    if (order < 0 .or. order > 3) then
       data%error = INVALID_ORDER
    else
       data%order = order
    end if
  end subroutine isr_data_set_order

@ %def isr_data_set_order
@ Handle error conditions.  Should always be done after
initialization, unless we are sure everything is ok.
<<SF isr: isr data: TBP>>=
  procedure :: check => isr_data_check
<<SF isr: procedures>>=
  subroutine isr_data_check (data)
    class(isr_data_t), intent(in) :: data
    select case (data%error)
    case (ZERO_MASS)
       call msg_fatal ("ISR: Particle mass is zero")
    case (Q_MAX_TOO_SMALL)
       call msg_fatal ("ISR: Particle mass exceeds Qmax")
    case (EPS_TOO_LARGE)
       call msg_fatal ("ISR: Expansion parameter too large, " // &
            "perturbative expansion breaks down")
    case (INVALID_ORDER)
       call msg_error ("ISR: LLA order invalid (valid values are 0,1,2,3)")
    case (MASS_MIX)
       call msg_fatal ("ISR: Incoming particle masses must be uniform")
    case (CHARGE_MIX)
       call msg_fatal ("ISR: Incoming particle charges must be uniform")
    case (CHARGE_ZERO)
       call msg_fatal ("ISR: Incoming particle must be charged")
    end select
  end subroutine isr_data_check

@ %def isr_data_check
@ Output
<<SF isr: isr data: TBP>>=
  procedure :: write => isr_data_write
<<SF isr: procedures>>=
  subroutine isr_data_write (data, unit, verbose) 
    class(isr_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "ISR data:"
    if (allocated (data%flv_in)) then
       write (u, "(3x,A)", advance="no") "  flavor =  "
       do i = 1, size (data%flv_in)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          call flavor_write (data%flv_in(i), u)
       end do
       write (u, *)    
       write (u, "(3x,A," // FMT_19 // ")") "  alpha  = ", data%alpha
       write (u, "(3x,A," // FMT_19 // ")") "  q_max  = ", data%q_max
       write (u, "(3x,A," // FMT_19 // ")") "  mass   = ", data%mass
       write (u, "(3x,A," // FMT_19 // ")") "  eps    = ", data%eps
       write (u, "(3x,A," // FMT_19 // ")") "  log    = ", data%log
       write (u, "(3x,A,I2)")      "  order  = ", data%order
       write (u, "(3x,A,L2)")      "  recoil = ", data%recoil
    else
       write (u, "(3x,A)") "[undefined]"       
    end if
  end subroutine isr_data_write

@ %def isr_data_write
@ For ISR, there is the option to generate transverse momentum is
generated. Hence, there can be up to three parameters, $x$, and two
angles. 
<<SF isr: isr data: TBP>>=
  procedure :: get_n_par => isr_data_get_n_par
<<SF isr: procedures>>=
  function isr_data_get_n_par (data) result (n)
    class(isr_data_t), intent(in) :: data
    integer :: n
    if (data%recoil) then
       n = 3
    else
       n = 1
    end if
  end function isr_data_get_n_par
  
@ %def isr_data_get_n_par
@ Return the outgoing particles PDG codes.  For ISR, these are
identical to the incoming particles.
<<SF isr: isr data: TBP>>=  
  procedure :: get_pdg_out => isr_data_get_pdg_out
<<SF isr: procedures>>=
  subroutine isr_data_get_pdg_out (data, pdg_out)
    class(isr_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    pdg_out(1) = flavor_get_pdg (data%flv_in)
  end subroutine isr_data_get_pdg_out
  
@ %def isr_data_get_pdg_out
@ Return the [[eps]] value.  We need it for an appropriate mapping of
structure-function parameters.
<<SF isr: isr data: TBP>>=
  procedure :: get_eps => isr_data_get_eps
<<SF isr: procedures>>=
  function isr_data_get_eps (data) result (eps)
    class(isr_data_t), intent(in) :: data
    real(default) :: eps
    eps = data%eps
  end function isr_data_get_eps

@ %def isr_data_get_eps
@ Allocate the interaction record.
<<SF isr: isr data: TBP>>=
  procedure :: allocate_sf_int => isr_data_allocate_sf_int
<<SF isr: procedures>>=
  subroutine isr_data_allocate_sf_int (data, sf_int)
    class(isr_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (isr_t :: sf_int)
  end subroutine isr_data_allocate_sf_int
  
@ %def isr_data_allocate_sf_int 
@ 
\subsection{The ISR object}
The [[isr_t]] data type is a $1\to 2$ interaction, i.e., we allow for
single-photon emission only (but use the multi-photon resummed
radiator function).  The particles are ordered as (incoming, photon,
outgoing).

There is no need to handle several flavors (and data blocks) in
parallel, since ISR is always applied immediately after beam
collision.  (ISR for partons is accounted for by the PDFs themselves.)
Polarization is carried through, i.e., we retain the polarization of
the incoming particle and treat the emitted photon as unpolarized.
Color is trivially carried through.  This implies that particles 1 and
3 should be locked together. For ISR we don't need the q variable.
<<SF isr: types>>=
  type, extends (sf_int_t) :: isr_t
     type(isr_data_t), pointer :: data => null ()
     real(default) :: x = 0
     real(default) :: xb= 0
   contains
   <<SF isr: isr: TBP>>
  end type isr_t 
  
@ %def isr_t
@ Type string: has to be here, but there is no string variable on which ISR
depends. Hence, a dummy routine.
<<SF isr: isr: TBP>>=
  procedure :: type_string => isr_type_string
<<SF isr: procedures>>=
  function isr_type_string (object) result (string)
    class(isr_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "ISR: e+ e- ISR spectrum" 
    else
       string = "ISR: [undefined]"
    end if
  end function isr_type_string
  
@ %def isr_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF isr: isr: TBP>>=
  procedure :: write => isr_write
<<SF isr: procedures>>=
  subroutine isr_write (object, unit, testflag)
    class(isr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
          write (u, "(3x,A," // FMT_17 // ")")  "xb=", object%xb
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "ISR data: [undefined]"
    end if
  end subroutine isr_write
    
@ %def isr_write
@
\subsection{Kinematics}
Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ were trivial. The ISR structure
function allows for a straightforward mapping of the unit interval.
So, to leading order, the structure function value is unity, but the
$x$ value is transformed.  Higher orders affect the function value.

The structure function implementation applies the above mapping to the
input (random) number [[r]] to generate the momentum fraction [[x]]
and the function value [[f]].  For numerical stability reasons, we
also output [[xb]], which is $\bar x=1-x$.

For the ISR structure function, the mapping Jacobian cancels the
structure function (to order zero).  We apply the cancellation
explicitly, therefore both the Jacobian [[f]] and the zeroth-order value
(see the [[apply]] method) are unity if mapping is turned on.  If
mapping is turned off, the Jacobian [[f]] includes the value of the
(zeroth-order) structure function, and strongly peaked.
<<SF isr: isr: TBP>>=
  procedure :: complete_kinematics => isr_complete_kinematics
<<SF isr: procedures>>=
  subroutine isr_complete_kinematics (sf_int, x, f, r, rb, map)
    class(isr_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: eps
    eps = sf_int%data%eps
    if (map) then
       call map_power_1 (sf_int%xb, f, rb(1), eps)
    else
       sf_int%xb = rb(1)
       if (rb(1) > 0) then
          f = 1
       else
          f = 0
       end if
    end if
    sf_int%x = 1 - sf_int%xb
    x(1) = sf_int%x
    if (size (x) == 3)  x(2:3) = r(2:3)
    call sf_int%split_momentum (x, sf_int%xb)
    select case (sf_int%status)
    case (SF_FAILED_KINEMATICS)
       sf_int%x = 0
       sf_int%xb= 0
       f = 0
    end select
  end subroutine isr_complete_kinematics

@ %def isr_complete_kinematics
@ Overriding the default method: we compute the [[x]] array from the
momentum configuration.  In the specific case of ISR, we also set the
internally stored $x$ and $\bar x$ values, so they can be used in the
following routine.

Note: the extraction of $\bar x$ is not numerically safe, but it can't
be as long as the base [[recover_x]] isn't.
<<SF isr: isr: TBP>>=
  procedure :: recover_x => sf_isr_recover_x
<<SF isr: procedures>>=
  subroutine sf_isr_recover_x (sf_int, x, x_free)
    class(isr_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(inout), optional :: x_free
    call sf_int%base_recover_x (x, x_free)
    sf_int%x  = x(1)
    sf_int%xb = 1 - x(1)
  end subroutine sf_isr_recover_x
  
@ %def sf_isr_recover_x
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.

For extracting $x$, we rely on the stored $\bar x$ value, since the
$x$ value in the argument is likely imprecise.  This means that either
[[complete_kinematics]] or [[recover_x]] must be called first, for the
current sampling point (but maybe another channel).
<<SF isr: isr: TBP>>=
  procedure :: inverse_kinematics => isr_inverse_kinematics
<<SF isr: procedures>>=
  subroutine isr_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(isr_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: eps
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    eps = sf_int%data%eps
    if (map) then
       call map_power_inverse_1 (sf_int%xb, f, rb(1), eps)
    else
       rb(1) = sf_int%xb
       if (rb(1) > 0) then
          f = 1
       else
          f = 0
       end if
    end if
    r(1) = 1 - rb(1)
    if (size(r) == 3) then
       r(2:3) = x(2:3)
       rb(2:3)= 1 - r(2:3)
    end if
    if (set_mom) then
       call sf_int%split_momentum (x, sf_int%xb)
       select case (sf_int%status)
       case (SF_FAILED_KINEMATICS)
          r = 0
          rb= 0
          f = 0
       end select
    end if
  end subroutine isr_inverse_kinematics

@ %def isr_inverse_kinematics
@
<<SF isr: isr: TBP>>=
  procedure :: init => isr_init
<<SF isr: procedures>>=
  subroutine isr_init (sf_int, data)
    class(isr_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    integer, dimension(3) :: hel_lock
    type(polarization_t) :: pol
    type(quantum_numbers_t), dimension(1) :: qn_fc, qn_hel
    type(flavor_t) :: flv_photon
    type(quantum_numbers_t) :: qn_photon, qn
    type(state_iterator_t) :: it_hel
    real(default) :: m2
    integer :: i
    mask = new_quantum_numbers_mask (.false., .false., &
         mask_h = [.false., .true., .false.])
    hel_lock = [3, 0, 1]
    select type (data)
    type is (isr_data_t)   
       m2 = data%mass**2
       call sf_int%base_init (mask, [m2], [0._default], [m2], &
            hel_lock = hel_lock)
       sf_int%data => data              
       call flavor_init (flv_photon, PHOTON, data%model)
       call quantum_numbers_init (qn_photon, flv_photon)
       do i = 1, size (data%flv_in)
          call polarization_init_generic (pol, data%flv_in(i))
          call quantum_numbers_init (qn_fc(1), &
               flv = data%flv_in(i), &
               col = color_from_flavor (data%flv_in(i), 1))
          call state_iterator_init (it_hel, pol%state)
          do while (state_iterator_is_valid (it_hel))
             qn_hel = state_iterator_get_quantum_numbers (it_hel)
             qn = qn_hel(1) .merge. qn_fc(1)
             call interaction_add_state &
                  (sf_int%interaction_t, [qn, qn_photon, qn])
             call state_iterator_advance (it_hel)
          end do
          call polarization_final (pol)
       end do
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
       sf_int%status = SF_INITIAL
    end select
  end subroutine isr_init
    
@ %def isr_init
@ 
\subsection{ISR application}
For ISR, we could in principle compute kinematics and function value
in a single step. In order to be able to reweight matrix elements
including structure functions we split kinematics and structure
function calculation. The structure function works on a single beam,
assuming that the input momentum has been set. 

For the structure-function evaluation, we rely on the fact that the
power mapping, which we apply in the kinematics method (if the [[map]]
flag is set), has a Jacobian which is just the inverse lowest-order
structure function.  With mapping active, the two should cancel
exactly.

After splitting momenta, we set the outgoing momenta on-shell.  We
choose to conserve momentum, so energy conservation may be violated.
<<SF isr: isr: TBP>>=
  procedure :: apply => isr_apply
<<SF isr: procedures>>=
  subroutine isr_apply (sf_int, scale)
    class(isr_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: f, finv, x, xb, eps, rb
    real(default) :: log_x, log_xb, x_2
    real(default), parameter :: &
         & xmin = 0.00714053329734592839549879772019_default
    real(default), parameter :: &
         & zeta3 = 1.20205690315959428539973816151_default
    real(default), parameter :: &
         & g1 = 3._default / 4._default, &
         & g2 = (27 - 8*pi**2) / 96._default, &
         & g3 = (27 - 24*pi**2 + 128*zeta3) / 384._default    
    associate (data => sf_int%data)
      eps = sf_int%data%eps
      x = sf_int%x
      xb = sf_int%xb
      call map_power_inverse_1 (xb, finv, rb, eps)
      if (finv > 0) then
         f = 1 / finv
      else
         f = 0
      end if   
      if (f > 0 .and. data%order > 0) then
         f = f * (1 + g1 * eps)
         x_2 = x*x
         if (rb>0)  f = f * (1 - (1-x_2) / (2 * rb))
         if (data%order > 1) then
            f = f * (1 + g2 * eps**2)
            if (rb>0 .and. xb>0 .and. x>xmin) then
               log_x  = log_prec (x, xb)
               log_xb = log_prec (xb, x)
               f = f * (1 - ((1+3*x_2)*log_x + xb * (4*(1+x)*log_xb + 5 + x)) &
                    / ( 8 * rb) * eps)
            end if
            if (data%order > 2) then
               f = f * (1 + g3 * eps**3)
               if (rb > 0 .and. xb > 0 .and. x > xmin) then
                  f = f * (1 - ((1+x) * xb &
                       * (6 * Li2(x) + 12 * log_xb**2 - 3 * pi**2) &
                       + 1.5_default * (1 + 8*x + 3*x_2) * log_x &
                       + 6 * (x+5) * xb * log_xb &
                       + 12 * (1+x_2) * log_x * log_xb &
                       - (1 + 7*x_2) * log_x**2 / 2 &
                       + (39 - 24*x - 15*x_2) / 4) &
                       / ( 48 * rb) * eps**2)
               end if
            end if
         end if
      end if
    end associate
    call interaction_set_matrix_element &
           (sf_int%interaction_t, cmplx (f, kind=default))    
    sf_int%status = SF_EVALUATED
  end subroutine isr_apply

@ %def isr_apply
@
\subsection{Unit tests}
<<SF isr: public>>=
  public :: sf_isr_test
<<SF isr: tests>>=
  subroutine sf_isr_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF isr: execute tests>>
  end subroutine sf_isr_test
  
@ %def sf_isr_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF isr: execute tests>>=
  call test (sf_isr_1, "sf_isr_1", &
       "structure function configuration", &
       u, results)
<<SF isr: tests>>=
  subroutine sf_isr_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_isr_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call model%init_qed_test ()
    pdg_in = ELECTRON

    allocate (isr_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    select type (data)
    type is (isr_data_t)
       call data%init (model, pdg_in, 1./137._default, 10._default, &
            0.000511_default, order = 3, recoil = .false.)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1
        
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_isr_1"

  end subroutine sf_isr_1

@ %def sf_isr_1
@
\subsubsection{Structure function without mapping}
Direct ISR evaluation.  This is the use case for a double-beam
structure function.  The parameter pair is mapped in the calling program.
<<SF isr: execute tests>>=
  call test (sf_isr_2, "sf_isr_2", &
       "no ISR mapping", &
       u, results)
<<SF isr: tests>>=
  subroutine sf_isr_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, f_isr
    
    write (u, "(A)")  "* Test output: sf_isr_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    pdg_in = ELECTRON
    call flavor_init (flv, ELECTRON, model)

    call reset_interaction_counter ()
    
    allocate (isr_data_t :: data)
    select type (data)
    type is (isr_data_t)
       call data%init (model, pdg_in, 1./137._default, 500._default, &
            0.000511_default, order = 3, recoil = .false.)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.9, no ISR mapping, &
         &collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.9_default
    rb = 1 - r
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    
    write (u, "(A)")
    write (u, "(A,9(1x," // FMT_12 // "))")  "x =", x
    write (u, "(A,9(1x," // FMT_12 // "))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Invert kinematics"
    write (u, "(A)")
    
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.) 
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb
    write (u, "(A,9(1x," // FMT_12 // "))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate ISR structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure-function value, default order"
    write (u, "(A)")

    f_isr = interaction_get_matrix_element (sf_int%interaction_t, 1)
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", f_isr
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", f_isr * f

    write (u, "(A)")
    write (u, "(A)")  "* Re-evaluate structure function, leading order"
    write (u, "(A)")
    
    select type (sf_int)
    type is (isr_t)
       sf_int%data%order = 0
    end select
    call sf_int%apply (scale = 100._default)
    f_isr = interaction_get_matrix_element (sf_int%interaction_t, 1)
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", f_isr
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", f_isr * f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_isr_2"

  end subroutine sf_isr_2

@ %def sf_isr_2
@
\subsubsection{Structure function with mapping}
Apply the optimal ISR mapping.  This is the use case for a single-beam
structure function.
<<SF isr: execute tests>>=
  call test (sf_isr_3, "sf_isr_3", &
       "ISR mapping", &
       u, results)
<<SF isr: tests>>=
  subroutine sf_isr_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, f_isr
    
    write (u, "(A)")  "* Test output: sf_isr_3"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()
    
    allocate (isr_data_t :: data)
    select type (data)
    type is (isr_data_t)
       call data%init (model, pdg_in, 1./137._default, 500._default, &
            0.000511_default, order = 3, recoil = .false.)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.7, with ISR mapping, &
         &collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.7_default
    rb = 1 - r
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb

    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    
    write (u, "(A)")
    write (u, "(A,9(1x," // FMT_12 // "))")  "x =", x
    write (u, "(A,9(1x," // FMT_12 // "))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Invert kinematics"
    write (u, "(A)")
    
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true.) 
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb
    write (u, "(A,9(1x," // FMT_12 // "))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate ISR structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure-function value, default order"
    write (u, "(A)")

    f_isr = interaction_get_matrix_element (sf_int%interaction_t, 1)
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", f_isr
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", f_isr * f

    write (u, "(A)")
    write (u, "(A)")  "* Re-evaluate structure function, leading order"
    write (u, "(A)")
    
    select type (sf_int)
    type is (isr_t)
       sf_int%data%order = 0
    end select
    call sf_int%apply (scale = 100._default)
    f_isr = interaction_get_matrix_element (sf_int%interaction_t, 1)
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", f_isr
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", f_isr * f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_isr_3"

  end subroutine sf_isr_3

@ %def sf_isr_3
@
\subsubsection{Non-collinear ISR splitting}
Construct and display a structure function object based on the ISR
structure function. We blank out numerical fluctuations for 32bit.
<<SF isr: execute tests>>=
  call test (sf_isr_4, "sf_isr_4", &
       "ISR non-collinear", &
       u, results)
<<SF isr: tests>>=
  subroutine sf_isr_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, f_isr
    character(len=80) :: buffer
    integer :: u_scratch, iostat
    
    write (u, "(A)")  "* Test output: sf_isr_4"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")

    allocate (isr_data_t :: data)
    select type (data)
    type is (isr_data_t)
       call data%init (model, pdg_in, 1./137._default, 500._default, &
            0.000511_default, order = 3, recoil = .true.)
    end select    
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
        
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.25, with ISR mapping, "
    write (u, "(A)")  "          non-coll., keeping energy"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = [0.5_default, 0.5_default, 0.25_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)
    
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true.)    
    
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate ISR structure function"
    write (u, "(A)")
    
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.) 
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)    
    call sf_int%apply (scale = 10._default)
    u_scratch = free_unit ()
    open (u_scratch, status="scratch", action = "readwrite")
    call sf_int%write (u_scratch, testflag = .true.)
    rewind (u_scratch)
    do 
       read (u_scratch, "(A)", iostat=iostat) buffer    
       if (iostat /= 0) exit
       if (buffer(1:27) == " P =   0.00000000E+00  9.57") then
          buffer = replace (buffer, 28, "XXXXXX")
       end if
       if (buffer(1:27) == " P =   0.00000000E+00 -9.57") then
          buffer = replace (buffer, 28, "XXXXXX")
       end if       
       write (u, "(A)") buffer
    end do
    close (u_scratch)
       
    write (u, "(A)")
    write (u, "(A)")  "* Structure-function value"
    write (u, "(A)")

    f_isr = interaction_get_matrix_element (sf_int%interaction_t, 1)
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", f_isr
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", f_isr * f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_isr_4"

  end subroutine sf_isr_4

@ %def sf_isr_4
@
\subsubsection{Structure function pair with mapping}
Apply the ISR mapping for a ISR pair.
structure function.
<<SF isr: execute tests>>=
  call test (sf_isr_5, "sf_isr_5", &
       "ISR pair mapping", &
       u, results)
<<SF isr: tests>>=
  subroutine sf_isr_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_mapping_t), allocatable :: mapping
    class(sf_int_t), dimension(:), allocatable :: sf_int
    type(vector4_t), dimension(2) :: k
    real(default) :: E, f_map
    real(default), dimension(:), allocatable :: p, pb, r, rb, x
    real(default), dimension(2) :: f, f_isr
    integer :: i
    
    write (u, "(A)")  "* Test output: sf_isr_5"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()
    
    allocate (isr_data_t :: data)
    select type (data)
    type is (isr_data_t)
       call data%init (model, pdg_in, 1./137._default, 500._default, &
            0.000511_default, order = 3, recoil = .false.)
    end select
       
    allocate (sf_ip_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ip_mapping_t)
       select type (data)
       type is (isr_data_t)
          call mapping%init (eps = data%eps)
       end select
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select

    call mapping%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")

    allocate (isr_t :: sf_int (2))

    do i = 1, 2
       call sf_int(i)%init (data)
       call sf_int(i)%set_beam_index ([i])
    end do

    write (u, "(A)")  "* Initialize incoming momenta with E=500"
    write (u, "(A)")
    E = 500
    k(1) = vector4_moving (E,   sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    k(2) = vector4_moving (E, - sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    do i = 1, 2
       call vector4_write (k(i), u)
       call sf_int(i)%seed_kinematics (k(i:i))
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for p=[0.7,0.4], collinear"
    write (u, "(A)")
    
    allocate (p (2 * data%get_n_par ()))
    allocate (pb(size (p)))
    allocate (r (size (p)))
    allocate (rb(size (p)))
    allocate (x (size (p)))
    
    p = [0.7_default, 0.4_default]
    pb= 1 - p
    call mapping%compute (r, rb, f_map, p, pb)

    write (u, "(A,9(1x," // FMT_12 // "))")  "p =", p
    write (u, "(A,9(1x," // FMT_12 // "))")  "pb=", pb
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb
    write (u, "(A,9(1x," // FMT_12 // "))")  "fm=", f_map

    do i = 1, 2
       call sf_int(i)%complete_kinematics (x(i:i), f(i), r(i:i), rb(i:i), &
            map=.false.)
    end do
    
    write (u, "(A)")
    write (u, "(A,9(1x," // FMT_12 // "))")  "x =", x
    write (u, "(A,9(1x," // FMT_12 // "))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Invert kinematics"
    write (u, "(A)")
    
    do i = 1, 2
       call sf_int(i)%inverse_kinematics (x(i:i), f(i), r(i:i), rb(i:i), &
            map=.false.) 
    end do
    call mapping%inverse (r, rb, f_map, p, pb)

    write (u, "(A,9(1x," // FMT_12 // "))")  "p =", p
    write (u, "(A,9(1x," // FMT_12 // "))")  "pb=", pb
    write (u, "(A,9(1x," // FMT_12 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_12 // "))")  "rb=", rb
    write (u, "(A,9(1x," // FMT_12 // "))")  "fm=", f_map

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate ISR structure function"
    
    call sf_int(1)%apply (scale = 100._default)
    call sf_int(2)%apply (scale = 100._default)

    write (u, "(A)")
    write (u, "(A)")  "* Structure function #1"
    write (u, "(A)")
    call sf_int(1)%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure function #2"
    write (u, "(A)")
    call sf_int(2)%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure-function value, default order"
    write (u, "(A)")

    do i = 1, 2
       f_isr(i) = interaction_get_matrix_element (sf_int(i)%interaction_t, 1)
    end do
    
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr         =", &
         product (f_isr)
    write (u, "(A,9(1x," // FMT_12 // "))")  "f_isr * f_map =", &
         product (f_isr * f) * f_map

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    do i = 1, 2
       call sf_int(i)%final ()
    end do
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_isr_5"

  end subroutine sf_isr_5

@ %def sf_isr_5
@
\clearpage
%------------------------------------------------------------------------
\section{EPA}

<<[[sf_epa.f90]]>>=
<<File header>>

module sf_epa

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use physics_defs, only: ELECTRON, PHOTON
  use lorentz
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  
<<Standard module head>>

<<SF epa: public>>

<<SF epa: parameters>>

<<SF epa: types>>

contains

<<SF epa: procedures>>

<<SF epa: tests>>

end module sf_epa
@ %def sf_epa
@
\subsection{Physics}
The EPA structure function for a photon inside an (elementary)
particle $p$ with energy $E$, mass $m$ and charge $q_p$ (e.g.,
electron) is given by ($\bar x \equiv 1-x$)
%% %\cite{Budnev:1974de}
%% \bibitem{Budnev:1974de}
%%   V.~M.~Budnev, I.~F.~Ginzburg, G.~V.~Meledin and V.~G.~Serbo,
%%   %``The Two photon particle production mechanism. Physical problems.
%%   %Applications. Equivalent photon approximation,''
%%   Phys.\ Rept.\  {\bf 15} (1974) 181.
%%   %%CITATION = PRPLC,15,181;%%
\begin{multline}
\label{EPA}
  f(x) = 
  \frac{\alpha}{\pi}\,q_p^2\,
  \frac{1}{x}\, 
  \biggl[\left(\bar x + \frac{x^2}{2}\right) 
        \ln\frac{Q^2_{\rm max}}{Q^2_{\rm min}} 
        \\
	- \left(1 - \frac{x}{2}\right)^2 
	  \ln\frac{x^2+\frac{Q^2_{\rm max}}{E^2}}
                  {x^2+\frac{Q^2_{\rm min}}{E^2}} 
        - x^2\frac{m^2}{Q^2_{\rm min}}
          \left(1 - \frac{Q^2_{\rm min}}{Q^2_{\rm max}}\right) 
  \biggr].
\end{multline}
If no explicit $Q$ bounds are provided, the kinematical bounds are
\begin{align}
  -Q^2_{\rm max} &= t_0 = -2\bar x(E^2+p\bar p) + 2m^2 \approx -4\bar x E^2,
\\
  -Q^2_{\rm min} &= t_1 = -2\bar x(E^2-p\bar p) + 2m^2 
  \approx
  -\frac{x^2}{\bar x}m^2.
\end{align}

The second and third terms in (\ref{EPA}) are negative definite (and
subleading).  Noting that $\bar x + x^2/2$ is bounded between
$1/2$ and $1$, we derive that $f(x)$ is always smaller than
\begin{equation}
  \bar f(x) = \frac{\alpha}{\pi}\,q_p^2\,\frac{L - 2\ln x}{x}
  \qquad\text{where}\qquad 
  L = \ln\frac{\min(4E_{\rm max}^2,Q^2_{\rm max})}{\max(m^2,Q_{\rm min}^2)},
\end{equation}
where we allow for explicit $Q$ bounds that narrow the kinematical range.
Therefore, we generate this distribution:
\begin{equation}\label{EPA-subst}
  \int_{x_0}^{x_1} dx\,\bar f(x) = C(x_0,x_1)\int_0^1 dx'
\end{equation}
We set
\begin{equation}\label{EPA-x(x')}
  \ln x = \frac12\left\{ L - \sqrt{L^2 - 4\left[ x'\ln x_1(L-\ln x_1)
	+ \bar x'\ln x_0(L-\ln x_0) \right]} \right\}
\end{equation}
such that $x(0)=x_0$ and $x(1)=x_1$ and
\begin{equation}
  \frac{dx}{dx'} = \left(\frac{\alpha}{\pi} q_p^2 \right)^{-1}
	x\frac{C(x_0,x_1)}{L - 2\ln x}
\end{equation}
with
\begin{equation}
  C(x_0,x_1) = \frac{\alpha}{\pi} q_p^2\,\left[\ln x_1(L-\ln x_1) - \ln
	x_0(L-\ln x_0)\right]
\end{equation}
such that (\ref{EPA-subst}) is satisfied.  Finally, we have
\begin{equation}
  \int_{x_0}^{x_1} dx\,f(x) = C(x_0,x_1)\int_0^1 dx'\,
	\frac{f(x(x'))}{\bar f(x(x'))}
\end{equation}
where $x'$ is calculated from $x$ via (\ref{EPA-x(x')}). 

The structure of the mapping is most obvious from:
\begin{equation}
  x'(x) = \frac{\log x ( L - \log x) - \log x_0 (L - \log x_0)}
  {\log x_1 ( L - \log x_1) - \log x_0 (L - \log x_0)} \; .
\end{equation}



\subsection{The EPA data block}
The EPA parameters are: $\alpha$, $E_{\rm max}$, $m$, $Q_{\rm min}$, and
$x_{\rm min}$.  Instead of $m$ we can use the incoming particle PDG
code as input; from this we can deduce the mass and charge.

Internally we store in addition $C_{0/1} = \frac{\alpha}{\pi}q_e^2\ln
x_{0/1} (L - \ln x_{0/1})$, the c.m. energy squared and the incoming
particle mass.
<<SF epa: public>>=
  public :: epa_data_t
<<SF epa: types>>=
  type, extends(sf_data_t) :: epa_data_t
     private
     class(model_data_t), pointer :: model => null ()
     type(flavor_t), dimension(:), allocatable :: flv_in
     real(default) :: alpha
     real(default) :: x_min
     real(default) :: x_max
     real(default) :: q_min
     real(default) :: q_max
     real(default) :: E_max
     real(default) :: mass
     real(default) :: log
     real(default) :: a
     real(default) :: c0
     real(default) :: c1
     real(default) :: dc
     integer :: error = NONE
     logical :: recoil = .false.
   contains
   <<SF epa: epa data: TBP>>  
  end type epa_data_t

@ %def epa_data_t
@ Error codes
<<SF epa: parameters>>=
  integer, parameter :: NONE = 0
  integer, parameter :: ZERO_QMIN = 1
  integer, parameter :: Q_MAX_TOO_SMALL = 2
  integer, parameter :: ZERO_XMIN = 3
  integer, parameter :: MASS_MIX = 4
  integer, parameter :: NO_EPA = 5
<<SF epa: epa data: TBP>>=
  procedure :: init => epa_data_init
<<SF epa: procedures>>=
  subroutine epa_data_init &
       (data, model, pdg_in, alpha, x_min, q_min, E_max, mass, recoil)
    class(epa_data_t), intent(inout) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    real(default), intent(in) :: alpha, x_min, q_min, E_max
    real(default), intent(in), optional :: mass
    logical, intent(in), optional :: recoil
    integer :: n_flv, i
    data%model => model
    n_flv = pdg_array_get_length (pdg_in)
    allocate (data%flv_in (n_flv))
    do i = 1, n_flv
       call flavor_init (data%flv_in(i), pdg_array_get (pdg_in, i), model)
    end do
    data%alpha = alpha
    data%E_max = E_max
    data%x_min = x_min
    data%x_max = 1
    if (data%x_min == 0) then
       data%error = ZERO_XMIN;  return
    end if
    data%q_min = q_min
    data%q_max = 2 * data%E_max
    select case (char (data%model%get_name ()))
    case ("QCD","Test")
       data%error = NO_EPA;  return
    end select     
    if (present (recoil)) then
       data%recoil = recoil
    end if
    if (present (mass)) then
       data%mass = mass
    else
       data%mass = flavor_get_mass (data%flv_in(1))
       if (any (flavor_get_mass (data%flv_in) /= data%mass)) then
          data%error = MASS_MIX;  return
       end if 
    end if
    if (max (data%mass, data%q_min) == 0) then
       data%error = ZERO_QMIN;  return
    else if (max (data%mass, data%q_min) >= data%E_max) then
       data%error = Q_MAX_TOO_SMALL;  return
    end if
    data%log = log (4 * (data%E_max / max (data%mass, data%q_min)) ** 2 )
    data%a  = data%alpha / pi
    data%c0 = log (data%x_min) * (data%log - log (data%x_min))
    data%c1 = log (data%x_max) * (data%log - log (data%x_max))
    data%dc = data%c1 - data%c0
  end subroutine epa_data_init

@ %def epa_data_init
@ Handle error conditions.  Should always be done after
initialization, unless we are sure everything is ok.
<<SF epa: epa data: TBP>>=
  procedure :: check => epa_data_check
<<SF epa: procedures>>=
  subroutine epa_data_check (data)
    class(epa_data_t), intent(in) :: data
    select case (data%error)
    case (NO_EPA)
       call msg_fatal ("EPA structure function not available for model " &
            // char (data%model%get_name ()) // ".")
    case (ZERO_QMIN)
       call msg_fatal ("EPA: Particle mass is zero")
    case (Q_MAX_TOO_SMALL)
       call msg_fatal ("EPA: Particle mass exceeds Qmax")
    case (ZERO_XMIN)
       call msg_fatal ("EPA: x_min must be larger than zero")
    case (MASS_MIX)
       call msg_fatal ("EPA: incoming particle masses must be uniform")
    end select
  end subroutine epa_data_check

@ %def epa_data_check
@ Output
<<SF epa: epa data: TBP>>=
  procedure :: write => epa_data_write
<<SF epa: procedures>>=
  subroutine epa_data_write (data, unit, verbose) 
    class(epa_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "EPA data:"
    if (allocated (data%flv_in)) then
       write (u, "(3x,A)", advance="no") "  flavor =  "
       do i = 1, size (data%flv_in)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          call flavor_write (data%flv_in(i), u)
       end do
       write (u, *)
       write (u, "(3x,A," // FMT_19 // ")") "  alpha  = ", data%alpha
       write (u, "(3x,A," // FMT_19 // ")") "  x_min  = ", data%x_min
       write (u, "(3x,A," // FMT_19 // ")") "  x_max  = ", data%x_max
       write (u, "(3x,A," // FMT_19 // ")") "  q_min  = ", data%q_min
       write (u, "(3x,A," // FMT_19 // ")") "  q_max  = ", data%q_max
       write (u, "(3x,A," // FMT_19 // ")") "  E_max  = ", data%e_max
       write (u, "(3x,A," // FMT_19 // ")") "  mass   = ", data%mass
       write (u, "(3x,A," // FMT_19 // ")") "  a      = ", data%a
       write (u, "(3x,A," // FMT_19 // ")") "  c0     = ", data%c0
       write (u, "(3x,A," // FMT_19 // ")") "  c1     = ", data%c1
       write (u, "(3x,A," // FMT_19 // ")") "  log    = ", data%log
       write (u, "(3x,A,L2)")      "  recoil = ", data%recoil
    else
       write (u, "(3x,A)") "[undefined]"
    end if
  end subroutine epa_data_write

@ %def epa_data_write
@ The number of kinematic parameters.
<<SF epa: epa data: TBP>>=
  procedure :: get_n_par => epa_data_get_n_par
<<SF epa: procedures>>=
  function epa_data_get_n_par (data) result (n)
    class(epa_data_t), intent(in) :: data
    integer :: n
    if (data%recoil) then
       n = 3
    else
       n = 1
    end if
  end function epa_data_get_n_par
  
@ %def epa_data_get_n_par
@ Return the outgoing particles PDG codes. The outgoing particle is always
the photon while the radiated particle is identical to the incoming one.
<<SF epa: epa data: TBP>>=  
  procedure :: get_pdg_out => epa_data_get_pdg_out
<<SF epa: procedures>>=
  subroutine epa_data_get_pdg_out (data, pdg_out)
    class(epa_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    pdg_out(1) = PHOTON
  end subroutine epa_data_get_pdg_out
  
@ %def epa_data_get_pdg_out
@ Allocate the interaction record.
<<SF epa: epa data: TBP>>=
  procedure :: allocate_sf_int => epa_data_allocate_sf_int
<<SF epa: procedures>>=
  subroutine epa_data_allocate_sf_int (data, sf_int)
    class(epa_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (epa_t :: sf_int)
  end subroutine epa_data_allocate_sf_int
  
@ %def epa_data_allocate_sf_int 
@ 
\subsection{The EPA object}
The [[epa_t]] data type is a $1\to 2$ interaction.  We should be able
to handle several flavors in parallel, since EPA is not necessarily
applied immediately after beam collision:  Photons may be radiated
from quarks.  In that case, the partons are massless and $q_{\rm min}$
applies instead, so we do not need to generate several kinematical
configurations in parallel.

The squared charge values multiply the matrix elements, depending on the
flavour.  We scan the interaction after building it, so we have the correct
assignments.

The particles are ordered as (incoming, radiated, photon), where the
photon initiates the hard interaction.

We generate an unpolarized photon and transfer initial polarization to
the radiated parton.  Color is transferred in the same way.
<<SF epa: types>>=
  type, extends (sf_int_t) :: epa_t
     type(epa_data_t), pointer :: data => null ()
     real(default) :: x  = 0
     real(default) :: xb = 0
     real(default) :: E  = 0     
     real(default), dimension(:), allocatable :: charge2
   contains
   <<SF epa: epa: TBP>>
  end type epa_t 
  
@ %def epa_t
@ Type string: has to be here, but there is no string variable on which EPA
depends. Hence, a dummy routine.
<<SF epa: epa: TBP>>=
  procedure :: type_string => epa_type_string
<<SF epa: procedures>>=
  function epa_type_string (object) result (string)
    class(epa_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "EPA: equivalent photon approx." 
    else
       string = "EPA: [undefined]"
    end if
  end function epa_type_string
  
@ %def epa_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF epa: epa: TBP>>=
  procedure :: write => epa_write
<<SF epa: procedures>>=
  subroutine epa_write (object, unit, testflag)
    class(epa_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
          if (object%status >= SF_FAILED_EVALUATION) then
             write (u, "(3x,A," // FMT_17 // ")")  "E =", object%E
          end if          
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "EPA data: [undefined]"
    end if
  end subroutine epa_write
    
@ %def epa_write
@ Prepare the interaction object.  We have to construct transition matrix
elements for all flavor and helicity combinations.
<<SF epa: epa: TBP>>=
  procedure :: init => epa_init
<<SF epa: procedures>>=
  subroutine epa_init (sf_int, data)
    class(epa_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    integer, dimension(3) :: hel_lock
    type(polarization_t) :: pol
    type(quantum_numbers_t), dimension(1) :: qn_fc, qn_hel
    type(flavor_t) :: flv_photon
    type(quantum_numbers_t) :: qn_photon, qn
    type(state_iterator_t) :: it_hel
    integer :: i
    mask = new_quantum_numbers_mask (.false., .false., &
         mask_h = [.false., .false., .true.])
    hel_lock = [2, 1, 0]
    select type (data)
    type is (epa_data_t)
       call sf_int%base_init (mask, [data%mass**2], &
            [data%mass**2], [0._default], hel_lock = hel_lock)       
       sf_int%data => data
       call flavor_init (flv_photon, PHOTON, data%model)
       call quantum_numbers_init (qn_photon, flv_photon)
       do i = 1, size (data%flv_in)
          call polarization_init_generic (pol, data%flv_in(i))
          call quantum_numbers_init (qn_fc(1), &
               flv = data%flv_in(i), &
               col = color_from_flavor (data%flv_in(i), 1))
          call state_iterator_init (it_hel, pol%state)
          do while (state_iterator_is_valid (it_hel))
             qn_hel = state_iterator_get_quantum_numbers (it_hel)
             qn = qn_hel(1) .merge. qn_fc(1)
             call interaction_add_state (sf_int%interaction_t, &
                  [qn, qn, qn_photon])
             call state_iterator_advance (it_hel)
          end do
          call polarization_final (pol)
       end do
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
    end select
  end subroutine epa_init
    
@ %def epa_init
@ Prepare the charge array.  This is separate from the previous routine since
the state matrix may be helicity-contracted.
<<SF epa: epa: TBP>>=
  procedure :: setup_constants => epa_setup_constants
<<SF epa: procedures>>=
  subroutine epa_setup_constants (sf_int)
    class(epa_t), intent(inout) :: sf_int
    type(state_iterator_t) :: it
    integer :: i, n_me
    n_me = interaction_get_n_matrix_elements (sf_int%interaction_t)
    allocate (sf_int%charge2 (n_me))
    call state_iterator_init (it, &
         interaction_get_state_matrix_ptr (sf_int%interaction_t))
    do while (state_iterator_is_valid (it))
       i = state_iterator_get_me_index (it)
       sf_int%charge2(i) = &
            flavor_get_charge (state_iterator_get_flavor (it, 1)) ** 2
       call state_iterator_advance (it)
    end do
    sf_int%status = SF_INITIAL
  end subroutine epa_setup_constants
  
@ %def epa_setup_constants
@
\subsection{Kinematics}
Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

The EPA structure function allows for a straightforward mapping of the
unit interval. The $x$ value is transformed, and the mapped structure
function becomes unity at its upper boundary. 

The structure function implementation applies the above mapping to the
input (random) number [[r]] to generate the momentum fraction [[x]]
and the function value [[f]].  For numerical stability reasons, we
also output [[xb]], which is $\bar x=1-x$. 
<<SF epa: epa: TBP>>=
  procedure :: complete_kinematics => epa_complete_kinematics
<<SF epa: procedures>>=
  subroutine epa_complete_kinematics (sf_int, x, f, r, rb, map)
    class(epa_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1
    real(default) :: delta, sqrt_delta, lx
    if (map) then                                   
       associate (data => sf_int%data)
         delta = data%log ** 2 -  4 * (r(1) * data%c1 + rb(1) * data%c0)
         if (delta > 0) then
            sqrt_delta = sqrt (delta)
            lx = (data%log - sqrt_delta) / 2
         else
            sf_int%status = SF_FAILED_KINEMATICS          
            f = 0
            return
         end if
         x(1) = exp (lx)
         f = x(1) * data%dc / sqrt_delta
       end associate
    else
       x(1) = r(1)
       if (sf_int%data%x_min < x(1) .and. x(1) < sf_int%data%x_max) then
          f = 1
       else
          sf_int%status = SF_FAILED_KINEMATICS
          f = 0
          return
       end if       
    end if       
    xb1 = 1 - x(1)
    if (size(x) == 3)  x(2:3) = r(2:3)
    call sf_int%split_momentum (x, xb1) 
    select case (sf_int%status)
    case (SF_DONE_KINEMATICS)
       sf_int%x = x(1)
       sf_int%xb= xb1
       sf_int%E  = &
            energy (interaction_get_momentum (sf_int%interaction_t, 1))
    case (SF_FAILED_KINEMATICS)
       sf_int%x = 0
       sf_int%xb= 0
       f = 0
    end select
  end subroutine epa_complete_kinematics

@ %def epa_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF epa: epa: TBP>>=
  procedure :: inverse_kinematics => epa_inverse_kinematics
<<SF epa: procedures>>=
  subroutine epa_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(epa_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: lx, delta, sqrt_delta, c
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       associate (data => sf_int%data)
         lx = log (x(1))
         sqrt_delta = data%log - 2 * lx
         delta = sqrt_delta ** 2
         c = (data%log ** 2 - delta) / 4
         r (1) = (c - data%c0) / data%dc
         rb(1) = (data%c1 - c) / data%dc
         f = x(1) * data%dc / sqrt_delta
       end associate
    else
       r (1) = x(1)
       rb(1) = 1 - x(1)
       if (sf_int%data%x_min < x(1) .and. x(1) < sf_int%data%x_max) then
          f = 1
       else
          f = 0
       end if
    end if
    if (size(r) == 3) then
       r (2:3) = x(2:3)
       rb(2:3) = 1 - x(2:3)
    end if
    if (set_mom) then
       call sf_int%split_momentum (x, sf_int%xb)
       select case (sf_int%status)
       case (SF_DONE_KINEMATICS)
          sf_int%x  = x(1)
          sf_int%xb = 1 - x(1)
          sf_int%E  = &
               energy (interaction_get_momentum (sf_int%interaction_t, 1))
       case (SF_FAILED_KINEMATICS)
          sf_int%x = 0
          f = 0
       end select
    end if
  end subroutine epa_inverse_kinematics

@ %def epa_inverse_kinematics
@ Overriding the default method: we compute the [[x]] array from the
momentum configuration.  In the specific case of EPA, we also set the
internally stored $x$ and $\bar x$ values, so they can be used in the
following routine.

Note: the extraction of $\bar x$ is not numerically safe, but it can't
be as long as the base [[recover_x]] isn't.
<<SF epa: epa: TBP>>=
  procedure :: recover_x => sf_epa_recover_x
<<SF epa: procedures>>=
  subroutine sf_epa_recover_x (sf_int, x, x_free)
    class(epa_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(inout), optional :: x_free
    call sf_int%base_recover_x (x, x_free)
    sf_int%x  = x(1)
    sf_int%xb = 1 - x(1)
  end subroutine sf_epa_recover_x
  
@ %def sf_epa_recover_x
@
\subsection{EPA application}
For EPA, we can in principle compute kinematics and function value in
a single step. In order to be able to reweight events, kinematics and
structure function application are separated. This function works on a
single beam, assuming that the input momentum has been set.  We need
three random numbers as input: one for $x$, and two for the polar and
azimuthal angles. Alternatively, for the no-recoil case, we can skip
$p_T$ generation; in this case, we only need one.

For obtaining splitting kinematics, we rely on the assumption that all
in-particles are mass-degenerate (or there is only one), so the
generated $x$ values are identical.
<<SF epa: epa: TBP>>=
  procedure :: apply => epa_apply
<<SF epa: procedures>>=
  subroutine epa_apply (sf_int, scale)
    class(epa_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: x, xb, qminsq, qmaxsq, f, E
    associate (data => sf_int%data)
      x = sf_int%x
      xb= sf_int%xb
      E = sf_int%E
      qminsq = max (x ** 2 / xb * data%mass ** 2, data%q_min ** 2)
      qmaxsq = min (4 * xb * E ** 2, data%q_max ** 2)
      if (qminsq < qmaxsq) then
         f = data%a / x &
              * ((xb + x ** 2 / 2) * log (qmaxsq / qminsq) &
              - (1 - x / 2) ** 2 &
              * log ((x**2 + qmaxsq / E ** 2) / (x**2 + qminsq / E ** 2)) &
              - x ** 2 * data%mass ** 2 / qminsq * (1 - qminsq / qmaxsq))
      else
         f = 0
      end if
      call interaction_set_matrix_element &
           (sf_int%interaction_t, cmplx (f, kind=default) * sf_int%charge2)
    end associate
    sf_int%status = SF_EVALUATED
  end subroutine epa_apply

@ %def epa_apply
@
\subsection{Unit tests}
<<SF epa: public>>=
  public :: sf_epa_test
<<SF epa: tests>>=
  subroutine sf_epa_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF epa: execute tests>>
  end subroutine sf_epa_test
  
@ %def sf_epa_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF epa: execute tests>>=
  call test (sf_epa_1, "sf_epa_1", &
       "structure function configuration", &
       u, results)
<<SF epa: tests>>=
  subroutine sf_epa_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_epa_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call model%init_qed_test ()
    pdg_in = ELECTRON

    allocate (epa_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    select type (data)
    type is (epa_data_t)
       call data%init (model, pdg_in, 1./137._default, 0.01_default, &
            10._default, 50._default, 0.000511_default, recoil = .false.)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1
        
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_epa_1"

  end subroutine sf_epa_1

@ %def sf_epa_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the EPA
structure function.
<<SF epa: execute tests>>=
  call test (sf_epa_2, "sf_epa_2", &
       "structure function instance", &
       u, results)
<<SF epa: tests>>=
  subroutine sf_epa_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_epa_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()
    
    allocate (epa_data_t :: data)
    select type (data)
    type is (epa_data_t)
       call data%init (model, pdg_in, 1./137._default, 0.01_default, &
            10._default, 50._default, 0.000511_default, recoil = .false.)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, no EPA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false., &
         set_momenta=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EPA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_epa_2"

  end subroutine sf_epa_2

@ %def sf_epa_2
@
\subsubsection{Standard mapping}
Construct and display a structure function object based on the EPA
structure function, applying the standard single-particle mapping.
<<SF epa: execute tests>>=
  call test (sf_epa_3, "sf_epa_3", &
       "apply mapping", &
       u, results)
<<SF epa: tests>>=
  subroutine sf_epa_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_epa_3"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()
    
    allocate (epa_data_t :: data)
    select type (data)
    type is (epa_data_t)
       call data%init (model, pdg_in, 1./137._default, 0.01_default, &
            10._default, 50._default, 0.000511_default, recoil = .false.)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, with EPA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true., &
         set_momenta=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EPA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_epa_3"

  end subroutine sf_epa_3

@ %def sf_epa_3
@
\subsubsection{Non-collinear case}
Construct and display a structure function object based on the EPA
structure function.
<<SF epa: execute tests>>=
  call test (sf_epa_4, "sf_epa_4", &
       "non-collinear", &
       u, results)
<<SF epa: tests>>=
  subroutine sf_epa_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E, m
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_epa_4"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv, ELECTRON, model)
    pdg_in = ELECTRON

    call reset_interaction_counter ()

    allocate (epa_data_t :: data)
    select type (data)
    type is (epa_data_t)
       call data%init (model, pdg_in, 1./137._default, 0.01_default, &
            10._default, 50._default, 5.0_default, recoil = .true.)
    end select    

    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
        
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()

    write (u, "(A)")  "* Initialize incoming momentum with E=500, me = 5 GeV"
    write (u, "(A)")
    E = 500
    m = 5
    k = vector4_moving (E, sqrt (E**2 - m**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
        
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.5/0.5/0.25, with EPA mapping, "
    write (u, "(A)")  "          non-coll., keeping energy, me = 5 GeV"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = [0.5_default, 0.5_default, 0.25_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY    
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)

    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true., &
         set_momenta=.true.)    
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)    
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EPA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u, testflag = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_epa_4"

  end subroutine sf_epa_4

@ %def sf_epa_4
@
\subsubsection{Structure function for multiple flavors}
Construct and display a structure function object based on the EPA
structure function.  The incoming state has multiple particles with
non-uniform charge.
<<SF epa: execute tests>>=
  call test (sf_epa_5, "sf_epa_5", &
       "multiple flavors", &
       u, results)
<<SF epa: tests>>=
  subroutine sf_epa_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_epa_5"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_sm_test ()
    call flavor_init (flv, 1, model)
    pdg_in = [1, 2, -1, -2]

    call reset_interaction_counter ()
    
    allocate (epa_data_t :: data)
    select type (data)
    type is (epa_data_t)
       call data%init (model, pdg_in, 1./137._default, 0.01_default, &
            10._default, 50._default, 0.000511_default, recoil = .false.)
       call data%check ()
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, no EPA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EPA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_epa_5"

  end subroutine sf_epa_5

@ %def sf_epa_5
@
\clearpage
%------------------------------------------------------------------------
\section{EWA}

<<[[sf_ewa.f90]]>>=
<<File header>>

module sf_ewa

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use physics_defs, only: W_BOSON, Z_BOSON
  use lorentz
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base

<<Standard module head>>

<<SF ewa: public>>

<<SF ewa: parameters>>

<<SF ewa: types>>

contains

<<SF ewa: procedures>>

<<SF ewa: tests>>

end module sf_ewa
@ %def sf_ewa
@
\subsection{Physics}
The EWA structure function for a $Z$ or $W$ inside a fermion (lepton
or quark) depends on the vector-boson polarization.  We distinguish
transversal ($\pm$) and longitudinal ($0$) polarization.
\begin{align}
  F_{+}(x) &= \frac{1}{16\pi^2}\,\frac{(v-a)^2 + (v+a)^2\bar x^2}{x}
  \left[
  \ln\left(\frac{p_{\perp,\textrm{max}}^2 + \bar x M^2}{\bar x M^2}\right)
  -
  \frac{p_{\perp,\textrm{max}}^2}{p_{\perp,\textrm{max}}^2 + \bar x M^2}
  \right]
  \\
  F_{-}(x) &= \frac{1}{16\pi^2}\,\frac{(v+a)^2 + (v-a)^2\bar x^2}{x}
  \left[
  \ln\left(\frac{p_{\perp,\textrm{max}}^2 + \bar x M^2}{\bar x M^2}\right)
  -
  \frac{p_{\perp,\textrm{max}}^2}{p_{\perp,\textrm{max}}^2 + \bar x M^2}
  \right]
  \\
  F_0(x) &= \frac{v^2+a^2}{8\pi^2}\,\frac{2\bar x}{x}\,
  \frac{p_{\perp,\textrm{max}}^2}{p_{\perp,\textrm{max}}^2 + \bar x M^2}
\end{align}
where $p_{\perp,\textrm{max}}$ is the cutoff in transversal momentum, $M$ is
the vector-boson mass, $v$ and $a$ are the vector and axial-vector
couplings, and $\bar x\equiv 1-x$.  Note that the longitudinal
structure function is finite for large cutoff, while the transversal
structure function is logarithmically divergent.

The maximal transverse momentum is given by the kinematical limit, it is
\begin{equation}
p_{\perp,\textrm{max}} = \bar x \sqrt{s}/2.
\end{equation}
The vector and axial couplings for a fermion branching into a $W$ are
\begin{align}
  v_W &= \frac{g}{2\sqrt 2},
& a_W &= \frac{g}{2\sqrt 2}.
\end{align}
For $Z$ emission, this is replaced by
\begin{align}
  v_Z &= \frac{g}{2\cos\theta_w}\left(t_3 - 2q\sin^2\theta_w\right),
& a_Z &= \frac{g}{2\cos\theta_w}t_3,
\end{align}
where $t_3=\pm\frac12$ is the fermion isospin, and $q$ its charge.

For an initial antifermion, the signs of the axial couplings are
inverted.  Note that a common sign change of $v$ and $a$ is
irrelevant.

%% Differentiating with respect to the cutoff, we get structure functions
%% \begin{align}
%%   f_{W,\pm}(x,p_T) &= \frac{g^2}{16\pi^2}\,
%%   \frac{1+\bar x^2}{x}
%%   \frac{p_\perp}{p_\perp^2 + \bar x M^2}
%%   \\
%%   f_{W,0}(x,p_T) &= \frac{g^2}{16\pi^2}\,
%%   \frac{2\bar x}{x}\,
%%   \frac{p_\perp \bar xM^2}{(p_\perp^2 + \bar x M^2)^2}
%%   \\
%%   F_{Z,\pm}(x,p_T) &= \frac{g^2}{16\pi^2\cos\theta_w^2}
%%   \left[(t_3^f-2q^2\sin\theta_w^2)^2 + (t_3^f)^2\right]\,
%%   \frac{1+\bar x^2}{x}
%%   \frac{p_\perp}{p_\perp^2 + \bar x M^2}
%%   \\
%%   F_{Z,0}(x,p_T) &= \frac{g^2}{16\pi^2\cos\theta_w^2}\,
%%   \left[(t_3^f-2q^2\sin\theta_w^2)^2 + (t_3^f)^2\right]\,
%%   \frac{2\bar x}{x}\,
%%   \frac{p_\perp \bar xM^2}{(p_\perp^2 + \bar x M^2)^2}
%% \end{align}
%% Here, $t_3^f$ is the $SU(2)_L$ quantum number of the fermion
%% $(\pm\frac12)$, and $q^f$ is the fermion charge in units of the
%% positron charge.

The EWA depends on the parameters $g$, $\sin^2\theta_w$, $M_W$, and
$M_Z$.  These can all be taken from the SM input, and the prefactors
are calculated from those and the incoming particle type.

Since these structure functions have a $1/x$ singularity (which is not
really relevant in practice, however, since the vector boson mass is
finite), we map this singularity allowing for nontrivial $x$ bounds:
\begin{equation}
  x = \exp(\bar r\ln x_0 + r\ln x_1)
\end{equation}
such that
\begin{equation}
  \int_{x_0}^{x_1}\frac{dx}{x} = (\ln x_1 - \ln x_0)\int_0^1 dr.
\end{equation}

As a user parameter, we have the cutoff $p_{\perp,\textrm{max}}$.
The divergence $1/x$ also requires a $x_0$ cutoff; and for
completeness we introduce a corresponding $x_1$.  Physically, the
minimal sensible value of $x$ is $M^2/s$, although the approximation
loses its value already at higher $x$ values.


\subsection{The EWA data block}
The EWA parameters are: $p_{T,\rm max}$, $c_V$, $c_A$, and
$m$. Instead of $m$ we can use the incoming particle PDG code as
input; from this we can deduce the mass and charges. In the
initialization phase it is not yet determined whether a $W$ or a $Z$
is radiated, hence we set the vector and axial-vector couplings equal
to the common prefactors $g/2 = e/2/\sin\theta_W$. 

In principle, for EWA it would make sense to allow the user to also
set the upper bound for $x$, $x_{\rm max}$, but we fix it to one here.
<<SF ewa: public>>=
  public :: ewa_data_t
<<SF ewa: types>>=
  type, extends(sf_data_t) :: ewa_data_t
     private
     class(model_data_t), pointer :: model => null ()
     type(flavor_t), dimension(:), allocatable :: flv_in
     type(flavor_t), dimension(:), allocatable :: flv_out
     real(default) :: pt_max
     real(default) :: sqrts
     real(default) :: x_min
     real(default) :: x_max
     real(default) :: mass
     real(default) :: m_out
     real(default) :: q_min
     real(default) :: cv
     real(default) :: ca
     real(default) :: costhw
     real(default) :: sinthw
     real(default) :: mW
     real(default) :: mZ
     real(default) :: coeff
     logical :: mass_set = .false.
     logical :: keep_momentum
     logical :: keep_energy     
     integer :: id = 0 
     integer :: error = NONE
   contains
   <<SF ewa: ewa data: TBP>>  
  end type ewa_data_t

@ %def ewa_data_t
@ Error codes
<<SF ewa: parameters>>=
  integer, parameter :: NONE = 0
  integer, parameter :: ZERO_QMIN = 1
  integer, parameter :: Q_MAX_TOO_SMALL = 2
  integer, parameter :: ZERO_XMIN = 3
  integer, parameter :: MASS_MIX = 4
  integer, parameter :: ZERO_SW = 5
  integer, parameter :: ISOSPIN_MIX = 6
  integer, parameter :: WRONG_PRT = 7
  integer, parameter :: MASS_MIX_OUT = 8
  integer, parameter :: NO_EWA = 9
<<SF ewa: ewa data: TBP>>=
  procedure :: init => ewa_data_init
<<SF ewa: procedures>>=
  subroutine ewa_data_init (data, model, pdg_in, x_min, pt_max, &
        sqrts, keep_momentum, keep_energy, mass)
    class(ewa_data_t), intent(inout) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    real(default), intent(in) :: x_min, pt_max, sqrts
    logical, intent(in) :: keep_momentum, keep_energy
    real(default), intent(in), optional :: mass
    real(default) :: g, ee
    integer :: n_flv, i
    data%model => model
    if (.not. any (pdg_in .match. &
         [1,2,3,4,5,6,11,13,15,-1,-2,-3,-4,-5,-6,-11,-13,-15])) then
       data%error = WRONG_PRT;  return
    end if   
    n_flv = pdg_array_get_length (pdg_in)
    allocate (data%flv_in (n_flv))
    allocate (data%flv_out(n_flv))
    do i = 1, n_flv
       call flavor_init (data%flv_in(i), pdg_array_get (pdg_in, i), model)
    end do
    data%pt_max = pt_max
    data%sqrts = sqrts
    data%x_min = x_min
    data%x_max = 1
    if (data%x_min == 0) then
       data%error = ZERO_XMIN;  return
    end if    
    select case (char (data%model%get_name ()))
    case ("QCD","QED","Test")
       data%error = NO_EWA;  return
    end select
    ee = data%model%get_real (var_str ("ee"))
    data%sinthw = data%model%get_real (var_str ("sw"))    
    data%costhw = data%model%get_real (var_str ("cw"))        
    data%mZ = data%model%get_real (var_str ("mZ"))
    data%mW = data%model%get_real (var_str ("mW"))    
    if (data%sinthw /= 0) then
       g = ee / data%sinthw
    else
       data%error = ZERO_SW;  return
    end if
    data%cv = g / 2._default
    data%ca = g / 2._default   
    data%coeff = 1._default / (8._default * PI**2)
    data%keep_momentum = keep_momentum
    data%keep_energy = keep_energy
    if (present (mass)) then
       data%mass = mass
       data%m_out = mass
       data%mass_set = .true.
    else
       data%mass = flavor_get_mass (data%flv_in(1))
       if (any (flavor_get_mass (data%flv_in) /= data%mass)) then
          data%error = MASS_MIX;  return
       end if
    end if
  end subroutine ewa_data_init

@ %def ewa_data_init
@ Set the vector boson ID for distinguishing $W$ and $Z$ bosons.
<<SF ewa: ewa data: TBP>>=
  procedure :: set_id => ewa_set_id
<<SF ewa: procedures>>=
  subroutine ewa_set_id (data, id)
    class(ewa_data_t), intent(inout) :: data
    integer, intent(in) :: id
    integer :: i, isospin, pdg
    if (.not. allocated (data%flv_in)) &
         call msg_bug ("EWA: incoming particles not set")
    data%id = id
    select case (data%id)
    case (23)
       data%m_out = data%mass
       data%flv_out = data%flv_in
    case (24)
       do i = 1, size (data%flv_in)
          pdg = flavor_get_pdg (data%flv_in(i)) 
          isospin = flavor_get_isospin_type (data%flv_in(i))
          if (isospin > 0) then            
             !!! up-type quark or neutrinos
             if (flavor_is_antiparticle (data%flv_in(i))) then
                call flavor_init (data%flv_out(i), pdg + 1, data%model)
             else
                call flavor_init (data%flv_out(i), pdg - 1, data%model)
             end if
          else
             !!! down-type quark or lepton
             if (flavor_is_antiparticle (data%flv_in(i))) then
                call flavor_init (data%flv_out(i), pdg - 1, data%model)
             else
                call flavor_init (data%flv_out(i), pdg + 1, data%model)
             end if
          end if
       end do
       if (.not. data%mass_set) then
          data%m_out = flavor_get_mass (data%flv_out(1))
          if (any (flavor_get_mass (data%flv_out) /= data%m_out)) then
             data%error = MASS_MIX_OUT;  return
          end if
       end if
    end select
  end subroutine ewa_set_id 

@ %def ewa_set_id
@ Handle error conditions.  Should always be done after
initialization, unless we are sure everything is ok.
<<SF ewa: ewa data: TBP>>=
  procedure :: check => ewa_data_check
<<SF ewa: procedures>>=
  subroutine ewa_data_check (data)
    class(ewa_data_t), intent(in) :: data
    select case (data%error)
    case (WRONG_PRT)
       call msg_fatal ("EWA structure function only accessible for " &
            // "SM quarks and leptons.")
    case (NO_EWA)
       call msg_fatal ("EWA structure function not available for model " &
            // char (data%model%get_name ()))
    case (ZERO_SW)
       call msg_fatal ("EWA: Vanishing value of sin(theta_w)")
    case (ZERO_QMIN)
       call msg_fatal ("EWA: Particle mass is zero")
    case (Q_MAX_TOO_SMALL)
       call msg_fatal ("EWA: Particle mass exceeds Qmax")
    case (ZERO_XMIN)
       call msg_fatal ("EWA: x_min must be larger than zero")
    case (MASS_MIX)
       call msg_fatal ("EWA: incoming particle masses must be uniform")
    case (MASS_MIX_OUT)
       call msg_fatal ("EWA: outgoing particle masses must be uniform")
    case (ISOSPIN_MIX)
       call msg_fatal ("EWA: incoming particle isospins must be uniform")
    end select
  end subroutine ewa_data_check

@ %def ewa_data_check
@ Output
<<SF ewa: ewa data: TBP>>=
  procedure :: write => ewa_data_write
<<SF ewa: procedures>>=
  subroutine ewa_data_write (data, unit, verbose) 
    class(ewa_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "EWA data:"
    if (allocated (data%flv_in) .and. allocated (data%flv_out)) then
       write (u, "(3x,A)", advance="no") "  flavor(in)  =  "
       do i = 1, size (data%flv_in)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          call flavor_write (data%flv_in(i), u)
       end do
       write (u, *)
       write (u, "(3x,A)", advance="no") "  flavor(out) =  "
       do i = 1, size (data%flv_out)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          call flavor_write (data%flv_out(i), u)
       end do
       write (u, *)
       write (u, "(3x,A," // FMT_19 // ")") "  x_min     = ", data%x_min
       write (u, "(3x,A," // FMT_19 // ")") "  x_max     = ", data%x_max
       write (u, "(3x,A," // FMT_19 // ")") "  pt_max    = ", data%pt_max
       write (u, "(3x,A," // FMT_19 // ")") "  sqrts     = ", data%sqrts    
       write (u, "(3x,A," // FMT_19 // ")") "  mass      = ", data%mass
       write (u, "(3x,A," // FMT_19 // ")") "  cv        = ", data%cv
       write (u, "(3x,A," // FMT_19 // ")") "  ca        = ", data%ca
       write (u, "(3x,A," // FMT_19 // ")") "  coeff     = ", data%coeff
       write (u, "(3x,A," // FMT_19 // ")") "  costhw    = ", data%costhw
       write (u, "(3x,A," // FMT_19 // ")") "  sinthw    = ", data%sinthw    
       write (u, "(3x,A," // FMT_19 // ")") "  mZ        = ", data%mZ
       write (u, "(3x,A," // FMT_19 // ")") "  mW        = ", data%mW
       write (u, "(3x,A,L2)")      "  keep_mom. = ", data%keep_momentum
       write (u, "(3x,A,L2)")      "  keep_en.  = ", data%keep_energy 
       write (u, "(3x,A,I2)")      "  PDG (VB)  = ", data%id
    else
       write (u, "(3x,A)") "[undefined]"
    end if       
  end subroutine ewa_data_write

@ %def ewa_data_write
@ The number of parameters is one for collinear splitting, in case one
of the options [[keep_energy]] or [[keep_momentum]] is set, we take
the recoil into account.
<<SF ewa: ewa data: TBP>>=
  procedure :: get_n_par => ewa_data_get_n_par
<<SF ewa: procedures>>=
  function ewa_data_get_n_par (data) result (n)
    class(ewa_data_t), intent(in) :: data
    integer :: n
    if (data%keep_energy .or. data%keep_momentum) then
       n = 3
    else
       n = 1
    end if
  end function ewa_data_get_n_par
  
@ %def ewa_data_get_n_par
@ Return the outgoing particles PDG codes. This depends, whether this
is a charged-current or neutral-current interaction.
<<SF ewa: ewa data: TBP>>=  
  procedure :: get_pdg_out => ewa_data_get_pdg_out
<<SF ewa: procedures>>=
  subroutine ewa_data_get_pdg_out (data, pdg_out)
    class(ewa_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    integer :: i, n_flv
    if (allocated (data%flv_out)) then
       n_flv = size (data%flv_out)
    else
       n_flv = 0
    end if
    allocate (pdg1 (n_flv))
    do i = 1, n_flv
       pdg1(i) = flavor_get_pdg (data%flv_out(i))
    end do
    pdg_out(1) = pdg1
  end subroutine ewa_data_get_pdg_out
  
@ %def ewa_data_get_pdg_out
@ Allocate the interaction record.
<<SF ewa: ewa data: TBP>>=
  procedure :: allocate_sf_int => ewa_data_allocate_sf_int
<<SF ewa: procedures>>=
  subroutine ewa_data_allocate_sf_int (data, sf_int)
    class(ewa_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (ewa_t :: sf_int)
  end subroutine ewa_data_allocate_sf_int
  
@ %def ewa_data_allocate_sf_int 
@ 
\subsection{The EWA object}
The [[ewa_t]] data type is a $1\to 2$ interaction.  We should be able
to handle several flavors in parallel, since EWA is not necessarily
applied immediately after beam collision:  $W/Z$ bosons may be radiated
from quarks.  In that case, the partons are massless and $q_{\rm min}$
applies instead, so we do not need to generate several kinematical
configurations in parallel.

The particles are ordered as (incoming, radiated, W/Z), where the
W/Z initiates the hard interaction.

In the case of EPA, we generated an unpolarized photon and transferred
initial polarization to the radiated parton.  Color is transferred in
the same way. I do not know whether the same can/should be done for
EWA, as the structure functions depend on the W/Z polarization. If we
are having $Z$ bosons, both up- and down-type fermions can
participate. Otherwise, with a $W^+$ an up-type fermion is transferred
to a down-type fermion, and the other way round.
<<SF ewa: types>>=
  type, extends (sf_int_t) :: ewa_t
     type(ewa_data_t), pointer :: data => null ()
     real(default) :: x  = 0
     real(default) :: xb = 0
     integer :: n_me = 0
     real(default), dimension(:), allocatable :: cv
     real(default), dimension(:), allocatable :: ca
   contains
   <<SF ewa: ewa: TBP>>
  end type ewa_t 
  
@ %def ewa_t
@ Type string: has to be here, but there is no string variable on which EWA
depends. Hence, a dummy routine.
<<SF ewa: ewa: TBP>>=
  procedure :: type_string => ewa_type_string
<<SF ewa: procedures>>=
  function ewa_type_string (object) result (string)
    class(ewa_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "EWA: equivalent W/Z approx." 
    else
       string = "EWA: [undefined]"
    end if
  end function ewa_type_string
  
@ %def ewa_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF ewa: ewa: TBP>>=
  procedure :: write => ewa_write
<<SF ewa: procedures>>=
  subroutine ewa_write (object, unit, testflag)
    class(ewa_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "EWA data: [undefined]"
    end if    
  end subroutine ewa_write
    
@ %def ewa_write
@ The current implementation requires uniform isospin for all incoming
particles, therefore we need to probe only the first one.
<<SF ewa: ewa: TBP>>=
  procedure :: init => ewa_init
<<SF ewa: procedures>>=
  subroutine ewa_init (sf_int, data)
    class(ewa_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    integer, dimension(3) :: hel_lock
    type(polarization_t) :: pol
    type(quantum_numbers_t), dimension(1) :: qn_fc, qn_hel, qn_fc_fin
    type(flavor_t) :: flv_z, flv_wp, flv_wm
    type(quantum_numbers_t) :: qn_z, qn_wp, qn_wm, qn, qn_out, qn_w
    type(state_iterator_t) :: it_hel
    integer :: i, isospin
    select type (data)
    type is (ewa_data_t)   
       mask = new_quantum_numbers_mask (.false., .false., &
            mask_h = [.false., .false., .true.])
       hel_lock = [2, 1, 0]
       select case (data%id)
       case (23)
          !!! Z boson, flavor is not changing    
          call sf_int%base_init (mask, [data%mass**2], [data%mass**2], &
               [data%mZ**2], hel_lock = hel_lock)
          sf_int%data => data          
          call flavor_init (flv_z, Z_BOSON, data%model)
          call quantum_numbers_init (qn_z, flv_z)
          do i = 1, size (data%flv_in)
             call polarization_init_generic (pol, data%flv_in(i))
             call quantum_numbers_init (qn_fc(1), &
                  flv = data%flv_in(i), &
                  col = color_from_flavor (data%flv_in(i), 1))
             call state_iterator_init (it_hel, pol%state)
             do while (state_iterator_is_valid (it_hel))
                qn_hel = state_iterator_get_quantum_numbers (it_hel)
                qn = qn_hel(1) .merge. qn_fc(1)
                call interaction_add_state &
                     (sf_int%interaction_t, [qn, qn, qn_z])
                call state_iterator_advance (it_hel)
             end do
             call polarization_final (pol)
          end do
       case (24)    
          call sf_int%base_init (mask, [data%mass**2], [data%m_out**2], &
               [data%mW**2], hel_lock = hel_lock)
          sf_int%data => data                       
          call flavor_init (flv_wp, W_BOSON, data%model)
          call flavor_init (flv_wm, - W_BOSON, data%model)
          call quantum_numbers_init (qn_wp, flv_wp)
          call quantum_numbers_init (qn_wm, flv_wm)
          do i = 1, size (data%flv_in)
             isospin = flavor_get_isospin_type (data%flv_in(i))
             if (isospin > 0) then            
                !!! up-type quark or neutrinos
                if (flavor_is_antiparticle (data%flv_in(i))) then
                   qn_w = qn_wm
                else
                   qn_w = qn_wp
                end if
             else
                !!! down-type quark or lepton
                if (flavor_is_antiparticle (data%flv_in(i))) then
                   qn_w = qn_wp
                else
                   qn_w = qn_wm
                end if
             end if
             call polarization_init_generic (pol, data%flv_in(i))
             call quantum_numbers_init (qn_fc(1), &
                  flv = data%flv_in(i), &
                  col = color_from_flavor (data%flv_in(i), 1))
             call quantum_numbers_init (qn_fc_fin(1), &
                  flv = data%flv_out(i), &
                  col = color_from_flavor (data%flv_out(i), 1))
             call state_iterator_init (it_hel, pol%state)
             do while (state_iterator_is_valid (it_hel))
                qn_hel = state_iterator_get_quantum_numbers (it_hel)
                qn = qn_hel(1) .merge. qn_fc(1)
                qn_out = qn_hel(1) .merge. qn_fc_fin(1)           
                call interaction_add_state &
                     (sf_int%interaction_t, [qn, qn_out, qn_w])
                call state_iterator_advance (it_hel)
             end do
             call polarization_final (pol)    
          end do
       case default
          call msg_fatal ("EWA initialization failed: wrong particle type.")
       end select
       call interaction_freeze (sf_int%interaction_t)
       if (data%keep_momentum) then
          if (data%keep_energy) then
             call msg_fatal ("EWA: momentum and energy" // &
                  "cannot be simultaneously conserved.")
          else          
             sf_int%on_shell_mode = KEEP_MOMENTUM
          end if
       else 
          if (data%keep_energy) then
             sf_int%on_shell_mode = KEEP_ENERGY
          end if
       end if
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
    end select
  end subroutine ewa_init
    
@ %def ewa_init
@ Prepare the coupling arrays.  This is separate from the previous routine since
the state matrix may be helicity-contracted.
<<SF ewa: ewa: TBP>>=
  procedure :: setup_constants => ewa_setup_constants
<<SF ewa: procedures>>=
  subroutine ewa_setup_constants (sf_int)
    class(ewa_t), intent(inout) :: sf_int
    type(state_iterator_t) :: it
    type(flavor_t) :: flv
    real(default) :: q, t3
    integer :: i
    sf_int%n_me = interaction_get_n_matrix_elements (sf_int%interaction_t) 
    allocate (sf_int%cv (sf_int%n_me))
    allocate (sf_int%ca (sf_int%n_me))
    associate (data => sf_int%data)
      select case (data%id)
      case (23)
         call state_iterator_init (it, &
              interaction_get_state_matrix_ptr (sf_int%interaction_t))
         do while (state_iterator_is_valid (it))
            i = state_iterator_get_me_index (it)
            flv = state_iterator_get_flavor (it, 1)
            q = flavor_get_charge (flv)
            t3 = flavor_get_isospin (flv)
            if (flavor_is_antiparticle (flv)) then
               sf_int%cv(i) = - data%cv &
                    * (t3 - 2._default * q * data%sinthw**2) / data%costhw
               sf_int%ca(i) = data%ca *  t3 / data%costhw    
            else	  
               sf_int%cv(i) = data%cv &
                    * (t3 - 2._default * q * data%sinthw**2) / data%costhw
               sf_int%ca(i) = data%ca *  t3 / data%costhw    
            end if
            call state_iterator_advance (it)
         end do
      case (24)
         call state_iterator_init (it, &
              interaction_get_state_matrix_ptr (sf_int%interaction_t))
         do while (state_iterator_is_valid (it))
            i = state_iterator_get_me_index (it)
            if (flavor_is_antiparticle (state_iterator_get_flavor (it, 1))) &
                 then
               sf_int%cv(i) = data%cv / sqrt(2._default)
               sf_int%ca(i) = - data%ca / sqrt(2._default)
            else	  
               sf_int%cv(i) = data%cv / sqrt(2._default)
               sf_int%ca(i) = data%ca / sqrt(2._default)
            end if
            call state_iterator_advance (it)
         end do
      end select
    end associate
    sf_int%status = SF_INITIAL
  end subroutine ewa_setup_constants
  
@ %def ewa_setup_constants
@
\subsection{Kinematics}
Set kinematics.  The EWA structure function allows for a
straightforward mapping of the unit interval.  So, to leading order,
the structure function value is unity, but the $x$ value is
transformed.  Higher orders affect the function value.
If [[map]] is unset, the $r$ and $x$ values coincide, and the Jacobian
$f(r)$ is trivial. 

If [[map]] is set, the exponential mapping for the $1/x$ singularity
discussed above is applied. 
<<SF ewa: ewa: TBP>>=
  procedure :: complete_kinematics => ewa_complete_kinematics
<<SF ewa: procedures>>=
  subroutine ewa_complete_kinematics (sf_int, x, f, r, rb, map)
    class(ewa_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1, e_1
    real(default) :: x0, x1, lx0, lx1, lx
    e_1 = energy (interaction_get_momentum (sf_int%interaction_t, 1))
    if (sf_int%data%keep_momentum .or. sf_int%data%keep_energy) then
       select case (sf_int%data%id)
       case (23)
          x0 = max (sf_int%data%x_min, sf_int%data%mz / e_1)
       case (24)
          x0 = max (sf_int%data%x_min, sf_int%data%mw / e_1)
       end select
    else 
       x0 = sf_int%data%x_min
    end if
    x1 = sf_int%data%x_max
    if ( x0 >= x1) then
       f = 0
       sf_int%status = SF_FAILED_KINEMATICS
       return
    end if
    if (map) then
       lx0 = log (x0)
       lx1 = log (x1)
       lx = lx1 * r(1) + lx0 * rb(1)
       x(1) = exp(lx)       
       f = x(1) * (lx1 - lx0)
    else       
       x(1) = r(1)
       if (x0 < x(1) .and. x(1) < x1) then
          f = 1
       else
          sf_int%status = SF_FAILED_KINEMATICS
          f = 0
          return
       end if
    end if
    xb1 = 1 - x(1)
    if (size(x) == 3)  x(2:3) = r(2:3)
    call sf_int%split_momentum (x, xb1)
    select case (sf_int%status)
    case (SF_DONE_KINEMATICS)
       sf_int%x  = x(1)
       sf_int%xb = xb1
    case (SF_FAILED_KINEMATICS)
       sf_int%x  = 0
       sf_int%xb = 0
       f = 0
    end select
  end subroutine ewa_complete_kinematics

@ %def ewa_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF ewa: ewa: TBP>>=
  procedure :: inverse_kinematics => ewa_inverse_kinematics
<<SF ewa: procedures>>=
  subroutine ewa_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(ewa_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: x0, x1, lx0, lx1, lx, e_1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    e_1 = energy (interaction_get_momentum (sf_int%interaction_t, 1))    
    if (sf_int%data%keep_momentum .or. sf_int%data%keep_energy) then
       select case (sf_int%data%id)
       case (23)
          x0 = max (sf_int%data%x_min, sf_int%data%mz / e_1)
       case (24)
          x0 = max (sf_int%data%x_min, sf_int%data%mw / e_1)
       end select
    else 
       x0 = sf_int%data%x_min
    end if
    x1 = sf_int%data%x_max
    if (map) then
       lx0 = log (x0)
       lx1 = log (x1)
       lx = log (x(1))
       r(1)  = (lx - lx0) / (lx1 - lx0)
       rb(1) = (lx1 - lx) / (lx1 - lx0)
       f = x(1) * (lx1 - lx0)
    else
       r (1) = x(1)
       rb(1) = 1 - x(1)
       if (x0 < x(1) .and. x(1) < x1) then
          f = 1
       else
          f = 0
       end if
    end if
    if (size(r) == 3) then 
       r (2:3) = x(2:3)
       rb(2:3) = 1 - x(2:3)
    end if
    if (set_mom) then
       call sf_int%split_momentum (x, sf_int%xb)
       select case (sf_int%status)
       case (SF_DONE_KINEMATICS)
          sf_int%x  = x(1)
          sf_int%xb = 1 - x(1)
       case (SF_FAILED_KINEMATICS)
          sf_int%x = 0
          f = 0
       end select
    end if
  end subroutine ewa_inverse_kinematics

@ %def ewa_inverse_kinematics
@
\subsection{EWA application}
For EWA, we can compute kinematics and function value in a single
step.  This function works on a single beam, assuming that the input
momentum has been set.  We need four random numbers as input: one for
$x$, one for $Q^2$, and two for the polar and azimuthal angles.
Alternatively, we can skip $p_T$ generation; in this case, we only
need one.

For obtaining splitting kinematics, we rely on the assumption that all
in-particles are mass-degenerate (or there is only one), so the
generated $x$ values are identical.
<<SF ewa: ewa: TBP>>=
  procedure :: apply => ewa_apply
<<SF ewa: procedures>>=
  subroutine ewa_apply (sf_int, scale)
    class(ewa_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: x, xb, pt2, c1, c2
    real(default) :: cv, ca
    real(default) :: f, fm, fp, fL
    integer :: i
    associate (data => sf_int%data)     
      x  = sf_int%x      
      xb = sf_int%xb
      pt2 = min ((data%pt_max)**2, (xb * data%sqrts / 2)**2)
      select case (data%id)
      case (23)
         !!! Z boson structure function
         c1 = log (1 + pt2 / (xb * (data%mZ)**2))
         c2 = 1 / (1 + (xb * (data%mZ)**2) / pt2)
      case (24)
         !!! W boson structure function
         c1 = log (1 + pt2 / (xb * (data%mW)**2))
         c2 = 1 / (1 + (xb * (data%mW)**2) / pt2)
      end select
      do i = 1, sf_int%n_me
         cv = sf_int%cv(i)
         ca = sf_int%ca(i)
         fm = data%coeff * &
              ((cv + ca)**2 + ((cv - ca) * xb)**2) * (c1 - c2) / (2 * x)
         fp = data%coeff * &
              ((cv - ca)**2 + ((cv + ca) * xb)**2) * (c1 - c2) / (2 * x)
         fL = data%coeff * &
              (cv**2 + ca**2) * (2 * xb / x) * c2       
         f = fp + fm + fL
         if (f /= 0) then
            fp = fp / f
            fm = fm / f
            fL = fL / f      
         end if
         call interaction_set_matrix_element &
              (sf_int%interaction_t, i, cmplx (f, kind=default))
      end do
    end associate
    sf_int%status = SF_EVALUATED
  end subroutine ewa_apply

@ %def ewa_apply
@
\subsection{Unit tests}
<<SF ewa: public>>=
  public :: sf_ewa_test
<<SF ewa: tests>>=
  subroutine sf_ewa_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF ewa: execute tests>>
  end subroutine sf_ewa_test
  
@ %def sf_ewa_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF ewa: execute tests>>=
  call test (sf_ewa_1, "sf_ewa_1", &
       "structure function configuration", &
       u, results)
<<SF ewa: tests>>=
  subroutine sf_ewa_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_ewa_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call model%init_sm_test ()
    pdg_in = 2

    allocate (ewa_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize for Z boson"
    write (u, "(A)")

    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 5000._default, .false., .false.)
       call data%set_id (23)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1
        
    write (u, "(A)")
    write (u, "(A)")  "* Initialize for W boson"
    write (u, "(A)")
    
    deallocate (data)
    allocate (ewa_data_t :: data)
    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 5000._default, .false., .false.)
       call data%set_id (24)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1
            
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_ewa_1"

  end subroutine sf_ewa_1

@ %def sf_ewa_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the EWA
structure function.
<<SF ewa: execute tests>>=
  call test (sf_ewa_2, "sf_ewa_2", &
       "structure function instance", &
       u, results)
<<SF ewa: tests>>=
  subroutine sf_ewa_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_ewa_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_sm_test ()
    call flavor_init (flv, 2, model)
    pdg_in = 2

    call reset_interaction_counter ()
    
    allocate (ewa_data_t :: data)
    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 3000._default, .false., .false.)
       call data%set_id (24)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=1500"
    write (u, "(A)")
    E = 1500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, no EWA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false., &
         set_momenta=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f    
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EWA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
        
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_ewa_2"
    
  end subroutine sf_ewa_2
  
@ %def sf_ewa_2
@
\subsubsection{Standard mapping}
Construct and display a structure function object based on the EWA
structure function, applying the standard single-particle mapping.
<<SF ewa: execute tests>>=
  call test (sf_ewa_3, "sf_ewa_3", &
       "apply mapping", &
       u, results)
<<SF ewa: tests>>=
  subroutine sf_ewa_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_ewa_3"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_sm_test ()
    call flavor_init (flv, 2, model)
    pdg_in = 2

    call reset_interaction_counter ()
    
    allocate (ewa_data_t :: data)
    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 3000._default, .false., .false.)
       call data%set_id (24)
    end select
    
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")    
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=1500"
    write (u, "(A)")
    E = 1500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, with EWA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true., &
         set_momenta=.true.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EWA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_ewa_3"

  end subroutine sf_ewa_3

@ %def sf_ewa_3
@
\subsubsection{Non-collinear case}
Construct and display a structure function object based on the EPA
structure function.
<<SF ewa: execute tests>>=
  call test (sf_ewa_4, "sf_ewa_4", &
       "non-collinear", &
       u, results)
<<SF ewa: tests>>=
  subroutine sf_ewa_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_ewa_4"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call modeL%init_sm_test ()
    call flavor_init (flv, 2, model)
    pdg_in = 2

    call reset_interaction_counter ()

    allocate (ewa_data_t :: data)
    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 3000.0_default, .false., .true.)
       call data%set_id (24)
    end select    

    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
        
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()

    write (u, "(A)")  "* Initialize incoming momentum with E=1500"
    write (u, "(A)")
    E = 1500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])        
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.5/0.5/0.25, with EWA mapping, "
    write (u, "(A)")  "          non-coll., keeping energy"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = [0.5_default, 0.5_default, 0.25_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r from momenta"
    write (u, "(A)")
    
    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true., &
         set_momenta=.true.)    
    call interaction_pacify_momenta (sf_int%interaction_t, 1e-10_default)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EWA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 1500._default)
    call sf_int%write (u, testflag = .true.)    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_ewa_4"

  end subroutine sf_ewa_4

@ %def sf_ewa_4
@
\subsubsection{Structure function for multiple flavors}
Construct and display a structure function object based on the EWA
structure function.  The incoming state has multiple particles with
non-uniform quantum numbers.
<<SF ewa: execute tests>>=
  call test (sf_ewa_5, "sf_ewa_5", &
       "structure function instance", &
       u, results)
<<SF ewa: tests>>=
  subroutine sf_ewa_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_ewa_5"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_sm_test ()
    call flavor_init (flv, 2, model)
    pdg_in = [1, 2, -1, -2]

    call reset_interaction_counter ()
    
    allocate (ewa_data_t :: data)
    select type (data)
    type is (ewa_data_t)
       call data%init (model, pdg_in, 0.01_default, &
            500._default, 3000._default, .false., .false.)
       call data%set_id (24)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    call sf_int%setup_constants ()
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=1500"
    write (u, "(A)")
    E = 1500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call pacify (k, 1e-10_default)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for r=0.4, no EWA mapping, collinear"
    write (u, "(A)")
    
    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    r = 0.4_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate EWA structure function"
    write (u, "(A)")
    
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)
        
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call sf_int%final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_ewa_5"
    
  end subroutine sf_ewa_5
  
@ %def sf_ewa_5
@
\clearpage
%------------------------------------------------------------------------
\section{Lepton collider beamstrahlung: CIRCE1}

<<[[sf_circe1.f90]]>>=
<<File header>>

module sf_circe1

<<Use kinds>>
  use kinds, only: double
<<Use strings>>
  use io_units
  use format_defs, only: FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use physics_defs, only: UNDEFINED, ELECTRON, PHOTON
  use lorentz
  use rng_base
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_mappings
  use sf_aux
  use sf_base
  use circe1, circe1_rng_t => rng_type !NODEP!

<<Standard module head>>

<<SF circe1: public>>

<<SF circe1: types>>

contains

<<SF circe1: procedures>>

<<SF circe1: tests>>

end module sf_circe1
@ %def sf_circe1
@ 
\subsection{Physics} 
Beamstrahlung is applied before ISR.  The [[CIRCE1]] implementation has 
a single structure function for both beams (which makes sense since it 
has to be switched on or off for both beams simultaneously). 
Nevertheless it is factorized: 
 
The functional form in the [[CIRCE1]] parameterization is defined for 
electrons or photons 
\begin{equation} 
  f(x) = \alpha\,x^\beta\,(1-x)^\gamma 
\end{equation} 
for $x<1-\epsilon$ (resp.\ $x>\epsilon$ in the photon case).  In the 
remaining interval, the standard form is zero, with a delta 
singularity at $x=1$ (resp.\ $x=0$).  Equivalently, the delta part may be 
distributed uniformly among this interval.  This latter form is 
implemented in the [[kirke]] version of the [[CIRCE1]] subroutines, and 
is used here. 
 
The parameter [[circe1\_eps]] sets the peak mapping of the [[CIRCE1]]
structure function. Its default value is $10^{-5}$. 
The other parameters are the parameterization version and revision 
number, the accelerator type, and the $\sqrt{s}$ value used by 
[[CIRCE1]]. The chattiness can also be set. 
 
Since the energy is distributed in a narrow region around unity (for 
electrons) or zero (for photons), it is advantageous to map the 
interval first.  The mapping is controlled by the parameter
[[circe1\_epsilon]] which is taken from the [[CIRCE1]] 
internal data structure. 
 
The $\sqrt{s}$ value, if not explicitly set, is taken from the
process data.  Note that interpolating $\sqrt{s}$ is not recommended;
one should rather choose one of the distinct values known to [[CIRCE1]].
 
\subsection{The CIRCE1 data block} 
The CIRCE1 parameters are: The incoming flavors, the flags whether the photon
or the lepton is the parton in the hard interaction, the flags for the
generation mode (generator/mapping/no mapping), the mapping parameter
$\epsilon$, $\sqrt{s}$ and several steering parameters: [[ver]],
[[rev]], [[acc]], [[chat]]. 

In generator mode, the $x$ values are actually discarded and a random number
generator is used instead.
<<SF circe1: public>>= 
  public :: circe1_data_t 
<<SF circe1: types>>= 
  type, extends (sf_data_t) :: circe1_data_t 
     private 
     class(model_data_t), pointer :: model => null () 
     type(flavor_t), dimension(2) :: flv_in 
     integer, dimension(2) :: pdg_in
     real(default), dimension(2) :: m_in = 0
     logical, dimension(2) :: photon = .false.
     logical :: generate = .false.
     class(rng_factory_t), allocatable :: rng_factory
     real(default) :: sqrts = 0
     real(default) :: eps = 0
     integer :: ver = 0 
     integer :: rev = 0      
     character(6) :: acc = "?"
     integer :: chat = 0    
   contains  
     <<SF circe1: circe1 data: TBP>>     
  end type circe1_data_t 
 
@ %def circe1_data_t 
@ 
<<SF circe1: circe1 data: TBP>>= 
  procedure :: init => circe1_data_init 
<<SF circe1: procedures>>= 
  subroutine circe1_data_init &
       (data, model, pdg_in, sqrts, eps, out_photon, &
        ver, rev, acc, chat)
    class(circe1_data_t), intent(out) :: data 
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), dimension(2), intent(in) :: pdg_in
    real(default), intent(in) :: sqrts 
    real(default), intent(in) :: eps
    logical, dimension(2), intent(in) :: out_photon
    character(*), intent(in) :: acc
    integer, intent(in) :: ver, rev, chat 
    data%model => model 
    if (any (pdg_array_get_length (pdg_in) /= 1)) then
       call msg_fatal ("CIRCE1: incoming beam particles must be unique")
    end if
    call flavor_init (data%flv_in(1), pdg_array_get (pdg_in(1), 1), model)
    call flavor_init (data%flv_in(2), pdg_array_get (pdg_in(2), 1), model)
    data%pdg_in = flavor_get_pdg (data%flv_in)
    data%m_in = flavor_get_mass (data%flv_in)
    data%sqrts = sqrts
    data%eps = eps
    data%photon = out_photon
    data%ver = ver
    data%rev = rev
    data%acc = acc 
    data%chat = chat 
    call data%check ()
    call circex (0.d0, 0.d0, dble (data%sqrts), &
         data%acc, data%ver, data%rev, data%chat)
  end subroutine circe1_data_init 
 
@ %def circe1_data_init
@ Activate the generator mode.  We import a RNG factory into the data
type, which can then spawn RNG generator objects.
<<SF circe1: circe1 data: TBP>>=
  procedure :: set_generator_mode => circe1_data_set_generator_mode
<<SF circe1: procedures>>=
  subroutine circe1_data_set_generator_mode (data, rng_factory)
    class(circe1_data_t), intent(inout) :: data
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    data%generate = .true.
    call move_alloc (from = rng_factory, to = data%rng_factory)
  end subroutine circe1_data_set_generator_mode
  
@ %def circe1_data_set_generator_mode
@ Handle error conditions.
<<SF circe1: circe1 data: TBP>>= 
  procedure :: check => circe1_data_check 
<<SF circe1: procedures>>= 
  subroutine circe1_data_check (data) 
    class(circe1_data_t), intent(in) :: data 
    type(flavor_t) :: flv_electron, flv_photon
    call flavor_init (flv_electron, ELECTRON, data%model)
    call flavor_init (flv_photon, PHOTON, data%model)
    if (flavor_get_pdg (flv_electron) == UNDEFINED &
         .or. flavor_get_pdg (flv_photon) == UNDEFINED) then
       call msg_fatal ("CIRCE1: model must contain photon and electron")
    end if
    if (any (abs (data%pdg_in) /= ELECTRON) &
         .or. (data%pdg_in(1) /= - data%pdg_in(2))) then
       call msg_fatal ("CIRCE1: applicable only for e+e- or e-e+ collisions")
    end if
    if (data%eps <= 0) then
       call msg_error ("CIRCE1: circe1_eps = 0: integration will &
            &miss x=1 peak")
    end if
  end subroutine circe1_data_check 
 
@ %def circe1_data_check 
@ Output 
<<SF circe1: circe1 data: TBP>>= 
  procedure :: write => circe1_data_write 
<<SF circe1: procedures>>= 
  subroutine circe1_data_write (data, unit, verbose)
    class(circe1_data_t), intent(in) :: data 
    integer, intent(in), optional :: unit 
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return 
    write (u, "(1x,A)") "CIRCE1 data:" 
    write (u, "(3x,A,2(1x,A))") "prt_in   =", &
         char (flavor_get_name (data%flv_in(1))), &
         char (flavor_get_name (data%flv_in(2)))
    write (u, "(3x,A,2(1x,L1))")  "photon   =", data%photon
    write (u, "(3x,A,L1)")        "generate = ", data%generate
    write (u, "(3x,A,2(1x," // FMT_19 // "))") "m_in     =", data%m_in
    write (u, "(3x,A," // FMT_19 // ")") "sqrts    = ", data%sqrts 
    write (u, "(3x,A," // FMT_19 // ")") "eps      = ", data%eps
    write (u, "(3x,A,I0)") "ver      = ", data%ver 
    write (u, "(3x,A,I0)") "rev      = ", data%rev 
    write (u, "(3x,A,A)")  "acc      = ", data%acc 
    write (u, "(3x,A,I0)") "chat     = ", data%chat 
    if (data%generate)  call data%rng_factory%write (u)
  end subroutine circe1_data_write 
 
@ %def circe1_data_write 
@ Return true if this structure function is in generator mode.  In
that case, all parameters are free, otherwise bound.  (We do not
support mixed cases.)  Default is: no generator.
<<SF circe1: circe1 data: TBP>>=
  procedure :: is_generator => circe1_data_is_generator
<<SF circe1: procedures>>=
  function circe1_data_is_generator (data) result (flag)
    class(circe1_data_t), intent(in) :: data
    logical :: flag
    flag = data%generate
  end function circe1_data_is_generator
  
@ %def circe1_data_is_generator
@ The number of parameters is two, collinear splitting for the two beams. 
<<SF circe1: circe1 data: TBP>>=
  procedure :: get_n_par => circe1_data_get_n_par
<<SF circe1: procedures>>=
  function circe1_data_get_n_par (data) result (n)
    class(circe1_data_t), intent(in) :: data
    integer :: n
    n = 2
  end function circe1_data_get_n_par
  
@ %def circe1_data_get_n_par
@ Return the outgoing particles PDG codes. This is either the incoming 
particle (if a photon is radiated), or the photon if that is the particle
of the hard interaction. The latter is determined via the [[photon]]
flag. There are two entries for the two beams.
<<SF circe1: circe1 data: TBP>>=  
  procedure :: get_pdg_out => circe1_data_get_pdg_out
<<SF circe1: procedures>>=
  subroutine circe1_data_get_pdg_out (data, pdg_out)
    class(circe1_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer :: i, n
    n = 2
    do i = 1, n
       if (data%photon(i)) then
          pdg_out(i) = PHOTON
       else
          pdg_out(i) = data%pdg_in(i)
       end if
    end do
  end subroutine circe1_data_get_pdg_out
  
@ %def circe1_data_get_pdg_out
@ This variant is not inherited, it returns integers.
<<SF circe1: circe1 data: TBP>>=
  procedure :: get_pdg_int => circe1_data_get_pdg_int
<<SF circe1: procedures>>=
  function circe1_data_get_pdg_int (data) result (pdg)
    class(circe1_data_t), intent(in) :: data
    integer, dimension(2) :: pdg
    integer :: i
    do i = 1, 2
       if (data%photon(i)) then
          pdg(i) = PHOTON
       else
          pdg(i) = data%pdg_in(i)
       end if
    end do
  end function circe1_data_get_pdg_int
  
@ %def circe1_data_get_pdg_int
@ Allocate the interaction record.
<<SF circe1: circe1 data: TBP>>=
  procedure :: allocate_sf_int => circe1_data_allocate_sf_int
<<SF circe1: procedures>>=
  subroutine circe1_data_allocate_sf_int (data, sf_int)
    class(circe1_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (circe1_t :: sf_int)
  end subroutine circe1_data_allocate_sf_int
  
@ %def circe1_data_allocate_sf_int 
@
\subsection{Random Number Generator for CIRCE}
The CIRCE implementation now supports a generic random-number
generator object that allows for a local state as a component.  To
support this, we must extend the abstract type provided by CIRCE and
delegate the generator call to the (also abstract) RNG used by WHIZARD.
<<SF circe1: types>>=
  type, extends (circe1_rng_t) :: rng_obj_t
     class(rng_t), allocatable :: rng
   contains
     procedure :: generate => rng_obj_generate
  end type rng_obj_t
  
@ %def rng_obj_t
<<SF circe1: procedures>>=
  subroutine rng_obj_generate (rng_obj, u)
    class(rng_obj_t), intent(inout) :: rng_obj
    real(double), intent(out) :: u
    real(default) :: x
    call rng_obj%rng%generate (x)
    u = x
  end subroutine rng_obj_generate

@ %def rng_obj_generate
@ 
\subsection{The CIRCE1 object} 
This is a $2\to 4$ interaction, where, depending on the parameters, any two of
the four outgoing particles are connected to the hard interactions, the others
are radiated.  Knowing that all particles are colorless, we do not have to
deal with color.

The flavors are sorted such that the first two particles are the incoming
leptons, the next two are the radiated particles, and the last two are the
partons initiating the hard interaction.

CIRCE1 does not support polarized beams explicitly.  For simplicity, we
nevertheless carry beam polarization through to the outgoing electrons and
make the photons unpolarized.
<<SF circe1: types>>=
  type, extends (sf_int_t) :: circe1_t
     type(circe1_data_t), pointer :: data => null ()
     real(default), dimension(2) :: x = 0
     real(default) :: f = 0
     logical, dimension(2) :: continuum = .true.
     logical, dimension(2) :: peak = .true.
     type(rng_obj_t) :: rng_obj
   contains
   <<SF circe1: circe1: TBP>>
  end type circe1_t 
  
@ %def circe1_t
@ Type string: has to be here, but there is no string variable on which CIRCE1
depends. Hence, a dummy routine.
<<SF circe1: circe1: TBP>>=
  procedure :: type_string => circe1_type_string
<<SF circe1: procedures>>=
  function circe1_type_string (object) result (string)
    class(circe1_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "CIRCE1: beamstrahlung" 
    else
       string = "CIRCE1: [undefined]"
    end if
  end function circe1_type_string
  
@ %def circe1_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF circe1: circe1: TBP>>=
  procedure :: write => circe1_write
<<SF circe1: procedures>>=
  subroutine circe1_write (object, unit, testflag)
    class(circe1_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%data%generate)  call object%rng_obj%rng%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(3x,A,2(1x," // FMT_17 // "))")  "x =", object%x
          if (object%status >= SF_FAILED_EVALUATION) then
             write (u, "(3x,A,1x," // FMT_17 // ")")  "f =", object%f
          end if
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "CIRCE1 data: [undefined]"
    end if
  end subroutine circe1_write
    
@ %def circe1_write
@
<<SF circe1: circe1: TBP>>= 
  procedure :: init => circe1_init
<<SF circe1: procedures>>= 
  subroutine circe1_init (sf_int, data) 
    class(circe1_t), intent(out) :: sf_int 
    class(sf_data_t), intent(in), target :: data
    logical, dimension(6) :: mask_h
    type(quantum_numbers_mask_t), dimension(6) :: mask 
    integer, dimension(6) :: hel_lock 
    type(polarization_t) :: pol1, pol2
    type(quantum_numbers_t), dimension(1) :: qn_fc1, qn_hel1, qn_fc2, qn_hel2
    type(flavor_t) :: flv_photon
    real(default), dimension(2) :: mi2, mr2, mo2
    type(quantum_numbers_t) :: qn_photon, qn1, qn2
    type(quantum_numbers_t), dimension(6) :: qn
    type(state_iterator_t) :: it_hel1, it_hel2
    hel_lock = 0
    mask_h = .false.
    select type (data)
    type is (circe1_data_t)
       mi2 = data%m_in**2
       if (data%photon(1)) then
          hel_lock(1) = 3;  hel_lock(3) = 1;  mask_h(5) = .true.
          mr2(1) = mi2(1)
          mo2(1) = 0._default
       else
          hel_lock(1) = 5;  hel_lock(5) = 1;  mask_h(3) = .true.
          mr2(1) = 0._default
          mo2(1) = mi2(1)
       end if
       if (data%photon(2)) then
          hel_lock(2) = 4;  hel_lock(4) = 2;  mask_h(6) = .true.
          mr2(2) = mi2(2)
          mo2(2) = 0._default
       else
          hel_lock(2) = 6;  hel_lock(6) = 2;  mask_h(4) = .true.
          mr2(2) = 0._default
          mo2(2) = mi2(2)
       end if
       mask = new_quantum_numbers_mask (.false., .false., mask_h)
       call sf_int%base_init (mask, mi2, mr2, mo2, &
            hel_lock = hel_lock)
       sf_int%data => data
       call flavor_init (flv_photon, PHOTON, data%model)
       call quantum_numbers_init (qn_photon, flv_photon)
       call polarization_init_generic (pol1, data%flv_in(1))
       call quantum_numbers_init (qn_fc1(1), flv = data%flv_in(1))
       call polarization_init_generic (pol2, data%flv_in(2))
       call quantum_numbers_init (qn_fc2(1), flv = data%flv_in(2))
       call state_iterator_init (it_hel1, pol1%state)
       
       do while (state_iterator_is_valid (it_hel1)) 
          qn_hel1 = state_iterator_get_quantum_numbers (it_hel1)
          qn1 = qn_hel1(1) .merge. qn_fc1(1) 
          qn(1) = qn1
          if (data%photon(1)) then
             qn(3) = qn1;  qn(5) = qn_photon
          else
             qn(3) = qn_photon;  qn(5) = qn1
          end if
          call state_iterator_init (it_hel2, pol2%state) 
          do while (state_iterator_is_valid (it_hel2)) 
             qn_hel2 = state_iterator_get_quantum_numbers (it_hel2) 
             qn2 = qn_hel2(1) .merge. qn_fc2(1) 
             qn(2) = qn2
             if (data%photon(2)) then
                qn(4) = qn2;  qn(6) = qn_photon
             else
                qn(4) = qn_photon;  qn(6) = qn2
             end if
             call interaction_add_state (sf_int%interaction_t, qn)
             call state_iterator_advance (it_hel2) 
          end do
          call state_iterator_advance (it_hel1)
       end do
       call polarization_final (pol1)
       call polarization_final (pol2)
       call interaction_freeze (sf_int%interaction_t) 
       call sf_int%set_incoming ([1,2])
       call sf_int%set_radiated ([3,4])
       call sf_int%set_outgoing ([5,6])
       sf_int%status = SF_INITIAL
    end select
    if (sf_int%data%generate) then
       call sf_int%data%rng_factory%make (sf_int%rng_obj%rng)
    end if
  end subroutine circe1_init

@ %def circe1_init
@
\subsection{Kinematics}
Refer to the [[data]] component.
<<SF circe1: circe1: TBP>>=
  procedure :: is_generator => circe1_is_generator
<<SF circe1: procedures>>=
  function circe1_is_generator (sf_int) result (flag)
    class(circe1_t), intent(in) :: sf_int
    logical :: flag
    flag = sf_int%data%is_generator ()
  end function circe1_is_generator
  
@ %def circe1_is_generator
@ Generate free parameters, if generator mode is on.  Otherwise, the
parameters will be discarded.
<<SF circe1: circe1: TBP>>=
  procedure :: generate_free => circe1_generate_free
<<SF circe1: procedures>>=
  subroutine circe1_generate_free (sf_int, r, rb,  x_free)
    class(circe1_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(inout) :: x_free

    if (sf_int%data%generate) then
       call circe_generate (r, sf_int%data%get_pdg_int (), sf_int%rng_obj)
       rb = 1 - r
       x_free = x_free * product (r)
    else
       r = 0
       rb= 1
    end if
  end subroutine circe1_generate_free
    
@ %def circe1_generate_free
@ Generator mode: depending on the particle codes, call one of the
available [[girce]] generators.  Illegal particle code combinations
should have been caught during data initialization.
<<SF circe1: procedures>>=
  subroutine circe_generate (x, pdg, rng_obj)
    real(default), dimension(2), intent(out) :: x
    integer, dimension(2), intent(in) :: pdg
    class(rng_obj_t), intent(inout) :: rng_obj
    real(double) :: xc1, xc2
    select case (abs (pdg(1)))
    case (ELECTRON)
       select case (abs (pdg(2)))
       case (ELECTRON)
          call gircee (xc1, xc2, rng_obj = rng_obj)
       case (PHOTON)
          call girceg (xc1, xc2, rng_obj = rng_obj)
       end select
    case (PHOTON)
       select case (abs (pdg(2)))
       case (ELECTRON)
          call girceg (xc2, xc1, rng_obj = rng_obj)
       case (PHOTON)
          call gircgg (xc1, xc2, rng_obj = rng_obj)
       end select
    end select
    x = [xc1, xc2]
  end subroutine circe_generate

@ %def circe_generate
@ Set kinematics.  The $r$ values (either from integration or from the
generator call above) are copied to $x$ unchanged, and $f$ is unity.
We store the $x$ values, so we can use them for the evaluation later.
<<SF circe1: circe1: TBP>>=
  procedure :: complete_kinematics => circe1_complete_kinematics
<<SF circe1: procedures>>=
  subroutine circe1_complete_kinematics (sf_int, x, f, r, rb, map)
    class(circe1_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default), dimension(2) :: xb1
    x = r
    sf_int%x = x
    f = 1
    xb1 = 1 - x
    call sf_int%split_momenta (x, xb1)
    select case (sf_int%status)
    case (SF_FAILED_KINEMATICS);  f = 0
    end select
  end subroutine circe1_complete_kinematics

@ %def circe1_complete_kinematics
@ Compute inverse kinematics.  In generator mode, the $r$ values are
meaningless, but we copy them anyway.
<<SF circe1: circe1: TBP>>=
  procedure :: inverse_kinematics => circe1_inverse_kinematics
<<SF circe1: procedures>>=
  subroutine circe1_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(circe1_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default), dimension(2) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    r = x
    rb = 1 - x
    sf_int%x = x
    f = 1
    if (set_mom) then
       xb1 = 1 - x
       call sf_int%split_momenta (x, xb1)
       select case (sf_int%status)
       case (SF_FAILED_KINEMATICS);  f = 0
       end select
    end if
  end subroutine circe1_inverse_kinematics

@ %def circe1_inverse_kinematics
@  
\subsection{CIRCE1 application} 
CIRCE is applied for the two beams at once.  We can safely assume that no
structure functions are applied before this, so the incoming particles are
on-shell electrons/positrons.

The scale is ignored.
<<SF circe1: circe1: TBP>>= 
  procedure :: apply => circe1_apply
<<SF circe1: procedures>>= 
  subroutine circe1_apply (sf_int, scale)
    class(circe1_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default), dimension(2) :: xb
    real(double), dimension(2) :: xc
    real(double), parameter :: one = 1
    associate (data => sf_int%data)
      xc = sf_int%x
      xb = 1 - sf_int%x
      if (data%generate) then
         sf_int%f = 1
      else
         sf_int%f = 0
         if (all (sf_int%continuum)) then
            sf_int%f = circe (xc(1), xc(2), data%pdg_in(1), data%pdg_in(2))
         end if
         if (sf_int%continuum(2) .and. sf_int%peak(1)) then
            sf_int%f = sf_int%f &
                 + circe (one, xc(2), data%pdg_in(1), data%pdg_in(2)) &
                 * peak (xb(1), data%eps)
         end if
         if (sf_int%continuum(1) .and. sf_int%peak(2)) then
            sf_int%f = sf_int%f &
                 + circe (xc(1), one, data%pdg_in(1), data%pdg_in(2)) &
                 * peak (xb(2), data%eps)
         end if
         if (all (sf_int%peak)) then
            sf_int%f = sf_int%f &
                 + circe (one, one, data%pdg_in(1), data%pdg_in(2)) &
                 * peak (xb(1), data%eps) * peak (xb(2), data%eps)
         end if
      end if
    end associate
    call interaction_set_matrix_element &
        (sf_int%interaction_t, cmplx (sf_int%f, kind=default)) 
    sf_int%status = SF_EVALUATED
  end subroutine circe1_apply
 
@ %def circe1_apply
@ This is a smeared delta peak at zero, as an endpoint singularity.
We choose an exponentially decreasing function, starting at zero, with
integral (from $0$ to $1$) $1-e^{-1/\epsilon}$.  For small $\epsilon$,
this reduces to one.
<<SF circe1: procedures>>=
  function peak (x, eps) result (f)
    real(default), intent(in) :: x, eps
    real(default) :: f
    f = exp (-x / eps) / eps
  end function peak
  
@ %def peak
@
\subsection{Unit tests}
<<SF circe1: public>>=
  public :: sf_circe1_test
<<SF circe1: tests>>=
  subroutine sf_circe1_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF circe1: execute tests>>
  end subroutine sf_circe1_test
  
@ %def sf_circe1_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF circe1: execute tests>>=
  call test (sf_circe1_1, "sf_circe1_1", &
       "structure function configuration", &
       u, results)
<<SF circe1: tests>>=
  subroutine sf_circe1_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(2) :: pdg_out
    integer, dimension(:), allocatable :: pdg1, pdg2
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_circe1_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &CIRCE structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call model%init_qed_test ()
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    allocate (circe1_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    select type (data)
    type is (circe1_data_t)
       call data%init (model, pdg_in, &
            sqrts = 500._default, &
            eps = 1e-6_default, &
            out_photon = [.false., .false.], &
            ver = 0, &
            rev = 0, &
            acc = "SBAND", &
            chat = 0)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    pdg2 = pdg_out(2)
    write (u, "(2x,99(1x,I0))")  pdg1, pdg2

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe1_1"

  end subroutine sf_circe1_1

@ %def sf_circe1_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the PDF builtin
structure function.
<<SF circe1: execute tests>>=
  call test (sf_circe1_2, "sf_circe1_2", &
       "structure function instance", &
       u, results)
<<SF circe1: tests>>=
  subroutine sf_circe1_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    type(vector4_t), dimension(4) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_circe1_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &circe1 structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv(1), ELECTRON, model)
    call flavor_init (flv(2), -ELECTRON, model)
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    call reset_interaction_counter ()
    
    allocate (circe1_data_t :: data)
    select type (data)
    type is (circe1_data_t)
       call data%init (model, pdg_in, &
            sqrts = 500._default, &
            eps = 1e-6_default, &
            out_photon = [.false., .false.], &
            ver = 0, &
            rev = 0, &
            acc = "SBAND", &
            chat = 0)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.95,0.85."
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = [0.9_default, 0.8_default]
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1, 2])

    call sf_int%seed_kinematics ([k1, k2])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)

    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.) 
    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe1_2"

  end subroutine sf_circe1_2

@ %def sf_circe1_2
@
\subsubsection{Generator mode}
Construct and evaluate a structure function object in generator mode.
<<SF circe1: execute tests>>=
  call test (sf_circe1_3, "sf_circe1_3", &
       "generator mode", &
       u, results)
<<SF circe1: tests>>=
  subroutine sf_circe1_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(rng_factory_t), allocatable :: rng_factory
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, x_free
    
    write (u, "(A)")  "* Test output: sf_circe1_3"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &circe1 structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_qed_test ()
    call flavor_init (flv(1), ELECTRON, model)
    call flavor_init (flv(2), -ELECTRON, model)
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    call reset_interaction_counter ()
    
    allocate (circe1_data_t :: data)
    allocate (rng_test_factory_t :: rng_factory)
    select type (data)
    type is (circe1_data_t)
       call data%init (model, pdg_in, &
            sqrts = 500._default, &
            eps = 1e-6_default, &
            out_photon = [.false., .false.], &
            ver = 0, &
            rev = 0, &
            acc = "SBAND", &
            chat = 0)
       call data%set_generator_mode (rng_factory)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])
    select type (sf_int)
    type is (circe1_t)
       call sf_int%rng_obj%rng%init (3)
    end select

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Generate x"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r  = 0
    rb = 0
    x_free = 1
    call sf_int%generate_free (r, rb, x_free)
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe1_3"

  end subroutine sf_circe1_3

@ %def sf_circe1_3
@ 
\clearpage
%------------------------------------------------------------------------
\section{Lepton Collider Beamstrahlung and Photon collider: CIRCE2} 

<<[[sf_circe2.f90]]>>=
<<File header>>

module sf_circe2

<<Use kinds>>
  use kinds, only: double
<<Use strings>>
  use io_units
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use os_interface
  use physics_defs, only: UNDEFINED, PHOTON, ELECTRON
  use lorentz
  use rng_base
  use selectors
  use pdg_arrays
  use model_data
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  use circe2, circe2_rng_t => rng_type !NODEP!

<<Standard module head>>

<<SF circe2: public>>

<<SF circe2: types>>

contains

<<SF circe2: procedures>>

<<SF circe2: tests>>

end module sf_circe2
@ %def sf_circe2
@
\subsection{Physics}
[[CIRCE2]] describes photon spectra
Beamstrahlung is applied before ISR.  The [[CIRCE2]] implementation has
a single structure function for both beams (which makes sense since it
has to be switched on or off for both beams simultaneously).


\subsection{The CIRCE2 data block}
The CIRCE2 parameters are: file and collider specification, incoming
(= outgoing) particles.  The luminosity is returned by [[circe2_luminosity]].
<<SF circe2: public>>=
  public :: circe2_data_t
<<SF circe2: types>>=
  type, extends (sf_data_t) :: circe2_data_t
     private
     class(model_data_t), pointer :: model => null () 
     type(flavor_t), dimension(2) :: flv_in
     integer, dimension(2) :: pdg_in
     real(default) :: sqrts = 0
     logical :: polarized = .false.
     class(rng_factory_t), allocatable :: rng_factory
     type(string_t) :: filename
     type(string_t) :: file 
     type(string_t) :: design 
     real(default) :: lumi = 0
     real(default), dimension(4) :: lumi_hel_frac = 0
     integer, dimension(0:4) :: h1 = [0, -1, -1, 1, 1]
     integer, dimension(0:4) :: h2 = [0, -1,  1,-1, 1]
     integer :: error = 1
   contains
     <<SF circe2: circe2 data: TBP>>
  end type circe2_data_t

@ %def circe2_data_t
<<SF circe2: types>>=
  type(circe2_state) :: circe2_global_state
  
@ 
<<SF circe2: circe2 data: TBP>>=
  procedure :: init => circe2_data_init
<<SF circe2: procedures>>=
  subroutine circe2_data_init &
       (data, os_data, model, pdg_in, sqrts, polarized, file, design)
    class(circe2_data_t), intent(out) :: data
    type(os_data_t), intent(in) :: os_data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), dimension(2), intent(in) :: pdg_in
    real(default), intent(in) :: sqrts
    logical, intent(in) :: polarized
    type(string_t), intent(in) :: file, design
    integer :: h
    data%model => model
    if (any (pdg_array_get_length (pdg_in) /= 1)) then
       call msg_fatal ("CIRCE2: incoming beam particles must be unique")
    end if
    call flavor_init (data%flv_in(1), pdg_array_get (pdg_in(1), 1), model)
    call flavor_init (data%flv_in(2), pdg_array_get (pdg_in(2), 1), model)
    data%pdg_in = flavor_get_pdg (data%flv_in)
    data%sqrts = sqrts
    data%polarized = polarized
    data%filename = file
    data%design = design
    call data%check_file (os_data)
    call circe2_load (circe2_global_state, trim (char(data%file)), &
            trim (char(data%design)), data%sqrts, data%error)
    data%lumi = circe2_luminosity (circe2_global_state, data%pdg_in, [0, 0])
    call data%check ()
    if (data%polarized) then
       do h = 1, 4
          data%lumi_hel_frac(h) = &
               circe2_luminosity (circe2_global_state, data%pdg_in, &
	                          [data%h1(h), data%h2(h)]) &
               / data%lumi
       end do
    end if
  end subroutine circe2_data_init

@ %def circe2_data_init
@ Activate the generator mode.  We import a RNG factory into the data
type, which can then spawn RNG generator objects.
<<SF circe2: circe2 data: TBP>>=
  procedure :: set_generator_mode => circe2_data_set_generator_mode
<<SF circe2: procedures>>=
  subroutine circe2_data_set_generator_mode (data, rng_factory)
    class(circe2_data_t), intent(inout) :: data
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    call move_alloc (from = rng_factory, to = data%rng_factory)
  end subroutine circe2_data_set_generator_mode
  
@ %def circe2_data_set_generator_mode
@ Check whether the requested data file is in the system directory or
in the current directory.
<<SF circe2: circe2 data: TBP>>=
  procedure :: check_file => circe2_check_file
<<SF circe2: procedures>>=
  subroutine circe2_check_file (data, os_data)
    class(circe2_data_t), intent(inout) :: data
    type(os_data_t), intent(in) :: os_data
    logical :: exist
    type(string_t) :: file
    file = data%filename
    inquire (file = char (file), exist = exist)
    if (exist) then
       data%file = file
    else
       file = os_data%whizard_circe2path // "/" // data%filename
       inquire (file = char (file), exist = exist)
       if (exist) then
          data%file = file
       else
          call msg_fatal ("CIRCE2: data file '" // char (data%filename) &
               // "' not found")
       end if
    end if
  end subroutine circe2_check_file
    
@ %def circe2_check_file
@ Handle error conditions.
<<SF circe2: circe2 data: TBP>>= 
  procedure :: check => circe2_data_check 
<<SF circe2: procedures>>= 
  subroutine circe2_data_check (data) 
    class(circe2_data_t), intent(in) :: data 
    type(flavor_t) :: flv_photon, flv_electron
    call flavor_init (flv_photon, PHOTON, data%model)
    if (flavor_get_pdg (flv_photon) == UNDEFINED) then
       call msg_fatal ("CIRCE2: model must contain photon")
    end if
    call flavor_init (flv_electron, ELECTRON, data%model)
    if (flavor_get_pdg (flv_electron) == UNDEFINED) then
       call msg_fatal ("CIRCE2: model must contain electron")
    end if
    if (any (abs (data%pdg_in) /= PHOTON .and. abs (data%pdg_in) /= ELECTRON)) &
         then
       call msg_fatal ("CIRCE2: applicable only for e+e- or photon collisions")
    end if
    select case (data%error)
    case (-1)
       call msg_fatal ("CIRCE2: data file not found.")
    case (-2)
       call msg_fatal ("CIRCE2: beam parameters do not match data file.")
    case (-3)
       call msg_fatal ("CIRCE2: invalid format of data file.")
    case (-4)
       call msg_fatal ("CIRCE2: data file too large.")
    end select
    if (data%lumi == 0) then
       call msg_fatal ("CIRCE2: luminosity vanishes for specified beams.")
    end if
  end subroutine circe2_data_check
  
@ %def circe2_data_check 
@ Output
<<SF circe2: circe2 data: TBP>>=
  procedure :: write => circe2_data_write
<<SF circe2: procedures>>=
  subroutine circe2_data_write (data, unit, verbose) 
    class(circe2_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, h
    u = given_output_unit (unit)
    write (u, "(1x,A)") "CIRCE2 data:"
    write (u, "(3x,A,A)")       "file   = ", char(data%filename)
    write (u, "(3x,A,A)")       "design = ", char(data%design)
    write (u, "(3x,A," // FMT_19 // ")") "sqrts  = ", data%sqrts
    write (u, "(3x,A,A,A,A)")   "prt_in = ", &
         char (flavor_get_name (data%flv_in(1))), &
         ", ", char (flavor_get_name (data%flv_in(2)))    
    write (u, "(3x,A,L1)")      "polarized  = ", data%polarized
    write (u, "(3x,A," // FMT_19 // ")") "luminosity = ", data%lumi
    if (data%polarized) then
       do h = 1, 4
          write (u, "(6x,'(',I2,1x,I2,')',1x,'=',1x)", advance="no") &
               data%h1(h), data%h2(h)
          write (u, "(6x, " // FMT_19 // ")")  data%lumi_hel_frac(h)
       end do
    end if
    call data%rng_factory%write (u)
  end subroutine circe2_data_write
  
@ %def circe2_data_write
@ This is always in generator mode.
<<SF circe2: circe2 data: TBP>>=
  procedure :: is_generator => circe2_data_is_generator
<<SF circe2: procedures>>=
  function circe2_data_is_generator (data) result (flag)
    class(circe2_data_t), intent(in) :: data
    logical :: flag
    flag = .true.
  end function circe2_data_is_generator
  
@ %def circe2_data_is_generator
@ The number of parameters is two, collinear splitting for
the two beams.
<<SF circe2: circe2 data: TBP>>=
  procedure :: get_n_par => circe2_data_get_n_par
<<SF circe2: procedures>>=
  function circe2_data_get_n_par (data) result (n)
    class(circe2_data_t), intent(in) :: data
    integer :: n
    n = 2
  end function circe2_data_get_n_par
  
@ %def circe2_data_get_n_par
@ Return the outgoing particles PDG codes.  They are equal to the
incoming ones.
<<SF circe2: circe2 data: TBP>>=  
  procedure :: get_pdg_out => circe2_data_get_pdg_out
<<SF circe2: procedures>>=
  subroutine circe2_data_get_pdg_out (data, pdg_out)
    class(circe2_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer :: i, n
    n = 2
    do i = 1, n
       pdg_out(i) = data%pdg_in(i)
    end do
  end subroutine circe2_data_get_pdg_out
  
@ %def circe2_data_get_pdg_out
@ Allocate the interaction record.
<<SF circe2: circe2 data: TBP>>=
  procedure :: allocate_sf_int => circe2_data_allocate_sf_int
<<SF circe2: procedures>>=
  subroutine circe2_data_allocate_sf_int (data, sf_int)
    class(circe2_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (circe2_t :: sf_int)
  end subroutine circe2_data_allocate_sf_int
  
@ %def circe2_data_allocate_sf_int 
@
\subsection{Random Number Generator for CIRCE}
The CIRCE implementation now supports a generic random-number
generator object that allows for a local state as a component.  To
support this, we must extend the abstract type provided by CIRCE and
delegate the generator call to the (also abstract) RNG used by WHIZARD.
<<SF circe2: types>>=
  type, extends (circe2_rng_t) :: rng_obj_t
     class(rng_t), allocatable :: rng
   contains
     procedure :: generate => rng_obj_generate
  end type rng_obj_t
  
@ %def rng_obj_t
<<SF circe2: procedures>>=
  subroutine rng_obj_generate (rng_obj, u)
    class(rng_obj_t), intent(inout) :: rng_obj
    real(default), intent(out) :: u
    real(default) :: x
    call rng_obj%rng%generate (x)
    u = x
  end subroutine rng_obj_generate

@ %def rng_obj_generate
@ 
\subsection{The CIRCE2 object}
For CIRCE2 spectra it does not make sense to describe the state matrix
as a radiation interaction, even if photons originate from laser
backscattering.  Instead, it is a $2\to 2$ interaction where the
incoming particles are identical to the outgoing ones.

The current implementation of CIRCE2 does support polarization and
classical correlations, but no entanglement, so the density matrix of
the outgoing particles is diagonal.  The incoming particles are
unpolarized (user-defined polarization for beams is meaningless, since
polarization is described by the data file).  The outgoing particles
are polarized or polarization-averaged, depending on user request.

When assigning matrix elements, we scan the previously initialized
state matrix.  For each entry, we extract helicity and call the
structure function.  In the unpolarized case, the helicity is
undefined and replaced by value zero.  In the polarized case, there
are four entries.  If the generator is used, only one entry is nonzero
in each call.  Which one, is determined by comparing with a previously
(randomly, distributed by relative luminosity) selected pair of
helicities.
<<SF circe2: types>>=
  type, extends (sf_int_t) :: circe2_t
     type(circe2_data_t), pointer :: data => null ()
     type(rng_obj_t) :: rng_obj
     type(selector_t) :: selector
     integer :: h_sel = 0
   contains
   <<SF circe2: circe2: TBP>>
  end type circe2_t 
  
@ %def circe2_t
@ Type string: show file and design of [[CIRCE2]] structure function.
<<SF circe2: circe2: TBP>>=
  procedure :: type_string => circe2_type_string
<<SF circe2: procedures>>=
  function circe2_type_string (object) result (string)
    class(circe2_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "CIRCE2: " // object%data%design
    else
       string = "CIRCE2: [undefined]"
    end if
  end function circe2_type_string
  
@ %def circe2_type_string
@
@ Output.  Call the interaction routine after displaying the configuration.
<<SF circe2: circe2: TBP>>=
  procedure :: write => circe2_write
<<SF circe2: procedures>>=
  subroutine circe2_write (object, unit, testflag)
    class(circe2_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "CIRCE2 data: [undefined]"
    end if
  end subroutine circe2_write
    
@ %def circe2_write
@
<<SF circe2: circe2: TBP>>=
  procedure :: init => circe2_init
<<SF circe2: procedures>>=
  subroutine circe2_init (sf_int, data)
    class(circe2_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    logical, dimension(4) :: mask_h
    real(default), dimension(0) :: null_array
    type(quantum_numbers_mask_t), dimension(4) :: mask
    type(quantum_numbers_t), dimension(4) :: qn
    type(helicity_t) :: hel
    integer :: h
    select type (data)
    type is (circe2_data_t)
       mask_h(1:2) = .true.
       mask_h(3:4) = .not. data%polarized       
       mask = new_quantum_numbers_mask (.false., .false., mask_h)
       call sf_int%base_init (mask, [0._default, 0._default], &
            null_array, [0._default, 0._default])    
       sf_int%data => data              
       if (data%polarized) then
          call sf_int%selector%init (data%lumi_hel_frac)
       end if
       call quantum_numbers_init (qn(1), flv = data%flv_in(1))
       call quantum_numbers_init (qn(2), flv = data%flv_in(2))
       if (data%polarized) then
          do h = 1, 4
             call helicity_init (hel, data%h1(h))
             call quantum_numbers_init (qn(3), flv = data%flv_in(1), hel = hel)
             call helicity_init (hel, data%h2(h))
             call quantum_numbers_init (qn(4), flv = data%flv_in(2), hel = hel)
             call interaction_add_state (sf_int%interaction_t, qn)
          end do
       else
          call quantum_numbers_init (qn(3), flv = data%flv_in(1))
          call quantum_numbers_init (qn(4), flv = data%flv_in(2))
          call interaction_add_state (sf_int%interaction_t, qn)
       end if
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1,2])
       call sf_int%set_outgoing ([3,4])
       call sf_int%data%rng_factory%make (sf_int%rng_obj%rng)
       sf_int%status = SF_INITIAL
    end select
  end subroutine circe2_init

@ %def circe2_init
@
\subsection{Kinematics}
Refer to the [[data]] component.
<<SF circe2: circe2: TBP>>=
  procedure :: is_generator => circe2_is_generator
<<SF circe2: procedures>>=
  function circe2_is_generator (sf_int) result (flag)
    class(circe2_t), intent(in) :: sf_int
    logical :: flag
    flag = sf_int%data%is_generator ()
  end function circe2_is_generator
  
@ %def circe2_is_generator
@ Generate free parameters.  We first select a helicity, which we have
to store, then generate $x$ values for that helicity.
<<SF circe2: circe2: TBP>>=
  procedure :: generate_free => circe2_generate_whizard_free
<<SF circe2: procedures>>=
  subroutine circe2_generate_whizard_free (sf_int, r, rb, x_free)
    class(circe2_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(inout) :: x_free
    integer :: h_sel
    if (sf_int%data%polarized) then
       call sf_int%selector%generate (sf_int%rng_obj%rng, h_sel)
    else
       h_sel = 0
    end if
    sf_int%h_sel = h_sel
    call circe2_generate_whizard (r, sf_int%data%pdg_in, &
         [sf_int%data%h1(h_sel), sf_int%data%h2(h_sel)], &
         sf_int%rng_obj)
    rb = 1 - r
    x_free = x_free * product (r)
  end subroutine circe2_generate_whizard_free
    
@ %def circe2_generate_whizard_free
@ Generator mode: call the CIRCE2 generator for the given particles
and helicities.  (For unpolarized generation, helicities are zero.)
<<SF circe2: procedures>>=
  subroutine circe2_generate_whizard (x, pdg, hel, rng_obj)
    real(default), dimension(2), intent(out) :: x
    integer, dimension(2), intent(in) :: pdg
    integer, dimension(2), intent(in) :: hel
    class(rng_obj_t), intent(inout) :: rng_obj
    call circe2_generate (circe2_global_state, rng_obj, x, pdg, hel)
  end subroutine circe2_generate_whizard

@ %def circe2_generate_whizard
@ Set kinematics.  Trivial here.
<<SF circe2: circe2: TBP>>=
  procedure :: complete_kinematics => circe2_complete_kinematics
<<SF circe2: procedures>>=
  subroutine circe2_complete_kinematics (sf_int, x, f, r, rb, map)
    class(circe2_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    if (map) then
       call msg_fatal ("CIRCE2: map flag not supported")
    else
       x = r
       f = 1
    end if
    call sf_int%reduce_momenta (x)
  end subroutine circe2_complete_kinematics

@ %def circe2_complete_kinematics
@ Compute inverse kinematics.
<<SF circe2: circe2: TBP>>=
  procedure :: inverse_kinematics => circe2_inverse_kinematics
<<SF circe2: procedures>>=
  subroutine circe2_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(circe2_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       call msg_fatal ("CIRCE2: map flag not supported")
    else
       r = x
       rb= 1 - r
       f = 1
    end if
    if (set_mom) then
       call sf_int%reduce_momenta (x)
    end if
  end subroutine circe2_inverse_kinematics

@ %def circe2_inverse_kinematics
@
\subsection{CIRCE2 application}
This function works on both beams.  In polarized mode, we set only the
selected helicity.  In unpolarized mode,
the interaction has only one entry, and the factor is unity.
<<SF circe2: circe2: TBP>>=
  procedure :: apply => circe2_apply
<<SF circe2: procedures>>=
  subroutine circe2_apply (sf_int, scale)
    class(circe2_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale    
    complex(default) :: f
    integer :: h
    associate (data => sf_int%data)
      f = 1
      if (data%polarized) then
         h = sf_int%h_sel
      else
         h = 1
      end if
      call interaction_set_matrix_element (sf_int%interaction_t, h, f)
    end associate
    sf_int%status = SF_EVALUATED
  end subroutine circe2_apply

@ %def circe2_apply
@
\subsection{Unit tests}
<<SF circe2: public>>=
  public :: sf_circe2_test
<<SF circe2: tests>>=
  subroutine sf_circe2_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF circe2: execute tests>>
  end subroutine sf_circe2_test
  
@ %def sf_circe2_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF circe2: execute tests>>=
  call test (sf_circe2_1, "sf_circe2_1", &
       "structure function configuration", &
       u, results)
<<SF circe2: tests>>=
  subroutine sf_circe2_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(2) :: pdg_out
    integer, dimension(:), allocatable :: pdg1, pdg2
    class(sf_data_t), allocatable :: data
    class(rng_factory_t), allocatable :: rng_factory
    
    write (u, "(A)")  "* Test output: sf_circe2_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &CIRCE structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_qed_test ()
    pdg_in(1) = PHOTON
    pdg_in(2) = PHOTON

    allocate (circe2_data_t :: data)
    allocate (rng_test_factory_t :: rng_factory)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize (unpolarized)"
    write (u, "(A)")

    select type (data)
    type is (circe2_data_t)
       call data%init (os_data, model, pdg_in, &
            sqrts = 500._default, &
            polarized = .false., &
            file = var_str ("teslagg_500_polavg.circe"), &
            design = var_str ("TESLA/GG"))
       call data%set_generator_mode (rng_factory)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    pdg2 = pdg_out(2)
    write (u, "(2x,99(1x,I0))")  pdg1, pdg2

    write (u, "(A)")
    write (u, "(A)")  "* Initialize (polarized)"
    write (u, "(A)")

    allocate (rng_test_factory_t :: rng_factory)

    select type (data)
    type is (circe2_data_t)
       call data%init (os_data, model, pdg_in, &
            sqrts = 500._default, &
            polarized = .true., &
            file = var_str ("teslagg_500.circe"), &
            design = var_str ("TESLA/GG"))
       call data%set_generator_mode (rng_factory)
    end select

    call data%write (u)

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe2_1"

  end subroutine sf_circe2_1

@ %def sf_circe2_1
@
\subsubsection{Generator mode, unpolarized}
Construct and evaluate a structure function object in generator mode.
<<SF circe2: execute tests>>=
  call test (sf_circe2_2, "sf_circe2_2", &
       "generator, unpolarized", &
       u, results)
<<SF circe2: tests>>=
  subroutine sf_circe2_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(rng_factory_t), allocatable :: rng_factory
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, x_free
    
    write (u, "(A)")  "* Test output: sf_circe2_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &circe2 structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_qed_test ()
    call flavor_init (flv(1), PHOTON, model)
    call flavor_init (flv(2), PHOTON, model)
    pdg_in(1) = PHOTON
    pdg_in(2) = PHOTON

    call reset_interaction_counter ()
    
    allocate (circe2_data_t :: data)
    allocate (rng_test_factory_t :: rng_factory)
    select type (data)
    type is (circe2_data_t)
       call data%init (os_data, model, pdg_in, &
            sqrts = 500._default, &
            polarized = .false., &
            file = var_str ("teslagg_500_polavg.circe"), &
            design = var_str ("TESLA/GG"))
       call data%set_generator_mode (rng_factory)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])
    select type (sf_int)
    type is (circe2_t)
       call sf_int%rng_obj%rng%init (3)
    end select

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Generate x"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r  = 0
    rb = 0
    x_free = 1
    call sf_int%generate_free (r, rb, x_free)
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe2_2"

  end subroutine sf_circe2_2

@ %def sf_circe2_2
@
\subsubsection{Generator mode, polarized}
Construct and evaluate a structure function object in generator mode.
<<SF circe2: execute tests>>=
  call test (sf_circe2_3, "sf_circe2_3", &
       "generator, polarized", &
       u, results)
<<SF circe2: tests>>=
  subroutine sf_circe2_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(rng_factory_t), allocatable :: rng_factory
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, x_free
    
    write (u, "(A)")  "* Test output: sf_circe2_3"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &circe2 structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_qed_test ()
    call flavor_init (flv(1), PHOTON, model)
    call flavor_init (flv(2), PHOTON, model)
    pdg_in(1) = PHOTON
    pdg_in(2) = PHOTON

    call reset_interaction_counter ()
    
    allocate (circe2_data_t :: data)
    allocate (rng_test_factory_t :: rng_factory)
    select type (data)
    type is (circe2_data_t)
       call data%init (os_data, model, pdg_in, &
            sqrts = 500._default, &
            polarized = .true., &
            file = var_str ("teslagg_500.circe"), &
            design = var_str ("TESLA/GG"))
       call data%set_generator_mode (rng_factory)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])
    select type (sf_int)
    type is (circe2_t)
       call sf_int%rng_obj%rng%init (3)
    end select

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Generate x"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r  = 0
    rb = 0
    x_free = 1
    call sf_int%generate_free (r, rb, x_free)
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_circe2_3"

  end subroutine sf_circe2_3

@ %def sf_circe2_3
@ 
\clearpage
%------------------------------------------------------------------------
\section{Energy-scan spectrum}

This spectrum is actually a trick that allows us to plot the c.m.\ energy
dependence of a cross section without scanning the input energy.  We
start with the observation that a spectrum $f(x)$, applied to one of
the incoming beams only, results in a cross section
\begin{equation}
  \sigma = \int dx\,f(x)\,\hat\sigma(xs).
\end{equation}
We want to compute the distribution of $E=\sqrt{\hat s}=\sqrt{xs}$, i.e.,
\begin{equation}
  \frac{d\sigma}{dE} = \frac{2\sqrt{x}}{\sqrt{s}}\,\frac{d\sigma}{dx}
  = \frac{2\sqrt{x}}{\sqrt{s}}\,f(x)\,\hat\sigma(xs),
\end{equation}
so if we set
\begin{equation}
  f(x) = \frac{\sqrt{s}}{2\sqrt{x}},
\end{equation}
we get the distribution
\begin{equation}
  \frac{d\sigma}{dE} = \hat\sigma(\hat s=E^2).
\end{equation}
We implement this as a spectrum with a single parameter $x$.  The
parameters for the individual beams are computed as $x_i=\sqrt{x}$, so
they are equal and the kinematics is always symmetric.
<<[[sf_escan.f90]]>>=
<<File header>>

module sf_escan

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_defs, only: FMT_12
  use unit_tests
  use diagnostics
  use lorentz
  use physics_defs, only: ELECTRON
  use pdg_arrays
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  
<<Standard module head>>

<<SF escan: public>>

<<SF escan: types>>

contains

<<SF escan: procedures>>

<<SF escan: tests>>

end module sf_escan
@ %def sf_escan
@ 
\subsection{Data type}
The [[norm]] is unity if the total cross section should be normalized
to one, and $\sqrt{s}$ if it should be normalized to the total
energy.  In the latter case, the differential distribution
$d\sigma/d\sqrt{\hat s}$ coincides with the partonic cross section
$\hat\sigma$ as a function of $\sqrt{\hat s}$.
<<SF escan: public>>=
  public :: escan_data_t
<<SF escan: types>>=
  type, extends(sf_data_t) :: escan_data_t
     private
     type(flavor_t), dimension(:,:), allocatable :: flv_in
     integer, dimension(2) :: n_flv = 0
     real(default) :: norm = 1
   contains
   <<SF escan: escan data: TBP>>  
  end type escan_data_t

@  %def escan_data_t
<<SF escan: escan data: TBP>>=
  procedure :: init => escan_data_init
<<SF escan: procedures>>=
  subroutine escan_data_init (data, model, pdg_in, norm)
    class(escan_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), dimension(2), intent(in) :: pdg_in
    real(default), intent(in), optional :: norm
    real(default), dimension(2) :: m2
    integer :: i, j
    data%n_flv = pdg_array_get_length (pdg_in)
    allocate (data%flv_in (maxval (data%n_flv), 2))
    do i = 1, 2
       do j = 1, data%n_flv(i)
          call flavor_init (data%flv_in(j, i), pdg_array_get (pdg_in(i), j), &
               model)
       end do
    end do
    m2 = flavor_get_mass (data%flv_in(1,:))
    do i = 1, 2
       if (any (flavor_get_mass (data%flv_in(1:data%n_flv(i),i)) /= m2(i))) then
          call msg_fatal ("Energy scan: incoming particle mass must be uniform")
       end if
    end do
    if (present (norm))  data%norm = norm
  end subroutine escan_data_init

@ %def escan_data_init
@ Output
<<SF escan: escan data: TBP>>=
  procedure :: write => escan_data_write
<<SF escan: procedures>>=
  subroutine escan_data_write (data, unit, verbose) 
    class(escan_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, i, j
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "Energy-scan data:"
    write (u, "(3x,A)", advance="no")  "prt_in = "
    do i = 1, 2
       if (i > 1)  write (u, "(',',1x)", advance="no")
       do j = 1, data%n_flv(i)
          if (j > 1)  write (u, "(':')", advance="no")
          write (u, "(A)", advance="no") &
               char (flavor_get_name (data%flv_in(j,i)))
       end do
    end do
    write (u, *)
    write (u, "(3x,A," // FMT_12 // ")")  "norm   =", data%norm
  end subroutine escan_data_write

@ %def escan_data_write
@ Kinematics is completely collinear, hence there is only one
parameter for a pair spectrum. 
<<SF escan: escan data: TBP>>=
  procedure :: get_n_par => escan_data_get_n_par
<<SF escan: procedures>>=
  function escan_data_get_n_par (data) result (n)
    class(escan_data_t), intent(in) :: data
    integer :: n
    n = 1
  end function escan_data_get_n_par
  
@ %def escan_data_get_n_par
@ Return the outgoing particles PDG codes. This is always the same as
the incoming particle, where we use two indices for the two beams.
<<SF escan: escan data: TBP>>=  
  procedure :: get_pdg_out => escan_data_get_pdg_out
<<SF escan: procedures>>=
  subroutine escan_data_get_pdg_out (data, pdg_out)
    class(escan_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer :: i, n
    n = 2
    do i = 1, n
       pdg_out(i) = flavor_get_pdg (data%flv_in(1:data%n_flv(i),i))
    end do
  end subroutine escan_data_get_pdg_out
  
@ %def escan_data_get_pdg_out
@ Allocate the interaction record.
<<SF escan: escan data: TBP>>=
  procedure :: allocate_sf_int => escan_data_allocate_sf_int
<<SF escan: procedures>>=
  subroutine escan_data_allocate_sf_int (data, sf_int)
    class(escan_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (escan_t :: sf_int)
  end subroutine escan_data_allocate_sf_int
  
@ %def escan_data_allocate_sf_int 
@
\subsection{The Energy-scan object}
This is a spectrum, not a radiation.  We create an interaction with
two incoming and two outgoing particles, flavor, color, and helicity
being carried through. $x$ nevertheless is only one-dimensional, as we
are always using only one beam parameter.
<<SF escan: types>>=
  type, extends (sf_int_t) :: escan_t
     type(escan_data_t), pointer :: data => null ()
   contains
   <<SF escan: escan: TBP>>
  end type escan_t 
  
@ %def escan_t
@ Type string: for the energy scan this is just a dummy function.
<<SF escan: escan: TBP>>=
  procedure :: type_string => escan_type_string
<<SF escan: procedures>>=
  function escan_type_string (object) result (string)
    class(escan_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "Escan: energy scan" 
    else
       string = "Escan: [undefined]"
    end if
  end function escan_type_string
  
@ %def escan_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF escan: escan: TBP>>=
  procedure :: write => escan_write
<<SF escan: procedures>>=
  subroutine escan_write (object, unit, testflag)
    class(escan_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "Energy scan data: [undefined]"
    end if
  end subroutine escan_write
    
@ %def escan_write
@
<<SF escan: escan: TBP>>=
  procedure :: init => escan_init
<<SF escan: procedures>>=
  subroutine escan_init (sf_int, data)
    class(escan_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(4) :: mask
    integer, dimension(4) :: hel_lock
    real(default), dimension(2) :: m2
    real(default), dimension(0) :: mr2
    type(quantum_numbers_t), dimension(4) :: qn_fc, qn_hel, qn
    type(polarization_t) :: pol1, pol2
    type(state_iterator_t) :: it_hel1, it_hel2
    integer :: j1, j2
    select type (data)
    type is (escan_data_t)
       hel_lock = [3, 4, 1, 2]
       m2 = flavor_get_mass (data%flv_in(1,:))
       call sf_int%base_init (mask, m2, mr2, m2, hel_lock = hel_lock)
       sf_int%data => data       
       do j1 = 1, data%n_flv(1)
          call quantum_numbers_init (qn_fc(1), &
               flv = data%flv_in(j1,1), &
               col = color_from_flavor (data%flv_in(j1,1)))
          call quantum_numbers_init (qn_fc(3), &
               flv = data%flv_in(j1,1), &
               col = color_from_flavor (data%flv_in(j1,1)))
          call polarization_init_generic (pol1, data%flv_in(j1,1))
          do j2 = 1, data%n_flv(2)
             call quantum_numbers_init (qn_fc(2), &
                  flv = data%flv_in(j2,2), &
                  col = color_from_flavor (data%flv_in(j2,2)))
             call quantum_numbers_init (qn_fc(4), &
                  flv = data%flv_in(j2,2), &
                  col = color_from_flavor (data%flv_in(j2,2)))
             call polarization_init_generic (pol2, data%flv_in(j2,2))
             call state_iterator_init (it_hel1, pol1%state)
             do while (state_iterator_is_valid (it_hel1))
                qn_hel(1:1) = state_iterator_get_quantum_numbers (it_hel1)
                qn_hel(3:3) = state_iterator_get_quantum_numbers (it_hel1)
                call state_iterator_init (it_hel2, pol2%state)
                do while (state_iterator_is_valid (it_hel2))
                   qn_hel(2:2) = state_iterator_get_quantum_numbers (it_hel2)
                   qn_hel(4:4) = state_iterator_get_quantum_numbers (it_hel2)
                   qn = qn_hel .merge. qn_fc
                   call interaction_add_state (sf_int%interaction_t, qn)
                   call state_iterator_advance (it_hel2)
                end do
                call state_iterator_advance (it_hel1)
             end do
             call polarization_final (pol2)
          end do
          call polarization_final (pol1)
       end do
       call sf_int%set_incoming ([1,2])
       call sf_int%set_outgoing ([3,4])
       call interaction_freeze (sf_int%interaction_t)       
       sf_int%status = SF_INITIAL
    end select
  end subroutine escan_init
    
@ %def escan_init
@
\subsection{Kinematics}
Set kinematics.  We have a single parameter, but reduce both beams.
The [[map]] flag is ignored.
<<SF escan: escan: TBP>>=
  procedure :: complete_kinematics => escan_complete_kinematics
<<SF escan: procedures>>=
  subroutine escan_complete_kinematics (sf_int, x, f, r, rb, map)
    class(escan_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default) :: sqrt_x
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    x = r
    sqrt_x = sqrt (x(1))
    if (sqrt_x > 0) then
       f = 1 / (2 * sqrt_x)
    else
       f = 0
       sf_int%status = SF_FAILED_KINEMATICS
       return
    end if
    call sf_int%reduce_momenta ([sqrt_x, sqrt_x])
  end subroutine escan_complete_kinematics

@ %def escan_complete_kinematics
@ Recover $x$.  The base procedure should return two momentum
fractions for the two beams, while we have only one parameter.  This
is the product of the extracted momentum fractions.
<<SF escan: escan: TBP>>=
  procedure :: recover_x => escan_recover_x
<<SF escan: procedures>>=
  subroutine escan_recover_x (sf_int, x, x_free)
    class(escan_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: xi
    call sf_int%base_recover_x (xi, x_free)
    x = product (xi)
  end subroutine escan_recover_x
  
@ %def escan_recover_x
@ Compute inverse kinematics.
<<SF escan: escan: TBP>>=
  procedure :: inverse_kinematics => escan_inverse_kinematics
<<SF escan: procedures>>=
  subroutine escan_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(escan_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: sqrt_x
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    sqrt_x = sqrt (x(1))
    if (sqrt_x > 0) then
       f = 1 / (2 * sqrt_x)
    else
       f = 0
       sf_int%status = SF_FAILED_KINEMATICS
       return
    end if
    r = x
    rb = 1 - r
    if (set_mom) then
       call sf_int%reduce_momenta ([sqrt_x, sqrt_x])
    end if
  end subroutine escan_inverse_kinematics

@ %def escan_inverse_kinematics
@
\subsection{Energy scan application}
Here, we insert the predefined norm.
<<SF escan: escan: TBP>>=
  procedure :: apply => escan_apply
<<SF escan: procedures>>=
  subroutine escan_apply (sf_int, scale)
    class(escan_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: f
    associate (data => sf_int%data)
      f = data%norm
    end associate
    call interaction_set_matrix_element (sf_int%interaction_t, &
         cmplx (f, kind=default))    
    sf_int%status = SF_EVALUATED
  end subroutine escan_apply

@ %def escan_apply
@
\subsection{Unit tests}
<<SF escan: public>>=
  public :: sf_escan_test
<<SF escan: tests>>=
  subroutine sf_escan_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF escan: execute tests>>
  end subroutine sf_escan_test
  
@ %def sf_escan_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF escan: execute tests>>=
  call test (sf_escan_1, "sf_escan_1", &
       "structure function configuration", &
       u, results)
<<SF escan: tests>>=
  subroutine sf_escan_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(2) :: pdg_out
    integer, dimension(:), allocatable :: pdg1, pdg2
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_escan_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &energy-scan structure function data"
    write (u, "(A)")
    
    call model%init_qed_test ()
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    allocate (escan_data_t :: data)
    select type (data)
    type is (escan_data_t)
       call data%init (model, pdg_in, norm = 2._default)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    pdg2 = pdg_out(2)
    write (u, "(2x,99(1x,I0))")  pdg1, pdg2

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_escan_1"

  end subroutine sf_escan_1

@ %def sf_escan_1
g@
\subsubsection{Probe the structure-function object}
Active the beam event reader, generate an event.
<<SF escan: execute tests>>=
  call test (sf_escan_2, "sf_escan_2", &
       "generate event", &
       u, results)
<<SF escan: tests>>=
  subroutine sf_escan_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: x_free, f
    
    write (u, "(A)")  "* Test output: sf_escan_2"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &beam-events structure function data"
    write (u, "(A)")
    
    call model%init_qed_test ()
    call flavor_init (flv(1), ELECTRON, model)
    call flavor_init (flv(2), -ELECTRON, model)
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    call reset_interaction_counter ()
    
    allocate (escan_data_t :: data)
    select type (data)
    type is (escan_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Set dummy parameters and generate x"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r  = 0.8
    rb = 1 - r
    x_free = 1

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call sf_int%recover_x (x, x_free)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_escan_2"

  end subroutine sf_escan_2

@ %def sf_escan_2
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using beam event data}

Instead of an analytic beam description, beam data may be provided in
form of an event file.  In its most simple form, the event file
contains pairs of $x$ values, relative to nominal beam energies.  More
advanced formats may include polarization, etc.  The current
implementation carries beam polarization through, if specified.

The code is very similar to the energy scan described above.
<<[[sf_beam_events.f90]]>>=
<<File header>>

module sf_beam_events

<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use physics_defs, only: ELECTRON
  use lorentz
  use pdg_arrays
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base

<<Standard module head>>

<<SF beam events: public>>

<<SF beam events: types>>

contains

<<SF beam events: procedures>>

<<SF beam events: tests>>

end module sf_beam_events
@ %def sf_beam_events
@ 
\subsection{Data type}
<<SF beam events: public>>=
  public :: beam_events_data_t
<<SF beam events: types>>=
  type, extends(sf_data_t) :: beam_events_data_t
     private
     type(flavor_t), dimension(2) :: flv_in
     type(string_t) :: dir
     type(string_t) :: file
     integer :: unit = 0
     logical :: warn_eof = .true.
   contains
   <<SF beam events: beam events data: TBP>>
  end type beam_events_data_t

@  %def beam_events_data_t
<<SF beam events: beam events data: TBP>>=
  procedure :: init => beam_events_data_init
<<SF beam events: procedures>>=
  subroutine beam_events_data_init (data, model, pdg_in, dir, file, warn_eof)
    class(beam_events_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), dimension(2), intent(in) :: pdg_in
    type(string_t), intent(in) :: dir
    type(string_t), intent(in) :: file
    logical, intent(in), optional :: warn_eof
    if (any (pdg_array_get_length (pdg_in) /= 1)) then
       call msg_fatal ("Beam events: incoming beam particles must be unique")
    end if
    call flavor_init (data%flv_in(1), pdg_array_get (pdg_in(1), 1), model)
    call flavor_init (data%flv_in(2), pdg_array_get (pdg_in(2), 1), model)
    data%dir = dir
    data%file = file
    if (present (warn_eof))  data%warn_eof = warn_eof
  end subroutine beam_events_data_init

@ %def beam_events_data_init
@ Return true since this spectrum is always in generator mode.
<<SF beam events: beam events data: TBP>>=
  procedure :: is_generator => beam_events_data_is_generator
<<SF beam events: procedures>>=
  function beam_events_data_is_generator (data) result (flag)
    class(beam_events_data_t), intent(in) :: data
    logical :: flag
    flag = .true.
  end function beam_events_data_is_generator
  
@ %def beam_events_data_is_generator
@ The number of parameters is two.  They are free parameters.
<<SF beam events: beam events data: TBP>>=
  procedure :: get_n_par => beam_events_data_get_n_par
<<SF beam events: procedures>>=
  function beam_events_data_get_n_par (data) result (n)
    class(beam_events_data_t), intent(in) :: data
    integer :: n
    n = 2
  end function beam_events_data_get_n_par
  
@ %def beam_events_data_get_n_par
<<SF beam events: beam events data: TBP>>=  
  procedure :: get_pdg_out => beam_events_data_get_pdg_out
<<SF beam events: procedures>>=
  subroutine beam_events_data_get_pdg_out (data, pdg_out)
    class(beam_events_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer :: i, n
    n = 2
    do i = 1, n
       pdg_out(i) = flavor_get_pdg (data%flv_in(i))
    end do
  end subroutine beam_events_data_get_pdg_out
  
@ %def beam_events_data_get_pdg_out
@ Allocate the interaction record.
<<SF beam events: beam events data: TBP>>=
  procedure :: allocate_sf_int => beam_events_data_allocate_sf_int
<<SF beam events: procedures>>=
  subroutine beam_events_data_allocate_sf_int (data, sf_int)
    class(beam_events_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (beam_events_t :: sf_int)
  end subroutine beam_events_data_allocate_sf_int
  
@ %def beam_events_data_allocate_sf_int 
@ Output
<<SF beam events: beam events data: TBP>>=
  procedure :: write => beam_events_data_write
<<SF beam events: procedures>>=
  subroutine beam_events_data_write (data, unit, verbose) 
    class(beam_events_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose        
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "Beam-event file data:"
    write (u, "(3x,A,A,A,A)") "prt_in = ", &
         char (flavor_get_name (data%flv_in(1))), &
         ", ", char (flavor_get_name (data%flv_in(2)))    
    write (u, "(3x,A,A,A)") "file   = '", char (data%file), "'"
    write (u, "(3x,A,I0)")  "unit   = ", data%unit
    write (u, "(3x,A,L1)")  "warn   = ", data%warn_eof
  end subroutine beam_events_data_write

@ %def beam_events_data_write
@ The data file needs to be opened and closed explicitly:
<<SF beam events: beam events data: TBP>>=
  procedure :: open => beam_events_data_open
  procedure :: close => beam_events_data_close
<<SF beam events: procedures>>=
  subroutine beam_events_data_open (data)
    class(beam_events_data_t), intent(inout) :: data
    type(string_t) :: filename
    logical :: exist
    if (data%unit == 0) then
       filename = data%file
       if (filename == "") &
            call msg_fatal ("Beam events: $beam_events_file is not set")
       inquire (file = char (filename), exist = exist)
       if (exist) then
          call msg_message ("Beam events: reading from file '" &
               // char (data%file) // "'")
          data%unit = free_unit ()
          open (unit = data%unit, file = char (filename), action = "read", &
               status = "old")
       else
          filename = data%dir // "/" // data%file
          inquire (file = char (filename), exist = exist)
          if (exist) then
             call msg_message ("Beam events: reading from file '" &
                  // char (data%file) // "'")
             data%unit = free_unit ()
             open (unit = data%unit, file = char (filename), action = "read", &
                  status = "old")
          else
             call msg_fatal ("Beam events: file '" &
                  // char (data%file) // "' not found")
          end if
       end if
    else
       call msg_bug ("Beam events: file '" &
         // char (data%file) // "' is already open")
    end if
  end subroutine beam_events_data_open

  subroutine beam_events_data_close (data)
    class(beam_events_data_t), intent(inout) :: data
    if (data%unit /= 0) then
       close (data%unit)
       call msg_message ("Beam events: closed file '" &
         // char (data%file) // "'")
       data%unit = 0
    end if
  end subroutine beam_events_data_close

@ %def beam_events_data_close
@
\subsection{The beam events object}
Flavor and polarization carried through, no radiated particles.
<<SF beam events: types>>=
  type, extends (sf_int_t) :: beam_events_t
     type(beam_events_data_t), pointer :: data => null ()
     integer :: count = 0
   contains
   <<SF beam events: beam events: TBP>>
  end type beam_events_t 
  
@ %def beam_events_t
@ Type string: show beam events file.
<<SF beam events: beam events: TBP>>=
  procedure :: type_string => beam_events_type_string
<<SF beam events: procedures>>=
  function beam_events_type_string (object) result (string)
    class(beam_events_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "Beam events: " // object%data%file 
    else
       string = "Beam events: [undefined]"
    end if
  end function beam_events_type_string
  
@ %def beam_events_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF beam events: beam events: TBP>>=
  procedure :: write => beam_events_write
<<SF beam events: procedures>>=
  subroutine beam_events_write (object, unit, testflag)
    class(beam_events_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "Beam events data: [undefined]"
    end if
  end subroutine beam_events_write
    
@ %def beam_events_write
@
<<SF beam events: beam events: TBP>>=
  procedure :: init => beam_events_init
<<SF beam events: procedures>>=
  subroutine beam_events_init (sf_int, data)
    class(beam_events_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    real(default), dimension(2) :: m2
    real(default), dimension(0) :: mr2
    type(quantum_numbers_mask_t), dimension(4) :: mask
    integer, dimension(4) :: hel_lock
    type(quantum_numbers_t), dimension(4) :: qn_fc, qn_hel, qn
    type(polarization_t) :: pol1, pol2
    type(state_iterator_t) :: it_hel1, it_hel2
    integer :: i
    select type (data)
    type is (beam_events_data_t)
       m2 = flavor_get_mass (data%flv_in) ** 2
       hel_lock = [3, 4, 1, 2]
       mask = new_quantum_numbers_mask (.false., .false., .false.)
       call sf_int%base_init (mask, m2, mr2, m2, hel_lock = hel_lock)
       sf_int%data => data
       do i = 1, 2
          call quantum_numbers_init (qn_fc(i), &
               flv = data%flv_in(i), &
               col = color_from_flavor (data%flv_in(i)))
          call quantum_numbers_init (qn_fc(i+2), &
               flv = data%flv_in(i), &
               col = color_from_flavor (data%flv_in(i)))
       end do
       call polarization_init_generic (pol1, data%flv_in(1))
       call state_iterator_init (it_hel1, pol1%state)
       do while (state_iterator_is_valid (it_hel1))
          qn_hel(1:1) = state_iterator_get_quantum_numbers (it_hel1)
          qn_hel(3:3) = state_iterator_get_quantum_numbers (it_hel1)
          call polarization_init_generic (pol2, data%flv_in(2))
          call state_iterator_init (it_hel2, pol2%state)
          do while (state_iterator_is_valid (it_hel2))
             qn_hel(2:2) = state_iterator_get_quantum_numbers (it_hel2)
             qn_hel(4:4) = state_iterator_get_quantum_numbers (it_hel2)
             qn = qn_hel .merge. qn_fc
             call interaction_add_state (sf_int%interaction_t, qn)
             call state_iterator_advance (it_hel2)
          end do
          call polarization_final (pol2)
          call state_iterator_advance (it_hel1)
       end do
       call polarization_final (pol2)
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1,2])
       call sf_int%set_outgoing ([3,4])
       call sf_int%data%open ()
       sf_int%status = SF_INITIAL
    end select
  end subroutine beam_events_init
    
@ %def beam_events_init
@ This spectrum type needs a finalizer, which closes the data file.
<<SF beam events: beam events: TBP>>=
  procedure :: final => sf_beam_events_final
<<SF beam events: procedures>>=
  subroutine sf_beam_events_final (object)
    class(beam_events_t), intent(inout) :: object
    call object%data%close ()
    call interaction_final (object%interaction_t)
  end subroutine sf_beam_events_final

@ %def sf_beam_events_final
@
\subsection{Kinematics}
Refer to the [[data]] component.
<<SF beam events: beam events: TBP>>=
  procedure :: is_generator => beam_events_is_generator
<<SF beam events: procedures>>=
  function beam_events_is_generator (sf_int) result (flag)
    class(beam_events_t), intent(in) :: sf_int
    logical :: flag
    flag = sf_int%data%is_generator ()
  end function beam_events_is_generator
  
@ %def beam_events_is_generator
@ Generate free parameters.  We read them from file.
<<SF beam events: beam events: TBP>>=
  procedure :: generate_free => beam_events_generate_free
<<SF beam events: procedures>>=
  recursive subroutine beam_events_generate_free (sf_int, r, rb,  x_free)
    class(beam_events_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(inout) :: x_free
    integer :: iostat
    associate (data => sf_int%data)
      if (data%unit /= 0) then
         read (data%unit, fmt=*, iostat=iostat)  r
         if (iostat > 0) then
            write (msg_buffer, "(A,I0,A)") &
                 "Beam events: I/O error after reading ", sf_int%count, &
                 " events"
            call msg_fatal ()
         else if (iostat < 0) then
            if (sf_int%count == 0) then
               call msg_fatal ("Beam events: file is empty")
            else if (sf_int%data%warn_eof) then
               write (msg_buffer, "(A,I0,A)") &
                    "Beam events: End of file after reading ", sf_int%count, &
                    " events, rewinding"
               call msg_warning ()
            end if
            rewind (data%unit)
            sf_int%count = 0
            call sf_int%generate_free (r, rb, x_free)
         else
            sf_int%count = sf_int%count + 1
            rb = 1 - r
            x_free = x_free * product (r)
         end if
      else
         call msg_bug ("Beam events: file is not open for reading")
      end if
    end associate
  end subroutine beam_events_generate_free
    
@ %def beam_events_generate_free
@ Set kinematics.  Trivial transfer since this is a pure generator.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ and consequently $f(r)=2r$.
<<SF beam events: beam events: TBP>>=
  procedure :: complete_kinematics => beam_events_complete_kinematics
<<SF beam events: procedures>>=
  subroutine beam_events_complete_kinematics (sf_int, x, f, r, rb, map)
    class(beam_events_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    if (map) then
       call msg_fatal ("Beam events: map flag not supported")
    else
       x = r
       f = 1
    end if
    call sf_int%reduce_momenta (x)
  end subroutine beam_events_complete_kinematics

@ %def beam_events_complete_kinematics
@ Compute inverse kinematics.  Trivial in this case.
<<SF beam events: beam events: TBP>>=
  procedure :: inverse_kinematics => beam_events_inverse_kinematics
<<SF beam events: procedures>>=
  subroutine beam_events_inverse_kinematics &
       (sf_int, x, f, r, rb, map, set_momenta)
    class(beam_events_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       call msg_fatal ("Beam events: map flag not supported")
    else
       r = x
       f = 1
    end if
    rb = 1 - r
    if (set_mom) then
       call sf_int%reduce_momenta (x)
    end if
  end subroutine beam_events_inverse_kinematics

@ %def beam_events_inverse_kinematics
@
\subsection{Beam events application}
Trivial, just set the unit weight.
<<SF beam events: beam events: TBP>>=
  procedure :: apply => beam_events_apply
<<SF beam events: procedures>>=
  subroutine beam_events_apply (sf_int, scale)
    class(beam_events_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: f
    f = 1
    call interaction_set_matrix_element (sf_int%interaction_t, &
         cmplx (f, kind=default))        
    sf_int%status = SF_EVALUATED
  end subroutine beam_events_apply

@ %def beam_events_apply
@
\subsection{Unit tests}
<<SF beam events: public>>=
  public :: sf_beam_events_test
<<SF beam events: tests>>=
  subroutine sf_beam_events_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF beam events: execute tests>>
  end subroutine sf_beam_events_test
  
@ %def sf_beam_events_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF beam events: execute tests>>=
  call test (sf_beam_events_1, "sf_beam_events_1", &
       "structure function configuration", &
       u, results)
<<SF beam events: tests>>=
  subroutine sf_beam_events_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(2) :: pdg_out
    integer, dimension(:), allocatable :: pdg1, pdg2
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_beam_events_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &beam-events structure function data"
    write (u, "(A)")
    
    call model%init_qed_test ()
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    allocate (beam_events_data_t :: data)
    select type (data)
    type is (beam_events_data_t)
       call data%init (model, pdg_in, var_str (""), var_str ("beam_events.dat"))
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    pdg2 = pdg_out(2)
    write (u, "(2x,99(1x,I0))")  pdg1, pdg2

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_beam_events_1"

  end subroutine sf_beam_events_1

@ %def sf_beam_events_1
g@
\subsubsection{Probe the structure-function object}
Active the beam event reader, generate an event.
<<SF beam events: execute tests>>=
  call test (sf_beam_events_2, "sf_beam_events_2", &
       "generate event", &
       u, results)
<<SF beam events: tests>>=
  subroutine sf_beam_events_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(2) :: flv
    type(pdg_array_t), dimension(2) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k1, k2
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: x_free, f
    integer :: i
    
    write (u, "(A)")  "* Test output: sf_beam_events_2"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &beam-events structure function data"
    write (u, "(A)")
    
    call model%init_qed_test ()
    call flavor_init (flv(1), ELECTRON, model)
    call flavor_init (flv(2), -ELECTRON, model)
    pdg_in(1) = ELECTRON
    pdg_in(2) = -ELECTRON

    call reset_interaction_counter ()
    
    allocate (beam_events_data_t :: data)
    select type (data)
    type is (beam_events_data_t)
       call data%init (model, pdg_in, &
            var_str (""), var_str ("test_beam_events.dat"))
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1,2])

    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 250
    k1 = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv(1))**2), 3)
    k2 = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv(2))**2), 3)
    call vector4_write (k1, u)
    call vector4_write (k2, u)
    call sf_int%seed_kinematics ([k1, k2])

    write (u, "(A)")
    write (u, "(A)")  "* Set dummy parameters and generate x."
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r  = 0
    rb = 0
    x_free = 1
    call sf_int%generate_free (r, rb, x_free)
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)

    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "rb=", rb
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free
    select type (sf_int)
    type is (beam_events_t)	
       write (u, "(A,1x,I0)")  "count =", sf_int%count
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_int%apply (scale = 0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate more events, rewind"
    write (u, "(A)")

    select type (sf_int)
    type is (beam_events_t)	
       do i = 1, 3
          call sf_int%generate_free (r, rb, x_free)
          write (u, "(A,9(1x,F10.7))")  "r =", r
          write (u, "(A,1x,I0)")  "count =", sf_int%count
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_beam_events_2"

  end subroutine sf_beam_events_2

@ %def sf_beam_events_2
@
\clearpage
%------------------------------------------------------------------------
\section{LHAPDF}
Parton distribution functions (PDFs) are available via an interface to
the LHAPDF standard library.
@
\subsection{The module}
<<[[sf_lhapdf.f90]]>>=
<<File header>>

module sf_lhapdf

<<Use kinds>>
<<Use strings>>
  use format_defs, only: FMT_17, FMT_19
  use io_units
  use unit_tests
  use system_dependencies, only: LHAPDF_PDFSETS_PATH
  use system_dependencies, only: LHAPDF5_AVAILABLE
  use system_dependencies, only: LHAPDF6_AVAILABLE  
  use diagnostics
  use physics_defs, only: PROTON, PHOTON, PIPLUS, GLUON
  use physics_defs, only: HADRON_REMNANT_SINGLET
  use physics_defs, only: HADRON_REMNANT_TRIPLET
  use physics_defs, only: HADRON_REMNANT_OCTET
  use lorentz
  use sm_qcd
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  use lhapdf !NODEP!
  use hoppet_interface

<<Standard module head>>

<<SF lhapdf: public>>

<<SF lhapdf: types>>

<<SF lhapdf: parameters>>

<<SF lhapdf: variables>>

<<SF lhapdf: interfaces>>

contains

<<SF lhapdf: procedures>>

<<SF lhapdf: tests>>

end module sf_lhapdf
@ %def sf_lhapdf
@ 
\subsection{Codes for default PDF sets}
The default PDF for protons set is chosen to be CTEQ6ll (LO fit with
LO $\alpha_s$).
<<SF lhapdf: parameters>>=
  character(*), parameter :: LHAPDF5_DEFAULT_PROTON = "cteq6ll.LHpdf"
  character(*), parameter :: LHAPDF5_DEFAULT_PION   = "ABFKWPI.LHgrid"
  character(*), parameter :: LHAPDF5_DEFAULT_PHOTON = "GSG960.LHgrid"
  character(*), parameter :: LHAPDF6_DEFAULT_PROTON = "CT10"
@ %def LHAPDF5_DEFAULT_PROTON LHAPDF5_DEFAULT_PION 
@ %def LHAPDF5_DEFAULT_PHOTON LHAPDF6_DEFAULT_PROTON
@ 
\subsection{LHAPDF library interface}
Here we specify explicit interfaces for all LHAPDF routines that we
use below.
<<SF lhapdf: interfaces>>=
  interface
     subroutine InitPDFsetM (set, file)
       integer, intent(in) :: set
       character(*), intent(in) :: file
     end subroutine InitPDFsetM
  end interface

@ %def InitPDFsetM
<<SF lhapdf: interfaces>>=
  interface
     subroutine InitPDFM (set, mem)
       integer, intent(in) :: set, mem
     end subroutine InitPDFM
  end interface

@ %def InitPDFM
<<SF lhapdf: interfaces>>=
  interface
     subroutine numberPDFM (set, n_members)
       integer, intent(in) :: set
       integer, intent(out) :: n_members
     end subroutine numberPDFM
  end interface

@ %def numberPDFM
<<SF lhapdf: interfaces>>=
  interface
     subroutine evolvePDFM (set, x, q, ff)
       integer, intent(in) :: set
       double precision, intent(in) :: x, q
       double precision, dimension(-6:6), intent(out) :: ff
     end subroutine evolvePDFM
  end interface

@ %def evolvePDFM
<<SF lhapdf: interfaces>>=
  interface
     subroutine evolvePDFphotonM (set, x, q, ff, fphot)
       integer, intent(in) :: set
       double precision, intent(in) :: x, q
       double precision, dimension(-6:6), intent(out) :: ff
       double precision, intent(out) :: fphot
     end subroutine evolvePDFphotonM
  end interface

@ %def evolvePDFphotonM
<<SF lhapdf: interfaces>>=
  interface
     subroutine evolvePDFpM (set, x, q, s, scheme, ff)
       integer, intent(in) :: set
       double precision, intent(in) :: x, q, s
       integer, intent(in) :: scheme
       double precision, dimension(-6:6), intent(out) :: ff
     end subroutine evolvePDFpM
  end interface

@ %def evolvePDFpM
<<SF lhapdf: interfaces>>=
  interface
     subroutine GetXminM (set, mem, xmin)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: xmin
     end subroutine GetXminM
  end interface

@ %def GetXminM
<<SF lhapdf: interfaces>>=
  interface
     subroutine GetXmaxM (set, mem, xmax)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: xmax
     end subroutine GetXmaxM
  end interface

@ %def GetXmaxM
<<SF lhapdf: interfaces>>=
  interface
     subroutine GetQ2minM (set, mem, q2min)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: q2min
     end subroutine GetQ2minM
  end interface

@ %def GetQ2minM
<<SF lhapdf: interfaces>>=
  interface
     subroutine GetQ2maxM (set, mem, q2max)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: q2max
     end subroutine GetQ2maxM
  end interface

@ %def GetQ2maxM
<<SF lhapdf: interfaces>>=
  interface
     function has_photon () result(flag)
        logical :: flag
     end function has_photon
  end interface

@ %def has_photon
@ 
\subsection{The LHAPDF status} 
This type holds the initialization status of the LHAPDF system. Entry
1 is for proton PDFs, entry 2 for pion PDFs, entry 3 for photon PDFs.

Since it is connected to the external LHAPDF library, this is a truly
global object.  We implement it as a a private module variable.  To
access it from elsewhere, the caller has to create and initialize an
object of type [[lhapdf_status_t]], which acts as a proxy.
<<SF lhapdf: types>>=
  type :: lhapdf_global_status_t
     private
     logical, dimension(3) :: initialized = .false.
  end type lhapdf_global_status_t

@ %def lhapdf_global_status_t
<<SF lhapdf: variables>>=
  type(lhapdf_global_status_t) :: lhapdf_global_status
@ %def lhapdf_global_status
<<SF lhapdf: procedures>>=
  function lhapdf_global_status_is_initialized (set) result (flag)
    logical :: flag
    integer, intent(in), optional :: set
    if (present (set)) then
       select case (set)
       case (1:3);    flag = lhapdf_global_status%initialized(set)
       case default;  flag = .false.
       end select
    else
       flag = any (lhapdf_global_status%initialized)
    end if
  end function lhapdf_global_status_is_initialized

@ %def lhapdf_global_status_is_initialized
<<SF lhapdf: procedures>>=
  subroutine lhapdf_global_status_set_initialized (set)
    integer, intent(in) :: set
    lhapdf_global_status%initialized(set) = .true.
  end subroutine lhapdf_global_status_set_initialized

@ %def lhapdf_global_status_set_initialized
@ This is the only public procedure, it tells the system to forget
about previous initialization, allowing for changing the chosen PDF
set.  Note that such a feature works only if the global program flow
is serial, so no two distinct sets are accessed simultaneously.  But
this applies to LHAPDF anyway.
<<SF lhapdf: public>>=
  public :: lhapdf_global_reset
<<SF lhapdf: procedures>>=
  subroutine lhapdf_global_reset ()
    lhapdf_global_status%initialized = .false.
  end subroutine lhapdf_global_reset

@ %def lhapdf_global_status_reset
@ 
\subsection{LHAPDF initialization}
Before using LHAPDF, we have to initialize it with a particular data
set and member.  This applies not just if we use structure functions,
but also if we just use an $\alpha_s$ formula.  The integer [[set]]
should be $1$ for proton, $2$ for pion, and $3$ for photon, but this
is just convention.

It appears as if LHAPDF does not allow for multiple data sets being
used concurrently (?), so multi-threaded usage with different sets
(e.g., a scan) is excluded.  The current setup with a global flag that
indicates initialization is fine as long as Whizard itself is run in
serial mode at the Sindarin level.  If we introduce multithreading in
any form from Sindarin, we have to rethink the implementation of the
LHAPDF interface.  (The same considerations apply to builtin PDFs.)

If the particular set has already been initialized, do nothing.  This
implies that whenever we want to change the setup for a particular
set, we have to reset the LHAPDF status.
[[lhapdf_initialize]] has an obvious name clash with [[lhapdf_init]], 
the reason it works for [[pdf_builtin]] is that there things are 
outsourced to a separate module (inc. [[lhapdf_status]] etc.).
<<SF lhapdf: public>>=
  public :: lhapdf_initialize
<<SF lhapdf: procedures>>=
  subroutine lhapdf_initialize (set, prefix, file, member, pdf, b_match)
    integer, intent(in) :: set
    type(string_t), intent(inout) :: prefix
    type(string_t), intent(inout) :: file
    type(lhapdf_pdf_t), intent(inout), optional :: pdf
    integer, intent(inout) :: member
    logical, intent(in), optional :: b_match
    if (prefix == "")  prefix = LHAPDF_PDFSETS_PATH
    if (LHAPDF5_AVAILABLE) then
       if (lhapdf_global_status_is_initialized (set))  return
       if (file == "") then
          select case (set)
          case (1);  file = LHAPDF5_DEFAULT_PROTON
          case (2);  file = LHAPDF5_DEFAULT_PION
          case (3);  file = LHAPDF5_DEFAULT_PHOTON
          end select
       end if
       if (data_file_exists (prefix // "/" // file)) then
          call InitPDFsetM (set, char (prefix // "/" // file))
       else
          call msg_fatal ("LHAPDF: Data file '" &
               // char (file) // "' not found in '" // char (prefix) // "'.")
          return
       end if
       if (.not. dataset_member_exists (set, member)) then
          call msg_error (" LHAPDF: Chosen member does not exist for set '" &
               // char (file) // "', using default.")
          member = 0
       end if
       call InitPDFM (set, member)
    else if (LHAPDF6_AVAILABLE) then
       if (lhapdf_global_status_is_initialized (set) .and. &
            pdf%is_associated ())  return
       if (file == "") then
          select case (set)
          case (1);  file = LHAPDF6_DEFAULT_PROTON
          case (2);  
             call msg_fatal ("LHAPDF6: no pion PDFs supported")
          case (3);  
             call msg_fatal ("LHAPDF6: no photon PDFs supported")
          end select
       end if
       if (data_file_exists (prefix // "/" // file // "/" // file // ".info")) then          
          call pdf%init (char (file), member)
       else
          call msg_fatal ("LHAPDF: Data file '" &
               // char (file) // "' not found in '" // char (prefix) // "'.")
          return
       end if        
    end if
    if (present (b_match)) then
       if (b_match) then
          if (LHAPDF5_AVAILABLE) then
             call hoppet_init (.false.)
          else if (LHAPDF6_AVAILABLE) then
             call hoppet_init (.false., pdf)
          end if
       end if
    end if
    call lhapdf_global_status_set_initialized (set)
  contains
    function data_file_exists (fq_name) result (exist)
      type(string_t), intent(in) :: fq_name
      logical :: exist
      inquire (file = char(fq_name), exist = exist)
    end function data_file_exists
    function dataset_member_exists (set, member) result (exist)
      integer, intent(in) :: set, member
      logical :: exist
      integer :: n_members
      call numberPDFM (set, n_members)
      exist = member >= 0 .and. member <= n_members
    end function dataset_member_exists
  end subroutine lhapdf_initialize

@ %def lhapdf_initialize
@
\subsection{Kinematics}
Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ and consequently $f(r)=2r$.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: complete_kinematics => lhapdf_complete_kinematics
<<SF lhapdf: procedures>>=
  subroutine lhapdf_complete_kinematics (sf_int, x, f, r, rb, map)
    class(lhapdf_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1
    if (map) then
       call msg_fatal ("LHAPDF: map flag not supported")
    else
       x(1) = r(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    call sf_int%split_momentum (x, xb1)
    select case (sf_int%status)
    case (SF_DONE_KINEMATICS)
       sf_int%x = x(1)
    case (SF_FAILED_KINEMATICS)
       sf_int%x = 0
       f = 0
    end select
  end subroutine lhapdf_complete_kinematics

@ %def lhapdf_complete_kinematics
@
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: inverse_kinematics => lhapdf_inverse_kinematics
<<SF lhapdf: procedures>>=
  subroutine lhapdf_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(lhapdf_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       call msg_fatal ("LHAPDF: map flag not supported")
    else
       r(1) = x(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    rb = 1 - r
    if (set_mom) then
       call sf_int%split_momentum (x, xb1)
       select case (sf_int%status)
       case (SF_DONE_KINEMATICS)
          sf_int%x = x(1)
       case (SF_FAILED_KINEMATICS)
          sf_int%x = 0
          f = 0
       end select
    end if
  end subroutine lhapdf_inverse_kinematics

@ %def lhapdf_inverse_kinematics
@
\subsection{The LHAPDF data block} 
The data block holds the incoming flavor (which has to be proton,
pion, or photon), the corresponding pointer to the global access data
(1, 2, or 3), the flag [[invert]] which is set for an antiproton, the
bounds as returned by LHAPDF for the specified set, and a mask that
determines which partons will be actually in use.
<<SF lhapdf: public>>=
  public :: lhapdf_data_t
<<SF lhapdf: types>>=
  type, extends (sf_data_t) :: lhapdf_data_t
     private
     type(string_t) :: prefix
     type(string_t) :: file
     type(lhapdf_pdf_t) :: pdf 
     integer :: member = 0
     class(model_data_t), pointer :: model => null ()
     type(flavor_t) :: flv_in
     integer :: set = 0
     logical :: invert = .false.
     logical :: photon = .false.
     logical :: has_photon = .false.
     integer :: photon_scheme = 0
     real(default) :: xmin = 0, xmax = 0
     real(default) :: qmin = 0, qmax = 0
     logical, dimension(-6:6) :: mask = .true.
     logical :: mask_photon = .true.
     logical :: hoppet_b_matching = .false.     
   contains
     <<SF lhapdf: lhapdf data: TBP>>
  end type lhapdf_data_t

@ %def lhapdf_data_t
@ Generate PDF data.  This is provided as a function, but it has the
side-effect of initializing the requested PDF set.  A finalizer is not
needed.

The library uses double precision, so since the default precision may be
extended or quadruple, we use auxiliary variables for type casting.
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: init => lhapdf_data_init
<<SF lhapdf: procedures>>=
  subroutine lhapdf_data_init &
       (data, model, pdg_in, prefix, file, member, photon_scheme, &
            hoppet_b_matching)
    class(lhapdf_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    type(string_t), intent(in), optional :: prefix, file
    integer, intent(in), optional :: member
    integer, intent(in), optional :: photon_scheme
    logical, intent(in), optional :: hoppet_b_matching
    double precision :: xmin, xmax, q2min, q2max
    external :: InitPDFsetM, InitPDFM, numberPDFM
    external :: GetXminM, GetXmaxM, GetQ2minM, GetQ2maxM
    if (.not. LHAPDF5_AVAILABLE .and. .not. LHAPDF6_AVAILABLE) then
       call msg_fatal ("LHAPDF requested but library is not linked")
       return
    end if
    data%model => model
    if (pdg_array_get_length (pdg_in) /= 1) &
         call msg_fatal ("PDF: incoming particle must be unique")
    call flavor_init (data%flv_in, pdg_array_get (pdg_in, 1), model)
    select case (pdg_array_get (pdg_in, 1))
    case (PROTON)
       data%set = 1
    case (-PROTON)
       data%set = 1
       data%invert = .true.
    case (PIPLUS)
       data%set = 2
    case (-PIPLUS)
       data%set = 2
       data%invert = .true.
    case (PHOTON)
       data%set = 3
       data%photon = .true.
       if (present (photon_scheme))  data%photon_scheme = photon_scheme
    case default
       call msg_fatal (" LHAPDF: " &
            // "incoming particle must be (anti)proton, pion, or photon.")
       return
    end select
    if (present (prefix)) then
       data%prefix = prefix
    else
       data%prefix = ""
    end if
    if (present (file)) then
       data%file = file
    else
       data%file = ""
    end if
    if (present (hoppet_b_matching))  data%hoppet_b_matching = hoppet_b_matching    
    if (LHAPDF5_AVAILABLE) then
       call lhapdf_initialize &
            (data%set, data%prefix, data%file, data%member, &
            b_match = data%hoppet_b_matching) 
       call GetXminM (data%set, data%member, xmin)
       call GetXmaxM (data%set, data%member, xmax)
       call GetQ2minM (data%set, data%member, q2min)
       call GetQ2maxM (data%set, data%member, q2max)
       data%xmin = xmin
       data%xmax = xmax
       data%qmin = sqrt (q2min)
       data%qmax = sqrt (q2max)       
       data%has_photon = has_photon ()       
    else if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
            (data%set, data%prefix, data%file, data%member, &
            data%pdf, data%hoppet_b_matching)              
       data%xmin = data%pdf%getxmin ()
       data%xmax = data%pdf%getxmax ()
       data%qmin = sqrt(data%pdf%getq2min ())
       data%qmax = sqrt(data%pdf%getq2max ())
       data%has_photon = data%pdf%has_photon ()       
    end if
  end subroutine lhapdf_data_init

@ %def lhapdf_data_init
@ Enable/disable partons explicitly.  If a mask entry is true,
applying the PDF will generate the corresponding flavor on output.
<<LHAPDF: lhapdf data: TBP>>=
  procedure :: set_mask => lhapdf_data_set_mask
<<LHAPDF: procedures>>=
  subroutine lhapdf_data_set_mask (data, mask)
    class(lhapdf_data_t), intent(inout) :: data
    logical, dimension(-6:6), intent(in) :: mask
    data%mask = mask
  end subroutine lhapdf_data_set_mask

@ %def lhapdf_data_set_mask
@ Return the public part of the data set.
<<LHAPDF: public>>=
  public :: lhapdf_data_get_public_info
<<LHAPDF: procedures>>=
  subroutine lhapdf_data_get_public_info &
       (data, lhapdf_dir, lhapdf_file, lhapdf_member)
    type(lhapdf_data_t), intent(in) :: data
    type(string_t), intent(out) :: lhapdf_dir, lhapdf_file
    integer, intent(out) :: lhapdf_member
    lhapdf_dir = data%prefix
    lhapdf_file = data%file
    lhapdf_member = data%member
  end subroutine lhapdf_data_get_public_info

@ %def lhapdf_data_get_public_info
@ Return the number of the member of the data set.
<<LHAPDF: public>>=
  public :: lhapdf_data_get_set
<<LHAPDF: procedures>>=
  function lhapdf_data_get_set(data) result(set)
    type(lhapdf_data_t), intent(in) :: data
    integer :: set
    set = data%set
  end function lhapdf_data_get_set

@ %def lhapdf_data_get_set
@ Output
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: write => lhapdf_data_write
<<SF lhapdf: procedures>>=
  subroutine lhapdf_data_write (data, unit, verbose) 
    class(lhapdf_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical :: verb
    integer :: u
    if (present (verbose)) then
       verb = verbose
    else
       verb = .false.
    end if       
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "LHAPDF data:"
    if (data%set /= 0) then
       write (u, "(3x,A)", advance="no") "flavor       =  "
       call flavor_write (data%flv_in, u);  write (u, *)
       if (verb) then
          write (u, "(3x,A,A)")       "  prefix       =  ", char (data%prefix)
       else
          write (u, "(3x,A,A)")       "  prefix       = ", &
               " <empty (non-verbose version)>"
       end if
       write (u, "(3x,A,A)")       "  file         =  ", char (data%file)
       write (u, "(3x,A,I3)")      "  member       = ", data%member
       write (u, "(3x,A," // FMT_19 // ")") "  x(min)       = ", data%xmin
       write (u, "(3x,A," // FMT_19 // ")") "  x(max)       = ", data%xmax
       write (u, "(3x,A," // FMT_19 // ")") "  Q(min)       = ", data%qmin
       write (u, "(3x,A," // FMT_19 // ")") "  Q(max)       = ", data%qmax
       write (u, "(3x,A,L1)")      "  invert       =  ", data%invert
       if (data%photon)  write (u, "(3x,A,I3)") &
            "  IP2 (scheme) = ", data%photon_scheme
          write (u, "(3x,A,6(1x,L1),1x,A,1x,L1,1x,A,6(1x,L1))") &
               "  mask         = ", &
               data%mask(-6:-1), "*", data%mask(0), "*", data%mask(1:6)
          write (u, "(3x,A,L1)")   "  photon mask  =  ", data%mask_photon
       if (data%set == 1)  write (u, "(3x,A,L1)") &
            "  hoppet_b     =  ", data%hoppet_b_matching
    else
       write (u, "(3x,A)") "[undefined]"       
    end if
  end subroutine lhapdf_data_write
@ %def lhapdf_data_write  
@ The number of parameters is one.  We do not generate transverse momentum.
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: get_n_par => lhapdf_data_get_n_par
<<SF lhapdf: procedures>>=
  function lhapdf_data_get_n_par (data) result (n)
    class(lhapdf_data_t), intent(in) :: data
    integer :: n
    n = 1
  end function lhapdf_data_get_n_par
  
@ %def lhapdf_data_get_n_par
@ Return the outgoing particle PDG codes.  This is based on the mask.
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: get_pdg_out => lhapdf_data_get_pdg_out
<<SF lhapdf: procedures>>=
  subroutine lhapdf_data_get_pdg_out (data, pdg_out)
    class(lhapdf_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    integer :: n, np, i
    n = count (data%mask)
    np = 0;  if (data%has_photon .and. data%mask_photon)  np = 1
    allocate (pdg1 (n + np))
    pdg1(1:n) = pack ([(i, i = -6, 6)], data%mask)
    if (np == 1)  pdg1(n+np) = PHOTON
    pdg_out(1) = pdg1
  end subroutine lhapdf_data_get_pdg_out
  
@ %def lhapdf_data_get_pdg_out
@ Allocate the interaction record.
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: allocate_sf_int => lhapdf_data_allocate_sf_int
<<SF lhapdf: procedures>>=
  subroutine lhapdf_data_allocate_sf_int (data, sf_int)
    class(lhapdf_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (lhapdf_t :: sf_int)
  end subroutine lhapdf_data_allocate_sf_int
  
@ %def lhapdf_data_allocate_sf_int 
@ Return the numerical PDF set index.
<<SF lhapdf: lhapdf data: TBP>>=
  procedure :: get_pdf_set => lhapdf_data_get_pdf_set
<<SF lhapdf: procedures>>=
  function lhapdf_data_get_pdf_set (data) result (pdf_set)
    class(lhapdf_data_t), intent(in) :: data
    integer :: pdf_set
    pdf_set = data%set
  end function lhapdf_data_get_pdf_set
  
@ %def lhapdf_data_get_pdf_set
@ 
\subsection{The LHAPDF object}
The [[lhapdf_t]] data type is a $1\to 2$ interaction which describes
the splitting of an (anti)proton into a parton and a beam remnant.  We
stay in the strict forward-splitting limit, but allow some invariant
mass for the beam remnant such that the outgoing parton is exactly
massless.  For a real event, we would replace this by a parton
cascade, where the outgoing partons have virtuality as dictated by
parton-shower kinematics, and transverse momentum is generated.

This is the LHAPDF object which holds input data together with the
interaction.  We also store the $x$ momentum fraction and the scale,
since kinematics and function value are requested at different times.

The PDF application is a $1\to 2$ splitting process, where the
particles are ordered as (hadron, remnant, parton).

Polarization is ignored completely.  The beam particle is colorless,
while partons and beam remnant carry color.  The remnant gets a
special flavor code.
<<SF lhapdf: types>>=
  type, extends (sf_int_t) :: lhapdf_t
     type(lhapdf_data_t), pointer :: data => null ()
     real(default) :: x = 0
     real(default) :: q = 0
     real(default) :: s = 0
   contains
   <<SF lhapdf: lhapdf: TBP>>
  end type lhapdf_t 
  
@ %def lhapdf_t
@ Type string: display the chosen PDF set.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: type_string => lhapdf_type_string
<<SF lhapdf: procedures>>=
  function lhapdf_type_string (object) result (string)
    class(lhapdf_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "LHAPDF: " // object%data%file
    else
       string = "LHAPDF: [undefined]"
    end if
  end function lhapdf_type_string
  
@ %def lhapdf_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: write => lhapdf_write
<<SF lhapdf: procedures>>=
  subroutine lhapdf_write (object, unit, testflag)
    class(lhapdf_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
          if (object%status >= SF_FAILED_EVALUATION) then
             write (u, "(3x,A," // FMT_17 // ")")  "Q =", object%q
          end if
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "LHAPDF data: [undefined]"
    end if
  end subroutine lhapdf_write
    
@ %def lhapdf_write
@ Initialize.  We know that [[data]] will be of concrete type
[[sf_lhapdf_data_t]], but we have to cast this explicitly.

For this implementation, we set the incoming and outgoing masses equal
to the physical particle mass, but keep the radiated mass zero.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: init => lhapdf_init
<<SF lhapdf: procedures>>=
  subroutine lhapdf_init (sf_int, data)
    class(lhapdf_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    type(flavor_t) :: flv, flv_remnant
    type(quantum_numbers_t), dimension(3) :: qn
    integer :: i
    select type (data)
    type is (lhapdf_data_t)
       mask = new_quantum_numbers_mask (.false., .false., .true.)
       call sf_int%base_init (mask, [0._default], [0._default], [0._default])
       sf_int%data => data
       do i = -6, 6
          if (data%mask(i)) then
             call quantum_numbers_init (qn(1), data%flv_in)
             if (i == 0) then                
                call flavor_init (flv, GLUON, data%model)
                call flavor_init (flv_remnant, HADRON_REMNANT_OCTET, data%model)
             else
                call flavor_init (flv, i, data%model)
                call flavor_init (flv_remnant, &
                     sign (HADRON_REMNANT_TRIPLET, -i), data%model)
             end if
             call quantum_numbers_init (qn(2), &
                  flv = flv_remnant, col = color_from_flavor (flv_remnant, 1))
             call quantum_numbers_init (qn(3), &
                  flv = flv, col = color_from_flavor (flv, 1, reverse=.true.))
             call interaction_add_state (sf_int%interaction_t, qn)
          end if
       end do
       if (data%has_photon .and. data%mask_photon) then
          call flavor_init (flv, PHOTON, data%model)
          call flavor_init (flv_remnant, HADRON_REMNANT_SINGLET, data%model)
          call quantum_numbers_init (qn(2), flv = flv_remnant, &
               col = color_from_flavor (flv_remnant, 1))
          call quantum_numbers_init (qn(3), flv = flv, &
               col = color_from_flavor (flv, 1, reverse=.true.))
          call interaction_add_state (sf_int%interaction_t, qn)
       end if
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
       sf_int%status = SF_INITIAL
    end select
  end subroutine lhapdf_init

@ %def lhapdf_init
@ 
\subsection{Structure function}
We have to cast the LHAPDF arguments to/from double precision (possibly
from/to extended/quadruple precision), if necessary.  Furthermore,
some structure functions can yield negative results (sea quarks close
to $x=1$).  We set these unphysical values to zero.
<<SF lhapdf: lhapdf: TBP>>=
  procedure :: apply => lhapdf_apply
<<SF lhapdf: procedures>>=
  subroutine lhapdf_apply (sf_int, scale)
    class(lhapdf_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default) :: x, s
    double precision :: xx, qq, ss    
    double precision, dimension(-6:6) :: ff
    double precision :: fphot
    complex(default), dimension(:), allocatable :: fc
    external :: evolvePDFM, evolvePDFpM
    associate (data => sf_int%data)
      sf_int%q = scale
      x = sf_int%x
      s = sf_int%s
      qq = min (data% qmax, scale)
      qq = max (data% qmin, qq)
      if (.not. data% photon) then
         xx = x
         if (data% invert) then
            if (data%has_photon) then
               if (LHAPDF5_AVAILABLE) then
                  call evolvePDFphotonM &
                       (data% set, xx, qq, ff(6:-6:-1), fphot)
               else if (LHAPDF6_AVAILABLE) then
                  call data%pdf%evolve_pdfphotonm &
                       (xx, qq, ff(6:-6:-1), fphot)
               end if
            else
               if (data%hoppet_b_matching) then
                  call hoppet_eval (xx, qq, ff(6:-6:-1)) 
               else
                  if (LHAPDF5_AVAILABLE) then
                     call evolvePDFM (data% set, xx, qq, ff(6:-6:-1))
                  else if (LHAPDF6_AVAILABLE) then
                     call data%pdf%evolve_pdfm (xx, qq, ff(6:-6:-1))
                  end if
               end if
            end if
         else
            if (data%has_photon) then
               if (LHAPDF5_AVAILABLE) then
                  call evolvePDFphotonM (data% set, xx, qq, ff, fphot)
               else if (LHAPDF6_AVAILABLE) then
                  call data%pdf%evolve_pdfphotonm (xx, qq, ff, fphot)
               end if
            else
               if (data%hoppet_b_matching) then
                  call hoppet_eval (xx, qq, ff) 
               else
                  if (LHAPDF5_AVAILABLE) then
                     call evolvePDFM (data% set, xx, qq, ff)
                  else if (LHAPDF6_AVAILABLE) then
                     call data%pdf%evolve_pdfm (xx, qq, ff)
                  end if
               end if
            end if
         end if
      else
         ss = s
         if (LHAPDF5_AVAILABLE) then
            call evolvePDFpM (data% set, xx, qq, &
                 ss, data% photon_scheme, ff)
         else if (LHAPDF6_AVAILABLE) then
            call data%pdf%evolve_pdfpm (xx, qq, ss, &
                 data%photon_scheme, ff)
         end if
      end if
      if (data%has_photon) then
         allocate (fc (count ([data%mask, data%mask_photon])))
         fc = max (pack ([ff, fphot] / x, &
              [data% mask, data%mask_photon]), 0._default)
      else
         allocate (fc (count (data%mask)))
         fc = max (pack (ff / x, data%mask), 0._default)
      end if
    end associate
    call interaction_set_matrix_element (sf_int%interaction_t, fc)
    sf_int%status = SF_EVALUATED
  end subroutine lhapdf_apply
  
@ %def apply_lhapdf
@
\subsection{Strong Coupling}
Since the PDF codes provide a function for computing the running
$\alpha_s$ value, we make this available as an implementation of the
abstract [[alpha_qcd_t]] type, which is used for matrix element evaluation.
<<SF lhapdf: public>>=
  public :: alpha_qcd_lhapdf_t
<<SF lhapdf: types>>=
  type, extends (alpha_qcd_t) :: alpha_qcd_lhapdf_t
     type(string_t) :: pdfset_dir
     type(string_t) :: pdfset_file
     integer :: pdfset_member = -1
     type(lhapdf_pdf_t) :: pdf
   contains
   <<SF lhapdf: alpha qcd: TBP>>
  end type alpha_qcd_lhapdf_t
  
@ %def alpha_qcd_lhapdf_t
@ Output. As in earlier versions we leave the LHAPDF path out.
<<SF lhapdf: alpha qcd: TBP>>=
  procedure :: write => alpha_qcd_lhapdf_write
<<SF lhapdf: procedures>>=
  subroutine alpha_qcd_lhapdf_write (object, unit)
    class(alpha_qcd_lhapdf_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "QCD parameters (lhapdf):"
    write (u, "(5x,A,A)")  "PDF set    = ", char (object%pdfset_file)
    write (u, "(5x,A,I0)") "PDF member = ", object%pdfset_member
  end subroutine alpha_qcd_lhapdf_write
  
@ %def alpha_qcd_lhapdf_write
@ Calculation: the numeric member ID selects the correct PDF set, which must
be properly initialized.
<<SF lhapdf: interfaces>>=
  interface
     double precision function alphasPDF (Q)
       double precision, intent(in) :: Q
     end function alphasPDF
  end interface

@ %def alphasPDF
@ 
<<SF lhapdf: alpha qcd: TBP>>=
  procedure :: get => alpha_qcd_lhapdf_get
<<SF lhapdf: procedures>>=
  function alpha_qcd_lhapdf_get (alpha_qcd, scale) result (alpha)
    class(alpha_qcd_lhapdf_t), intent(in) :: alpha_qcd
    real(default), intent(in) :: scale
    real(default) :: alpha
    if (LHAPDF5_AVAILABLE) then
       alpha = alphasPDF (dble (scale))
    else if (LHAPDF6_AVAILABLE) then
       alpha = alpha_qcd%pdf%alphas_pdf (dble (scale))
    end if
  end function alpha_qcd_lhapdf_get
  
@ %def alpha_qcd_lhapdf_get
@
Initialization.  We need to access the (quasi-global) initialization status.
<<SF lhapdf: alpha qcd: TBP>>=
  procedure :: init => alpha_qcd_lhapdf_init
<<SF lhapdf: procedures>>=
  subroutine alpha_qcd_lhapdf_init (alpha_qcd, file, member, path)
    class(alpha_qcd_lhapdf_t), intent(out) :: alpha_qcd
    type(string_t), intent(inout) :: file
    integer, intent(inout) :: member
    type(string_t), intent(inout) :: path
    alpha_qcd%pdfset_file = file
    alpha_qcd%pdfset_member = member
    if (alpha_qcd%pdfset_member < 0) &
         call msg_fatal ("QCD parameter initialization: PDF set " &
         // char (file) // " is unknown")
    if (LHAPDF5_AVAILABLE) then
       call lhapdf_initialize (1, path, file, member)
    else if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
            (1, path, file, member, alpha_qcd%pdf)
    end if
  end subroutine alpha_qcd_lhapdf_init
    
@ %def alpha_qcd_lhapdf_init
@
\subsection{Unit tests}
<<SF lhapdf: public>>=
  public :: sf_lhapdf_test
<<SF lhapdf: tests>>=
  subroutine sf_lhapdf_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF lhapdf: execute tests>>
  end subroutine sf_lhapdf_test
  
@ %def sf_lhapdf_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF lhapdf: execute tests>>=
  if (LHAPDF5_AVAILABLE) then  
     call test (sf_lhapdf_1, "sf_lhapdf5_1", &
          "structure function configuration", &
          u, results)
  else if (LHAPDF6_AVAILABLE) then
     call test (sf_lhapdf_1, "sf_lhapdf6_1", &
          "structure function configuration", &
          u, results)
  end if
<<SF lhapdf: tests>>=
  subroutine sf_lhapdf_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_lhapdf_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call model%init_sm_test ()
    pdg_in = PROTON

    allocate (lhapdf_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    select type (data)
    type is (lhapdf_data_t)
       call data%init (model, pdg_in)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_lhapdf_1"

  end subroutine sf_lhapdf_1

@ %def sf_lhapdf_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the PDF builtin
structure function.
<<SF lhapdf: execute tests>>=
  if (LHAPDF5_AVAILABLE) then
     call test (sf_lhapdf_2, "sf_lhapdf5_2", &
          "structure function instance", &
          u, results)
  else if (LHAPDF6_AVAILABLE) then
     call test (sf_lhapdf_2, "sf_lhapdf6_2", &
          "structure function instance", &
          u, results)     
  end if
<<SF lhapdf: tests>>=
  subroutine sf_lhapdf_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_lhapdf_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_sm_test ()
    call flavor_init (flv, PROTON, model)
    pdg_in = PROTON
    call lhapdf_global_reset ()
    
    call reset_interaction_counter ()
    
    allocate (lhapdf_data_t :: data)
    select type (data)
    type is (lhapdf_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = 0.5_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)

    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for Q = 100 GeV"
    write (u, "(A)")

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.) 
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u, testflag = .true.)


    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_lhapdf_2"

  end subroutine sf_lhapdf_2

@ %def sf_lhapdf_2
@
\subsubsection{Strong Coupling}
Test $\alpha_s$ as an implementation of the [[alpha_qcd_t]] abstract
type.
<<SF lhapdf: execute tests>>=
  if (LHAPDF5_AVAILABLE) then
     call test (sf_lhapdf_3, "sf_lhapdf5_3", &
          "running alpha_s", &
          u, results)
  else if (LHAPDF6_AVAILABLE) then
     call test (sf_lhapdf_3, "sf_lhapdf6_3", &
          "running alpha_s", &
          u, results)     
  end if
<<SF lhapdf: tests>>=
  subroutine sf_lhapdf_3 (u)
    integer, intent(in) :: u
    type(qcd_t) :: qcd
    type(string_t) :: name, path
    integer :: member
    
    write (u, "(A)")  "* Test output: sf_lhapdf_3"
    write (u, "(A)")  "*   Purpose: initialize and evaluate alpha_s"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call lhapdf_global_reset ()

    if (LHAPDF5_AVAILABLE) then
       name = "cteq6ll.LHpdf"
       member = 1
       path = ""
    else if (LHAPDF6_AVAILABLE) then
       name = "CT10"
       member = 1
       path = ""
    end if
       
    write (u, "(A)")  "* Initialize qcd object"
    write (u, "(A)")
    
    allocate (alpha_qcd_lhapdf_t :: qcd%alpha)
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_lhapdf_t)
       call alpha%init (name, member, path)
    end select
    call qcd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for Q = 100"
    write (u, "(A)")
    
    write (u, "(1x,A,F8.5)")  "alpha = ", qcd%alpha%get (100._default)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_lhapdf_3"

  end subroutine sf_lhapdf_3

@ %def sf_lhapdf_3
@
%------------------------------------------------------------------------
\section{Builtin PDF sets}
For convenience in order not to depend on the external package LHAPDF,
we ship some PDFs with WHIZARD. 
@
\subsection{The module}
<<[[sf_pdf_builtin.f90]]>>=
<<File header>>

module sf_pdf_builtin

<<Use kinds>>
  use kinds, only: double
<<Use strings>>
  use io_units
  use format_defs, only: FMT_17
  use unit_tests
  use diagnostics
  use os_interface
  use physics_defs, only: PROTON, PHOTON, GLUON
  use physics_defs, only: HADRON_REMNANT_SINGLET
  use physics_defs, only: HADRON_REMNANT_TRIPLET
  use physics_defs, only: HADRON_REMNANT_OCTET
  use sm_qcd
  use lorentz
  use pdg_arrays
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  use pdf_builtin !NODEP!
  use hoppet_interface

<<Standard module head>>

<<SF pdf builtin: public>>

<<SF pdf builtin: types>>

<<SF pdf builtin: parameters>>

contains

<<SF pdf builtin: procedures>>

<<SF pdf builtin: tests>>

end module sf_pdf_builtin
@ %def sf_pdf_builtin
@ 
\subsection{Codes for default PDF sets} 
<<SF pdf builtin: parameters>>=
  character(*), parameter :: PDF_BUILTIN_DEFAULT_PROTON = "CTEQ6L"
  character(*), parameter :: PDF_BUILTIN_DEFAULT_PION   = "NONE"
  character(*), parameter :: PDF_BUILTIN_DEFAULT_PHOTON = "MRST2004QEDp"
@ %def PDF_BUILTIN_DEFAULT_SET
@ 
\subsection{The PDF builtin data block} 
The data block holds the incoming flavor (which has to be proton,
pion, or photon), the corresponding pointer to the global access data
(1, 2, or 3), the flag [[invert]] which is set for an antiproton, the
bounds as returned by LHAPDF for the specified set, and a mask that
determines which partons will be actually in use.
<<SF pdf builtin: public>>=
  public :: pdf_builtin_data_t
<<SF pdf builtin: types>>=
  type, extends (sf_data_t) :: pdf_builtin_data_t
     private
     integer :: id = -1
     type (string_t) :: name
     class(model_data_t), pointer :: model => null ()
     type(flavor_t) :: flv_in
     logical :: invert
     logical :: has_photon
     logical :: photon
     logical, dimension(-6:6) :: mask
     logical :: mask_photon
     logical :: hoppet_b_matching = .false.
   contains
   <<SF pdf builtin: pdf builtin data: TBP>>
  end type pdf_builtin_data_t

@ %def pdf_builtin_data_t
@ Generate PDF data and initialize the requested set. Pion and photon PDFs
are disabled at the moment until we ship appropiate structure functions.
needed.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: init => pdf_builtin_data_init
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_data_init (data, &
       model, pdg_in, name, path, hoppet_b_matching)
    class(pdf_builtin_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    type(string_t), intent(in) :: name
    type(string_t), intent(in) :: path
    logical, intent(in), optional :: hoppet_b_matching
    data%model => model
    if (pdg_array_get_length (pdg_in) /= 1) &
         call msg_fatal ("PDF: incoming particle must be unique")
    call flavor_init (data%flv_in, pdg_array_get (pdg_in, 1), model)
    data%mask = .true.
    data%mask_photon = .true.
    select case (pdg_array_get (pdg_in, 1))
    case (PROTON)
       data%name = var_str (PDF_BUILTIN_DEFAULT_PROTON)
       data%invert = .false.
       data%photon = .false.
    case (-PROTON)
       data%name = var_str (PDF_BUILTIN_DEFAULT_PROTON)
       data%invert = .true.
       data%photon = .false.
       ! case (PIPLUS)
       !    data%name = var_str (PDF_BUILTIN_DEFAULT_PION)
       !    data%invert = .false.
       !    data%photon = .false.
       ! case (-PIPLUS)
       !    data%name = var_str (PDF_BUILTIN_DEFAULT_PION)
       !    data%invert = .true.
       !    data%photon = .false.
       ! case (PHOTON)
       !    data%name = var_str (PDF_BUILTIN_DEFAULT_PHOTON)
       !    data%invert = .false.
       !    data%photon = .true.
    case default
       call msg_fatal ("PDF: " &
            // "incoming particle must either proton or antiproton.")
       return
    end select
    data%name = name
    data%id = pdf_get_id (data%name)
    if (data%id < 0) call msg_fatal ("unknown PDF set " // char (data%name))
    data%has_photon = pdf_provides_photon (data%id)
    if (present (hoppet_b_matching))  data%hoppet_b_matching = hoppet_b_matching
    call pdf_init (data%id, path)
    if (data%hoppet_b_matching)  call hoppet_init (.true., pdf_id = data%id)
  end subroutine pdf_builtin_data_init

@ %def pdf_builtin_data_init
@ Enable/disable partons explicitly.  If a mask entry is true,
applying the PDF will generate the corresponding flavor on output.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: set_mask => pdf_builtin_data_set_mask
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_data_set_mask (data, mask)
    class(pdf_builtin_data_t), intent(inout) :: data
    logical, dimension(-6:6), intent(in) :: mask
    data%mask = mask
  end subroutine pdf_builtin_data_set_mask

@ %def pdf_builtin_data_set_mask
@ Output.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: write => pdf_builtin_data_write
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_data_write (data, unit, verbose)
    class(pdf_builtin_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose    
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)")  "PDF builtin data:"
    if (data%id < 0) then
       write (u, "(3x,A)") "[undefined]"
       return
    end if
    write (u, "(3x,A)", advance="no") "flavor       = "
    call flavor_write (data%flv_in, u);  write (u, *)
    write (u, "(3x,A,A)")   "name         = ", char (data%name)
    write (u, "(3x,A,L1)")  "invert       = ", data%invert
    write (u, "(3x,A,L1)")  "has photon   = ", data%has_photon
    write (u, "(3x,A,6(1x,L1),1x,A,1x,L1,1x,A,6(1x,L1))") &
         "mask         =", &
         data%mask(-6:-1), "*", data%mask(0), "*", data%mask(1:6)
    write (u, "(3x,A,L1)") "photon mask  = ", data%mask_photon
    write (u, "(3x,A,L1)") "hoppet_b     = ", data%hoppet_b_matching    
  end subroutine pdf_builtin_data_write

@ %def pdf_builtin_data_write
@ The number of parameters is one.  We do not generate transverse momentum.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: get_n_par => pdf_builtin_data_get_n_par
<<SF pdf builtin: procedures>>=
  function pdf_builtin_data_get_n_par (data) result (n)
    class(pdf_builtin_data_t), intent(in) :: data
    integer :: n
    n = 1
  end function pdf_builtin_data_get_n_par
  
@ %def pdf_builtin_data_get_n_par
@ Return the outgoing particle PDG codes.  This is based on the mask.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: get_pdg_out => pdf_builtin_data_get_pdg_out
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_data_get_pdg_out (data, pdg_out)
    class(pdf_builtin_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    integer :: n, np, i
    n = count (data%mask)
    np = 0;  if (data%has_photon .and. data%mask_photon)  np = 1
    allocate (pdg1 (n + np))
    pdg1(1:n) = pack ([(i, i = -6, 6)], data%mask)
    if (np == 1)  pdg1(n+np) = PHOTON
    pdg_out(1) = pdg1
  end subroutine pdf_builtin_data_get_pdg_out
  
@ %def pdf_builtin_data_get_pdg_out
@ Allocate the interaction record.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: allocate_sf_int => pdf_builtin_data_allocate_sf_int
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_data_allocate_sf_int (data, sf_int)
    class(pdf_builtin_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (pdf_builtin_t :: sf_int)
  end subroutine pdf_builtin_data_allocate_sf_int
  
@ %def pdf_builtin_data_allocate_sf_int 
@ Return the numerical PDF set index.
<<SF pdf builtin: pdf builtin data: TBP>>=
  procedure :: get_pdf_set => pdf_builtin_data_get_pdf_set
<<SF pdf builtin: procedures>>=
  function pdf_builtin_data_get_pdf_set (data) result (pdf_set)
    class(pdf_builtin_data_t), intent(in) :: data
    integer :: pdf_set
    pdf_set = data%id
  end function pdf_builtin_data_get_pdf_set
  
@ %def pdf_builtin_data_get_pdf_set
@ 
\subsection{The PDF object}
The PDF $1\to 2$ interaction which describes
the splitting of an (anti)proton into a parton and a beam remnant.  We
stay in the strict forward-splitting limit, but allow some invariant
mass for the beam remnant such that the outgoing parton is exactly
massless.  For a real event, we would replace this by a parton
cascade, where the outgoing partons have virtuality as dictated by
parton-shower kinematics, and transverse momentum is generated.

The PDF application is a $1\to 2$ splitting process, where the
particles are ordered as (hadron, remnant, parton).

Polarization is ignored completely.  The beam particle is colorless,
while partons and beam remnant carry color.  The remnant gets a
special flavor code.
<<SF pdf builtin: types>>=
  type, extends (sf_int_t) :: pdf_builtin_t
     type(pdf_builtin_data_t), pointer :: data => null ()
     real(default) :: x = 0
     real(default) :: q = 0
   contains
   <<SF pdf builtin: pdf builtin: TBP>>
  end type pdf_builtin_t
  
@ %def pdf_builtin_t
@ Type string: display the chosen PDF set.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: type_string => pdf_builtin_type_string
<<SF pdf builtin: procedures>>=
  function pdf_builtin_type_string (object) result (string)
    class(pdf_builtin_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "PDF builtin: " // object%data%name
    else
       string = "PDF builtin: [undefined]"
    end if
  end function pdf_builtin_type_string
  
@ %def pdf_builtin_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: write => pdf_builtin_write
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_write (object, unit, testflag)
    class(pdf_builtin_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
          if (object%status >= SF_FAILED_EVALUATION) then
             write (u, "(3x,A," // FMT_17 // ")")  "Q =", object%q
          end if
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "PDF builtin data: [undefined]"
    end if
  end subroutine pdf_builtin_write
    
@ %def pdf_builtin_write
@ Initialize.  We know that [[data]] will be of concrete type
[[sf_test_data_t]], but we have to cast this explicitly.

For this implementation, we set the incoming and outgoing masses equal
to the physical particle mass, but keep the radiated mass zero.

Optionally, we can provide minimum and maximum values for the momentum
transfer.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: init => pdf_builtin_init
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_init (sf_int, data)
    class(pdf_builtin_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    type(flavor_t) :: flv, flv_remnant
    type(quantum_numbers_t), dimension(3) :: qn
    integer :: i
    select type (data)
    type is (pdf_builtin_data_t)
       mask = new_quantum_numbers_mask (.false., .false., .true.)
       call sf_int%base_init (mask, [0._default], [0._default], [0._default])
       sf_int%data => data
       do i = -6, 6
          if (data%mask(i)) then
             call quantum_numbers_init (qn(1), data%flv_in)
             if (i == 0) then
                call flavor_init (flv, GLUON, data%model)
                call flavor_init (flv_remnant, HADRON_REMNANT_OCTET, data%model)
             else
                call flavor_init (flv, i, data%model)
                call flavor_init (flv_remnant, &
                     sign (HADRON_REMNANT_TRIPLET, -i), data%model)
             end if
             call quantum_numbers_init (qn(2), &
                  flv = flv_remnant, col = color_from_flavor (flv_remnant, 1))
             call quantum_numbers_init (qn(3), &
                  flv = flv, col = color_from_flavor (flv, 1, reverse=.true.))
             call interaction_add_state (sf_int%interaction_t, qn)
          end if
       end do
       if (data%has_photon .and. data%mask_photon) then
          call flavor_init (flv, PHOTON, data%model)
          call flavor_init (flv_remnant, HADRON_REMNANT_SINGLET, data%model)
          call quantum_numbers_init (qn(2), flv = flv_remnant, &
               col = color_from_flavor (flv_remnant, 1))
          call quantum_numbers_init (qn(3), flv = flv, &
               col = color_from_flavor (flv, 1, reverse = .true.))
          call interaction_add_state (sf_int%interaction_t, qn)
       end if
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
       sf_int%status = SF_INITIAL
    end select
  end subroutine pdf_builtin_init

@ %def pdf_builtin_init
@
\subsection{Kinematics}
Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ and consequently $f(r)=2r$.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: complete_kinematics => pdf_builtin_complete_kinematics
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_complete_kinematics (sf_int, x, f, r, rb, map)
    class(pdf_builtin_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1
    if (map) then
       call msg_fatal ("PDF builtin: map flag not supported")
    else
       x(1) = r(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    call sf_int%split_momentum (x, xb1)
    select case (sf_int%status)
    case (SF_DONE_KINEMATICS)
       sf_int%x = x(1)
    case (SF_FAILED_KINEMATICS)
       sf_int%x = 0
       f = 0
    end select
  end subroutine pdf_builtin_complete_kinematics

@ %def pdf_builtin_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: inverse_kinematics => pdf_builtin_inverse_kinematics
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(pdf_builtin_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       call msg_fatal ("PDF builtin: map flag not supported")
    else
       r(1) = x(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    rb = 1 - r
    if (set_mom) then
       call sf_int%split_momentum (x, xb1)
       select case (sf_int%status)
       case (SF_DONE_KINEMATICS)
          sf_int%x = x(1)
       case (SF_FAILED_KINEMATICS)
          sf_int%x = 0
          f = 0
       end select
    end if
  end subroutine pdf_builtin_inverse_kinematics

@ %def pdf_builtin_inverse_kinematics
@ 
\subsection{Structure function}
Once the scale is also known, we can actually call the PDF and
set the values.  Contrary to LHAPDF, the wrapper already takes care of
adjusting to the $x$ and $Q$ bounds.  Account for the Jacobian.
<<SF pdf builtin: pdf builtin: TBP>>=
  procedure :: apply => pdf_builtin_apply
<<SF pdf builtin: procedures>>=
  subroutine pdf_builtin_apply (sf_int, scale)
    class(pdf_builtin_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default), dimension(-6:6) :: ff
    real(double), dimension(-6:6) :: ff_dbl
    real(default) :: x, fph
    real(double) :: xx, qq
    complex(default), dimension(:), allocatable :: fc
    associate (data => sf_int%data)
      sf_int%q = scale
      x = sf_int%x
      xx = x
      qq = scale
      if (data%invert) then
         if (data%has_photon) then
            call pdf_evolve (data%id, x, scale, ff(6:-6:-1), fph)
         else
            if (data%hoppet_b_matching) then
               call hoppet_eval (xx, qq, ff_dbl(6:-6:-1))
               ff = ff_dbl
            else
               call pdf_evolve (data%id, x, scale, ff(6:-6:-1))
            end if
         end if
      else
         if (data%has_photon) then
            call pdf_evolve (data%id, x, scale, ff, fph)
         else
            if (data%hoppet_b_matching) then
               call hoppet_eval (xx, qq, ff_dbl)
               ff = ff_dbl
            else
               call pdf_evolve (data%id, x, scale, ff)               
            end if
         end if
      end if
      if (data%has_photon) then
         allocate (fc (count ([data%mask, data%mask_photon])))
         fc = max (pack ([ff, fph], &
              [data%mask, data%mask_photon]), 0._default)
      else
         allocate (fc (count (data%mask)))
         fc = max (pack (ff, data%mask), 0._default)
      end if
    end associate
    call interaction_set_matrix_element (sf_int%interaction_t, fc)
    sf_int%status = SF_EVALUATED
  end subroutine pdf_builtin_apply

@ %def pdf_builtin_apply
@
\subsection{Strong Coupling}
Since the PDF codes provide a function for computing the running
$\alpha_s$ value, we make this available as an implementation of the
abstract [[alpha_qcd_t]] type, which is used for matrix element evaluation.
<<SF pdf builtin: public>>=
  public :: alpha_qcd_pdf_builtin_t
<<SF pdf builtin: types>>=
  type, extends (alpha_qcd_t) :: alpha_qcd_pdf_builtin_t
     type(string_t) :: pdfset_name
     integer :: pdfset_id = -1
   contains
   <<SF pdf builtin: alpha qcd: TBP>>
  end type alpha_qcd_pdf_builtin_t
  
@ %def alpha_qcd_pdf_builtin_t
@ Output.
<<SF pdf builtin: alpha qcd: TBP>>=
  procedure :: write => alpha_qcd_pdf_builtin_write
<<SF pdf builtin: procedures>>=
  subroutine alpha_qcd_pdf_builtin_write (object, unit)
    class(alpha_qcd_pdf_builtin_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "QCD parameters (pdf_builtin):"
    write (u, "(5x,A,A)")  "PDF set = ", char (object%pdfset_name)
    write (u, "(5x,A,I0)") "PDF ID  = ", object%pdfset_id
  end subroutine alpha_qcd_pdf_builtin_write
  
@ %def alpha_qcd_pdf_builtin_write
@ Calculation: the numeric ID selects the correct PDF set, which must
be properly initialized.
<<SF pdf builtin: alpha qcd: TBP>>=
  procedure :: get => alpha_qcd_pdf_builtin_get
<<SF pdf builtin: procedures>>=
  function alpha_qcd_pdf_builtin_get (alpha_qcd, scale) result (alpha)
    class(alpha_qcd_pdf_builtin_t), intent(in) :: alpha_qcd
    real(default), intent(in) :: scale
    real(default) :: alpha
    alpha = pdf_alphas (alpha_qcd%pdfset_id, scale)
  end function alpha_qcd_pdf_builtin_get
  
@ %def alpha_qcd_pdf_builtin_get
@
Initialization.  We need to access the global initialization status.
<<SF pdf builtin: alpha qcd: TBP>>=
  procedure :: init => alpha_qcd_pdf_builtin_init
<<SF pdf builtin: procedures>>=
  subroutine alpha_qcd_pdf_builtin_init (alpha_qcd, name, path)
    class(alpha_qcd_pdf_builtin_t), intent(out) :: alpha_qcd
    type(string_t), intent(in) :: name
    type(string_t), intent(in) :: path
    alpha_qcd%pdfset_name = name
    alpha_qcd%pdfset_id = pdf_get_id (name)
    if (alpha_qcd%pdfset_id < 0) &
         call msg_fatal ("QCD parameter initialization: PDF set " &
         // char (name) // " is unknown")
    call pdf_init (alpha_qcd%pdfset_id, path)
  end subroutine alpha_qcd_pdf_builtin_init
    
@ %def alpha_qcd_pdf_builtin_init
@
\subsection{Unit tests}
<<SF pdf builtin: public>>=
  public :: sf_pdf_builtin_test
<<SF pdf builtin: tests>>=
  subroutine sf_pdf_builtin_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF pdf builtin: execute tests>>
  end subroutine sf_pdf_builtin_test
  
@ %def sf_pdf_builtin_test
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF pdf builtin: execute tests>>=
  call test (sf_pdf_builtin_1, "sf_pdf_builtin_1", &
       "structure function configuration", &
       u, results)
<<SF pdf builtin: tests>>=
  subroutine sf_pdf_builtin_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: sf_pdf_builtin_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    write (u, "(A)")  "* Create empty data object"
    write (u, "(A)")

    call os_data_init (os_data)

    call model%init_sm_test ()
    pdg_in = PROTON

    allocate (pdf_builtin_data_t :: data)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    name = "CTEQ6L"

    select type (data)
    type is (pdf_builtin_data_t)
       call data%init (model, pdg_in, name, &
            os_data%pdf_builtin_datapath)
    end select

    call data%write (u)

    write (u, "(A)")

    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_pdf_builtin_1"

  end subroutine sf_pdf_builtin_1

@ %def sf_pdf_builtin_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the PDF builtin
structure function.
<<SF pdf builtin: execute tests>>=
  call test (sf_pdf_builtin_2, "sf_pdf_builtin_2", &
       "structure function instance", &
       u, results)
<<SF pdf builtin: tests>>=
  subroutine sf_pdf_builtin_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(string_t) :: name
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_pdf_builtin_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_sm_test ()
    call flavor_init (flv, PROTON, model)
    pdg_in = PROTON

    call reset_interaction_counter ()
    
    name = "CTEQ6L"

    allocate (pdf_builtin_data_t :: data)
    select type (data)
    type is (pdf_builtin_data_t)
       call data%init (model, pdg_in, name, &
            os_data%pdf_builtin_datapath)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    
    call sf_int%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = 0.5_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)

    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for Q = 100 GeV"
    write (u, "(A)")

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.) 
    call sf_int%apply (scale = 100._default)
    call sf_int%write (u)


    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_pdf_builtin_2"

  end subroutine sf_pdf_builtin_2

@ %def sf_pdf_builtin_2
@
\subsubsection{Strong Coupling}
Test $\alpha_s$ as an implementation of the [[alpha_qcd_t]] abstract
type.
<<SF pdf builtin: execute tests>>=
  call test (sf_pdf_builtin_3, "sf_pdf_builtin_3", &
       "running alpha_s", &
       u, results)
<<SF pdf builtin: tests>>=
  subroutine sf_pdf_builtin_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: sf_pdf_builtin_3"
    write (u, "(A)")  "*   Purpose: initialize and evaluate alpha_s"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call os_data_init (os_data)

    name = "CTEQ6L"
       
    write (u, "(A)")  "* Initialize qcd object"
    write (u, "(A)")
    
    allocate (alpha_qcd_pdf_builtin_t :: qcd%alpha)
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_pdf_builtin_t)
       call alpha%init (name, os_data%pdf_builtin_datapath)
    end select
    call qcd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for Q = 100"
    write (u, "(A)")
    
    write (u, "(1x,A,F8.5)")  "alpha = ", qcd%alpha%get (100._default)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_pdf_builtin_3"

  end subroutine sf_pdf_builtin_3

@ %def sf_pdf_builtin_3
@
%------------------------------------------------------------------------
\section{User Plugin for Structure Functions}
This variant gives access to user-defined structure functions or spectra.

\subsection{The module}
<<[[sf_user.f90]]>>=
<<File header>>

module sf_user

  use, intrinsic :: iso_c_binding !NODEP!
<<Use kinds>>
<<Use strings>>
  use io_units
  use format_defs, only: FMT_17
  use diagnostics
  use c_particles
  use lorentz
  use subevents
  use user_code_interface
  use pdg_arrays
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use sf_aux
  use sf_base
  
<<Standard module head>>

<<SF user: public>>

<<SF user: types>>

contains

<<SF user: procedures>>

end module sf_user
@ %def sf_user
@  
\subsection{The user structure function data block} 
The data block holds the procedure pointers that are used for retrieving
static information, as well as the actual evaluation.
<<SF user: public>>=
  public :: user_data_t
<<SF user: types>>=
  type, extends(sf_data_t) :: user_data_t
     private
     type(string_t) :: name
     integer :: n_in
     integer :: n_out
     integer :: n_tot
     integer :: n_states
     integer :: n_col
     integer :: n_dim
     integer :: n_var
     integer, dimension(2) :: pdg_in
     class(model_data_t), pointer :: model => null ()
     procedure(user_int_info), nopass, pointer :: info => null ()
     procedure(user_int_mask), nopass, pointer :: mask => null ()
     procedure(user_int_state), nopass, pointer :: state => null ()
     procedure(user_int_kinematics), nopass, pointer :: kinematics => null ()
     procedure(user_int_evaluate), nopass, pointer :: evaluate => null ()
   contains
   <<SF user: user data: TBP>>  
  end type user_data_t

@ %def user_data_t
@ Assign procedure pointers from a dynamically loaded library, given the
specified [[name]].  

We have to distinguish three cases: (1) Both beams are affected, and
the user spectrum implements both beams.  There is a single data
object. (2) Both beams are
affected, and the user spectrum applies to single beams.  Fill two
different objects.  (3) A single beam is affected.
<<SF User: public>>=
  public :: sf_user_data_init
<<SF User: procedures>>=
  subroutine sf_user_data_init (data, name, flv, model)
    type(sf_user_data_t), intent(out) :: data
    type(string_t), intent(in) :: name
    type(flavor_t), dimension(2), intent(in) :: flv
    class(model_data_t), intent(in), target :: model
    integer(c_int) :: n_in
    integer(c_int) :: n_out
    integer(c_int) :: n_states
    integer(c_int) :: n_col
    integer(c_int) :: n_dim
    integer(c_int) :: n_var
    data%name = name
    data%pdg_in = flavor_get_pdg (flv)
    data%model => model
    call c_f_procpointer (user_code_find_proc (name // "_info"), data%info)
    call c_f_procpointer (user_code_find_proc (name // "_mask"), data%mask)
    call c_f_procpointer (user_code_find_proc (name // "_state"), data%state)
    call c_f_procpointer &
         (user_code_find_proc (name // "_kinematics"), data%kinematics)
    call c_f_procpointer &
         (user_code_find_proc (name // "_evaluate"), data%evaluate)
    n_in = 1
    n_out = 2
    n_states = 1
    n_col = 2
    n_dim = 1
    n_var = 1
    call data%info (n_in, n_out, n_states, n_col, n_dim, n_var)
    data%n_in = n_in
    data%n_out = n_out
    data%n_tot = n_in + n_out
    data%n_states = n_states
    data%n_col = n_col
    data%n_dim = n_dim
    data%n_var = n_var
  end subroutine sf_user_data_init

@ %def sf_user_data_init
@ Output
<<SF user: user data: TBP>>=
  procedure :: write => user_data_write
<<SF user: procedures>>=
  subroutine user_data_write (data, unit, verbose) 
    class(user_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose        
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A,A)") "User structure function: ", char (data%name)
  end subroutine user_data_write

@ %def user_data_write
@ Retrieving contents
<<SF User: public>>=
  public :: sf_user_data_get_name
<<SF User: procedures>>=
  function sf_user_data_get_name (data) result (name)
    type(string_t) :: name
    type(sf_user_data_t), intent(in) :: data
    name = data%name
  end function sf_user_data_get_name

@ %def sf_user_data_get_name
<<SF User: public>>=
  public :: sf_user_data_get_n_in
  public :: sf_user_data_get_n_out
  public :: sf_user_data_get_n_tot
  public :: sf_user_data_get_n_dim
  public :: sf_user_data_get_n_var
<<SF User: procedures>>=
  function sf_user_data_get_n_in (data) result (n_in)
    integer :: n_in
    type(sf_user_data_t), intent(in) :: data
    n_in = data%n_in
  end function sf_user_data_get_n_in

   function sf_user_data_get_n_out (data) result (n_out)
    integer :: n_out
    type(sf_user_data_t), intent(in) :: data
    n_out = data%n_out
  end function sf_user_data_get_n_out

  function sf_user_data_get_n_tot (data) result (n_tot)
    integer :: n_tot
    type(sf_user_data_t), intent(in) :: data
    n_tot = data%n_tot
  end function sf_user_data_get_n_tot

  function sf_user_data_get_n_dim (data) result (n_dim)
    integer :: n_dim
    type(sf_user_data_t), intent(in) :: data
    n_dim = data%n_dim
  end function sf_user_data_get_n_dim

 function sf_user_data_get_n_var (data) result (n_var)
    integer :: n_var
    type(sf_user_data_t), intent(in) :: data
    n_var = data%n_var
  end function sf_user_data_get_n_var

@ %def sf_user_data_get_n_in
@ %def sf_user_data_get_n_out
@ %def sf_user_data_get_n_tot
@ %def sf_user_data_get_n_dim
@ %def sf_user_data_get_n_var
@
\subsection{The interaction}
We fill the interaction by looking up the table of states using the interface
functions.

For particles which have a known flavor (as indicated by the mask), we
compute the mass squared, so we can use it for the invariant mass of
the particle objects.
<<SF user: user: TBP>>=
  procedure :: init => user_init
<<SF user: procedures>>=
  subroutine user_init (sf_int, data)
    !!! JRR: WK please check (#529)
    class(user_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask
    integer, dimension(:), allocatable :: hel_lock
    integer(c_int) :: m_flv, m_hel, m_col, i_lock
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer(c_int) :: f, h
    integer(c_int), dimension(:), allocatable :: c
    type(flavor_t) :: flv
    type(helicity_t) :: hel
    type(color_t) :: col
    integer :: i, s
    integer(c_int) :: i_prt, i_state
    select type (data)
    type is (user_data_t)   
       allocate (mask (data%n_tot))
       allocate (hel_lock (data%n_tot))
       allocate (qn (data%n_tot))
       allocate (c (data%n_col))
       do i = 1, size (mask)
          i_prt = i
          m_flv = 0;  m_col = 0;  m_hel = 0;  i_lock = 0
          call data%mask (i_prt, m_flv, m_col, m_hel, i_lock)
          mask(i) = &
               new_quantum_numbers_mask (m_flv /= 0, m_col /= 0, m_hel /= 0)
          hel_lock(i) = i_lock
       end do
       !!! JRR: WK please check (#529)
       !!! Will have to be filled in later.
       ! call sf_int%base_init (mask, &
       !      hel_lock = hel_lock)
       call interaction_init &
            (sf_int%interaction_t, data%n_in, 0, data%n_out, mask=mask, &
            hel_lock=hel_lock, set_relations=.true.)       
       do s = 1, data%n_states
          i_state = s
          do i = 1, data%n_tot
             i_prt = i
             f = 0;  h = 0;  c = 0
             call data%state (i_state, i_prt, f, h, c)
             if (m_flv == 0) then
                call flavor_init (flv, int (f), data%model)
             else
                call flavor_init (flv)
             end if
             if (m_hel == 0) then
                call helicity_init (hel, int (h))
             else
                call helicity_init (hel)
             end if
             if (m_col == 0) then
                call color_init_from_array (col, int (c))
             else
                call color_init (col)
             end if
             call quantum_numbers_init (qn(i), flv, col, hel)
          end do
          call interaction_add_state (sf_int%interaction_t, qn)
       end do
       call interaction_freeze (sf_int%interaction_t)
       !!! JRR: WK please check (#529)
       !!! What has to be inserted here?
       ! call sf_int%set_incoming (??)
       ! call sf_int%set_radiated (??)
       ! call sf_int%set_outgoing (??)
       sf_int%status = SF_INITIAL
    end select
  end subroutine user_init

@ %def user_init
@ 
@ Allocate the interaction record.
<<SF user: user data: TBP>>=
  procedure :: allocate_sf_int => user_data_allocate_sf_int
<<SF user: procedures>>=
  subroutine user_data_allocate_sf_int (data, sf_int)
    class(user_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (user_t :: sf_int)
  end subroutine user_data_allocate_sf_int
  
@ %def user_data_allocate_sf_int 
@ The number of parameters is one.  We do not generate transverse momentum.
<<SF user: user data: TBP>>=
  procedure :: get_n_par => user_data_get_n_par
<<SF user: procedures>>=
  function user_data_get_n_par (data) result (n)
    class(user_data_t), intent(in) :: data
    integer :: n
    n = data%n_var
  end function user_data_get_n_par
  
@ %def user_data_get_n_par
@ 
@ Return the outgoing particle PDG codes. This has to be inferred from
the states (right?). JRR: WK please check.
<<SF user: user data: TBP>>=
  procedure :: get_pdg_out => user_data_get_pdg_out
<<SF user: procedures>>=
  subroutine user_data_get_pdg_out (data, pdg_out)
    class(user_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    !!! JRR: WK please check (#529)
    !!! integer :: n, np, i
    !!! n = count (data%mask)
    !!! np = 0;  if (data%has_photon .and. data%mask_photon)  np = 1
    !!! allocate (pdg_out (n + np))
    !!! pdg_out(1:n) = pack ([(i, i = -6, 6)], data%mask)
    !!! if (np == 1)  pdg_out(n+np) = PHOTON
  end subroutine user_data_get_pdg_out
  
@ %def user_data_get_pdg_out
\subsection{The user structure function}
For maximal flexibility, user structure functions separate kinematics from
dynamics just as the PDF interface does.  (JRR: Ok, I guess this now
done for all structure functions, right?) We create [[c_prt_t]]
particle objects from the incoming momenta (all other quantum numbers
are irrelevant) and call the user-supplied kinematics function to
compute the outgoing momenta, along with other variables that will be
needed for matrix element evaluation.  If known, we use the mass
squared computed above.
!!! JRR: WK please check (\#529)
I don't know actually whether this really fits into the setup done by
WK. 
<<SF user: types>>=
  !!! JRR: WK please check (#529)
  type, extends (sf_int_t) :: user_t
     type(user_data_t), pointer :: data => null ()
     real(default) :: x = 0
     real(default) :: q = 0
   contains
   <<SF user: user: TBP>>
  end type user_t 
  
@ %def user_t
@ Type string: display the name of the user structure function.
<<SF user: user: TBP>>=
  procedure :: type_string => user_type_string
<<SF user: procedures>>=
  function user_type_string (object) result (string)
    class(user_t), intent(in) :: object
    type(string_t) :: string
    if (associated (object%data)) then
       string = "User structure function: " // object%data%name
    else
       string = "User structure function: [undefined]"
    end if
  end function user_type_string
  
@ %def user_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF user: user: TBP>>=
  procedure :: write => user_write
<<SF user: procedures>>=
  subroutine user_write (object, unit, testflag)
    !!! JRR: WK please check (#529)
    !!! Guess these variables do not exist for user strfun (?)
    class(user_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       if (object%status >= SF_DONE_KINEMATICS) then
          write (u, "(1x,A)")  "SF parameters:"
          write (u, "(3x,A," // FMT_17 // ")")  "x =", object%x
          if (object%status >= SF_FAILED_EVALUATION) then
             write (u, "(3x,A," // FMT_17 // ")")  "Q =", object%q
          end if
       end if
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "User structure function data: [undefined]"
    end if
  end subroutine user_write
    
@ %def user_write
@
\subsection{Kinematics}
Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ and consequently $f(r)=2r$.
<<SF user: user: TBP>>=
  procedure :: complete_kinematics => user_complete_kinematics
<<SF user: procedures>>=
  subroutine user_complete_kinematics (sf_int, x, f, r, rb, map)
    !!! JRR: WK please check (#529)
    !!! This cannot be correct, as the CIRCE1 structure function has 
    !!! twice the variables (2->4 instead of 1->2 splitting)
    class(user_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1
    if (map) then
       call msg_fatal ("User structure function: map flag not supported")
    else
       x(1) = r(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    call sf_int%split_momentum (x, xb1)
    select case (sf_int%status)
    case (SF_DONE_KINEMATICS)
       sf_int%x = x(1)
    case (SF_FAILED_KINEMATICS)
       sf_int%x = 0
       f = 0
    end select
  end subroutine user_complete_kinematics

@ %def user_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF user: user: TBP>>=
  procedure :: inverse_kinematics => user_inverse_kinematics
<<SF user: procedures>>=
  subroutine user_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    !!! JRR: WK please check (#529)
    !!! This cannot be correct, as the CIRCE1 structure function has 
    !!! twice the variables (2->4 instead of 1->2 splitting)
    class(user_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       call msg_fatal ("User structure function: map flag not supported")
    else
       r(1) = x(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    rb = 1 - r
    if (set_mom) then
       call sf_int%split_momentum (x, xb1)
       select case (sf_int%status)
       case (SF_DONE_KINEMATICS)
          sf_int%x = x(1)
       case (SF_FAILED_KINEMATICS)
          sf_int%x = 0
          f = 0
       end select
    end if
  end subroutine user_inverse_kinematics

@ %def user_inverse_kinematics
@
<<SF User: public>>=
  public :: interaction_set_kinematics_sf_user
<<SF User: procedures>>=
  subroutine interaction_set_kinematics_sf_user (int, x, r, data)
    type(interaction_t), intent(inout) :: int
    real(default), dimension(:), intent(out) :: x
    real(default), dimension(:), intent(in) :: r
    type(sf_user_data_t), intent(in) :: data
    type(vector4_t), dimension(data%n_in) :: p_in
    type(vector4_t), dimension(data%n_out) :: p_out
    type(c_prt_t), dimension(data%n_in) :: prt_in
    type(c_prt_t), dimension(data%n_out) :: prt_out
    real(c_double), dimension(data%n_var) :: xval
    call interaction_get_momenta_sub (int, p_in, outgoing=.false.)
    prt_in = vector4_to_c_prt (p_in)
    prt_in%type = PRT_INCOMING
    call data%kinematics (prt_in, real (r, c_double), prt_out, xval)
    x = xval
    p_out = vector4_from_c_prt (prt_out)
    call interaction_set_momenta (int, p_out, outgoing=.true.)
  end subroutine interaction_set_kinematics_sf_user

@ %def interaction_set_kinematics_sf_user
@ The matrix-element evaluation may require a scale parameter, therefore this
routine is separate.  We take the variables computed above together
with the event energy scale and call the user function that computes
the matrix elements.
<<SF user: user: TBP>>=
  procedure :: apply => user_apply
<<SF user: procedures>>=
  subroutine user_apply (sf_int, scale) !, x, data)    
    !!! JRR: WK please check (#529)
    class(user_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    real(default), dimension(:), allocatable :: x
    real(c_double), dimension(sf_int%data%n_states) :: fval
    complex(default), dimension(sf_int%data%n_states) :: fc
    associate (data => sf_int%data)
      !!! This is wrong, has to be replaced
      ! allocate (x, size (sf_int%x)))
      x = sf_int%x
      call data%evaluate (real (x, c_double), real (scale, c_double), fval)
      fc = fval
      call interaction_set_matrix_element (sf_int%interaction_t, fc)
    end associate
    sf_int%status = SF_EVALUATED
  end subroutine user_apply

@ %def user_apply
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HOPPET interface}
Interface to the HOPPET wrapper necessary to perform
the LO vs. NLO matching of processes containing an initial
b quark.
<<[[hoppet_interface.f90]]>>=
<<File header>>

module hoppet_interface
  use lhapdf !NODEP!     
  
<<Standard module head>>

  public :: hoppet_init, hoppet_eval

contains

  subroutine hoppet_init (pdf_builtin, pdf, pdf_id)
    logical, intent(in) :: pdf_builtin
    type(lhapdf_pdf_t), intent(inout), optional :: pdf
    integer, intent(in), optional :: pdf_id
    external InitForWhizard
    call InitForWhizard (pdf_builtin, pdf, pdf_id)
  end subroutine hoppet_init

  subroutine hoppet_eval (x, q, f)
    double precision, intent(in)  :: x, q
    double precision, intent(out) :: f(-6:6)
    external EvalForWhizard
    call EvalForWhizard (x, q, f)
  end subroutine hoppet_eval

end module hoppet_interface
@ %def hoppet_interface
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Phase space and hard matrix elements}

These modules contain the internal representation and evaluation of
phase space and the interface to (hard-)process evaluation.

\begin{description}
\item[mappings] 
  Generate invariant masses and decay angles from given
  random numbers (or the inverse operation).  Each mapping pertains to a
  particular node in a phase-space tree.  Different mappings account for
  uniform distributions, resonances, zero-mass behavior, and so on.
\item[phs\_trees] 
  Phase space parameterizations for scattering
  processes are defined recursively as if there was an initial particle
  decaying.  This module sets up a representation in terms of abstract
  trees, where each node gets a unique binary number.  Each tree is
  stored as an array of branches, where integers indicate the
  connections.  This emulates pointers in a transparent way.  Real
  pointers would also be possible, but seem to be less efficient for
  this particular case.
\item[phs\_forests] 
  The type defined by this module collects the
  decay trees corresponding to a given process and the applicable
  mappings.  To set this up, a file is read which is either written by
  the user or by the \textbf{cascades} module functions.  The module
  also contains the routines that evaluate phase space, i.e., generate
  momenta from random numbers and back.
\item[cascades] 
  This module is a Feynman diagram generator with the
  particular purpose of finding the phase space parameterizations best
  suited for a given process.  It uses a model file to set up the
  possible vertices, generates all possible diagrams, identifies
  resonances and singularities, and simplifies the list by merging
  equivalent diagrams and dropping irrelevant ones.  This process can be
  controlled at several points by user-defined parameters.  Note that it
  depends on the particular values of particle masses, so it cannot be
  done before reading the input file.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Single-particle phase space}

This module implements the phase space for a single particle, i.e., the solid
angle, in a straightforward parameterization with a single channel.  The
phase-space implementation may be used either for $1\to 2$ decays or for $2\to
2$ scattering processes, so the number of incoming particles is the only free
parameter in the configuration.  In the latter case, we should restrict its
use to non-resonant s-channel processes, because there is no mapping of the
scattering angle.

(We might extend this later to account for generic $2\to 2$ situations, e.g.,
account for a Coulomb singularity or detect an s-channel resonance structure
that requires matching structure-function mappings.)

This is derived from the [[phs_test]] implementation in the
[[phs_base]] module above, even more simplified, but intended for
actual use.
<<[[phs_single.f90]]>>=
<<File header>>

module phs_single

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use model_data
  use flavors
  use process_constants
  use sf_mappings
  use sf_base
  use phs_base
  
<<Standard module head>>

<<PHS single: public>>

<<PHS single: types>>

contains

<<PHS single: procedures>>

<<PHS single: tests>>

end module phs_single
@ %def phs_single
@
\subsection{Configuration}
<<PHS single: public>>=
  public :: phs_single_config_t
<<PHS single: types>>=
  type, extends (phs_config_t) :: phs_single_config_t  
   contains
   <<PHS single: phs single config: TBP>>
  end type phs_single_config_t

@ %def phs_single_config_t
@ The finalizer is empty.
<<PHS single: phs single config: TBP>>=
  procedure :: final => phs_single_config_final
<<PHS single: procedures>>=
  subroutine phs_single_config_final (object)
    class(phs_single_config_t), intent(inout) :: object
  end subroutine phs_single_config_final

@ %def phs_single_final
@ Output.
<<PHS single: phs single config: TBP>>=
  procedure :: write => phs_single_config_write
<<PHS single: procedures>>=
  subroutine phs_single_config_write (object, unit)
    class(phs_single_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Partonic phase-space configuration (single-particle):"
    call object%base_write (unit)
  end subroutine phs_single_config_write
  
@ %def phs_single_config_write
@ Configuration: there is only one channel and two parameters.  The
second parameter is the azimuthal angle, which may be a flat dimension.
<<PHS single: phs single config: TBP>>=
  procedure :: configure => phs_single_config_configure
<<PHS single: procedures>>=
  subroutine phs_single_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_single_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(string_t), intent(inout), optional :: nlo_type
    if (.not. present (nlo_type)) &
      phs_config%nlo_type = 'Born'
    if (phs_config%n_out == 2) then
       phs_config%n_channel = 1
       phs_config%n_par = 2
       phs_config%sqrts = sqrts
       if (present (sqrts_fixed))  phs_config%sqrts_fixed = sqrts_fixed
       if (present (cm_frame))  phs_config%cm_frame = cm_frame
       if (present (azimuthal_dependence)) then
          phs_config%azimuthal_dependence = azimuthal_dependence
          if (.not. azimuthal_dependence) then
             allocate (phs_config%dim_flat (1))
             phs_config%dim_flat(1) = 2
          end if
       end if
       if (allocated (phs_config%channel))  deallocate (phs_config%channel)
       allocate (phs_config%channel (1))
       call phs_config%compute_md5sum ()
    else
       call msg_fatal ("Single-particle phase space requires n_out = 2")
    end if
  end subroutine phs_single_config_configure
  
@ %def phs_single_config_configure
@ Startup message, after configuration is complete.
<<PHS single: phs single config: TBP>>=
  procedure :: startup_message => phs_single_config_startup_message
<<PHS single: procedures>>=
  subroutine phs_single_config_startup_message (phs_config, unit)
    class(phs_single_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%base_startup_message (unit)
    write (msg_buffer, "(A,2(1x,I0,1x,A))") &
         "Phase space: single-particle"
    call msg_message (unit = unit)
  end subroutine phs_single_config_startup_message
    
@ %def phs_single_config_startup_message
@ Allocate an instance: the actual phase-space object.
<<PHS single: phs single config: TBP>>=
  procedure, nopass :: allocate_instance => phs_single_config_allocate_instance
<<PHS single: procedures>>=
  subroutine phs_single_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_single_t :: phs)
  end subroutine phs_single_config_allocate_instance
  
@ %def phs_single_config_allocate_instance
@
\subsection{Kinematics implementation}
We generate $\cos\theta$ and $\phi$ uniformly, covering the solid angle.

Note: The incoming momenta must be in the c.m. system.
<<PHS single: public>>=
  public :: phs_single_t
<<PHS single: types>>=
  type, extends (phs_t) :: phs_single_t
   contains
   <<PHS single: phs single: TBP>>
  end type phs_single_t
  
@ %def phs_single_t
@ Output.  The [[verbose]] setting is irrelevant, we just display the contents
of the base object.
<<PHS single: phs single: TBP>>=
  procedure :: write => phs_single_write
<<PHS single: procedures>>=
  subroutine phs_single_write (object, unit, verbose)
    class(phs_single_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
  end subroutine phs_single_write
    
@ %def phs_single_write
@ The finalizer is empty.
<<PHS single: phs single: TBP>>=
  procedure :: final => phs_single_final
<<PHS single: procedures>>=
  subroutine phs_single_final (object)
    class(phs_single_t), intent(inout) :: object
  end subroutine phs_single_final
  
@ %def phs_single_final
@ Initialization.  We allocate arrays ([[base_init]]) and adjust the
phase-space volume.  The massless two-particle phase space volume is
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.55294034614 \times 10^{-5}
\end{equation}
For a decay with nonvanishing masses ($m_3$, $m_4$), there is a correction
factor 
\begin{equation}
  \Phi_2(m) / \Phi_2(0) = \frac{1}{\hat s}
  \lambda^{1/2}(\hat s, m_3^2, m_4^2).
\end{equation}
For a scattering process with nonvanishing masses, the correction
factor is
\begin{equation}
  \Phi_2(m) / \Phi_2(0) = \frac{1}{\hat s ^ 2}
  \lambda^{1/2}(\hat s, m_1^2, m_2^2)\,
  \lambda^{1/2}(\hat s, m_3^2, m_4^2).
\end{equation}
If the energy is fixed, this is constant.  Otherwise, we have to account for
varying $\hat s$.
<<PHS single: phs single: TBP>>=
  procedure :: init => phs_single_init
<<PHS single: procedures>>=
  subroutine phs_single_init (phs, phs_config)
    class(phs_single_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    phs%volume = 1 / (4 * twopi5)
    call phs%compute_factor ()
  end subroutine phs_single_init
  
@ %def phs_single_init
@ Compute the correction factor for nonzero masses.  We do this during
initialization (when the incoming momenta [[p]] are undefined), unless
[[sqrts]] is variable.  We do this again once for each phase-space point, but
then we skip the calculation if [[sqrts]] is fixed.
<<PHS single: phs single: TBP>>=
  procedure :: compute_factor => phs_single_compute_factor
<<PHS single: procedures>>=
  subroutine phs_single_compute_factor (phs)
    class(phs_single_t), intent(inout) :: phs
    real(default) :: s_hat
    select case (phs%config%n_in)
    case (1)
       if (.not. phs%p_defined) then
          if (sum (phs%m_out) < phs%m_in(1)) then
             s_hat = phs%m_in(1) ** 2
             phs%f(1) = 1 / s_hat &
                  * sqrt (lambda (s_hat, phs%m_out(1)**2, phs%m_out(2)**2))
          else
             print *, "m_in  = ", phs%m_in
             print *, "m_out = ", phs%m_out
             call msg_fatal ("Decay is kinematically forbidden")
          end if
       end if
    case (2)
       if (phs%config%sqrts_fixed) then
          if (phs%p_defined)  return
          s_hat = phs%config%sqrts ** 2
       else
          if (.not. phs%p_defined)  return
          s_hat = sum (phs%p) ** 2
       end if
       if (sum (phs%m_in)**2 < s_hat .and. sum (phs%m_out)**2 < s_hat) then
          phs%f(1) = 1 / s_hat * &
               ( lambda (s_hat, phs%m_in (1)**2, phs%m_in (2)**2)   &
               * lambda (s_hat, phs%m_out(1)**2, phs%m_out(2)**2) ) &
               ** 0.25_default
       else
          phs%f(1) = 0
       end if
    end select
  end subroutine phs_single_compute_factor
    
@ %def phs_single_compute_factor
@ Evaluation.  We uniformly generate $\cos\theta$ and
$\phi$, with Jacobian normalized to one.

There is only a single channel, so the second subroutine does nothing.

Note: the current implementation works for elastic scattering only.
<<PHS single: phs single: TBP>>=
  procedure :: evaluate_selected_channel => phs_single_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_single_evaluate_other_channels
<<PHS single: procedures>>=
  subroutine phs_single_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_single_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    !!! Catching a gfortran bogus warning
    type(vector4_t), dimension(2) :: p_dum
    if (phs%p_defined) then
       call phs%select_channel (c_in)
       phs%r(:,c_in) = r_in
       select case (phs%config%n_in)
       case (2)
          if (all (phs%m_in == phs%m_out)) then
             call compute_kinematics_solid_angle (phs%p, phs%q, r_in) 
          else
             call msg_bug ("PHS single: inelastic scattering not implemented")
          end if
       case (1)
          !!! Catching a gfortran bogus warning
          !!! call compute_kinematics_solid_angle (phs%decay_p (), phs%q, x)
          p_dum = phs%decay_p ()
          call compute_kinematics_solid_angle (p_dum, phs%q, r_in)
       end select
       call phs%compute_factor ()
       phs%q_defined = .true.
       phs%r_defined = .true.
    end if
  end subroutine phs_single_evaluate_selected_channel
  
  subroutine phs_single_evaluate_other_channels (phs, c_in)
    class(phs_single_t), intent(inout) :: phs
    integer, intent(in) :: c_in
  end subroutine phs_single_evaluate_other_channels
  
@ %def phs_single_evaluate_selected_channel
@ %def phs_single_evaluate_other_channels
@ Auxiliary: split a decaying particle at rest into the decay products,
aligned along the $z$ axis.
<<PHS single: phs single: TBP>>=
  procedure :: decay_p => phs_single_decay_p
<<PHS single: procedures>>=
  function phs_single_decay_p (phs) result (p)
    class(phs_single_t), intent(in) :: phs
    type(vector4_t), dimension(2) :: p
    real(default) :: k
    real(default), dimension(2) :: E
    k = sqrt (lambda (phs%m_in(1) ** 2, phs%m_out(1) ** 2, phs%m_out(2) ** 2)) &
         / (2 * phs%m_in(1))
    E = sqrt (phs%m_out ** 2 + k ** 2)
    p(1) = vector4_moving (E(1), k, 3)
    p(2) = vector4_moving (E(2),-k, 3)
  end function phs_single_decay_p
  
@ %def phs_single_decay_p
@ Inverse evaluation.
<<PHS single: phs single: TBP>>=
  procedure :: inverse => phs_single_inverse
<<PHS single: procedures>>=
  subroutine phs_single_inverse (phs)
    class(phs_single_t), intent(inout) :: phs
    real(default), dimension(:), allocatable :: x
    if (phs%p_defined .and. phs%q_defined) then
       call phs%select_channel ()
       allocate (x (phs%config%n_par))
       call inverse_kinematics_solid_angle (phs%p, phs%q, x)
       phs%r(:,1) = x
       call phs%compute_factor ()
       phs%r_defined = .true.
    end if
  end subroutine phs_single_inverse
  
@ %def phs_single_inverse
@
\subsection{Unit tests}
<<PHS single: public>>=
  public :: phs_single_test
<<PHS single: tests>>=
  subroutine phs_single_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS single: execute tests>>
  end subroutine phs_single_test
  
@ %def phs_single_test
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.  Also
check the [[azimuthal_dependence]] flag.
<<PHS single: execute tests>>=
  call test (phs_single_1, "phs_single_1", &
       "phase-space configuration", &
       u, results)
<<PHS single: tests>>=
  subroutine phs_single_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    real(default) :: sqrts
    
    write (u, "(A)")  "* Test output: phs_single_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_1"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts, azimuthal_dependence=.false.)
       
    call phs_data%write (u)
  
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_1"

  end subroutine phs_single_1

@ %def phs_single_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS single: execute tests>>=
  call test (phs_single_2, "phs_single_2", &
       "phase-space evaluation", &
       u, results)
<<PHS single: tests>>=
  subroutine phs_single_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    
    write (u, "(A)")  "* Test output: phs_single_2"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flavor_init (flv, 25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_2"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv)**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_2"

  end subroutine phs_single_2

@ %def phs_single_2
@
\subsubsection{Phase space for non-c.m. system}
Compute kinematics for given parameters, also invert the calculation.
Since this will involve cancellations, we call [[pacify]] to eliminate
numerical noise.
<<PHS single: execute tests>>=
  call test (phs_single_3, "phs_single_3", &
       "phase-space evaluation in lab frame", &
       u, results)
<<PHS single: tests>>=
  subroutine phs_single_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    type(lorentz_transformation_t) :: lt
    
    write (u, "(A)")  "* Test output: phs_single_3"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")  "*            without c.m. kinematics assumption"
    write (u, "(A)")
    
    call model%init_test ()
    call flavor_init (flv, 25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_3"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts, cm_frame=.false., sqrts_fixed=.false.)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta in lab system"
    write (u, "(A)")

    lt = boost (0.1_default, 1) * boost (0.3_default, 3)
    
    E = sqrts / 2
    p(1) = lt * vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    p(2) = lt * vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv)**2), 3)

    call vector4_write (p(1), u)
    call vector4_write (p(2), u)

    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    
    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call pacify (phs)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Extract outgoing momenta in lab system"
    write (u, "(A)")
    
    call phs%get_outgoing_momenta (q)
    call vector4_write (q(1), u)
    call vector4_write (q(2), u)

    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call pacify (phs)
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_3"

  end subroutine phs_single_3

@ %def phs_single_3
@
\subsubsection{Decay Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.  This
time, implement a decay process.
<<PHS single: execute tests>>=
  call test (phs_single_4, "phs_single_4", &
       "decay phase-space evaluation", &
       u, results)
<<PHS single: tests>>=
  subroutine phs_single_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(1) :: p
    type(vector4_t), dimension(2) :: q
    
    write (u, "(A)")  "* Test output: phs_single_4"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()

    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))
    call flavor_init (flv, 25, model)

    write (u, "(A)")  "* Initialize a decay and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_decay_data (var_str ("phs_single_4"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    call phs_data%configure (flavor_get_mass (flv))

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    p(1) = vector4_at_rest (flavor_get_mass (flv))

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs_data%configure (flavor_get_mass (flv))

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_4"

  end subroutine phs_single_4

@ %def phs_single_4
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Mappings}

Mappings are objects that encode the transformation of the interval
$(0,1)$ to a physical variable $m^2$ or $\cos\theta$ (and back), as it
is used in the phase space parameterization.  The mapping objects
contain fixed parameters, the associated methods implement the mapping
and inverse mapping operations, including the computation of the
Jacobian (phase space factor).
<<[[mappings.f90]]>>=
<<File header>>

module mappings

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_19
  use diagnostics
  use md5
  use model_data
  use flavors

<<Standard module head>>

<<Mappings: public>>

<<Mappings: parameters>>

<<Mappings: types>>

<<Mappings: interfaces>>

contains

<<Mappings: procedures>>

end module mappings
@ %def mappings
@ 
\subsection{Default parameters}
This type holds the default parameters, needed for setting the scale
in cases where no mass parameter is available.  The contents are public.
<<Mappings: public>>=
  public :: mapping_defaults_t
<<Mappings: types>>=
  type :: mapping_defaults_t
     real(default) :: energy_scale = 10
     real(default) :: invariant_mass_scale = 10
     real(default) :: momentum_transfer_scale = 10
     logical :: step_mapping = .true.
     logical :: step_mapping_exp = .true.
     logical :: enable_s_mapping = .false.
   contains
   <<Mappings: mapping defaults: TBP>>
  end type mapping_defaults_t

@ %def mapping_defaults_t
@ Output.
<<Mappings: mapping defaults: TBP>>=
  procedure :: write => mapping_defaults_write
<<Mappings: procedures>>=
  subroutine mapping_defaults_write (object, unit)
    class(mapping_defaults_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A," // FMT_19 // ")") "energy scale  = ", &
         object%energy_scale
    write (u, "(3x,A," // FMT_19 // ")") "mass scale    = ", &
         object%invariant_mass_scale
    write (u, "(3x,A," // FMT_19 // ")") "q scale       = ", &
         object%momentum_transfer_scale
    write (u, "(3x,A,L1)") "step mapping     = ", &
         object%step_mapping
    write (u, "(3x,A,L1)") "step exp. mode   = ", &
         object%step_mapping_exp
    write (u, "(3x,A,L1)") "allow s mapping  = ", &
         object%enable_s_mapping
  end subroutine mapping_defaults_write    

@ %def mapping_defaults_write
@ 
<<Mappings: public>>=
  public :: mapping_defaults_md5sum
<<Mappings: procedures>>=
  function mapping_defaults_md5sum (mapping_defaults) result (md5sum_map)
    character(32) :: md5sum_map
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    integer :: u
    u = free_unit ()
    open (u, status = "scratch")
    write (u, *)  mapping_defaults%energy_scale
    write (u, *)  mapping_defaults%invariant_mass_scale
    write (u, *)  mapping_defaults%momentum_transfer_scale
    write (u, *)  mapping_defaults%step_mapping
    write (u, *)  mapping_defaults%step_mapping_exp
    write (u, *)  mapping_defaults%enable_s_mapping
    rewind (u)
    md5sum_map = md5sum (u)
    close (u)
  end function mapping_defaults_md5sum

@ %def mapping_defaults_md5sum
@
\subsection{The Mapping type}
Each mapping has a type (e.g., s-channel, infrared), a binary code
(redundant, but useful for debugging), and a reference particle.  The
flavor code of this particle is stored for bookkeeping reasons, what
matters are the mass and width of this particle.  Furthermore,
depending on the type, various mapping parameters can be set and used.

The parameters [[a1]] to [[a3]] (for $m^2$ mappings) and [[b1]] to
[[b3]] (for $\cos\theta$ mappings) are values that are stored once to
speed up the calculation, if [[variable_limits]] is false.  The exact
meaning of these parameters depends on the mapping type.  The limits
are fixed if there is a fixed c.m. energy.
<<Mappings: public>>=
  public :: mapping_t
<<Mappings: types>>=
  type :: mapping_t
     private
     integer :: type = NO_MAPPING
     integer(TC) :: bincode
     type(flavor_t) :: flv
     real(default) :: mass = 0
     real(default) :: width = 0
     logical :: a_unknown = .true.
     real(default) :: a1 = 0
     real(default) :: a2 = 0
     real(default) :: a3 = 0
     logical :: b_unknown = .true.
     real(default) :: b1 = 0
     real(default) :: b2 = 0
     real(default) :: b3 = 0
     logical :: variable_limits = .true.
  end type mapping_t
  
@ %def mapping_t
@ The valid mapping types.  The extra type [[STEP_MAPPING]] is used
only internally.
<<Mappings: parameters>>=
<<Mapping modes>>
@
\subsection{Screen output}
Do not write empty mappings.
<<Mappings: public>>=
  public :: mapping_write
<<Mappings: procedures>>=
  subroutine mapping_write (map, unit, verbose)
    type(mapping_t), intent(in) :: map
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    character(len=9) :: str
    u = given_output_unit (unit);  if (u < 0)  return
    select case(map%type)
    case(S_CHANNEL); str = "s_channel"
    case(COLLINEAR); str = "collinear"
    case(INFRARED);  str = "infrared "
    case(RADIATION); str = "radiation"
    case(T_CHANNEL); str = "t_channel"
    case(U_CHANNEL); str = "u_channel"
    case(STEP_MAPPING_E);  str = "step_exp"
    case(STEP_MAPPING_H);  str = "step_hyp"
    case(ON_SHELL);  str = "on_shell"
    case default;    str = "????????"
    end select
    if (map%type /= NO_MAPPING) then
       write (u, '(1x,A,I4,A)') &
            "Branch #", map%bincode, ":  " // &
            "Mapping (" // str // ") for particle " // &
            '"' // char (flavor_get_name (map%flv)) // '"'
       if (present (verbose)) then
          if (verbose) then
             select case (map%type)
             case (S_CHANNEL, RADIATION, STEP_MAPPING_E, STEP_MAPPING_H)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  m/w    = ", map%mass, map%width
             case default
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  m      = ", map%mass
             end select
             select case (map%type)
             case (S_CHANNEL, T_CHANNEL, U_CHANNEL, &
                  STEP_MAPPING_E, STEP_MAPPING_H, &
                  COLLINEAR, INFRARED, RADIATION)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  a1/2/3 = ", map%a1, map%a2, map%a3
             end select
             select case (map%type)
             case (T_CHANNEL, U_CHANNEL, COLLINEAR)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  b1/2/3 = ", map%b1, map%b2, map%b3
             end select
          end if
       end if
    end if
  end subroutine mapping_write

@ %def mapping_write
@ 
\subsection{Define a mapping}
The initialization routine sets the mapping type and the particle
(binary code and flavor code) for which the mapping applies (e.g., a
$Z$ resonance in branch \#3).  We only need the absolute value of the
flavor code.
<<Mappings: public>>=
  public :: mapping_init
<<Mappings: procedures>>=
  subroutine mapping_init (mapping, bincode, type, f, model)
    type(mapping_t), intent(inout) :: mapping
    integer(TC), intent(in) :: bincode
    type(string_t), intent(in) :: type
    integer, intent(in), optional :: f
    class(model_data_t), intent(in), optional, target :: model
    mapping%bincode = bincode
    select case (char (type))
    case ("s_channel");  mapping%type = S_CHANNEL
    case ("collinear");  mapping%type = COLLINEAR
    case ("infrared");   mapping%type = INFRARED
    case ("radiation");  mapping%type = RADIATION
    case ("t_channel");  mapping%type = T_CHANNEL
    case ("u_channel");  mapping%type = U_CHANNEL
    case ("step_exp");  mapping%type = STEP_MAPPING_E
    case ("step_hyp");  mapping%type = STEP_MAPPING_H
    case ("on_shell");  mapping%type = ON_SHELL
    case default
       call msg_bug ("Mappings: encountered undefined mapping key '" &
            // char (type) // "'")
    end select
    if (present (f) .and. present (model)) &
         call flavor_init (mapping%flv, abs (f), model)
  end subroutine mapping_init

@ %def mapping_init
@ This sets the actual mass and width, using a parameter set.  Since
the auxiliary parameters will only be determined when the mapping is
first called, they are marked as unknown.
<<Mappings: public>>=
  public :: mapping_set_parameters
<<Mappings: procedures>>=
  subroutine mapping_set_parameters (map, mapping_defaults, variable_limits)
    type(mapping_t), intent(inout) :: map
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    if (map%type /= NO_MAPPING) then
       map%mass  = flavor_get_mass (map%flv)
       map%width = flavor_get_width (map%flv)
       map%variable_limits = variable_limits
       map%a_unknown = .true.
       map%b_unknown = .true.
       select case (map%type)
       case (S_CHANNEL)
          if (map%mass <= 0) then
             call mapping_write (map)
             call msg_fatal &
                  & (" S-channel resonance must have positive mass")
          else if (map%width <= 0) then
             call mapping_write (map)
             call msg_fatal &
                  & (" S-channel resonance must have positive width")
          end if
       case (RADIATION)
          map%width = max (map%width, mapping_defaults%energy_scale)
       case (INFRARED, COLLINEAR)
          map%mass = max (map%mass, mapping_defaults%invariant_mass_scale)
       case (T_CHANNEL, U_CHANNEL)
          map%mass = max (map%mass, mapping_defaults%momentum_transfer_scale)
       end select
    end if
  end subroutine mapping_set_parameters

@ %def mapping_set_code mapping_set_parameters
@ For a step mapping the mass and width are set directly, instead of
being determined from the flavor parameter (which is meaningless
here).  They correspond to the effective upper bound of phase space
due to a resonance, as opposed to the absolute upper bound.
<<Mappings: public>>=
  public :: mapping_set_step_mapping_parameters
<<Mappings: procedures>>=
  subroutine mapping_set_step_mapping_parameters (map, &
       mass, width, variable_limits)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: mass, width
    logical, intent(in) :: variable_limits
    select case (map%type)
    case (STEP_MAPPING_E, STEP_MAPPING_H)
       map%variable_limits = variable_limits
       map%a_unknown = .true.
       map%b_unknown = .true.
       map%mass = mass
       map%width = width
    end select
  end subroutine mapping_set_step_mapping_parameters

@ %def mapping_set_step_mapping_parameters
@ 
\subsection{Retrieve contents}
Return true if there is any / an s-channel mapping.
<<Mappings: public>>=
  public :: mapping_is_set
  public :: mapping_is_s_channel
  public :: mapping_is_on_shell
<<Mappings: procedures>>=
  function mapping_is_set (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type /= NO_MAPPING
  end function mapping_is_set

  function mapping_is_s_channel (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type == S_CHANNEL
  end function mapping_is_s_channel

  function mapping_is_on_shell (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type == ON_SHELL
  end function mapping_is_on_shell

@ %def mapping_is_set
@ %def mapping_is_s_channel
@ %def mapping_is_on_shell
@ Return stored mass and width, respectively.
<<Mappings: public>>=
  public :: mapping_get_mass
  public :: mapping_get_width
<<Mappings: procedures>>=
  function mapping_get_mass (mapping) result (mass)
    real(default) :: mass
    type(mapping_t), intent(in) :: mapping
    mass = mapping%mass
  end function mapping_get_mass

  function mapping_get_width (mapping) result (width)
    real(default) :: width
    type(mapping_t), intent(in) :: mapping
    width = mapping%width
  end function mapping_get_width

@ %def mapping_get_mass
@ %def mapping_get_width
@ 
\subsection{Compare mappings}
Equality for single mappings and arrays
<<Mappings: public>>=
  public :: operator(==)
<<Mappings: interfaces>>=
  interface operator(==)
     module procedure mapping_equal
  end interface
<<Mappings: procedures>>=
  function mapping_equal (m1, m2) result (equal)
    type(mapping_t), intent(in) :: m1, m2
    logical :: equal
    if (m1%type == m2%type) then
       select case (m1%type)
       case (NO_MAPPING)
          equal = .true.
       case (S_CHANNEL, RADIATION, STEP_MAPPING_E, STEP_MAPPING_H)
          equal = (m1%mass == m2%mass) .and. (m1%width == m2%width)
       case default
          equal = (m1%mass == m2%mass)
       end select
    else
       equal = .false.
    end if
  end function mapping_equal

@ %def mapping_equal
@
\subsection{Mappings of the invariant mass}
Inserting an $x$ value between 0 and 1, we want to compute the
corresponding invariant mass $m^2(x)$ and the jacobian, aka phase
space factor $f(x)$.  We also need the reverse operation.

In general, the phase space factor $f$ is defined by
\begin{equation}
  \frac{1}{s}\int_{m^2_{\textrm{min}}}^{m^2_{\textrm{max}}} dm^2\,g(m^2)
  = \int_0^1 dx\,\frac{1}{s}\,\frac{dm^2}{dx}\,g(m^2(x))
  = \int_0^1 dx\,f(x)\,g(x),
\end{equation}
where thus
\begin{equation}
  f(x) = \frac{1}{s}\,\frac{dm^2}{dx}.
\end{equation}
With this mapping, a function of the form
\begin{equation}
  g(m^2) = c\frac{dx(m^2)}{dm^2}
\end{equation}
is mapped to a constant:
\begin{equation}
  \frac{1}{s}\int_{m^2_{\textrm{min}}}^{m^2_{\textrm{max}}} dm^2\,g(m^2)
  = \int_0^1 dx\,f(x)\,g(m^2(x)) = \int_0^1 dx\,\frac{c}{s}.
\end{equation}

Here is the mapping routine.  Input are the available energy
squared [[s]], the limits for $m^2$, and the $x$ value.  Output are
the $m^2$ value and the phase space factor $f$.
<<Mappings: public>>=
  public :: mapping_compute_msq_from_x
<<Mappings: procedures>>=
  subroutine mapping_compute_msq_from_x (map, s, msq_min, msq_max, msq, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s, msq_min, msq_max
    real(default), intent(out) :: msq, f
    real(default), intent(in) :: x
    real(default) :: z, msq0, msq1, tmp
    integer :: type
    type = map%type
    if (s == 0) &
         call msg_fatal (" Applying msq mapping for zero energy")
  <<Modify mapping type if necessary>>
    select case(type)
    case (NO_MAPPING)
     <<Constants for trivial msq mapping>>
     <<Apply trivial msq mapping>>
    case (S_CHANNEL)
     <<Constants for s-channel resonance mapping>>
     <<Apply s-channel resonance mapping>>
    case (COLLINEAR, INFRARED, RADIATION)
     <<Constants for s-channel pole mapping>>
     <<Apply s-channel pole mapping>>
    case (T_CHANNEL, U_CHANNEL)
     <<Constants for t-channel pole mapping>>
     <<Apply t-channel pole mapping>>
    case (STEP_MAPPING_E)
     <<Constants for exponential step mapping>>
     <<Apply exponential step mapping>>
    case (STEP_MAPPING_H)
     <<Constants for hyperbolic step mapping>>
     <<Apply hyperbolic step mapping>>
    case default
       call msg_fatal ( " Attempt to apply undefined msq mapping")
    end select
  end subroutine mapping_compute_msq_from_x

@ %def mapping_compute_msq_from_x
@ The inverse mapping
<<Mappings: public>>=
  public :: mapping_compute_x_from_msq
<<Mappings: procedures>>=
  subroutine mapping_compute_x_from_msq (map, s, msq_min, msq_max, msq, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s, msq_min, msq_max
    real(default), intent(in) :: msq
    real(default), intent(out) :: f, x
    real(default) :: msq0, msq1, tmp, z
    integer :: type
    type = map%type
    if (s == 0) &
         call msg_fatal (" Applying inverse msq mapping for zero energy")
  <<Modify mapping type if necessary>>
    select case (type)
    case (NO_MAPPING)
     <<Constants for trivial msq mapping>>
     <<Apply inverse trivial msq mapping>>
    case (S_CHANNEL)
     <<Constants for s-channel resonance mapping>>
     <<Apply inverse s-channel resonance mapping>>
    case (COLLINEAR, INFRARED, RADIATION)
     <<Constants for s-channel pole mapping>>
     <<Apply inverse s-channel pole mapping>>
    case (T_CHANNEL, U_CHANNEL)
     <<Constants for t-channel pole mapping>>
     <<Apply inverse t-channel pole mapping>>
    case (STEP_MAPPING_E)
     <<Constants for exponential step mapping>>
     <<Apply inverse exponential step mapping>>
    case (STEP_MAPPING_H)
     <<Constants for hyperbolic step mapping>>
     <<Apply inverse hyperbolic step mapping>>
    case default
       call msg_fatal ( " Attempt to apply undefined msq mapping")
    end select
  end subroutine mapping_compute_x_from_msq

@ %def mapping_compute_x_from_msq
@
\subsubsection{Trivial mapping}
We simply map the boundaries of the interval $(m_{\textrm{min}},
m_{\textrm{max}})$ to $(0,1)$:
\begin{equation}
  m^2 = (1-x) m_{\textrm{min}}^2 + x m_{\textrm{max}}^2;
\end{equation}
the inverse is
\begin{equation}
  x = \frac{m^2 - m_{\textrm{min}}^2}{m_{\textrm{max}}^2- m_{\textrm{min}}^2}.
\end{equation}
Hence
\begin{equation}
  f(x) = \frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{s},
\end{equation}
and we have, as required,
\begin{equation}
  f(x)\,\frac{dx}{dm^2} = \frac{1}{s}.
\end{equation}

We store the constant parameters the first time the mapping is called
-- or, if limits vary, recompute them each time.
<<Constants for trivial msq mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a1 = 0
     map%a2 = msq_max - msq_min
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply trivial msq mapping>>=
  msq = (1-x) * msq_min + x * msq_max
  f = map%a3
<<Apply inverse trivial msq mapping>>=
  if (map%a2 /= 0) then
     x = (msq - msq_min) / map%a2
  else
     x = 0
  end if
  f = map%a3
@ Resonance or step mapping does not make much sense if the resonance mass is
outside the kinematical bounds.  If this is the case, revert to
[[NO_MAPPING]].  This is possible even if the kinematical bounds vary
from event to event.
<<Modify mapping type if necessary>>=
  select case (type)
  case (S_CHANNEL, STEP_MAPPING_E, STEP_MAPPING_H)
     msq0 = map%mass**2
     if (msq0 < msq_min .or. msq0 > msq_max)  type = NO_MAPPING
  end select
@ 
\subsubsection{Breit-Wigner mapping}
A Breit-Wigner resonance with mass $M$ and width $\Gamma$ is flattened
by the following mapping:

This mapping does not make much sense if the resonance mass is too low.
If this is the case, revert to [[NO_MAPPING]].  There is a tricky
point with this if the mass is too high: [[msq_max]] is not a
constant if structure functions are around.  However, switching the
type depending on the overall energy does not change the integral, it
is just another branching point.
\begin{equation}
  m^2 = M(M+t\Gamma),
\end{equation}
where
\begin{equation}
  t = \tan\left[(1-x)\arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}
                + x  \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}\right].
\end{equation}
The inverse:
\begin{equation}
  x = \frac{  \arctan\frac{m^2 - M^2}{M\Gamma}
            - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}}
           {  \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}
            - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}}
\end{equation}
The phase-space factor of this transformation is
\begin{equation}
  f(x) = \frac{M\Gamma}{s}\left(
           \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}
         - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}\right)
	 (1 + t^2).
\end{equation}
This maps any function proportional to
\begin{equation}
  g(m^2) = \frac{M\Gamma}{(m^2-M^2)^2 + M^2\Gamma^2}
\end{equation}
to a constant times $1/s$.
<<Constants for s-channel resonance mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     msq0 = map%mass ** 2
     map%a1 = atan ((msq_min - msq0) / (map%mass * map%width))
     map%a2 = atan ((msq_max - msq0) / (map%mass * map%width))
     map%a3 = (map%a2 - map%a1) * (map%mass * map%width) / s 
     map%a_unknown = .false.
  end if
<<Apply s-channel resonance mapping>>=
  z = (1-x) * map%a1 + x * map%a2
  if (-pi/2 < z .and. z < pi/2) then
     tmp = tan (z)
     msq = map%mass * (map%mass + map%width * tmp)
     f = map%a3 * (1 + tmp**2) 
  else
     msq = 0
     f = 0
  end if
<<Apply inverse s-channel resonance mapping>>=
  tmp = (msq - msq0) / (map%mass * map%width)
  x = (atan (tmp) - map%a1) / (map%a2 - map%a1)
  f = map%a3 * (1 + tmp**2)
@ 
\subsubsection{Mapping for massless splittings}
This mapping accounts for approximately scale-invariant behavior where
$\ln M^2$ is evenly distributed.
\begin{equation}
  m^2 = m_{\textrm{min}}^2 + M^2\left(\exp(xL)-1\right)
\end{equation}
where
\begin{equation}
  L = \ln\left(\frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{M^2} + 1\right).
\end{equation}
The inverse:
\begin{equation}
  x = \frac1L\ln\left(\frac{m^2-m_{\textrm{min}}^2}{M^2} + 1\right)
\end{equation}
The constant $M$ is a characteristic scale.  Above this scale
($m^2-m_{\textrm{min}}^2 \gg M^2$), this mapping behaves like
$x\propto\ln m^2$, while below the scale it reverts to a linear
mapping.

The phase-space factor is
\begin{equation}
  f(x) = \frac{M^2}{s}\,\exp(xL)\,L.
\end{equation}
A function proportional to
\begin{equation}
  g(m^2) = \frac{1}{(m^2-m_{\textrm{min}}^2) + M^2}
\end{equation}
is mapped to a constant, i.e., a simple pole near $m_{\textrm{min}}$
with a regulator mass $M$.

This type of mapping is useful for massless collinear and infrared
singularities, where the scale is stored as the mass parameter.  In
the radiation case (IR radiation off massive particle), the heavy
particle width is the characteristic scale.
<<Constants for s-channel pole mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     if (type == RADIATION) then
        msq0 = map%width**2
     else
        msq0 = map%mass**2
     end if
     map%a1 = msq0
     map%a2 = log ((msq_max - msq_min) / msq0 + 1)
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply s-channel pole mapping>>=
  msq1 = map%a1 * exp (x * map%a2)
  msq = msq1 - map%a1 + msq_min 
  f = map%a3 * msq1
<<Apply inverse s-channel pole mapping>>=
  msq1 = msq - msq_min + map%a1
  x = log (msq1 / map%a1) / map%a2
  f = map%a3 * msq1
@ 
\subsubsection{Mapping for t-channel poles}
This is also approximately scale-invariant, and we use the same type
of mapping as before.  However, we map $1/x$ singularities at both
ends of the interval; again, the mapping becomes linear when the
distance is less than $M^2$:
\begin{equation}
  m^2 = 
  \begin{cases}
    m_{\textrm{min}}^2 + M^2\left(\exp(xL)-1\right)
    &
    \text{for $0 < x < \frac12$}
    \\
    m_{\textrm{max}}^2 - M^2\left(\exp((1-x)L)-1\right)
    &
    \text{for $\frac12 \leq x < 1$}
  \end{cases}
\end{equation}
where
\begin{equation}
  L = 2\ln\left(\frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{2M^2} 
                + 1\right).
\end{equation}
The inverse:
\begin{equation}
  x = 
  \begin{cases}
    \frac1L\ln\left(\frac{m^2-m_{\textrm{min}}^2}{M^2} + 1\right)
    &
    \text{for $m^2 < (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
    \\
    1 - \frac1L\ln\left(\frac{m_{\textrm{max}}-m^2}{M^2} + 1\right)
    &
    \text{for $m^2 \geq (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
  \end{cases}
\end{equation}
The phase-space factor is
\begin{equation}
  f(x) = 
  \begin{cases}
    \frac{M^2}{s}\,\exp(xL)\,L.
    &
    \text{for $0 < x < \frac12$}
    \\
    \frac{M^2}{s}\,\exp((1-x)L)\,L.
    &
    \text{for $\frac12 \leq x < 1$}
  \end{cases}
\end{equation}
A (continuous) function proportional to
\begin{equation}
  g(m^2) =
  \begin{cases}
    1/(m^2-m_{\textrm{min}}^2) + M^2)
    &
    \text{for $m^2 < (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
    \\
    1/((m_{\textrm{max}}^2 - m^2) + M^2)
    &
    \text{for $m^2 \leq (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
  \end{cases}
\end{equation}
is mapped to a constant by this mapping, i.e., poles near both ends of
the interval.
<<Constants for t-channel pole mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     msq0 = map%mass**2
     map%a1 = msq0
     map%a2 = 2 * log ((msq_max - msq_min)/(2*msq0) + 1)
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply t-channel pole mapping>>=
  if (x < .5_default) then
     msq1 = map%a1 * exp (x * map%a2)
     msq = msq1 - map%a1 + msq_min
  else
     msq1 = map%a1 * exp ((1-x) * map%a2)
     msq = -(msq1 - map%a1) + msq_max
  end if
  f = map%a3 * msq1
<<Apply inverse t-channel pole mapping>>=
  if (msq < (msq_max + msq_min)/2) then
     msq1 = msq - msq_min + map%a1
     x = log (msq1/map%a1) / map%a2
  else
     msq1 = msq_max - msq + map%a1
     x = 1 - log (msq1/map%a1) / map%a2
  end if
  f = map%a3 * msq1
@
\subsection{Step mapping}
Step mapping is useful when the allowed range for a squared-mass
variable is large, but only a fraction at the lower end is populated
because the particle in question is an (off-shell) decay product of a
narrow resonance.  I.e., if the resonance was forced to be on-shell,
the upper end of the range would be the resonance mass, minus the
effective (real or resonance) mass of the particle(s) in the sibling
branch of the decay.

The edge of this phase space section has a width which is determined
by the width of the parent, plus the width of the sibling branch.  (The
widths might be added in quadrature, but this precision is probably
not important.)

\subsubsection{Fermi function}

A possible mapping is derived from the Fermi function which has
precisely this behavior.  The Fermi function is given by
\begin{equation}
  f(x) = \frac{1}{1 + \exp\frac{x-\mu}{\gamma}}
\end{equation}
where $x$ is taken as the invariant mass squared, $\mu$ is the
invariant mass squared of the edge, and $\gamma$ is the effective
width which is given by the widths of the parent and the sibling
branch.  (Widths might be added in quadrature, but we do not require
this level of precision.)
\begin{align}
  x &= \frac{m^2 - m_{\text{min}}^2}{\Delta m^2}
\\
  \mu &= 
  \frac{m_{\text{max,eff}}^2 - m_{\text{min}}^2}
          {\Delta m^2}
\\
  \gamma &= \frac{2m_{\text{max,eff}}\Gamma}{\Delta m^2}
\end{align}
with
\begin{equation}
  \Delta m^2 = m_{\text{max}}^2 - m_{\text{min}}^2
\end{equation}
$m^2$ is thus given by
\begin{equation}
  m^2(x) = xm_{\text{max}}^2 + (1-x)m_{\text{min}}^2
\end{equation}
For the mapping, we compute the integral $g(x)$ of the Fermi function,
normalized such that $g(0)=0$ and $g(1)=1$.  We introduce the abbreviations
\begin{align}
  \alpha &= 1 - \gamma\ln\frac{1 + \beta e^{1/\gamma}}{1 + \beta}
\\
  \beta  &= e^{- \mu/\gamma}
\end{align}
and obtain
\begin{equation}
  g(x) = \frac{1}{\alpha}
         \left(x - \gamma\ln\frac{1 + \beta e^{x/\gamma}}
                                 {1 + \beta}\right)
\end{equation}
The actual mapping is the inverse function $h(y) = g^{-1}(y)$,
\begin{equation}
  h(y) = -\gamma\ln\left(e^{-\alpha y/\gamma}(1 + \beta) - \beta\right)
\end{equation}
The Jacobian is
\begin{equation}
  \frac{dh}{dy} = \alpha\left(1 - e^{\alpha y/\gamma}
                                  \frac{\beta}{1 + \beta}\right)^{-1}
\end{equation}
which is equal to $1/(dg/dx)$, namely
\begin{equation}
  \frac{dg}{dx} = \frac{1}{\alpha}\,\frac{1}{1 + \beta e^{x/\gamma}}
\end{equation}
The final result is
\begin{align}
  \int_{m_{\text{min}}^2}^{m_{\text{max}}^2} dm^2\,F(m^2)
  &= \Delta m^2\int_0^1\,dx\,F(m^2(x))
\\
  &= \Delta m^2\int_0^1\,dy\,F(m^2(h(y)))\,\frac{dh}{dy}
\end{align}
Here is the implementation.  We fill [[a1]], [[a2]], [[a3]] with
$\alpha,\beta,\gamma$, respectively.
<<Constants for exponential step mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a3 = max (2 * map%mass * map%width / (msq_max - msq_min), 0.01_default)
     map%a2 = exp (- (map%mass**2 - msq_min) / (msq_max - msq_min) &
                     / map%a3)
     map%a1 = 1 - map%a3 * log ((1 + map%a2 * exp (1 / map%a3)) / (1 + map%a2))
  end if
<<Apply exponential step mapping>>=
  tmp = exp (- x * map%a1 / map%a3) * (1 + map%a2)
  z = - map%a3 * log (tmp - map%a2)
  msq  = z * msq_max + (1 - z) * msq_min
  f = map%a1 / (1 - map%a2 / tmp) * (msq_max - msq_min) / s
<<Apply inverse exponential step mapping>>=
  z = (msq - msq_min) / (msq_max - msq_min)
  tmp = 1 + map%a2 * exp (z / map%a3)
  x = (z - map%a3 * log (tmp / (1 + map%a2))) &
      / map%a1
  f = map%a1 * tmp * (msq_max - msq_min) / s
@ 
\subsubsection{Hyperbolic mapping}

The Fermi function has the drawback that it decreases exponentially.
It might be preferable to take a function with a power-law decrease,
such that the high-mass region is not completely depopulated.

Here, we start with the actual mapping which we take as
\begin{equation}
  h(y) = \frac{b}{a-y} - \frac{b}{a} + \mu y
\end{equation}
with the abbreviation
\begin{equation}
  a = \frac12\left(1 + \sqrt{1 + \frac{4b}{1-\mu}}\right)
\end{equation}
This is a hyperbola in the $xy$ plane.  The derivative is
\begin{equation}
  \frac{dh}{dy} = \frac{b}{(a-y)^2} + \mu
\end{equation}
The constants correspond to
\begin{align}
  \mu &= 
  \frac{m_{\text{max,eff}}^2 - m_{\text{min}}^2}
          {\Delta m^2}
\\
  b &= \frac{1}{\mu}\left(\frac{2m_{\text{max,eff}}\Gamma}{\Delta m^2}\right)^2
\end{align}
The inverse function is the solution of a quadratic equation,
\begin{equation}
  g(x) = \frac{1}{2}
         \left[\left(a + \frac{x}{\mu} + \frac{b}{a\mu}\right) 
               - \sqrt{\left(a-\frac{x}{\mu}\right)^2
                       + 2\frac{b}{a\mu}\left(a + \frac{x}{\mu}\right)
                       + \left(\frac{b}{a\mu}\right)^2}\right]
\end{equation}
The constants $a_{1,2,3}$ are identified with $a,b,\mu$.
<<Constants for hyperbolic step mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a3 = (map%mass**2 - msq_min) / (msq_max - msq_min)
     map%a2 = max ((2 * map%mass * map%width / (msq_max - msq_min))**2 &
                   / map%a3, 1e-6_default)
     map%a1 = (1 + sqrt (1 + 4 * map%a2 / (1 - map%a3))) / 2
  end if
<<Apply hyperbolic step mapping>>=
  z = map%a2 / (map%a1 - x) - map%a2 / map%a1 + map%a3 * x
  msq = z * msq_max + (1 - z) * msq_min
  f = (map%a2 / (map%a1 - x)**2 + map%a3) * (msq_max - msq_min) / s
<<Apply inverse hyperbolic step mapping>>=
  z = (msq - msq_min) / (msq_max - msq_min)
  tmp = map%a2 / (map%a1 * map%a3)
  x = ((map%a1 + z / map%a3 + tmp) &
       - sqrt ((map%a1 - z / map%a3)**2 + 2 * tmp * (map%a1 + z / map%a3) &
               + tmp**2)) / 2
  f = (map%a2 / (map%a1 - x)**2 + map%a3) * (msq_max - msq_min) / s
@ 
\subsection{Mappings of the polar angle}
The other type of singularity, a simple pole just outside the
integration region, can occur in the integration over $\cos\theta$.
This applies to exchange of massless (or light) particles.

Double poles (Coulomb scattering) are also possible, but only in
certain cases.  These are also handled by the single-pole mapping.

The mapping is analogous to the previous $m^2$ pole mapping, but with
a different normalization and notation of variables:
\begin{equation}
  \frac12\int_{-1}^1 d\cos\theta\,g(\theta)
  = \int_0^1 dx\,\frac{d\cos\theta}{dx}\,g(\theta(x))
  = \int_0^1 dx\,f(x)\,g(x),
\end{equation}
where thus
\begin{equation}
  f(x) = \frac12\,\frac{d\cos\theta}{dx}.
\end{equation}
With this mapping, a function of the form
\begin{equation}
  g(\theta) = c\frac{dx(\cos\theta)}{d\cos\theta}
\end{equation}
is mapped to a constant:
\begin{equation}
  \int_{-1}^1 d\cos\theta\,g(\theta)
  = \int_0^1 dx\,f(x)\,g(\theta(x)) = \int_0^1 dx\,c.
\end{equation}
<<Mappings: public>>=
  public :: mapping_compute_ct_from_x
<<Mappings: procedures>>=
  subroutine mapping_compute_ct_from_x (map, s, ct, st, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s
    real(default), intent(out) :: ct, st, f
    real(default), intent(in) :: x
    real(default) :: tmp, ct1
    select case (map%type)
    case (NO_MAPPING, S_CHANNEL, INFRARED, RADIATION, &
         STEP_MAPPING_E, STEP_MAPPING_H)
     <<Apply trivial ct mapping>>
    case (T_CHANNEL, U_CHANNEL, COLLINEAR)
     <<Constants for ct pole mapping>>
     <<Apply ct pole mapping>>
    case default
       call msg_fatal (" Attempt to apply undefined ct mapping")
    end select
  end subroutine mapping_compute_ct_from_x

@ %def mapping_compute_ct_from_x
<<Mappings: public>>=
  public :: mapping_compute_x_from_ct
<<Mappings: procedures>>=
  subroutine mapping_compute_x_from_ct (map, s, ct, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s
    real(default), intent(in) :: ct
    real(default), intent(out) :: f, x
    real(default) :: ct1
    select case (map%type)
    case (NO_MAPPING, S_CHANNEL, INFRARED, RADIATION, &
         STEP_MAPPING_E, STEP_MAPPING_H)
     <<Apply inverse trivial ct mapping>>
    case (T_CHANNEL, U_CHANNEL, COLLINEAR)
     <<Constants for ct pole mapping>>
     <<Apply inverse ct pole mapping>>
    case default
       call msg_fatal (" Attempt to apply undefined inverse ct mapping")
    end select
  end subroutine mapping_compute_x_from_ct

@ %def mapping_compute_x_from_ct
@
\subsubsection{Trivial mapping}
This is just the mapping of the interval $(-1,1)$ to $(0,1)$:
\begin{equation}
  \cos\theta = -1 + 2x
\end{equation}
and
\begin{equation}
  f(x) = 1
\end{equation}
with the inverse
\begin{equation}
  x = \frac{1+\cos\theta}{2}
\end{equation}
<<Apply trivial ct mapping>>=
  tmp = 2 * (1-x)
  ct = 1 - tmp
  st = sqrt (tmp * (2-tmp))
  f = 1
<<Apply inverse trivial ct mapping>>=
  x = (ct + 1) / 2
  f = 1
@ 
\subsubsection{Pole mapping}
As above for $m^2$, we simultaneously map poles at both ends of the
$\cos\theta$ interval.  The formulae are completely analogous:
\begin{equation}
  \cos\theta =
  \begin{cases}
    \frac{M^2}{s}\left[\exp(xL)-1\right] - 1
    &
    \text{for $x<\frac12$}
    \\
    -\frac{M^2}{s}\left[\exp((1-x)L)-1\right] + 1
    &
    \text{for $x\geq\frac12$}
  \end{cases}
\end{equation}
where
\begin{equation}
  L = 2\ln\frac{M^2+s}{M^2}.
\end{equation}
Inverse:
\begin{equation}
  x = 
  \begin{cases}
    \frac{1}{2L}\ln\frac{1 + \cos\theta + M^2/s}{M^2/s}
    &
    \text{for $\cos\theta < 0$}
    \\
    1 - \frac{1}{2L}\ln\frac{1 - \cos\theta + M^2/s}{M^2/s}
    &
    \text{for $\cos\theta \geq 0$}
  \end{cases}
\end{equation}
The phase-space factor:
\begin{equation}
  f(x) = 
  \begin{cases}
    \frac{M^2}{s}\exp(xL)\,L
    &
    \text{for $x<\frac12$}
    \\
    \frac{M^2}{s}\exp((1-x)L)\,L
    &
    \text{for $x\geq\frac12$}
  \end{cases}
\end{equation}
<<Constants for ct pole mapping>>=
  if (map%variable_limits .or. map%b_unknown) then
     map%b1 = map%mass**2 / s
     map%b2 = log ((map%b1 + 1) / map%b1)
     map%b3 = 0
     map%b_unknown = .false.
  end if
<<Apply ct pole mapping>>=
  if (x < .5_default) then
     ct1 = map%b1 * exp (2 * x * map%b2)
     ct = ct1 - map%b1 - 1
  else
     ct1 = map%b1 * exp (2 * (1-x) * map%b2)
     ct = -(ct1 - map%b1) + 1
  end if
  if (ct >= -1 .and. ct <= 1) then
     st = sqrt (1 - ct**2)
     f = ct1 * map%b2
  else
     ct = 1;  st = 0;  f = 0
  end if
<<Apply inverse ct pole mapping>>=
  if (ct < 0) then
     ct1 = ct + map%b1 + 1
     x = log (ct1 / map%b1) / (2 * map%b2)
  else
     ct1 = -ct + map%b1 + 1
     x = 1 - log (ct1 / map%b1) / (2 * map%b2)
  end if
  f = ct1 * map%b2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Phase-space trees}
The phase space evaluation is organized in terms of trees, where each
branch corresponds to three integrations: $m^2$, $\cos\theta$, and
$\phi$.  The complete tree thus makes up a specific parameterization
of the multidimensional phase-space integral.  For the multi-channel
integration, the phase-space tree is a single channel.

The trees imply mappings of formal Feynman tree graphs into arrays of
integer numbers: Each branch, corresponding to a particular line in
the graph, is assigned an integer code $c$ (with kind value [[TC]] =
tree code).

In this integer, each bit determines whether a particular external
momentum flows through the line.  The external branches therefore have
codes $1,2,4,8,\ldots$.  An internal branch has those bits ORed
corresponding to the momenta flowing through it.  For example, a
branch with momentum $p_1+p_4$ has code $2^0+2^3=1+8=9$.

There is a two-fold ambiguity: Momentum conservation implies that the
branch with code
\begin{equation}
  c_0 = \sum_{i=1}^{n(\rm{ext})} 2^{i-1}
\end{equation}
i.e. the branch with momentum $p_1+p_2+\ldots p_n$ has momentum zero,
which is equivalent to tree code $0$ by definition.  Correspondingly,
\begin{equation}
  c \quad\textrm{and}\quad c_0 - c = c\;\textrm{XOR}\;c_0
\end{equation}
are equivalent.  E.g., if there are five externals with codes
$c=1,2,4,8,16$, then $c=9$ and $\bar c=31-9=22$ are equivalent.

This ambiguity may be used to assign a direction to the line: If all
momenta are understood as outgoing, $c=9$ in the example above means
$p_1+p_4$, but $c=22$ means $p_2+p_3+p_5 = -(p_1+p_4)$.

Here we make use of the ambiguity in a slightly different way.  First,
the initial particles are singled out as those externals with the
highest bits, the IN-bits.  (Here: $8$ and $16$ for a $2\to 3$
scattering process, $16$ only for a $1\to 4$ decay.)  Then we invert
those codes where all IN-bits are set.  For a decay process this maps
each tree of an equivalence class onto a unique representative (that one
with the smallest integer codes).  For a scattering process we proceed
further:

The ambiguity remains in all branches where only one IN-bit is set,
including the initial particles.  If there are only externals with
this property, we have an $s$-channel graph which we leave as it is.
In all other cases, an internal with only one IN-bit is a $t$-channel
line, which for phase space integration should be associated with one
of the initial momenta as a reference axis.  We take that one whose
bit is set in the current tree code.  (E.g., for branch $c=9$ we use
the initial particle $c=8$ as reference axis, whereas for the same
branch we would take $c=16$ if it had been assigned $\bar c=31-9=22$
as tree code.) Thus, different ways of coding the same $t$-channel
graph imply different phase space parameterizations.

$s$-channel graphs have a unique parameterization.  The same sets of
parameterizations are used for $t$-channel graphs, except for the
reference frames of their angular parts.  We map each
$t$-channel graph onto an $s$-channel graph as follows:

Working in ascending order, for each $t$-channel line (whose code has
exactly one IN-bit set) the attached initial line is flipped upstream,
while the outgoing line is flipped downstream.  (This works only if
$t$-channel graphs are always parameterized beginning at their outer
vertices, which we require as a restriction.)  After all possible
flips have been applied, we have an $s$-channel graph.  We only have
to remember the initial particle a vertex was originally attached to.
<<[[phs_trees.f90]]>>=
<<File header>>

module phs_trees

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use constants, only: twopi, twopi2, twopi5
  use format_defs, only: FMT_19
  use diagnostics
  use lorentz
  use permutations, only: permutation_t, permutation_size
  use permutations, only: permutation_init, permutation_find
  use permutations, only: tc_decay_level, tc_permute
  use model_data
  use flavors
  use mappings

<<Standard module head>>

<<PHS trees: public>>

<<PHS trees: types>>

contains

<<PHS trees: procedures>>

end module phs_trees
@ %def phs_trees
@ 
\subsection{Particles}
We define a particle type which contains only four-momentum and
invariant mass squared, and a flag that tells whether the momentum is
filled or not.
<<PHS trees: public>>=
  public :: phs_prt_t
<<PHS trees: types>>=
  type :: phs_prt_t
     private
     logical :: defined = .false.
     type(vector4_t) :: p
     real(default) :: p2
  end type phs_prt_t

@ %def phs_prt_t
@ Set contents:
<<PHS trees: public>>=
  public :: phs_prt_set_defined
  public :: phs_prt_set_undefined
  public :: phs_prt_set_momentum
  public :: phs_prt_set_msq
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_set_defined (prt)
    type(phs_prt_t), intent(inout) :: prt
    prt%defined = .true.
  end subroutine phs_prt_set_defined

  elemental subroutine phs_prt_set_undefined (prt)
    type(phs_prt_t), intent(inout) :: prt
    prt%defined = .false.
  end subroutine phs_prt_set_undefined

  elemental subroutine phs_prt_set_momentum (prt, p)
    type(phs_prt_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: p
    prt%p = p
  end subroutine phs_prt_set_momentum

  elemental subroutine phs_prt_set_msq (prt, p2)
    type(phs_prt_t), intent(inout) :: prt
    real(default), intent(in) :: p2
    prt%p2 = p2
  end subroutine phs_prt_set_msq

@ %def phs_prt_set_defined phs_prt_set_momentum phs_prt_set_msq
@ Access methods:
<<PHS trees: public>>=
  public :: phs_prt_is_defined
  public :: phs_prt_get_momentum
  public :: phs_prt_get_msq
<<PHS trees: procedures>>=
  elemental function phs_prt_is_defined (prt) result (defined)
    logical :: defined
    type(phs_prt_t), intent(in) :: prt
    defined = prt%defined
  end function phs_prt_is_defined

  elemental function phs_prt_get_momentum (prt) result (p)
    type(vector4_t) :: p
    type(phs_prt_t), intent(in) :: prt
    p = prt%p
  end function phs_prt_get_momentum

  elemental function phs_prt_get_msq (prt) result (p2)
    real(default) :: p2
    type(phs_prt_t), intent(in) :: prt
    p2 = prt%p2
  end function phs_prt_get_msq

@ %def phs_prt_is_defined phs_prt_get_momentum phs_prt_get_msq
@ Addition of momenta (invariant mass square is computed).
<<PHS trees: public>>=
  public :: phs_prt_combine
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_combine (prt, prt1, prt2)
    type(phs_prt_t), intent(inout) :: prt
    type(phs_prt_t), intent(in) :: prt1, prt2
    prt%defined = .true.
    prt%p = prt1%p + prt2%p
    prt%p2 = prt%p ** 2
    call phs_prt_check (prt)
  end subroutine phs_prt_combine

@ %def phs_prt_combine
@ Output
<<PHS trees: public>>=
  public :: phs_prt_write
<<PHS trees: procedures>>=    
  subroutine phs_prt_write (prt, unit)
    type(phs_prt_t), intent(in) :: prt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    if (prt%defined) then
       call vector4_write (prt%p, u)
       write (u, "(1x,A,1x," // FMT_19 // ")") "T = ", prt%p2
    else
       write (u, "(3x,A)") "[undefined]"
    end if
  end subroutine phs_prt_write

@ %def phs_prt_write
<<PHS trees: public>>=
  public :: phs_prt_check
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_check (prt)
    type(phs_prt_t), intent(inout) :: prt
    real(default), parameter :: eps = 1E-9
    if (prt%p2 < 0._default) then
       prt%p2 = 0._default
    end if
  end subroutine phs_prt_check

@ %def phs_prt_check
@ Mark the emitting branch of the tree
<<PHS trees: public>>=
  public :: phs_tree_set_emitter
<<PHS trees: procedures>>=
  subroutine phs_tree_set_emitter (phs_tree)
    use fks_regions
    class(phs_tree_t), intent(inout) :: phs_tree
    integer :: n_out, n
    n_out = phs_tree%n_externals - phs_tree%n_in
    n = 2**(n_out - 1)
    phs_tree%emitter = phs_tree%branch(n)%sibling
  end subroutine phs_tree_set_emitter

@ %def phs_tree_set_emitter
@ Mark those branches of the tree which only occur in the real phase space
<<PHS trees: public>>=
  public :: phs_tree_set_real
<<PHS trees: procedures>>=
  subroutine phs_tree_set_real (phs_tree)
    class(phs_tree_t), intent(inout) :: phs_tree
    integer :: n_out
    integer(TC) :: k_em, k0, k_rad
    if (phs_tree%real_phsp) then
      n_out = phs_tree%n_externals - phs_tree%n_in 
      k_rad = 2**(n_out-1)
      k_em = phs_tree%branch(k_rad)%sibling
      phs_tree%branch(k_rad)%is_real = .true.
      phs_tree%branch(k_em)%is_real = .true.
    end if
  end subroutine phs_tree_set_real

@ %def phs_tree_set _real
@
\subsection{The phase-space tree type}
\subsubsection{Definition}
In the concrete implementation, each branch $c$ may have two
\emph{daughters} $c_1$ and $c_2$ such that $c_1+c_2=c$, a
\emph{sibling} $c_s$ and a \emph{mother} $c_m$ such that $c+c_s =
c_m$, and a \emph{friend} which is kept during flips, such that it can
indicate a fixed reference frame.  Absent entries are set $c=0$.

First, declare the branch type.  There is some need to have this
public. Give initializations for all components, so no [[init]]
routine is necessary.  The branch has some information about the
associated coordinates and about connections.
<<PHS trees: types>>=
  type :: phs_branch_t
     private
     logical :: set = .false.
     logical :: inverted_decay = .false.
     logical :: inverted_axis = .false.
     integer(TC) :: mother = 0
     integer(TC) :: sibling = 0
     integer(TC) :: friend = 0
     integer(TC) :: origin = 0
     integer(TC), dimension(2) :: daughter = 0
     integer :: firstborn = 0
     logical :: has_children = .false.
     logical :: has_friend = .false.
     logical :: is_real = .false.
  end type phs_branch_t

@ %def phs_branch_t
@ The tree type: No initialization, this is done by
[[phs_tree_init]].  In addition to the branch array which 

The branches are collected in an array which holds all possible
branches, of which only a few are set.  After flips have been applied,
the branch $c_M=\sum_{i=1}^{n({\rm fin})}2^{i-1}$ must be there,
indicating the mother of all decay products.  In addition, we should
check for consistency at the beginning.

[[n_branches]] is the number of those actually set.  [[n_externals]]
defines the number of significant bit, and [[mask]] is a code where all
bits are set.  Analogous: [[n_in]] and [[mask_in]] for the incoming
particles.

The [[mapping]] array contains the mappings associated to the branches
(corresponding indices).  The array [[mass_sum]] contains the sum of
the real masses of the external final-state particles associated to
the branch.  During phase-space evaluation, this determines the
boundaries.
<<PHS trees: public>>=
  public :: phs_tree_t
<<PHS trees: types>>=
  type :: phs_tree_t
     private
     integer :: n_branches, n_externals, n_in, n_msq, n_angles
     integer(TC) :: n_branches_tot, n_branches_out
     integer(TC) :: mask, mask_in, mask_out
     type(phs_branch_t), dimension(:), allocatable :: branch
     type(mapping_t), dimension(:), allocatable :: mapping
     real(default), dimension(:), allocatable :: mass_sum
     real(default), dimension(:), allocatable :: effective_mass
     real(default), dimension(:), allocatable :: effective_width
     logical :: real_phsp = .false.
     integer(TC) :: emitter = 0
     integer, dimension(:), allocatable :: momentum_link
   contains
   <<PHS trees: phs tree: TBP>>
  end type phs_tree_t

@ %def phs_tree_t
@ The maximum number of external particles that can be represented is
related to the bit size of the integer that stores binary codes.  With
the default integer of 32 bit on common machines, this is more than
enough space.  If [[TC]] is actually the default integer kind, there
is no need to keep it separate, but doing so marks this as a
special type of integer.  So, just state that the maximum number is 32:
<<Limits: public parameters>>=
  integer, parameter, public :: MAX_EXTERNAL = 32
@ %def MAX_EXTERNAL
@
\subsubsection{Constructor and destructor}
Allocate memory for a phase-space tree with given number of externals and
incoming.  The number of allocated branches can easily become large,
but appears manageable for realistic cases, e.g., for [[n_in=2]] and
[[n_out=8]] we get $2^{10}-1=1023$.
<<PHS trees: public>>=
  public :: phs_tree_init
  public :: phs_tree_final
@ Here we set the masks for incoming and for all externals.
<<PHS trees: procedures>>=
  elemental subroutine phs_tree_init (tree, n_in, n_out, n_masses, n_angles)
    type(phs_tree_t), intent(inout) :: tree
    integer, intent(in) :: n_in, n_out, n_masses, n_angles
    integer(TC) :: i
    tree%n_externals = n_in + n_out
    tree%n_branches_tot = 2**(n_in+n_out) - 1
    tree%n_branches_out = 2**n_out - 1
    tree%mask = 0
    do i = 0, n_in + n_out - 1
       tree%mask = ibset (tree%mask, i)
    end do
    tree%n_in = n_in
    tree%mask_in = 0
    do i = n_out, n_in + n_out - 1
       tree%mask_in = ibset (tree%mask_in, i)
    end do
    tree%mask_out = ieor (tree%mask, tree%mask_in)
    tree%n_msq = n_masses
    tree%n_angles = n_angles
    allocate (tree%branch (tree%n_branches_tot))
    tree%n_branches  = 0
    allocate (tree%mapping (tree%n_branches_out))
    allocate (tree%mass_sum (tree%n_branches_out))
    allocate (tree%effective_mass (tree%n_branches_out))
    allocate (tree%effective_width (tree%n_branches_out))
  end subroutine phs_tree_init

  elemental subroutine phs_tree_final (tree)
    type(phs_tree_t), intent(inout) :: tree
    deallocate (tree%branch)
    deallocate (tree%mapping)
    deallocate (tree%mass_sum)
    deallocate (tree%effective_mass)
    deallocate (tree%effective_width)
  end subroutine phs_tree_final

@ %def phs_tree_init phs_tree_final
@
\subsubsection{Screen output}
Write only the branches that are set:
<<PHS trees: public>>=
  public :: phs_tree_write
<<PHS trees: procedures>>=
  subroutine phs_tree_write (tree, unit)
    type(phs_tree_t), intent(in) :: tree
    integer, intent(in), optional :: unit
    integer :: u
    integer(TC) :: k
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'External:', tree%n_externals, 'Mask:', tree%mask
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'Incoming:', tree%n_in, 'Mask:', tree%mask_in
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'Branches:', tree%n_branches
    do k = size (tree%branch), 1, -1
       if (tree%branch(k)%set) &
            call phs_branch_write (tree%branch(k), unit=unit, kval=k)
    end do
    do k = 1, size (tree%mapping)
       call mapping_write (tree%mapping (k), unit, verbose=.true.)
    end do
    write (u, "(3x,A)") "Arrays: mass_sum, effective_mass, effective_width"
    do k = 1, size (tree%mass_sum)
       if (tree%branch(k)%set) then
          write (u, "(5x,I0,3(2x," // FMT_19 // "))") k, tree%mass_sum(k), &
               tree%effective_mass(k), tree%effective_width(k)
       end if
    end do
  end subroutine phs_tree_write

  subroutine phs_branch_write (b, unit, kval)
    type(phs_branch_t), intent(in) :: b
    integer, intent(in), optional :: unit
    integer(TC), intent(in), optional :: kval
    integer :: u
    integer(TC) :: k
    character(len=6) :: tmp
    character(len=1) :: firstborn(2), sign_decay, sign_axis
    integer :: i
    u = given_output_unit (unit);  if (u < 0)  return
    k = 0;  if (present (kval))  k = kval
    if (b%origin /= 0) then
       write(tmp, '(A,I4,A)') '(', b%origin, ')'
    else
       tmp = ' '
    end if
    do i=1, 2
       if (b%firstborn == i) then
          firstborn(i) = "*"
       else
          firstborn(i) = " "
       end if
    end do
    if (b%inverted_decay) then
       sign_decay = "-"
    else
       sign_decay = "+"
    end if
    if (b%inverted_axis) then
       sign_axis = "-"
    else
       sign_axis = "+"
    end if
    if (b%has_children) then
       if (b%has_friend) then
          write(u,'(4X,A1,I0,3x,A,1X,A,I0,A1,1x,I0,A1,1X,A1,1X,A,1x,I0)') &
               &   '*', k, tmp, &
               &   'Daughters: ', &
               &   b%daughter(1), firstborn(1), &
               &   b%daughter(2), firstborn(2), sign_decay, &
               &   'Friend:    ', b%friend
       else
          write(u,'(4X,A1,I0,3x,A,1X,A,I0,A1,1x,I0,A1,1X,A1,1X,A)') &
               &   '*', k, tmp, &
               &   'Daughters: ', &
               &   b%daughter(1), firstborn(1), &
               &   b%daughter(2), firstborn(2), sign_decay, &
               &   '(axis '//sign_axis//')'
       end if
    else
       write(u,'(5X,I0)') k
    end if
  end subroutine phs_branch_write

@ %def phs_tree_write phs_branch_write
@
\subsection{PHS tree setup}
\subsubsection{Transformation into an array of branch codes and back}
Assume that the tree/array has been created before with the
appropriate length and is empty.  
<<PHS trees: public>>=
  public :: phs_tree_from_array
<<PHS trees: procedures>>=
  subroutine phs_tree_from_array (tree, a)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC), dimension(:), intent(in) :: a
    integer :: i
    integer(TC) :: k
  <<Set branches from array [[a]]>>
  <<Set external branches if necessary>>
  <<Check number of branches>>
  <<Determine the connections>>
  contains
  <<Subroutine: set relatives>>
  end subroutine phs_tree_from_array

@ %def phs_tree_from_array
@ First, set all branches specified by the user.  If all IN-bits
are set, we invert the branch code.  
<<Set branches from array [[a]]>>=
  do i=1, size(a)
     k = a(i)
     if (iand(k, tree%mask_in) == tree%mask_in)  k = ieor(tree%mask, k)
     tree%branch(k)%set = .true.
     tree%n_branches = tree%n_branches+1
  end do
@ The external branches are understood, so set them now if not yet
done.  In all cases ensure that the representative with one bit set is
used, except for decays where the in-particle is represented by all
OUT-bits set instead.
<<Set external branches if necessary>>=
  do i=0, tree%n_externals-1
     k = ibset(0,i)
     if (iand(k, tree%mask_in) == tree%mask_in)  k = ieor(tree%mask, k)
     if (tree%branch(ieor(tree%mask, k))%set) then
        tree%branch(ieor(tree%mask, k))%set = .false.
        tree%branch(k)%set = .true.
     else if (.not.tree%branch(k)%set) then
        tree%branch(k)%set = .true.
        tree%n_branches = tree%n_branches+1
     end if
  end do
@ Now the number of branches set can be checked.  Here we assume that
the tree is binary.  For three externals there are three branches in
total, and for each additional external branch we get another internal
one.
<<Check number of branches>>=
  if (tree%n_branches /= tree%n_externals*2-3) then
     call phs_tree_write (tree)
     call msg_bug &
          & (" Wrong number of branches set in phase space tree")
  end if
@ For all branches that are set, except for the externals, we try to
find the daughter branches:
<<Determine the connections>>=
  do k=1, size (tree%branch)
     if (tree%branch(k)%set .and. tc_decay_level (k) /= 1) then
        call branch_set_relatives(k)
     end if
  end do
@ To this end, we scan all codes less than the current code, whether
we can find two branches which are set and which together give the
current code.  After that, the tree may still not be connected, but at
least we know if a branch does not have daughters: This indicates some
inconsistency.

The algorithm ensures that, at this stage, the first daughter has a
smaller code value than the second one.
<<Subroutine: set relatives>>=
  subroutine branch_set_relatives (k)
    integer(TC), intent(in) :: k
    integer(TC) :: m,n
    do m=1, k-1
       if(iand(k,m)==m) then
          n = ieor(k,m)
          if ( tree%branch(m)%set .and. tree%branch(n)%set ) then
             tree%branch(k)%daughter(1) = m;  tree%branch(k)%daughter(2) = n
             tree%branch(m)%mother      = k;  tree%branch(n)%mother      = k
             tree%branch(m)%sibling     = n;  tree%branch(n)%sibling     = m
             tree%branch(k)%has_children = .true.
             return
          end if
       end if
    end do
    call phs_tree_write (tree)
    call msg_bug &
         & (" Missing daughter branch(es) in phase space tree")
  end subroutine branch_set_relatives

@ The inverse: this is trivial, fortunately.
@
\subsubsection{Flip $t$-channel into $s$-channel}
Flipping the tree is done upwards, beginning from the decay products.
First we select a $t$-channel branch [[k]]: one which is set, which
does have an IN-bit, and which is not an external particle.

Next, we determine the adjacent in-particle (called the 'friend' [[f]]
here, since it will provide the reference axis for the angular
integration).  In addition, we look for the 'mother' and 'sibling' of
this particle.  If the latter field is empty, we select the (unique)
other out-particle which has no mother, calling the internal
subroutine [[find_orphan]].  

The flip is done as follows: We assume that the first daughter [[d]]
is an $s$-channel line, which is true if the daughters are sorted.
This will stay the first daughter.  The second one is a $t$-channel
line; it is exchanged with the 'sibling' [[s]].  The new line which
replaces the branch [[k]] is just the sum of [[s]] and [[d]].  In
addition, we have to rearrange the relatives of [[s]] and [[d]], as
well of [[f]].

Finally, we flip 'sibling' and 'friend' and set the new $s$-channel
branch [[n]] which replaces the $t$-channel branch [[k]].  After this
is complete, we are ready to execute another flip.

[Although the friend is not needed for the final flip, since it would
be an initial particle anyway, we need to know whether we have $t$- or
$u$-channel.]
<<PHS trees: public>>=
  public :: phs_tree_flip_t_to_s_channel
<<PHS trees: procedures>>=
  subroutine phs_tree_flip_t_to_s_channel (tree)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC) :: k, f, m, n, d, s
    if (tree%n_in == 2) then
       FLIP: do k=3, tree%mask-1
          if (.not. tree%branch(k)%set) cycle FLIP
          f = iand(k,tree%mask_in)
          if (f==0 .or. f==k) cycle FLIP
          m = tree%branch(k)%mother
          s = tree%branch(k)%sibling
          if (s==0) call find_orphan(s)
          d = tree%branch(k)%daughter(1)
          n = ior(d,s)  
          tree%branch(k)%set = .false.
          tree%branch(n)%set = .true.
          tree%branch(n)%origin = k
          tree%branch(n)%daughter(1) = d; tree%branch(d)%mother  = n
          tree%branch(n)%daughter(2) = s; tree%branch(s)%mother  = n
          tree%branch(n)%has_children = .true.
          tree%branch(d)%sibling = s;  tree%branch(s)%sibling = d
          tree%branch(n)%sibling = f;  tree%branch(f)%sibling = n
          tree%branch(n)%mother      = m
          tree%branch(f)%mother      = m
          if (m/=0) then
             tree%branch(m)%daughter(1) = n
             tree%branch(m)%daughter(2) = f
          end if
          tree%branch(n)%friend = f
          tree%branch(n)%has_friend = .true.
          tree%branch(n)%firstborn = 2
       end do FLIP
    end if
  contains
    subroutine find_orphan(s)
      integer(TC) :: s
      do s=1, tree%mask_out
         if (tree%branch(s)%set .and. tree%branch(s)%mother==0) return
      end do
      call phs_tree_write (tree)
      call msg_bug (" Can't flip phase space tree to channel")
    end subroutine find_orphan
  end subroutine phs_tree_flip_t_to_s_channel

@ %def phs_tree_flip_t_to_s_channel
@ After the tree has been flipped, one may need to determine what has
become of a particular $t$-channel branch.  This function gives the
bincode of the flipped tree.  If the original bincode does not contain
IN-bits, we leave it as it is.
<<PHS trees: procedures>>=
  function tc_flipped (tree, kt) result (ks)
    type(phs_tree_t), intent(in) :: tree
    integer(TC), intent(in) :: kt
    integer(TC) :: ks
    if (iand (kt, tree%mask_in) == 0) then
       ks = kt
    else
       ks = tree%branch(iand (kt, tree%mask_out))%mother
    end if
  end function tc_flipped

@ %def tc_flipped
@ Scan a tree and make sure that the first daughter has always a
smaller code than the second one.  Furthermore, delete any [[friend]]
entry in the root branch -- this branching has the incoming particle
direction as axis anyway.  Keep track of reordering by updating
[[inverted_axis]], [[inverted_decay]] and [[firstborn]].
<<PHS trees: public>>=
  public :: phs_tree_canonicalize
<<PHS trees: procedures>>=
  subroutine phs_tree_canonicalize (tree)
    type(phs_tree_t), intent(inout) :: tree
    integer :: n_out
    integer(TC) :: k_out
    call branch_canonicalize (tree%branch(tree%mask_out))
    n_out = tree%n_externals - tree%n_in
    k_out = tree%mask_out
    if (tree%branch(k_out)%has_friend &
         & .and. tree%branch(k_out)%friend == ibset (0, n_out)) then
       tree%branch(k_out)%inverted_axis = .not.tree%branch(k_out)%inverted_axis
    end if
    tree%branch(k_out)%has_friend = .false.
    tree%branch(k_out)%friend = 0
  contains
    recursive subroutine branch_canonicalize (b)
      type(phs_branch_t), intent(inout) :: b
      integer(TC) :: d1, d2
      if (b%has_children) then
         d1 = b%daughter(1)
         d2 = b%daughter(2)
         if (d1 > d2) then
            b%daughter(1) = d2
            b%daughter(2) = d1
            b%inverted_decay = .not.b%inverted_decay
            if (b%firstborn /= 0)  b%firstborn = 3 - b%firstborn
         end if
         call branch_canonicalize (tree%branch(b%daughter(1)))
         call branch_canonicalize (tree%branch(b%daughter(2)))
      end if
    end subroutine branch_canonicalize
  end subroutine phs_tree_canonicalize

@ %def phs_tree_canonicalize
@ 
\subsubsection{Mappings}
Initialize a mapping for the current tree.  This is done while reading
from file, so the mapping parameters are read, but applied to the
flipped tree.  Thus, the size of the array of mappings is given by the
number of outgoing particles only.
<<PHS trees: public>>=
  public :: phs_tree_init_mapping
<<PHS trees: procedures>>=
  subroutine phs_tree_init_mapping (tree, k, type, pdg, model)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC), intent(in) :: k
    type(string_t), intent(in) :: type
    integer, intent(in) :: pdg
    class(model_data_t), intent(in), target :: model
    integer(TC) :: kk
    kk = tc_flipped (tree, k)
    call mapping_init (tree%mapping(kk), kk, type, pdg, model)
  end subroutine phs_tree_init_mapping

@ %def phs_tree_init_mapping
@ Set the physical parameters for the mapping, using a specific
parameter set.  Also set the mass sum array.
<<PHS trees: public>>=
  public :: phs_tree_set_mapping_parameters
<<PHS trees: procedures>>=
  subroutine phs_tree_set_mapping_parameters &
       (tree, mapping_defaults, variable_limits)
    type(phs_tree_t), intent(inout) :: tree
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    integer(TC) :: k
    do k = 1, tree%n_branches_out
       call mapping_set_parameters &
            (tree%mapping(k), mapping_defaults, variable_limits) 
    end do
  end subroutine phs_tree_set_mapping_parameters

@ %def phs_tree_set_mapping_parameters
@ Return the mapping for the sum of all outgoing particles.  This
should either be no mapping or a global s-channel mapping.
<<PHS trees: public>>=
  public :: phs_tree_assign_s_mapping
<<PHS trees: procedures>>=
  subroutine phs_tree_assign_s_mapping (tree, mapping)
    type(phs_tree_t), intent(in) :: tree
    type(mapping_t), intent(out) :: mapping
    mapping = tree%mapping(tree%mask_out)
  end subroutine phs_tree_assign_s_mapping

@ %def phs_tree_assign_s_mapping
@ 
\subsubsection{Kinematics}
Fill the mass sum array, starting from the external particles and
working down to the tree root.  For each bincode [[k]] we scan the
bits in [[k]]; if only one is set, we take the physical mass of the
corresponding external particle; if more then one is set, we sum up
the two masses (which we know have already been set).
<<PHS trees: public>>=
  public :: phs_tree_set_mass_sum
<<PHS trees: procedures>>=
  subroutine phs_tree_set_mass_sum (tree, flv)
    type(phs_tree_t), intent(inout) :: tree
    type(flavor_t), dimension(:), intent(in) :: flv
    integer(TC) :: k
    integer :: i
    tree%mass_sum = 0
    do k = 1, tree%n_branches_out
       do i = 0, size (flv) - 1
          if (btest(k,i)) then
             if (ibclr(k,i) == 0) then
                tree%mass_sum(k) = flavor_get_mass (flv(i+1))
             else
                tree%mass_sum(k) = &
                     tree%mass_sum(ibclr(k,i)) + tree%mass_sum(ibset(0,i))
             end if
             exit
          end if
       end do
    end do
  end subroutine phs_tree_set_mass_sum
  
@ %def phs_tree_set_mass_sum
@ Set the effective masses and widths.  For each non-resonant branch
in a tree, the effective mass is equal to the sum of the effective
masses of the children (and analogous for the width).  External
particles have their real mass and width zero.  For resonant branches,
we insert mass and width from the corresponding mapping.

This routine has [[phs_tree_set_mass_sum]] and
[[phs_tree_set_mapping_parameters]] as prerequisites.
<<PHS trees: public>>=
  public :: phs_tree_set_effective_masses
<<PHS trees: procedures>>=
  subroutine phs_tree_set_effective_masses (tree)
    type(phs_tree_t), intent(inout) :: tree
    tree%effective_mass = 0
    tree%effective_width = 0
    call set_masses_x (tree%mask_out)
  contains
    recursive subroutine set_masses_x (k)
      integer(TC), intent(in) :: k
      integer(TC) :: k1, k2
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1)
         k2 = tree%branch(k)%daughter(2)
         call set_masses_x (k1)
         call set_masses_x (k2)
         if (mapping_is_s_channel (tree%mapping(k))) then
            tree%effective_mass(k) = mapping_get_mass (tree%mapping(k))
            tree%effective_width(k) = mapping_get_width (tree%mapping(k))
         else
            tree%effective_mass(k) = &
                 tree%effective_mass(k1) + tree%effective_mass(k2)
            tree%effective_width(k) = &
                 tree%effective_width(k1) + tree%effective_width(k2)
         end if
      else
         tree%effective_mass(k) = tree%mass_sum(k)
      end if
    end subroutine set_masses_x
  end subroutine phs_tree_set_effective_masses

@ %def phs_tree_set_effective_masses
@ Define step mappings, recursively, for the decay products of all
intermediate resonances.  Step mappings account for the fact that a
branch may originate from a resonance, which almost replaces the
upper limit on the possible invariant mass.  The step
mapping implements a smooth cutoff that interpolates between the
resonance and the real kinematic limit.  The mapping width determines
the sharpness of the cutoff.

Step mappings are inserted only for branches that are not mapped
otherwise.

At each branch, we record the mass that is effectively available for
phase space, by taking the previous limit and subtracting the
effective mass of the sibling branch.  Widths are added, not subtracted.

If we encounter a resonance decay, we discard the previous limit and
replace it by the mass and width of the resonance, also subtracting
the sibling branch.

Initially, the limit is zero, so it becomes negative at any branch.  Only
if there is a resonance, the limit becomes positive.  Whenever the
limit is positive, and the current branch decays, we activate a step
mapping for the current branch.

As a result, step mappings are implemented for all internal lines that
originate from an intermediate resonance decay.

The flag [[variable_limits]] applies to the ultimate limit from the
available energy, not to the intermediate resonances whose masses are
always fixed.

This routine requires [[phs_tree_set_effective_masses]]
<<PHS trees: public>>=
  public :: phs_tree_set_step_mappings
<<PHS trees: procedures>>=
  subroutine phs_tree_set_step_mappings (tree, exp_type, variable_limits)
    type(phs_tree_t), intent(inout) :: tree
    logical, intent(in) :: exp_type
    logical, intent(in) :: variable_limits
    type(string_t) :: map_str
    integer(TC) :: k
    if (exp_type) then
       map_str = "step_exp"
    else
       map_str = "step_hyp"
    end if
    k = tree%mask_out
    call set_step_mappings_x (k, 0._default, 0._default)
  contains
    recursive subroutine set_step_mappings_x (k, m_limit, w_limit)
      integer(TC), intent(in) :: k
      real(default), intent(in) :: m_limit, w_limit
      integer(TC), dimension(2) :: kk
      real(default), dimension(2) :: m, w
      if (tree%branch(k)%has_children) then
         if (m_limit > 0) then
            if (.not. mapping_is_set (tree%mapping(k))) then
               call mapping_init (tree%mapping(k), k, map_str)
               call mapping_set_step_mapping_parameters (tree%mapping(k), &
                    m_limit, w_limit, &
                    variable_limits)
            end if
         end if
         kk = tree%branch(k)%daughter
         m = tree%effective_mass(kk)
         w = tree%effective_width(kk)
         if (mapping_is_s_channel (tree%mapping(k))) then
            call set_step_mappings_x (kk(1), &
                 mapping_get_mass (tree%mapping(k)) - m(2), &
                 mapping_get_width (tree%mapping(k)) + w(2))
            call set_step_mappings_x (kk(2), &
                 mapping_get_mass (tree%mapping(k)) - m(1), &
                 mapping_get_width (tree%mapping(k)) + w(1))
         else if (m_limit > 0) then
            call set_step_mappings_x (kk(1), &
                 m_limit - m(2), &
                 w_limit + w(2))
            call set_step_mappings_x (kk(2), &
                 m_limit - m(1), &
                 w_limit + w(1))
         else
            call set_step_mappings_x (kk(1), &
                 - m(2), &
                 + w(2))
            call set_step_mappings_x (kk(2), &
                 - m(1), &
                 + w(1))
         end if
      end if
    end subroutine set_step_mappings_x
  end subroutine phs_tree_set_step_mappings

@ %def phs_tree_set_step_mappings
@ 
\subsubsection{Structural comparison}
This function allows to check whether one tree is the permutation of
another one.  The permutation is applied to the second tree in the
argument list.  We do not make up a temporary permuted tree, but
compare the two trees directly.  The branches are scanned recursively,
where for each daughter we check the friend and the mapping as well.
Once a discrepancy is found, the recursion is exited immediately.
<<PHS trees: public>>=
  public :: phs_tree_equivalent
<<PHS trees: procedures>>=
  function phs_tree_equivalent (t1, t2, perm) result (is_equal)
    type(phs_tree_t), intent(in) :: t1, t2
    type(permutation_t), intent(in) :: perm
    logical :: equal, is_equal
    integer(TC) :: k1, k2, mask_in
    k1 = t1%mask_out
    k2 = t2%mask_out
    mask_in = t1%mask_in
    equal = .true.
    call check (t1%branch(k1), t2%branch(k2), k1, k2)
    is_equal = equal
  contains
    recursive subroutine check (b1, b2, k1, k2)
      type(phs_branch_t), intent(in) :: b1, b2
      integer(TC), intent(in) :: k1, k2
      integer(TC), dimension(2) :: d1, d2, pd2
      integer :: i
      if (.not.b1%has_friend .and. .not.b2%has_friend) then
         equal = .true.
      else if (b1%has_friend .and. b2%has_friend) then
         equal = (b1%friend == tc_permute (b2%friend, perm, mask_in))
      end if
      if (equal) then
         if (b1%has_children .and. b2%has_children) then
            d1 = b1%daughter
            d2 = b2%daughter
            do i=1, 2
               pd2(i) = tc_permute (d2(i), perm, mask_in)
            end do
            if (d1(1)==pd2(1) .and. d1(2)==pd2(2)) then
               equal = (b1%firstborn == b2%firstborn)
               if (equal) call check &
                    &     (t1%branch(d1(1)), t2%branch(d2(1)), d1(1), d2(1))
               if (equal) call check &
                    &     (t1%branch(d1(2)), t2%branch(d2(2)), d1(2), d2(2))
            else if (d1(1)==pd2(2) .and. d1(2)==pd2(1)) then
               equal = ( (b1%firstborn == 0 .and. b2%firstborn == 0) &
                    &   .or. (b1%firstborn == 3 - b2%firstborn) )
               if (equal) call check &
                    &     (t1%branch(d1(1)), t2%branch(d2(2)), d1(1), d2(2))
               if (equal) call check &
                    &     (t1%branch(d1(2)), t2%branch(d2(1)), d1(2), d2(1))
            else
               equal = .false.
            end if
         end if
      end if
      if (equal) then
         equal = (t1%mapping(k1) == t2%mapping(k2))
      end if
    end subroutine check
  end function phs_tree_equivalent

@ %def phs_tree_equivalent
@ Scan two decay trees and determine the correspondence of mass
variables, i.e., the permutation that transfers the ordered list of
mass variables belonging to the second tree into the first one.  Mass
variables are assigned beginning from branches and ending at the root.
<<PHS trees: public>>=
  public :: phs_tree_find_msq_permutation
<<PHS trees: procedures>>=
  subroutine phs_tree_find_msq_permutation (tree1, tree2, perm2, msq_perm)
    type(phs_tree_t), intent(in) :: tree1, tree2
    type(permutation_t), intent(in) :: perm2
    type(permutation_t), intent(out) :: msq_perm
    type(permutation_t) :: perm1
    integer(TC) :: mask_in, root
    integer(TC), dimension(:), allocatable :: index1, index2
    integer :: i
    allocate (index1 (tree1%n_msq), index2 (tree2%n_msq))
    call permutation_init (perm1, permutation_size (perm2))
    mask_in = tree1%mask_in
    root = tree1%mask_out
    i = 0
    call tree_scan (tree1, root, perm1, index1)
    i = 0
    call tree_scan (tree2, root, perm2, index2)
    call permutation_find (msq_perm, index1, index2)
  contains
    recursive subroutine tree_scan (tree, k, perm, index)
      type(phs_tree_t), intent(in) :: tree
      integer(TC), intent(in) :: k
      type(permutation_t), intent(in) :: perm
      integer, dimension(:), intent(inout) :: index
      if (tree%branch(k)%has_children) then
         call tree_scan (tree, tree%branch(k)%daughter(1), perm, index)
         call tree_scan (tree, tree%branch(k)%daughter(2), perm, index)
         i = i + 1
         if (i <= size (index))  index(i) = tc_permute (k, perm, mask_in)
      end if
    end subroutine tree_scan
  end subroutine phs_tree_find_msq_permutation

@ %def phs_tree_find_msq_permutation
<<PHS trees: public>>=
  public :: phs_tree_find_angle_permutation
<<PHS trees: procedures>>=
  subroutine phs_tree_find_angle_permutation &
       (tree1, tree2, perm2, angle_perm, sig2)
    type(phs_tree_t), intent(in) :: tree1, tree2
    type(permutation_t), intent(in) :: perm2
    type(permutation_t), intent(out) :: angle_perm
    logical, dimension(:), allocatable, intent(out) :: sig2
    type(permutation_t) :: perm1
    integer(TC) :: mask_in, root
    integer(TC), dimension(:), allocatable :: index1, index2
    logical, dimension(:), allocatable :: sig1
    integer :: i
    allocate (index1 (tree1%n_angles), index2 (tree2%n_angles))
    allocate (sig1 (tree1%n_angles), sig2 (tree2%n_angles))
    call permutation_init (perm1, permutation_size (perm2))
    mask_in = tree1%mask_in
    root = tree1%mask_out
    i = 0
    call tree_scan (tree1, root, perm1, index1, sig1)
    i = 0
    call tree_scan (tree2, root, perm2, index2, sig2)
    call permutation_find (angle_perm, index1, index2)
  contains
    recursive subroutine tree_scan (tree, k, perm, index, sig)
      type(phs_tree_t), intent(in) :: tree
      integer(TC), intent(in) :: k
      type(permutation_t), intent(in) :: perm
      integer, dimension(:), intent(inout) :: index
      logical, dimension(:), intent(inout) :: sig
      integer(TC) :: k1, k2, kp
      logical :: s
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1)
         k2 = tree%branch(k)%daughter(2)
         s = (tc_permute(k1, perm, mask_in) < tc_permute(k2, perm, mask_in))
         kp = tc_permute (k, perm, mask_in)
         i = i + 1
         index(i) = kp
         sig(i) = s
         i = i + 1
         index(i) = - kp
         sig(i) = s
         call tree_scan (tree, k1, perm, index, sig)
         call tree_scan (tree, k2, perm, index, sig)
      end if
    end subroutine tree_scan
  end subroutine phs_tree_find_angle_permutation

@ %def phs_tree_find_angle_permutation
@
\subsection{Phase-space evaluation} 
\subsubsection{Phase-space volume}
We compute the phase-space volume recursively, following the same path
as for computing other kinematical variables.  However, the volume
depends just on $\sqrt{\hat s}$, not on the momentum configuration.

Note: counting branches, we may replace this by a simple formula.
<<PHS trees: public>>=
  public :: phs_tree_compute_volume
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_volume (tree, sqrts, volume)
    type(phs_tree_t), intent(in) :: tree
    real(default), intent(in) :: sqrts
    real(default), intent(out) :: volume
    integer(TC) :: k
    k  = tree%mask_out
    if (tree%branch(k)%has_children) then
       call compute_volume_x (tree%branch(k), k, volume, .true.)
    else
       volume = 1
    end if
  contains
    recursive subroutine compute_volume_x (b, k, volume, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: volume
      logical, intent(in) :: initial
      integer(TC) :: k1, k2
      real(default) :: v1, v2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call compute_volume_x (tree%branch(k1), k1, v1, .false.)
      else
         v1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call compute_volume_x (tree%branch(k2), k2, v2, .false.)
      else
         v2 = 1
      end if
      if (initial) then
         volume = v1 * v2 / (4 * twopi5)
      else
         volume = v1 * v2 * sqrts**2 / (4 * twopi2)
      end if
    end subroutine compute_volume_x
  end subroutine phs_tree_compute_volume

@ %def phs_tree_compute_volume
@ 
\subsubsection{Determine momenta}
This is done in two steps: First the masses are determined.  This step
may fail, in which case [[ok]] is set to false.  If successful, we
generate angles and the actual momenta.  The array [[decay_p]] serves
for transferring the individual three-momenta of the daughter
particles in their mother rest frame from the mass generation to the
momentum generation step.
<<PHS trees: public>>=
  public :: phs_tree_compute_momenta_from_x
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_momenta_from_x &
       (tree, prt, factor, volume, sqrts, x, ok)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(out) :: factor, volume
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    logical, intent(out) :: ok
    real(default), dimension(tree%mask_out) :: decay_p
    integer :: n1, n2
    integer :: n_out
    if (tree%real_phsp) then
      n_out = tree%n_externals - tree%n_in - 1
      n1 = max (n_out-2, 0)
      n2 = n1 + max (2*n_out, 0)
    else
      n1 = tree%n_msq
      n2 = n1 + tree%n_angles
    end if
    call phs_tree_set_msq &
         (tree, prt, factor, volume, decay_p, sqrts, x(1:n1), ok)
    if (ok) call phs_tree_set_angles &
         (tree, prt, factor, decay_p, sqrts, x(n1+1:n2))
  end subroutine phs_tree_compute_momenta_from_x

@ %def phs_tree_compute_momenta_from_x
@ Mass generation is done recursively.  The [[ok]] flag causes the
filled tree to be discarded if set to [[.false.]].  This happens if a
three-momentum turns out to be imaginary, indicating impossible
kinematics.  The index [[ix]] tells us how far we have used up the
input array [[x]].
<<PHS trees: procedures>>=
  subroutine phs_tree_set_msq &
       (tree, prt, factor, volume, decay_p, sqrts, x, ok)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(out) :: factor, volume
    real(default), dimension(:), intent(out) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    logical, intent(out) :: ok
    integer :: ix
    integer(TC) :: k
    real(default) :: m_tot
    ok =.true.
    ix = 1
    k  = tree%mask_out
    m_tot = tree%mass_sum(k)
    decay_p(k) = 0.
    if (m_tot < sqrts .or. k == 1) then
       if (tree%branch(k)%has_children) then
          call set_msq_x (tree%branch(k), k, factor, volume, .true.)
       else
          factor = 1
          volume = 1
       end if
    else
       ok = .false.
    end if
  contains
    recursive subroutine set_msq_x (b, k, factor, volume, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: factor, volume
      logical, intent(in) :: initial
      real(default) :: msq, m, m_min, m_max, m1, m2, msq1, msq2, lda, rlda
      integer(TC) :: k1, k2
      real(default) :: f1, f2, v1, v2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call set_msq_x (tree%branch(k1), k1, f1, v1, .false.)
         if (.not.ok) return
      else
         f1 = 1;  v1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call set_msq_x (tree%branch(k2), k2, f2, v2, .false.)
         if (.not.ok) return
      else
         f2 = 1;  v2 = 1
      end if
      m_min = tree%mass_sum(k)
      if (initial) then
         msq = sqrts**2
         m = sqrts
         m_max = sqrts
         factor = f1 * f2
         volume = v1 * v2 / (4 * twopi5)
      else
         m_max = sqrts - m_tot + m_min
         call mapping_compute_msq_from_x &
              (tree%mapping(k), sqrts**2, m_min**2, m_max**2, msq, factor, &
               x(ix)); ix = ix + 1
         if (msq >= 0) then
            m = sqrt (msq)
            factor = f1 * f2 * factor
            volume = v1 * v2 * sqrts**2 / (4 * twopi2)
            call phs_prt_set_msq (prt(k), msq)
            call phs_prt_set_defined (prt(k))
         else
            ok = .false.
         end if
      end if
      if (ok) then
         msq1 = phs_prt_get_msq (prt(k1));  m1 = sqrt (msq1)
         msq2 = phs_prt_get_msq (prt(k2));  m2 = sqrt (msq2)
         lda = lambda (msq, msq1, msq2)
         if (lda > 0 .and. m > m1 + m2 .and. m <= m_max) then
            rlda = sqrt (lda)
            decay_p(k1) = rlda / (2*m)
            decay_p(k2) = - decay_p(k1)
            factor = rlda / msq * factor
         else
            ok = .false.
         end if
      end if
    end subroutine set_msq_x

  end subroutine phs_tree_set_msq

@ %def phs_tree_set_msq
@ 
The heart of phase space generation: Now we have the invariant masses,
let us generate angles.  At each branch, we take a Lorentz
transformation and augment it by a boost to the current particle
rest frame, and by rotations $\phi$ and $\theta$ around the $z$ and
$y$ axis, respectively.  This transformation is passed down to the
daughter particles, if present.
<<PHS trees: procedures>>=
  subroutine phs_tree_set_angles (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(inout) :: factor
    real(default), dimension(:), intent(in) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    integer :: ix
    integer(TC) :: k
    ix = 1
    k  = tree%mask_out
    call set_angles_x (tree%branch(k), k)
  contains
    recursive subroutine set_angles_x (b, k, L0)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      type(lorentz_transformation_t), intent(in), optional :: L0
      real(default) :: m, msq, ct, st, phi, f, E, p, bg
      type(lorentz_transformation_t) :: L, LL
      integer(TC) :: k1, k2
      type(vector3_t) :: axis
      p = decay_p(k)
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      E = sqrt (msq + p**2)
      if (present (L0)) then
         call phs_prt_set_momentum (prt(k), L0 * vector4_moving (E,p,3))
      else
         call phs_prt_set_momentum (prt(k), vector4_moving (E,p,3))
      end if
      call phs_prt_set_defined (prt(k))
      if (b%has_children) then
         k1 = b%daughter(1)
         k2 = b%daughter(2)
         if (m > 0) then
            bg = p / m
         else
            bg = 0
         end if
         phi = x(ix) * twopi;  ix = ix + 1
         call mapping_compute_ct_from_x &
              (tree%mapping(k), sqrts**2, ct, st, f, x(ix));  ix = ix + 1
         factor = factor * f
         if (.not. b%has_friend) then
            L = LT_compose_r2_r3_b3 (ct, st, cos(phi), sin(phi), bg)
            !!! The function above is equivalent to:
            ! L = boost (bg,3) * rotation (phi,3) * rotation (ct,st,2)
         else
            LL = boost (-bg,3);  if (present (L0))  LL = LL * inverse(L0)
            axis = space_part ( &
                 LL * phs_prt_get_momentum (prt(tree%branch(k)%friend)) )
            L = boost(bg,3) * rotation_to_2nd (vector3_canonical(3), axis) &
                 * LT_compose_r2_r3_b3 (ct, st, cos(phi), sin(phi), 0._default)
         end if
         if (present (L0))  L = L0 * L
         call set_angles_x (tree%branch(k1), k1, L)
         call set_angles_x (tree%branch(k2), k2, L)
      end if
    end subroutine set_angles_x

  end subroutine phs_tree_set_angles

@ %def phs_tree_set_angles
@ 
\subsubsection{Recover random numbers}
For the other channels we want to compute the random numbers that
would have generated the momenta that we already know.
<<PHS trees: public>>=
  public :: phs_tree_compute_x_from_momenta
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_x_from_momenta (tree, prt, factor, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(out) :: factor
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(inout) :: x
    real(default), dimension(tree%mask_out) :: decay_p
    integer :: n1, n2
    n1 = tree%n_msq
    n2 = n1 + tree%n_angles
    call phs_tree_get_msq &
         (tree, prt, factor, decay_p, sqrts, x(1:n1))
    call phs_tree_get_angles &
         (tree, prt, factor, decay_p, sqrts, x(n1+1:n2))
  end subroutine phs_tree_compute_x_from_momenta

@ %def phs_tree_compute_x_from_momenta
@ The inverse operation follows exactly the same steps.  The tree is
[[inout]] because it contains mappings whose parameters can be reset
when the mapping is applied.
<<PHS trees: procedures>>=
  subroutine phs_tree_get_msq (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(out) :: factor
    real(default), dimension(:), intent(out) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(inout) :: x
    integer :: ix
    integer(TC) :: k
    real(default) :: m_tot
    ix = 1
    k  = tree%mask_out
    m_tot = tree%mass_sum(k)
    decay_p(k) = 0.
    if (tree%branch(k)%has_children) then
       call get_msq_x (tree%branch(k), k, factor, .true.)
    else
       factor = 1
    end if
  contains
    recursive subroutine get_msq_x (b, k, factor, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: factor
      logical, intent(in) :: initial
      real(default) :: msq, m, m_min, m_max, msq1, msq2, lda, rlda
      integer(TC) :: k1, k2
      real(default) :: f1, f2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call get_msq_x (tree%branch(k1), k1, f1, .false.)
      else
         f1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call get_msq_x (tree%branch(k2), k2, f2, .false.)
      else
         f2 = 1
      end if
      m_min = tree%mass_sum(k)
      m_max = sqrts - m_tot + m_min
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      if (initial) then
         factor = f1 * f2
      else
         call mapping_compute_x_from_msq &
              (tree%mapping(k), sqrts**2, m_min**2, m_max**2, msq, factor, &
               x(ix));  ix = ix + 1
         factor = f1 * f2 * factor
      end if
      msq1 = phs_prt_get_msq (prt(k1))
      msq2 = phs_prt_get_msq (prt(k2))  
      lda = lambda (msq, msq1, msq2)
      if (lda > 0) then
         rlda = sqrt (lda)
         decay_p(k1) = rlda / (2 * m)
         decay_p(k2) = - decay_p(k1)
         factor = rlda / msq * factor
      else
         decay_p(k1) = 0
         decay_p(k2) = 0
         factor = 0
      end if
    end subroutine get_msq_x

  end subroutine phs_tree_get_msq

@ %def phs_tree_get_msq
@ This subroutine is the most time-critical part of the whole
program.  Therefore, we do not exactly parallel the angle generation
routine above but make sure that things get evaluated only if they are
really needed, at the expense of readability.  Particularly important
is to have as few multiplications of Lorentz transformations as
possible.
<<PHS trees: procedures>>=
  subroutine phs_tree_get_angles (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(inout) :: factor
    real(default), dimension(:), intent(in) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(out) :: x
    integer :: ix
    integer(TC) :: k
    ix = 1
    k  = tree%mask_out
    if (tree%branch(k)%has_children) then
       call get_angles_x (tree%branch(k), k)
    end if
  contains
    recursive subroutine get_angles_x (b, k, ct0, st0, phi0, L0)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(in), optional :: ct0, st0, phi0
      type(lorentz_transformation_t), intent(in), optional :: L0
      real(default) :: cp0, sp0, m, msq, ct, st, phi, bg, f
      type(lorentz_transformation_t) :: L, LL
      type(vector4_t) :: p1, pf
      type(vector3_t) :: n, axis
      integer(TC) :: k1, k2, kf
      logical :: has_friend, need_L
      k1 = b%daughter(1)
      k2 = b%daughter(2)
      kf = b%friend
      has_friend = b%has_friend
      if (present(L0)) then
         p1 = L0 * phs_prt_get_momentum (prt(k1))
         if (has_friend)  pf = L0 * phs_prt_get_momentum (prt(kf))
      else
         p1 = phs_prt_get_momentum (prt(k1))
         if (has_friend)  pf = phs_prt_get_momentum (prt(kf))
      end if
      if (present(phi0)) then
         cp0 = cos (phi0)
         sp0 = sin (phi0)
      end if
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      if (m > 0) then
         bg = decay_p(k) / m
      else
         bg = 0
      end if
      if (has_friend) then
         if (present (phi0)) then
            axis = axis_from_p_r3_r2_b3 (pf, cp0, -sp0, ct0, -st0, -bg)
            LL = rotation_to_2nd (axis, vector3_canonical (3)) &
                 * LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg)
         else
            axis = axis_from_p_b3 (pf, -bg)
            LL = rotation_to_2nd (axis, vector3_canonical(3))
            if (bg /= 0)  LL = LL * boost(-bg, 3)
         end if
         n = space_part (LL * p1)
      else if (present (phi0)) then
         n = axis_from_p_r3_r2_b3 (p1, cp0, -sp0, ct0, -st0, -bg)
      else
         n = axis_from_p_b3 (p1, -bg)
      end if
      phi = azimuthal_angle (n)
      x(ix) = phi / twopi;  ix = ix + 1
      ct = polar_angle_ct (n)
      st = sqrt (1 - ct**2)
      call mapping_compute_x_from_ct (tree%mapping(k), sqrts**2, ct, f, &
           x(ix));  ix = ix + 1
      factor = factor * f
      if (tree%branch(k1)%has_children .or. tree%branch(k2)%has_children) then
         need_L = .true.
         if (has_friend) then
            if (present (L0)) then
               L = LL * L0
            else
               L = LL
            end if
         else if (present (L0)) then
            L = LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg) * L0
         else if (present (phi0)) then
            L = LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg)
         else if (bg /= 0) then
            L = boost(-bg, 3)
         else
            need_L = .false.
         end if
         if (need_L) then
            if (tree%branch(k1)%has_children) &
                 call get_angles_x (tree%branch(k1), k1, ct, st, phi, L)
            if (tree%branch(k2)%has_children) &
                 call get_angles_x (tree%branch(k2), k2, ct, st, phi, L)
         else
            if (tree%branch(k1)%has_children) &
                 call get_angles_x (tree%branch(k1), k1, ct, st, phi)
            if (tree%branch(k2)%has_children) &
                 call get_angles_x (tree%branch(k2), k2, ct, st, phi)
         end if
      end if
    end subroutine get_angles_x
  end subroutine phs_tree_get_angles

@ %def phs_tree_get_angles
@ 
\subsubsection{Auxiliary stuff}
This calculates all momenta that are not yet known by summing up
daughter particle momenta.  The external particles must be known.
Only composite particles not yet known are calculated.
<<PHS trees: public>>=
  public :: phs_tree_combine_particles
<<PHS trees: procedures>>=
  subroutine phs_tree_combine_particles (tree, prt)
    type(phs_tree_t), intent(in) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    call combine_particles_x (tree%mask_out)
  contains
    recursive subroutine combine_particles_x (k)
      integer(TC), intent(in) :: k
      integer :: k1, k2
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1);  k2 = tree%branch(k)%daughter(2)
         call combine_particles_x (k1)
         call combine_particles_x (k2)
         if (.not. prt(k)%defined) then
            call phs_prt_combine (prt(k), prt(k1), prt(k2))
         end if
      end if
    end subroutine combine_particles_x
  end subroutine phs_tree_combine_particles

@ %def phs_tree_combine_particles
@ The previous routine is to be evaluated at runtime.  Instead of
scanning trees, we can as well set up a multiplication table.  This is
generated here.  Note that the table is [[intent(out)]].
<<PHS trees: public>>=
  public :: phs_tree_setup_prt_combinations
<<PHS trees: procedures>>=
  subroutine phs_tree_setup_prt_combinations (tree, comb)
    type(phs_tree_t), intent(in) :: tree
    integer, dimension(:,:), intent(out) :: comb
    comb = 0
    call setup_prt_combinations_x (tree%mask_out)
  contains
    recursive subroutine setup_prt_combinations_x (k)
      integer(TC), intent(in) :: k
      integer, dimension(2) :: kk
      if (tree%branch(k)%has_children) then
         kk = tree%branch(k)%daughter
         call setup_prt_combinations_x (kk(1))
         call setup_prt_combinations_x (kk(2))
         comb(:,k) = kk
      end if
    end subroutine setup_prt_combinations_x
  end subroutine phs_tree_setup_prt_combinations
      
@ %def phs_tree_setup_prt_combinations
@
<<PHS trees: public>>=
  public :: phs_tree_reshuffle_mappings
<<PHS trees: procedures>>=
  subroutine phs_tree_reshuffle_mappings (tree)
   type(phs_tree_t), intent(inout) :: tree
   integer(TC) :: k0, k_old, k_new, k2
   integer :: i
   type(mapping_t) :: mapping_tmp
   real(default) :: mass_tmp
   do i = 1, size (tree%momentum_link)
     if (i /= tree%momentum_link (i)) then
       k_old = 2**(i-tree%n_in-1)
       k_new = 2**(tree%momentum_link(i)-tree%n_in-1)
       k0 = tree%branch(k_old)%mother
       k2 = k_new + tree%branch(k_old)%sibling
       mapping_tmp = tree%mapping(k0)
       mass_tmp = tree%mass_sum(k0)
       tree%mapping(k0) = tree%mapping(k2)
       tree%mapping(k2) = mapping_tmp
       tree%mass_sum(k0) = tree%mass_sum(k2)
       tree%mass_sum(k2) = mass_tmp
     end if
   end do
  end subroutine phs_tree_reshuffle_mappings

@ %def phs_tree_reshuffle_mappings
@
<<PHS trees: public>>=
  public :: phs_tree_set_momentum_links
<<PHS trees: procedures>>=
  subroutine phs_tree_set_momentum_links (tree, list)
    type(phs_tree_t), intent(inout) :: tree
    integer, dimension(:), allocatable :: list
    tree%momentum_link = list
  end subroutine phs_tree_set_momentum_links

@ %def phs_tree_set_momentum_links
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The phase-space forest}
Simply stated, a phase-space forest is a collection of phase-space
trees.  More precisely, a [[phs_forest]] object contains all
parameterizations of phase space that \whizard\ will use for a single
hard process, prepared in the form of [[phs_tree]] objects.  This is
suitable for evaluation by the \vamp\ integration package:  each
parameterization (tree) is a valid channel in the multi-channel
adaptive integration, and each variable in a tree corresponds to an
integration dimension, defined by an appropriate mapping of the
$(0,1)$ interval to the allowed range of the integration variable.

The trees are grouped in groves.  The trees (integration channels)
within a grove share a common weight, assuming that they are related
by some approximate symmetry.

Trees/channels that are related by an exact symmetry are connected by
an array of equivalences; each equivalence object holds the data that
relate one channel to another.

The phase-space setup, i.e., the detailed structure of trees and
forest, are read from a file.  Therefore, this module also contains
the syntax definition and the parser needed for interpreting this
file.
<<[[phs_forests.f90]]>>=
<<File header>>

module phs_forests

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use format_defs, only: FMT_12, FMT_19
  use diagnostics
  use lorentz
  use unit_tests
  use permutations
  use ifiles
  use syntax_rules
  use lexers
  use parser
  use model_data
  use model_data
  use flavors
  use interactions

  use phs_base
  use mappings
  use phs_trees

  use fks_regions

<<Standard module head>>

<<PHS forests: public>>

<<PHS forests: types>>

<<PHS forests: interfaces>>

<<PHS forests: variables>>

contains

<<PHS forests: procedures>>

<<PHS forests: tests>>

end module phs_forests
@ %def phs_forests
@ 
\subsection{Phase-space setup parameters}
This transparent container holds the parameters that the algorithm
needs for phase-space setup, with reasonable defaults.

The threshold mass (for considering a particle as effectively
massless) is specified separately for s- and t-channel. The default is
to treat $W$ and $Z$ bosons as massive in the s-channel, but as
massless in the t-channel.  The $b$-quark is treated always massless,
the $t$-quark always massive.
<<PHS forests: public>>=
  public :: phs_parameters_t
<<PHS forests: types>>=
  type :: phs_parameters_t
     real(default) :: sqrts = 0
     real(default) :: m_threshold_s = 50._default
     real(default) :: m_threshold_t = 100._default
     integer :: off_shell = 1
     integer :: t_channel = 2
     logical :: keep_nonresonant = .true.
  end type phs_parameters_t

@ %def phs_parameters_t
@ Write phase-space parameters to file.
<<PHS forests: public>>=
  public :: phs_parameters_write
<<PHS forests: procedures>>=
  subroutine phs_parameters_write (phs_par, unit)
    type(phs_parameters_t), intent(in) :: phs_par
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A," // FMT_19 // ")") "sqrts         = ", phs_par%sqrts
    write (u, "(3x,A," // FMT_19 // ")") "m_threshold_s = ", phs_par%m_threshold_s
    write (u, "(3x,A," // FMT_19 // ")") "m_threshold_t = ", phs_par%m_threshold_t
    write (u, "(3x,A,I0)") "off_shell = ", phs_par%off_shell
    write (u, "(3x,A,I0)") "t_channel = ", phs_par%t_channel
    write (u, "(3x,A,L1)") "keep_nonresonant = ", phs_par%keep_nonresonant
  end subroutine phs_parameters_write

@ %def phs_parameters_write
@ Read phase-space parameters from file.
<<PHS forests: public>>=
  public :: phs_parameters_read
<<PHS forests: procedures>>=
  subroutine phs_parameters_read (phs_par, unit)
    type(phs_parameters_t), intent(out) :: phs_par
    integer, intent(in) :: unit
    character(20) :: dummy
    character :: equals
    read (unit, *)  dummy, equals, phs_par%sqrts
    read (unit, *)  dummy, equals, phs_par%m_threshold_s
    read (unit, *)  dummy, equals, phs_par%m_threshold_t
    read (unit, *)  dummy, equals, phs_par%off_shell
    read (unit, *)  dummy, equals, phs_par%t_channel
    read (unit, *)  dummy, equals, phs_par%keep_nonresonant
  end subroutine phs_parameters_read

@ %def phs_parameters_write
@ Comparison.
<<PHS forests: interfaces>>=
  interface operator(==)
     module procedure phs_parameters_eq
  end interface
  interface operator(/=)
     module procedure phs_parameters_ne
  end interface
<<PHS forests: procedures>>=
  function phs_parameters_eq (phs_par1, phs_par2) result (equal)
    logical :: equal
    type(phs_parameters_t), intent(in) :: phs_par1, phs_par2
    equal = phs_par1%sqrts == phs_par2%sqrts &
         .and. phs_par1%m_threshold_s == phs_par2%m_threshold_s &
         .and. phs_par1%m_threshold_t == phs_par2%m_threshold_t &
         .and. phs_par1%off_shell == phs_par2%off_shell &
         .and. phs_par1%t_channel == phs_par2%t_channel &
	 .and.(phs_par1%keep_nonresonant .eqv. phs_par2%keep_nonresonant)
  end function phs_parameters_eq

  function phs_parameters_ne (phs_par1, phs_par2) result (ne)
    logical :: ne
    type(phs_parameters_t), intent(in) :: phs_par1, phs_par2
    ne = phs_par1%sqrts /= phs_par2%sqrts &
         .or. phs_par1%m_threshold_s /= phs_par2%m_threshold_s &
         .or. phs_par1%m_threshold_t /= phs_par2%m_threshold_t &
         .or. phs_par1%off_shell /= phs_par2%off_shell &
         .or. phs_par1%t_channel /= phs_par2%t_channel &
	 .or.(phs_par1%keep_nonresonant .neqv. phs_par2%keep_nonresonant)
  end function phs_parameters_ne

@ %def phs_parameters_eq phs_parameters_ne
@ 
\subsection{Equivalences}
This type holds information about equivalences between phase-space
trees.  We make a linked list, where each node contains the two
trees which are equivalent and the corresponding permutation of
external particles.  Two more arrays are to be filled: The permutation
of mass variables and the permutation of angular variables, where the
signature indicates a necessary exchange of daughter branches.
<<PHS forests: types>>=
  type :: equivalence_t
     private
     integer :: left, right
     type(permutation_t) :: perm
     type(permutation_t) :: msq_perm, angle_perm
     logical, dimension(:), allocatable :: angle_sig
     type(equivalence_t), pointer :: next => null ()
  end type equivalence_t

@ %def equivalence_t
<<PHS forests: types>>=
  type :: equivalence_list_t
     private
     integer :: length = 0
     type(equivalence_t), pointer :: first => null ()
     type(equivalence_t), pointer :: last => null ()
  end type equivalence_list_t

@ %def equivalence_list_t
@ Append an equivalence to the list
<<PHS forests: procedures>>=
  subroutine equivalence_list_add (eql, left, right, perm)
    type(equivalence_list_t), intent(inout) :: eql
    integer, intent(in) :: left, right
    type(permutation_t), intent(in) :: perm
    type(equivalence_t), pointer :: eq
    allocate (eq)
    eq%left = left
    eq%right = right
    eq%perm = perm
    if (associated (eql%last)) then
       eql%last%next => eq
    else
       eql%first => eq
    end if
    eql%last => eq
    eql%length = eql%length + 1
  end subroutine equivalence_list_add

@ %def equivalence_list_add
@ Delete the list contents.  Has to be pure because it is called from
an elemental subroutine.
<<PHS forests: procedures>>=
  pure subroutine equivalence_list_final (eql)
    type(equivalence_list_t), intent(inout) :: eql
    type(equivalence_t), pointer :: eq
    do while (associated (eql%first))
       eq => eql%first
       eql%first => eql%first%next
       deallocate (eq)
    end do
    eql%last => null ()
    eql%length = 0
  end subroutine equivalence_list_final

@ %def equivalence_list_final
@ Make a deep copy of the equivalence list.  This allows for deep
copies of groves and forests.
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure equivalence_list_assign
  end interface

<<PHS forests: procedures>>=
  subroutine equivalence_list_assign (eql_out, eql_in)
    type(equivalence_list_t), intent(out) :: eql_out
    type(equivalence_list_t), intent(in) :: eql_in
    type(equivalence_t), pointer :: eq, eq_copy
    eq => eql_in%first
    do while (associated (eq))
       allocate (eq_copy)
       eq_copy = eq
       eq_copy%next => null ()
       if (associated (eql_out%first)) then
          eql_out%last%next => eq_copy
       else
          eql_out%first => eq_copy
       end if
       eql_out%last => eq_copy
       eq => eq%next
    end do
  end subroutine equivalence_list_assign

@ %def equivalence_list_assign
@ The number of list entries
<<PHS forests: procedures>>=
  elemental function equivalence_list_length (eql) result (length)
    integer :: length
    type(equivalence_list_t), intent(in) :: eql
    length = eql%length
  end function equivalence_list_length

@ %def equivalence_list_length
@ Recursively write the equivalences list
<<PHS forests: procedures>>=
  subroutine equivalence_list_write (eql, unit)
    type(equivalence_list_t), intent(in) :: eql
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    if (associated (eql%first)) then
       call equivalence_write_rec (eql%first, u)
    else
       write (u, *) " [empty]"
    end if
  contains
    recursive subroutine equivalence_write_rec (eq, u)
      type(equivalence_t), intent(in) :: eq
      integer, intent(in) :: u
      integer :: i
      write (u, "(3x,A,1x,I0,1x,I0,2x,A)", advance="no") &
           "Equivalence:", eq%left, eq%right, "Final state permutation:"
      call permutation_write (eq%perm, u)
      write (u, "(1x,12x,1x,A,1x)", advance="no") &
           "       msq permutation:  "
      call permutation_write (eq%msq_perm, u)
      write (u, "(1x,12x,1x,A,1x)", advance="no") &
           "       angle permutation:"
      call permutation_write (eq%angle_perm, u)
      write (u, "(1x,12x,1x,26x)", advance="no")
      do i = 1, size (eq%angle_sig)
         if (eq%angle_sig(i)) then
            write (u, "(1x,A)", advance="no") "+"
         else
            write (u, "(1x,A)", advance="no") "-"
         end if
      end do
      write (u, *) 
      if (associated (eq%next))  call equivalence_write_rec (eq%next, u)
    end subroutine equivalence_write_rec
  end subroutine equivalence_list_write

@ %def equivalence_list_write
@ 
\subsection{Groves}
A grove is a group of trees (phase-space channels) that share a common
weight in the integration.  Within a grove, channels can be declared
equivalent, so they also share their integration grids (up to
symmetries).  The grove contains a list of equivalences.  The
[[tree_count_offset]] is the total number of trees of the preceding
groves; when the trees are counted per forest (integration channels),
the offset has to be added to all tree indices.
<<PHS forests: types>>=
  type :: phs_grove_t
     private
     integer :: tree_count_offset
     type(phs_tree_t), dimension(:), allocatable :: tree
     type(equivalence_list_t) :: equivalence_list
  end type phs_grove_t

@ %def phs_grove_t
@ Call [[phs_tree_init]] which is also elemental:
<<PHS forests: procedures>>=
  elemental subroutine phs_grove_init &
       (grove, n_trees, n_in, n_out, n_masses, n_angles)
    type(phs_grove_t), intent(inout) :: grove
    integer, intent(in) :: n_trees, n_in, n_out, n_masses, n_angles
    grove%tree_count_offset = 0
    allocate (grove%tree (n_trees))
    call phs_tree_init (grove%tree, n_in, n_out, n_masses, n_angles)
  end subroutine phs_grove_init

@ %def phs_grove_init
@ The trees do not have pointer components, thus no call to
[[phs_tree_final]]:
<<PHS forests: procedures>>=
  elemental subroutine phs_grove_final (grove)
    type(phs_grove_t), intent(inout) :: grove
    deallocate (grove%tree)
    call equivalence_list_final (grove%equivalence_list)
  end subroutine phs_grove_final

@ %def phs_grove_final
@ Deep copy.
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure phs_grove_assign0
     module procedure phs_grove_assign1
  end interface

<<PHS forests: procedures>>=
  subroutine phs_grove_assign0 (grove_out, grove_in)
    type(phs_grove_t), intent(out) :: grove_out
    type(phs_grove_t), intent(in) :: grove_in
    grove_out%tree_count_offset = grove_in%tree_count_offset
    if (allocated (grove_in%tree)) then
       allocate (grove_out%tree (size (grove_in%tree)))
       grove_out%tree = grove_in%tree
    end if
    grove_out%equivalence_list = grove_in%equivalence_list
  end subroutine phs_grove_assign0

  subroutine phs_grove_assign1 (grove_out, grove_in)
    type(phs_grove_t), dimension(:), intent(out) :: grove_out
    type(phs_grove_t), dimension(:), intent(in) :: grove_in
    integer :: i
    do i = 1, size (grove_in)
       call phs_grove_assign0 (grove_out(i), grove_in(i))
    end do
  end subroutine phs_grove_assign1

@ %def phs_grove_assign
@ Get the global (s-channel) mappings.  Implemented as a subroutine
which returns an array (slice).
<<PHS forests: procedures>>=
  subroutine phs_grove_assign_s_mappings (grove, mapping)
    type(phs_grove_t), intent(in) :: grove
    type(mapping_t), dimension(:), intent(out) :: mapping
    integer :: i
    if (size (mapping) == size (grove%tree)) then
       do i = 1, size (mapping)
          call phs_tree_assign_s_mapping (grove%tree(i), mapping(i))
       end do
    else
       call msg_bug ("phs_grove_assign_s_mappings: array size mismatch")
    end if
  end subroutine phs_grove_assign_s_mappings

@ %def phs_grove_assign_s_mappings
@
\subsection{The forest type}
This is a collection of trees and associated particles.  In a given
tree, each branch code corresponds to a particle in the [[prt]] array.
Furthermore, we have an array of mass sums which is independent of the
decay tree and of the particular event.  The mappings directly
correspond to the decay trees, and the decay groves collect the trees
in classes.  The permutation list consists of all permutations of
outgoing particles that map the decay forest onto itself.

The particle codes [[flv]] (one for each external particle) are needed
for determining masses and such.  The trees and associated information
are collected in the [[grove]] array, together with a lookup table
that associates tree indices to groves.  Finally, the [[prt]] array
serves as workspace for phase-space evaluation.

The [[prt_combination]] is a list of index pairs, namely the particle
momenta pairs that need to be combined in order to provide all
momentum combinations that the phase-space trees need to know.
<<PHS forests: public>>=
  public :: phs_forest_t
<<PHS forests: types>>=
  type :: phs_forest_t
     private
     integer :: n_in, n_out, n_tot
     integer :: n_masses, n_angles, n_dimensions
     integer :: n_trees, n_equivalences
     type(flavor_t), dimension(:), allocatable :: flv
     type(phs_grove_t), dimension(:), allocatable :: grove
     integer, dimension(:), allocatable :: grove_lookup
     type(phs_prt_t), dimension(:), allocatable :: prt_in
     type(phs_prt_t), dimension(:), allocatable :: prt_out
     type(phs_prt_t), dimension(:), allocatable :: prt
     integer(TC), dimension(:,:), allocatable :: prt_combination
     type(mapping_t), dimension(:), allocatable :: s_mapping
   contains
   <<PHS forests: phs forest: TBP>>
  end type phs_forest_t

@ %def phs_forest_t
@ 
The initialization merely allocates memory.  We have to know how many
trees there are in each grove, so we can initialize everything.  The
number of groves is the size of the [[n_tree]] array.

In the [[grove_lookup]] table we store the grove index that belongs to
each absolute tree index.  The difference between the absolute index
and the relative (to the grove) index is stored, for each grove, as
[[tree_count_offset]].

The particle array is allocated according to the total number of
branches each tree has, but not filled.
<<PHS forests: public>>=
  public :: phs_forest_init
<<PHS forests: procedures>>=
  subroutine phs_forest_init (forest, n_tree, n_in, n_out)
    type(phs_forest_t), intent(inout) :: forest
    integer, dimension(:), intent(in) :: n_tree
    integer, intent(in) :: n_in, n_out
    integer :: g, count, k_root
    forest%n_in = n_in
    forest%n_out = n_out
    forest%n_tot = n_in + n_out
    forest%n_masses = max (n_out - 2, 0)
    forest%n_angles = max (2*n_out - 2, 0)
    forest%n_dimensions = forest%n_masses + forest%n_angles
    forest%n_trees = sum (n_tree)
    forest%n_equivalences = 0
    allocate (forest%grove (size (n_tree)))
    call phs_grove_init &
         (forest%grove, n_tree, n_in, n_out, forest%n_masses, &
          forest%n_angles)
    allocate (forest%grove_lookup (forest%n_trees))
    count = 0
    do g = 1, size (forest%grove)
       forest%grove(g)%tree_count_offset = count
       forest%grove_lookup (count+1:count+n_tree(g)) = g
       count = count + n_tree(g)
    end do
    allocate (forest%prt_in  (n_in))
    allocate (forest%prt_out (forest%n_out))
    k_root = 2**forest%n_tot - 1
    allocate (forest%prt (k_root))
    allocate (forest%prt_combination (2, k_root))
    allocate (forest%s_mapping (forest%n_trees))
  end subroutine phs_forest_init

@ %def phs_forest_init
@ Assign the global (s-channel) mappings.
<<PHS forests: public>>=
  public :: phs_forest_set_s_mappings
<<PHS forests: procedures>>=
  subroutine phs_forest_set_s_mappings (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: g, i0, i1, n
    do g = 1, size (forest%grove)
       call phs_forest_get_grove_bounds (forest, g, i0, i1, n)
       call phs_grove_assign_s_mappings &
            (forest%grove(g), forest%s_mapping(i0:i1))
    end do
  end subroutine phs_forest_set_s_mappings

@ %def phs_forest_set_s_mappings
@ The grove finalizer is called because it contains the equivalence list:
<<PHS forests: public>>=
  public :: phs_forest_final
<<PHS forests: procedures>>=
  subroutine phs_forest_final (forest)
    type(phs_forest_t), intent(inout) :: forest
    if (allocated (forest%grove)) then
       call phs_grove_final (forest%grove)
       deallocate (forest%grove)
    end if
    if (allocated (forest%grove_lookup))  deallocate (forest%grove_lookup)
    if (allocated (forest%prt))  deallocate (forest%prt)
    if (allocated (forest%s_mapping))  deallocate (forest%s_mapping)
  end subroutine phs_forest_final

@ %def phs_forest_final
@ 
\subsection{Screen output}
Write the particles that are non-null, then the trees which point to
them:
<<PHS forests: public>>=
  public :: phs_forest_write
<<PHS forests: phs forest: TBP>>=
  procedure :: write => phs_forest_write
<<PHS forests: procedures>>=
  subroutine phs_forest_write (forest, unit)
    class(phs_forest_t), intent(in) :: forest
    integer, intent(in), optional :: unit
    integer :: u
    integer :: i, g, k
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "Phase space forest:"
    write (u, "(3x,A,I0)") "n_in  = ", forest%n_in
    write (u, "(3x,A,I0)") "n_out = ", forest%n_out
    write (u, "(3x,A,I0)") "n_tot = ", forest%n_tot
    write (u, "(3x,A,I0)") "n_masses = ", forest%n_masses
    write (u, "(3x,A,I0)") "n_angles = ", forest%n_angles
    write (u, "(3x,A,I0)") "n_dim    = ", forest%n_dimensions
    write (u, "(3x,A,I0)") "n_trees  = ", forest%n_trees
    write (u, "(3x,A,I0)") "n_equiv  = ", forest%n_equivalences
    write (u, "(3x,A)", advance="no") "flavors  ="
    if (allocated (forest%flv)) then
       do i = 1, size (forest%flv)
          write (u, "(1x,I0)", advance="no")  flavor_get_pdg (forest%flv(i))
       end do
       write (u, "(A)")
    else
       write (u, "(1x,A)") "[empty]"
    end if
    write (u, "(1x,A)") "Particle combinations:"
    if (allocated (forest%prt_combination)) then
       do k = 1, size (forest%prt_combination, 2)
          if (forest%prt_combination(1, k) /= 0) then
             write (u, "(3x,I0,1x,'<=',1x,I0,1x,'+',1x,I0)") &
                  k, forest%prt_combination(:,k)
          end if
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(1x,A)") "Groves and trees:"
    if (allocated (forest%grove)) then
       do g = 1, size (forest%grove)
          write (u, "(3x,A,1x,I0)") "Grove    ", g
          call phs_grove_write (forest%grove(g), unit)
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(1x,A,I0)") "Total number of equivalences: ", &
         forest%n_equivalences
    write (u, "(A)")
    write (u, "(1x,A)") "Global s-channel mappings:"
    if (allocated (forest%s_mapping)) then
       do i = 1, size (forest%s_mapping)
          associate (mapping => forest%s_mapping(i))
            if (mapping_is_s_channel (mapping) &
                 .or. mapping_is_on_shell (mapping)) then
               write (u, "(1x,I0,':',1x)", advance="no")  i
               call mapping_write (forest%s_mapping(i), unit)
            end if
          end associate
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Incoming particles:"
    if (allocated (forest%prt_in)) then
       if (any (phs_prt_is_defined (forest%prt_in))) then
          do i = 1, size (forest%prt_in)
             if (phs_prt_is_defined (forest%prt_in(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt_in(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(3x,A)")  "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Outgoing particles:"
    if (allocated (forest%prt_out)) then
       if (any (phs_prt_is_defined (forest%prt_out))) then
          do i = 1, size (forest%prt_out)
             if (phs_prt_is_defined (forest%prt_out(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt_out(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(1x,A)")  "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Tree particles:"
    if (allocated (forest%prt)) then
       if (any (phs_prt_is_defined (forest%prt))) then
          do i = 1, size (forest%prt)
             if (phs_prt_is_defined (forest%prt(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(3x,A)")  "  [empty]"
    end if
  end subroutine phs_forest_write

  subroutine phs_grove_write (grove, unit)
    type(phs_grove_t), intent(in) :: grove
    integer, intent(in), optional :: unit
    integer :: u
    integer :: t
    u = given_output_unit (unit);  if (u < 0)  return
    do t = 1, size (grove%tree)
       write (u, "(3x,A,I0)") "Tree      ", t
       call phs_tree_write (grove%tree(t), unit)
    end do
    write (u, "(1x,A)") "Equivalence list:"
    call equivalence_list_write (grove%equivalence_list, unit)
  end subroutine phs_grove_write

@ %def phs_grove_write phs_forest_write
@ Deep copy.
<<PHS forests: public>>=
  public :: assignment(=)
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure phs_forest_assign
  end interface

<<PHS forests: procedures>>=
  subroutine phs_forest_assign (forest_out, forest_in)
    type(phs_forest_t), intent(out) :: forest_out
    type(phs_forest_t), intent(in) :: forest_in
    forest_out%n_in  = forest_in%n_in
    forest_out%n_out = forest_in%n_out
    forest_out%n_tot = forest_in%n_tot
    forest_out%n_masses = forest_in%n_masses
    forest_out%n_angles = forest_in%n_angles
    forest_out%n_dimensions  = forest_in%n_dimensions
    forest_out%n_trees  = forest_in%n_trees
    forest_out%n_equivalences  = forest_in%n_equivalences
    if (allocated (forest_in%flv)) then
       allocate (forest_out%flv (size (forest_in%flv)))
       forest_out%flv = forest_in%flv
    end if
    if (allocated (forest_in%grove)) then
       allocate (forest_out%grove (size (forest_in%grove)))
       forest_out%grove = forest_in%grove
    end if
    if (allocated (forest_in%grove_lookup)) then
       allocate (forest_out%grove_lookup (size (forest_in%grove_lookup)))
       forest_out%grove_lookup = forest_in%grove_lookup
    end if
    if (allocated (forest_in%prt_in)) then
       allocate (forest_out%prt_in (size (forest_in%prt_in)))
       forest_out%prt_in = forest_in%prt_in
    end if
    if (allocated (forest_in%prt_out)) then
       allocate (forest_out%prt_out (size (forest_in%prt_out)))
       forest_out%prt_out = forest_in%prt_out
    end if
    if (allocated (forest_in%prt)) then
       allocate (forest_out%prt (size (forest_in%prt)))
       forest_out%prt = forest_in%prt
    end if
    if (allocated (forest_in%s_mapping)) then
       allocate (forest_out%s_mapping (size (forest_in%s_mapping)))
       forest_out%s_mapping = forest_in%s_mapping
    end if
    if (allocated (forest_in%prt_combination)) then
       allocate (forest_out%prt_combination &
            (2, size (forest_in%prt_combination, 2)))
       forest_out%prt_combination = forest_in%prt_combination
    end if
  end subroutine phs_forest_assign

@ %def phs_forest_assign
@ 
\subsection{Accessing contents}
Get the number of integration parameters
<<PHS forests: public>>=
  public :: phs_forest_get_n_parameters
<<PHS forests: procedures>>=
  function phs_forest_get_n_parameters (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_dimensions
  end function phs_forest_get_n_parameters

@ %def phs_forest_get_n_parameters
@ Get the number of integration channels
<<PHS forests: public>>=
  public :: phs_forest_get_n_channels
<<PHS forests: procedures>>=
  function phs_forest_get_n_channels (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_trees
  end function phs_forest_get_n_channels

@ %def phs_forest_get_n_channels
@ Get the number of groves
<<PHS forests: public>>=
  public :: phs_forest_get_n_groves
<<PHS forests: procedures>>=
  function phs_forest_get_n_groves (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = size (forest%grove)
  end function phs_forest_get_n_groves

@ %def phs_forest_get_n_groves
@ Get the index bounds for a specific grove.
<<PHS forests: public>>=
  public :: phs_forest_get_grove_bounds
<<PHS forests: procedures>>=
  subroutine phs_forest_get_grove_bounds (forest, g, i0, i1, n)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: g
    integer, intent(out) :: i0, i1, n
    n = size (forest%grove(g)%tree)
    i0 = forest%grove(g)%tree_count_offset + 1
    i1 = forest%grove(g)%tree_count_offset + n
  end subroutine phs_forest_get_grove_bounds

@ %def phs_forest_get_grove_bounds
@ Get the number of equivalences
<<PHS forests: public>>=
  public :: phs_forest_get_n_equivalences
<<PHS forests: procedures>>=
  function phs_forest_get_n_equivalences (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_equivalences
  end function phs_forest_get_n_equivalences

@ %def phs_forest_get_n_equivalences
@ Return true if a particular channel has a global (s-channel)
mapping; also return the resonance mass and width for this mapping.
<<PHS forests: public>>=
  public :: phs_forest_get_s_mapping
  public :: phs_forest_get_on_shell
<<PHS forests: procedures>>=
  subroutine phs_forest_get_s_mapping (forest, channel, flag, mass, width)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: channel
    logical, intent(out) :: flag
    real(default), intent(out) :: mass, width
    flag = mapping_is_s_channel (forest%s_mapping(channel))
    if (flag) then
       mass = mapping_get_mass (forest%s_mapping(channel))
       width = mapping_get_width (forest%s_mapping(channel))
    else
       mass = 0
       width = 0
    end if
  end subroutine phs_forest_get_s_mapping

  subroutine phs_forest_get_on_shell (forest, channel, flag, mass)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: channel
    logical, intent(out) :: flag
    real(default), intent(out) :: mass
    flag = mapping_is_on_shell (forest%s_mapping(channel))
    if (flag) then
       mass = mapping_get_mass (forest%s_mapping(channel))
    else
       mass = 0
    end if
  end subroutine phs_forest_get_on_shell

@ %def phs_forest_get_s_mapping
@ %def phs_forest_get_on_shell
@ 
\subsection{Read the phase space setup from file}
The phase space setup is stored in a file.  The file may be generated
by the [[cascades]] module below, or by other means.  This file has to
be read and parsed to create the PHS forest as the internal
phase-space representation.

Create lexer and syntax:
<<PHS forests: procedures>>=
  subroutine define_phs_forest_syntax (ifile)
    type(ifile_t) :: ifile
    call ifile_append (ifile, "SEQ phase_space_list = process_phase_space*")
    call ifile_append (ifile, "SEQ process_phase_space = " &
         // "process_def process_header phase_space")
    call ifile_append (ifile, "SEQ process_def = process process_list")
    call ifile_append (ifile, "KEY process")
    call ifile_append (ifile, "LIS process_list = process_tag*")
    call ifile_append (ifile, "IDE process_tag")
    call ifile_append (ifile, "SEQ process_header = " &
         // "md5sum_process = md5sum " &
         // "md5sum_model_par = md5sum " &
         // "md5sum_phs_config = md5sum " &
         // "sqrts = real " &
         // "m_threshold_s = real " &
         // "m_threshold_t = real " &
         // "off_shell = integer " &
         // "t_channel = integer " &
         // "keep_nonresonant = logical")
    call ifile_append (ifile, "KEY '='")
    call ifile_append (ifile, "KEY md5sum_process")
    call ifile_append (ifile, "KEY md5sum_model_par")
    call ifile_append (ifile, "KEY md5sum_phs_config")
    call ifile_append (ifile, "KEY sqrts")
    call ifile_append (ifile, "KEY m_threshold_s")
    call ifile_append (ifile, "KEY m_threshold_t")
    call ifile_append (ifile, "KEY off_shell")
    call ifile_append (ifile, "KEY t_channel")
    call ifile_append (ifile, "KEY keep_nonresonant")
    call ifile_append (ifile, "QUO md5sum = '""' ... '""'")
    call ifile_append (ifile, "REA real")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "IDE logical")
    call ifile_append (ifile, "SEQ phase_space = grove_def+")
    call ifile_append (ifile, "SEQ grove_def = grove tree_def+")
    call ifile_append (ifile, "KEY grove")
    call ifile_append (ifile, "SEQ tree_def = tree bincodes mapping*")
    call ifile_append (ifile, "KEY tree")
    call ifile_append (ifile, "SEQ bincodes = bincode*")
    call ifile_append (ifile, "INT bincode")
    call ifile_append (ifile, "SEQ mapping = map bincode channel pdg")
    call ifile_append (ifile, "KEY map")
    call ifile_append (ifile, "ALT channel = &
         &s_channel | t_channel | u_channel | &
         &collinear | infrared | radiation | on_shell")
    call ifile_append (ifile, "KEY s_channel")
    ! call ifile_append (ifile, "KEY t_channel")   !!! Key already exists
    call ifile_append (ifile, "KEY u_channel")
    call ifile_append (ifile, "KEY collinear")
    call ifile_append (ifile, "KEY infrared")
    call ifile_append (ifile, "KEY radiation")
    call ifile_append (ifile, "KEY on_shell")
    call ifile_append (ifile, "INT pdg")
  end subroutine define_phs_forest_syntax

@ %def define_phs_forest_syntax
@ The model-file syntax and lexer are fixed, therefore stored as
module variables:
<<PHS forests: variables>>=
  type(syntax_t), target, save :: syntax_phs_forest

@ %def syntax_phs_forest
<<PHS forests: public>>=
  public :: syntax_phs_forest_init
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_init ()
    type(ifile_t) :: ifile
    call define_phs_forest_syntax (ifile)
    call syntax_init (syntax_phs_forest, ifile)
    call ifile_final (ifile)
  end subroutine syntax_phs_forest_init

@ %def syntax_phs_forest_init
<<PHS forests: procedures>>=
  subroutine lexer_init_phs_forest (lexer)
    type(lexer_t), intent(out) :: lexer
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "", &
         special_class = ["="] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_phs_forest))
  end subroutine lexer_init_phs_forest

@ %def lexer_init_phs_forest
<<PHS forests: public>>=
  public :: syntax_phs_forest_final
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_final ()
    call syntax_final (syntax_phs_forest)
  end subroutine syntax_phs_forest_final

@ %def syntax_phs_forest_final
<<PHS forests: public>>=
  public :: syntax_phs_forest_write
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_phs_forest, unit)
  end subroutine syntax_phs_forest_write

@ %def syntax_phs_forest_write
@ The concrete parser and interpreter.  Generate an input stream for
the external [[unit]], read the parse tree (with given [[syntax]] and
[[lexer]]) from this stream, and transfer the contents of the parse
tree to the PHS [[forest]].

We look for the matching [[process]] tag, count groves and trees for
initializing the [[forest]], and fill the trees.

If the optional parameters are set, compare the parameters stored in
the file to those.  Set [[match]] true if everything agrees.
<<PHS forests: public>>=
  public :: phs_forest_read
<<PHS forests: interfaces>>=
  interface phs_forest_read
     module procedure phs_forest_read_file
     module procedure phs_forest_read_unit
     module procedure phs_forest_read_parse_tree
  end interface

<<PHS forests: procedures>>=
  subroutine phs_forest_read_file &
       (forest, filename, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, &
        md5sum_phs_config, phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    type(string_t), intent(in) :: filename
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_tree_t), target :: parse_tree
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_phs_forest (lexer)
    call stream_init (stream, char (filename))
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_phs_forest, lexer)
    call phs_forest_read (forest, parse_tree, &
         process_id, n_in, n_out, model, found, &
         md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
    call stream_final (stream)
    call lexer_final (lexer)
    call parse_tree_final (parse_tree)
  end subroutine phs_forest_read_file

  subroutine phs_forest_read_unit &
       (forest, unit, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, md5sum_phs_config, &
        phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    integer, intent(in) :: unit
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_tree_t), target :: parse_tree
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_phs_forest (lexer)
    call stream_init (stream, unit)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_phs_forest, lexer)
    call phs_forest_read (forest, parse_tree, &
         process_id, n_in, n_out, model, found, &
         md5sum_process, md5sum_model_par, md5sum_phs_config, &
         phs_par, match)
    call stream_final (stream)
    call lexer_final (lexer)
    call parse_tree_final (parse_tree)
  end subroutine phs_forest_read_unit

  subroutine phs_forest_read_parse_tree &
       (forest, parse_tree, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, md5sum_phs_config, &
        phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    type(parse_tree_t), intent(in), target :: parse_tree
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_node_t), pointer :: node_header, node_phs, node_grove
    integer :: n_grove, g
    integer, dimension(:), allocatable :: n_tree
    integer :: t
    logical :: real_phsp_work
    ! call parse_tree_write (parse_tree)     !!! Debugging
    node_header => parse_tree_get_process_ptr (parse_tree, process_id)
    found = associated (node_header);  if (.not. found)  return
    if (present (match)) then
       call phs_forest_check_input (node_header, &
            md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
       if (.not. match)  return
    end if
    node_phs => parse_node_get_next_ptr (node_header)
    n_grove = parse_node_get_n_sub (node_phs)
    allocate (n_tree (n_grove))
    do g = 1, n_grove
       node_grove => parse_node_get_sub_ptr (node_phs, g)
       n_tree(g) = parse_node_get_n_sub (node_grove) - 1
    end do
    call phs_forest_init (forest, n_tree, n_in, n_out)
    do g = 1, n_grove
       node_grove => parse_node_get_sub_ptr (node_phs, g)
       do t = 1, n_tree(g)
          call phs_tree_set (forest%grove(g)%tree(t), &
               parse_node_get_sub_ptr (node_grove, t+1), model)
       end do
    end do
  end subroutine phs_forest_read_parse_tree

@ %def phs_forest
@ Check the input for consistency.  If any MD5 sum or phase-space
parameter disagrees, the phase-space file cannot be used.  The MD5
sum checks are skipped if the stored MD5 sum is empty.
<<PHS forests: procedures>>=
  subroutine phs_forest_check_input (pn_header, &
       md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
    type(parse_node_t), intent(in), target :: pn_header
    character(32), intent(in) :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out) :: match
    type(parse_node_t), pointer :: pn_md5sum, pn_rval, pn_ival, pn_lval
    character(32) :: md5sum
    type(phs_parameters_t) :: phs_par_old
    character(1) :: lstr
    pn_md5sum => parse_node_get_sub_ptr (pn_header, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_process) then
       call msg_message ("Phase space: discarding old configuration &
            &(process changed)")
       match = .false.;  return
    end if
    pn_md5sum => parse_node_get_next_ptr (pn_md5sum, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_model_par) then
       call msg_message ("Phase space: discarding old configuration &
            &(model parameters changed)")
       match = .false.;  return
    end if
    pn_md5sum => parse_node_get_next_ptr (pn_md5sum, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_phs_config) then
       call msg_message ("Phase space: discarding old configuration &
            &(configuration parameters changed)")
       match = .false.;  return
    end if
    if (present (phs_par)) then
       pn_rval => parse_node_get_next_ptr (pn_md5sum, 3)
       phs_par_old%sqrts = parse_node_get_real (pn_rval)
       pn_rval => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%m_threshold_s = parse_node_get_real (pn_rval)
       pn_rval => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%m_threshold_t = parse_node_get_real (pn_rval)
       pn_ival => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%off_shell = parse_node_get_integer (pn_ival)
       pn_ival => parse_node_get_next_ptr (pn_ival, 3)
       phs_par_old%t_channel = parse_node_get_integer (pn_ival)
       pn_lval => parse_node_get_next_ptr (pn_ival, 3)
       lstr = parse_node_get_string (pn_lval)
       read (lstr, "(L1)")  phs_par_old%keep_nonresonant
       if (phs_par_old /= phs_par) then
          call msg_message &
               ("Phase space: discarding old configuration &
               &(configuration parameters changed)")
          match = .false.;  return
       end if
    end if
    match = .true.
  end subroutine phs_forest_check_input

@ %def phs_forest_check_input
@ Initialize a specific tree in the forest, using the contents of the
'tree' node.  First, count the bincodes, allocate an array and read
them in, and make the tree.  Each $t$-channel tree is flipped to
$s$-channel.  Then, find mappings and initialize them.
<<PHS forests: procedures>>=
  subroutine phs_tree_set (tree, node, model)
    type(phs_tree_t), intent(inout) :: tree
    type(parse_node_t), intent(in), target :: node
    class(model_data_t), intent(in), target :: model
    type(parse_node_t), pointer :: node_bincodes, node_mapping
    integer :: n_bincodes, offset
    integer(TC), dimension(:), allocatable :: bincode
    integer :: b, n_mappings, m
    integer(TC) :: k
    type(string_t) :: type
    integer :: pdg
    node_bincodes => parse_node_get_sub_ptr (node, 2)
    if (associated (node_bincodes)) then
       select case (char (parse_node_get_rule_key (node_bincodes)))
       case ("bincodes")
          n_bincodes = parse_node_get_n_sub (node_bincodes)
          offset = 2
       case default
          n_bincodes = 0
          offset = 1
       end select
    else
       n_bincodes = 0
       offset = 2
    end if
    allocate (bincode (n_bincodes))
    do b = 1, n_bincodes
       bincode(b) = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_bincodes, b))
    end do
    call phs_tree_from_array (tree, bincode)
    call phs_tree_flip_t_to_s_channel (tree)
    call phs_tree_canonicalize (tree)
    n_mappings = parse_node_get_n_sub (node) - offset
    do m = 1, n_mappings
       node_mapping => parse_node_get_sub_ptr (node, m + offset)
       k = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_mapping, 2))
       type = parse_node_get_key &
            (parse_node_get_sub_ptr (node_mapping, 3))
       pdg = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_mapping, 4))
       call phs_tree_init_mapping (tree, k, type, pdg, model)
    end do
  end subroutine phs_tree_set

@ %def phs_tree_set
@ 
\subsection{Preparation}
The trees that we read from file do not carry flavor information.
This is set separately:

The flavor list must be unique for a unique set of masses; if a given
particle can have different flavor, the mass must be degenerate, so we
can choose one of the possible flavor combinations.
<<PHS forests: public>>=
  public :: phs_forest_set_flavors
<<PHS forests: procedures>>=
  subroutine phs_forest_set_flavors (forest, flv, reshuffle, flv_extra)
    type(phs_forest_t), intent(inout) :: forest
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, intent(in), dimension(:), allocatable, optional :: reshuffle
    type(flavor_t), intent(in), optional :: flv_extra
    integer :: i, n_flv0
    if (present (reshuffle) .and. present (flv_extra)) then
       n_flv0 = size (flv)
       do i = 1, n_flv0
          if (reshuffle(i) <= n_flv0) then
             forest%flv(i) = flv (reshuffle(i))
          else
             forest%flv(i) = flv_extra
          end if
       end do
    else
       allocate (forest%flv (size (flv)))
       forest%flv = flv
    end if
  end subroutine phs_forest_set_flavors

@ %def phs_forest_set_flavors
@ 
<<PHS forests: public>>=
  public :: phs_forest_set_momentum_links
<<PHS forests: procedures>>=
  subroutine phs_forest_set_momentum_links (forest, list)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in), dimension(:), allocatable :: list
    integer :: g, t
    do g = 1, size (forest%grove)
      do t = 1, size (forest%grove(g)%tree)
        associate (tree => forest%grove(g)%tree(t))
          call phs_tree_set_momentum_links (tree, list)
!!!          call phs_tree_reshuffle_mappings (tree)
        end associate
      end do
    end do
  end subroutine phs_forest_set_momentum_links

@ %def phs_forest_set_momentum_links  
@ Once the parameter set is fixed, the masses and the widths of the
particles are known and the [[mass_sum]] arrays as well as the mapping
parameters can be computed.  Note that order is important: we first
compute the mass sums, then the ordinary mappings.  The resonances
obtained here determine the effective masses, which in turn are used
to implement step mappings for resonance decay products that are not
mapped otherwise.
<<PHS forests: public>>=
  public :: phs_forest_set_parameters
<<PHS forests: procedures>>=
  subroutine phs_forest_set_parameters &
       (forest, mapping_defaults, variable_limits)
    type(phs_forest_t), intent(inout) :: forest
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    integer :: g, t
    do g = 1, size (forest%grove)
       do t = 1, size (forest%grove(g)%tree)
          call phs_tree_set_mass_sum &
               (forest%grove(g)%tree(t), forest%flv(forest%n_in+1:))
          call phs_tree_set_mapping_parameters (forest%grove(g)%tree(t), &
               mapping_defaults, variable_limits)
          call phs_tree_set_effective_masses (forest%grove(g)%tree(t))
          if (mapping_defaults%step_mapping) then
             call phs_tree_set_step_mappings (forest%grove(g)%tree(t), &
                  mapping_defaults%step_mapping_exp, variable_limits)
          end if
       end do
    end do
  end subroutine phs_forest_set_parameters

@ %def phs_forest_set_parameters
@ Generate the particle combination table.  Scan all trees and merge
their individual combination tables.  At the end, valid entries are
non-zero, and they indicate the indices of a pair of particles to be
combined to a new particle.  If a particle is accessible by more than
one tree (this is usual), only keep the first possibility.
<<PHS forests: public>>=
  public :: phs_forest_setup_prt_combinations
<<PHS forests: procedures>>=
  subroutine phs_forest_setup_prt_combinations (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: g, t
    integer, dimension(:,:), allocatable :: tree_prt_combination
    forest%prt_combination = 0
    allocate (tree_prt_combination (2, size (forest%prt_combination, 2)))
    do g = 1, size (forest%grove)
       do t = 1, size (forest%grove(g)%tree)
          call phs_tree_setup_prt_combinations &
               (forest%grove(g)%tree(t), tree_prt_combination)
          where (tree_prt_combination /= 0 .and. forest%prt_combination == 0)
             forest%prt_combination = tree_prt_combination
          end where
       end do
    end do
  end subroutine phs_forest_setup_prt_combinations

@ %def phs_forest_setup_prt_combinations
@ 
\subsection{Accessing the particle arrays}
Set the incoming particles from the contents of an interaction.
<<PHS forests: public>>=
  public :: phs_forest_set_prt_in
<<PHS forests: interfaces>>=
  interface phs_forest_set_prt_in
     module procedure phs_forest_set_prt_in_int, phs_forest_set_prt_in_mom
  end interface phs_forest_set_prt_in
<<PHS forests: procedures>>=
  subroutine phs_forest_set_prt_in_int (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(interaction_t), intent(in) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_in, &
            inverse (lt_cm_to_lab) * &
            interaction_get_momenta (int, outgoing=.false.))
    else
       call phs_prt_set_momentum (forest%prt_in, &
            interaction_get_momenta (int, outgoing=.false.))
    end if
    call phs_prt_set_msq (forest%prt_in, &
         flavor_get_mass (forest%flv(:forest%n_in)) ** 2)
    call phs_prt_set_defined (forest%prt_in)
  end subroutine phs_forest_set_prt_in_int

  subroutine phs_forest_set_prt_in_mom (forest, mom, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(vector4_t), dimension(size (forest%prt_in)), intent(in) :: mom
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_in, &
            inverse (lt_cm_to_lab) * mom)
    else
       call phs_prt_set_momentum (forest%prt_in, mom)
    end if
    call phs_prt_set_msq (forest%prt_in, &
         flavor_get_mass (forest%flv(:forest%n_in)) ** 2)
    call phs_prt_set_defined (forest%prt_in)
  end subroutine phs_forest_set_prt_in_mom

@ %def phs_forest_set_prt_in
@ Set the outgoing particles from the contents of an interaction.
<<PHS forests: public>>=
  public :: phs_forest_set_prt_out
<<PHS forests: interfaces>>=
  interface phs_forest_set_prt_out
     module procedure phs_forest_set_prt_out_int, phs_forest_set_prt_out_mom
  end interface phs_forest_set_prt_out
<<PHS forests: procedures>>=
  subroutine phs_forest_set_prt_out_int (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(interaction_t), intent(in) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_out, &
            inverse (lt_cm_to_lab) * &
            interaction_get_momenta (int, outgoing=.true.))
    else
       call phs_prt_set_momentum (forest%prt_out, &
            interaction_get_momenta (int, outgoing=.true.))
    end if
    call phs_prt_set_msq (forest%prt_out, &
         flavor_get_mass (forest%flv(forest%n_in+1:)) ** 2)
    call phs_prt_set_defined (forest%prt_out)
  end subroutine phs_forest_set_prt_out_int

  subroutine phs_forest_set_prt_out_mom (forest, mom, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(vector4_t), dimension(size (forest%prt_out)), intent(in) :: mom
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_out, &
            inverse (lt_cm_to_lab) * mom)
    else
       call phs_prt_set_momentum (forest%prt_out, mom)
    end if
    call phs_prt_set_msq (forest%prt_out, &
         flavor_get_mass (forest%flv(forest%n_in+1:)) ** 2)
    call phs_prt_set_defined (forest%prt_out)
  end subroutine phs_forest_set_prt_out_mom

@ %def phs_forest_set_prt_out
@ Combine particles as described by the particle combination table.
Particle momentum sums will be calculated only if the resulting
particle is contained in at least one of the trees in the current
forest.  The others are kept undefined.
<<PHS forests: public>>=
  public :: phs_forest_combine_particles
<<PHS forests: procedures>>=
  subroutine phs_forest_combine_particles (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: k
    integer, dimension(2) :: kk
    do k = 1, size (forest%prt_combination, 2)
       kk = forest%prt_combination(:,k)
       if (kk(1) /= 0) then
          call phs_prt_combine (forest%prt(k), &
               forest%prt(kk(1)), forest%prt(kk(2)))
       end if
    end do
  end subroutine phs_forest_combine_particles

@ %def phs_forest_combine_particles
@ Extract the outgoing particles and insert into an interaction.
<<PHS forests: public>>=
  public :: phs_forest_get_prt_out
<<PHS forests: procedures>>=
  subroutine phs_forest_get_prt_out (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(in) :: forest
    type(interaction_t), intent(inout) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call interaction_set_momenta (int, &
            lt_cm_to_lab * &
            phs_prt_get_momentum (forest%prt_out), outgoing=.true.)
    else
       call interaction_set_momenta (int, &
            phs_prt_get_momentum (forest%prt_out), outgoing=.true.)
    end if
  end subroutine phs_forest_get_prt_out

@ %def phs_forest_get_prt_out
@ Extract the outgoing particle momenta
<<PHS forests: public>>=
  public :: phs_forest_get_momenta_out
<<PHS forests: procedures>>=
  function phs_forest_get_momenta_out (forest, lt_cm_to_lab) result (p)
    type(phs_forest_t), intent(in) :: forest
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    type(vector4_t), dimension(size (forest%prt_out)) :: p
    p = phs_prt_get_momentum (forest%prt_out)
    if (present (lt_cm_to_lab)) p = p * lt_cm_to_lab
  end function phs_forest_get_momenta_out
  
@ %def phs_forest_get_momenta_out
@
\subsection{Find equivalences among phase-space trees}
Scan phase space for equivalences.  We generate the complete set of
unique permutations for the given list of outgoing particles, and use
this for scanning equivalences within each grove.
@ We scan all pairs of trees, using all permutations.  This implies
that trivial equivalences are included, and equivalences between
different trees are recorded twice.  This is intentional.
<<PHS forests: procedures>>=
  subroutine phs_grove_set_equivalences (grove, perm_array)
    type(phs_grove_t), intent(inout) :: grove
    type(permutation_t), dimension(:), intent(in) :: perm_array
    type(equivalence_t), pointer :: eq
    integer :: t1, t2, i
    do t1 = 1, size (grove%tree)
       do t2 = 1, size (grove%tree)
          SCAN_PERM: do i = 1, size (perm_array)
             if (phs_tree_equivalent &
                  (grove%tree(t1), grove%tree(t2), perm_array(i))) then
                call equivalence_list_add &
                     (grove%equivalence_list, t1, t2, perm_array(i))
                eq => grove%equivalence_list%last
                call phs_tree_find_msq_permutation &
                     (grove%tree(t1), grove%tree(t2), eq%perm, &
                      eq%msq_perm)
                call phs_tree_find_angle_permutation &
                     (grove%tree(t1), grove%tree(t2), eq%perm, &
                      eq%angle_perm, eq%angle_sig)
	     end if
          end do SCAN_PERM
       end do
    end do
  end subroutine phs_grove_set_equivalences

@ %def phs_grove_set_equivalences
<<PHS forests: public>>=
  public :: phs_forest_set_equivalences
<<PHS forests: procedures>>=
  subroutine phs_forest_set_equivalences (forest)
    type(phs_forest_t), intent(inout) :: forest
    type(permutation_t), dimension(:), allocatable :: perm_array
    integer :: i
    call permutation_array_make &
         (perm_array, flavor_get_pdg (forest%flv(forest%n_in+1:)))
    do i = 1, size (forest%grove)
       call phs_grove_set_equivalences (forest%grove(i), perm_array)
    end do
    forest%n_equivalences = sum (forest%grove%equivalence_list%length)
  end subroutine phs_forest_set_equivalences

@ %def phs_forest_set_equivalences
@ 
\subsection{Interface for channel equivalences}
Here, we store the equivalence list in the appropriate containers that
the [[phs_base]] module provides.  There is one separate list for each
channel.
<<PHS forests: public>>=
  public :: phs_forest_get_equivalences 
<<PHS forests: procedures>>=
  subroutine phs_forest_get_equivalences (forest, channel, azimuthal_dependence)
    type(phs_forest_t), intent(in) :: forest
    type(phs_channel_t), dimension(:), intent(out) :: channel
    logical, intent(in) :: azimuthal_dependence
    integer :: n_masses, n_angles
    integer :: mode_azimuthal_angle
    integer, dimension(:), allocatable :: n_eq
    type(equivalence_t), pointer :: eq
    integer, dimension(:), allocatable :: perm, mode
    integer :: g, c, j, left, right
    n_masses = forest%n_masses
    n_angles = forest%n_angles
    allocate (n_eq (forest%n_trees), source = 0)
    allocate (perm (forest%n_dimensions))
    allocate (mode (forest%n_dimensions), source = EQ_IDENTITY)
    do g = 1, size (forest%grove)
       eq => forest%grove(g)%equivalence_list%first
       do while (associated (eq))
          left = eq%left + forest%grove(g)%tree_count_offset
          n_eq(left) = n_eq(left) + 1
          eq => eq%next
       end do
    end do
    do c = 1, size (channel)
       allocate (channel(c)%eq (n_eq(c)))
       do j = 1, n_eq(c)
          call channel(c)%eq(j)%init (forest%n_dimensions)
       end do
    end do
    n_eq = 0
    if (azimuthal_dependence) then
       mode_azimuthal_angle = EQ_IDENTITY
    else
       mode_azimuthal_angle = EQ_INVARIANT
    end if
    do g = 1, size (forest%grove)
       eq => forest%grove(g)%equivalence_list%first
       do while (associated (eq))
          left = eq%left + forest%grove(g)%tree_count_offset
          right = eq%right + forest%grove(g)%tree_count_offset
          do j = 1, n_masses
             perm(j) = permute (j, eq%msq_perm)
             mode(j) = EQ_IDENTITY
          end do
          do j = 1, n_angles
             perm(n_masses+j) = n_masses + permute (j, eq%angle_perm)
             if (j == 1) then
                mode(n_masses+j) = mode_azimuthal_angle   ! first az. angle
             else if (mod(j,2) == 1) then
                mode(n_masses+j) = EQ_SYMMETRIC          ! other az. angles
             else if (eq%angle_sig(j)) then
                mode(n_masses+j) = EQ_IDENTITY           ! polar angle +
             else
                mode(n_masses+j) = EQ_INVERT             ! polar angle -
             end if
          end do
          n_eq(left) = n_eq(left) + 1
          associate (eq_cur => channel(left)%eq(n_eq(left)))
            eq_cur%c = right
            eq_cur%perm = perm
            eq_cur%mode = mode
          end associate
          eq => eq%next
       end do
    end do
  end subroutine phs_forest_get_equivalences

@ %def phs_forest_get_equivalences
@
\subsection{Phase-space evaluation}
Given one row of the [[x]] parameter array and the corresponding
channel index, compute first all relevant momenta and then recover the
remainder of the [[x]] array, the Jacobians [[phs_factor]], and the
phase-space [[volume]].

The output argument [[ok]] indicates whether this was successful.
<<PHS forests: public>>=
  public :: phs_forest_evaluate_selected_channel
<<PHS forests: procedures>>=
  subroutine phs_forest_evaluate_selected_channel &
       (forest, channel, active, sqrts, x, phs_factor, volume, ok)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    logical, dimension(:), intent(in) :: active
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(out) :: phs_factor
    real(default), intent(out) :: volume
    logical, intent(out) :: ok
    integer :: g, t
    integer(TC) :: k, k_root, k_in

    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset
    call phs_prt_set_undefined (forest%prt)
    call phs_prt_set_undefined (forest%prt_out)
    k_in = forest%n_tot
    
    do k = 1,forest%n_in
       forest%prt(ibset(0,k_in-k)) = forest%prt_in(k)
    end do

    do k = 1, forest%n_out
       call phs_prt_set_msq (forest%prt(ibset(0,k-1)), &
            flavor_get_mass (forest%flv(forest%n_in+k)) ** 2)
    end do


    k_root = 2**forest%n_out - 1
    select case (forest%n_in)
    case (1)
       forest%prt(k_root) = forest%prt_in(1)
    case (2)
       call phs_prt_combine &
            (forest%prt(k_root), forest%prt_in(1), forest%prt_in(2))
    end select
    call phs_tree_compute_momenta_from_x (forest%grove(g)%tree(t), &
         forest%prt, phs_factor(channel), volume, sqrts, x(:,channel), ok)
    if (ok) then
       do k = 1, forest%n_out
          forest%prt_out(k) = forest%prt(ibset(0,k-1))
       end do
    end if
  end subroutine phs_forest_evaluate_selected_channel

@ %def phs_forest_evaluate_selected_channel
@ The remainder: recover $x$ values for all channels except for the current 
channel.

NOTE: OpenMP not used for the first loop.  [[combine_particles]] is not a
channel-local operation.
<<PHS forests: public>>=
  public :: phs_forest_evaluate_other_channels
<<PHS forests: procedures>>=
  subroutine phs_forest_evaluate_other_channels &
       (forest, channel, active, sqrts, x, phs_factor, combine)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    logical, dimension(:), intent(in) :: active
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(inout) :: phs_factor
    logical, intent(in) :: combine
    integer :: g, t, ch, n_channel

    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset

    n_channel = forest%n_trees
    if (combine) then
       do ch = 1, n_channel
          if (ch == channel)  cycle
          if (active(ch)) then
             g = forest%grove_lookup(ch)
             t = ch - forest%grove(g)%tree_count_offset
             call phs_tree_combine_particles &
                  (forest%grove(g)%tree(t), forest%prt)
          end if
       end do
    end if

    !OMP PARALLEL PRIVATE (g,t,ch) SHARED(active,forest,sqrts,x,channel)
    !OMP DO SCHEDULE(STATIC)
    do ch = 1, n_channel
       if (ch == channel)  cycle
       if (active(ch)) then
          g = forest%grove_lookup(ch)
          t = ch - forest%grove(g)%tree_count_offset
          call phs_tree_compute_x_from_momenta &
               (forest%grove(g)%tree(t), &
               forest%prt, phs_factor(ch), sqrts, x(:,ch))
       end if
    end do
    !OMP END DO
    !OMP END PARALLEL

  end subroutine phs_forest_evaluate_other_channels

@ %def phs_forest_evaluate_other_channels
@ The complement: recover one row of the [[x]] array and the
associated Jacobian entry, corresponding to
[[channel]], from incoming and outgoing momenta.  Also compute the
phase-space volume.
<<PHS forests: public>>=
  public :: phs_forest_recover_channel
<<PHS forests: procedures>>=
  subroutine phs_forest_recover_channel &
       (forest, channel, sqrts, x, phs_factor, volume)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(inout) :: phs_factor
    real(default), intent(out) :: volume
    integer :: g, t
    integer(TC) :: k, k_in
    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset
    call phs_prt_set_undefined (forest%prt)
    k_in = forest%n_tot
    forall (k = 1:forest%n_in)
       forest%prt(ibset(0,k_in-k)) = forest%prt_in(k)
    end forall
    forall (k = 1:forest%n_out)
       forest%prt(ibset(0,k-1)) = forest%prt_out(k)
    end forall
    call phs_forest_combine_particles (forest)
    call phs_tree_compute_volume &
         (forest%grove(g)%tree(t), sqrts, volume)
    call phs_tree_compute_x_from_momenta &
         (forest%grove(g)%tree(t), &
         forest%prt, phs_factor(channel), sqrts, x(:,channel))
  end subroutine phs_forest_recover_channel

@ %def phs_forest_recover_channel
@ 
\subsection{Unit tests}
Write a possible phase-space file for a $2\to 3$ process and make the
corresponding forest, print the forest. Choose some in-particle
momenta and a random-number array and evaluate out-particles and
phase-space factors. 
<<PHS forests: public>>=
  public :: phs_forest_test
<<PHS forests: procedures>>=
  subroutine phs_forest_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS forests: execute tests>>  
  end subroutine phs_forest_test
  
@  %def phs_forest_test
<<PHS forests: execute tests>>=
  call test (phs_forest_1, "phs_forest_1", &
       "check phs forest setup", &
       u, results)
<<PHS forests: tests>>= 
  subroutine phs_forest_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(phs_forest_t) :: forest
    type(phs_channel_t), dimension(:), allocatable :: channel
    type(model_data_t), target :: model
    type(string_t) :: process_id
    type(flavor_t), dimension(5) :: flv
    type(string_t) :: filename
    type(interaction_t) :: int
    integer, parameter :: unit_fix = 20
    type(mapping_defaults_t) :: mapping_defaults
    logical :: found_process, ok
    integer :: n_channel, ch, i
    logical, dimension(4) :: active = .true.
    real(default) :: sqrts = 1000
    real(default), dimension(5,4) :: x
    real(default), dimension(4) :: factor
    real(default) :: volume

    write (u, "(A)")  "* Test output: PHS forest"
    write (u, "(A)")  "*   Purpose: test PHS forest routines"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    
    call model%init_sm_test ()

    write (u, "(A)")
    write (u, "(A)")  "* Create phase-space file 'phs_forest_test.phs'"
    write (u, "(A)")
    
    call flavor_init (flv, [11, -11, 11, -11, 22], model)
    open (file="phs_forest_test.phs", unit=unit_fix, action="write")
    write (unit_fix, *) "process foo"
    write (unit_fix, *) 'md5sum_process    = "6ABA33BC2927925D0F073B1C1170780A"'
    write (unit_fix, *) 'md5sum_model_par  = "1A0B151EE6E2DEB92D880320355A3EAB"'
    write (unit_fix, *) 'md5sum_phs_config = "B6A8877058809A8BDD54753CDAB83ACE"'
    write (unit_fix, *) "sqrts         =    100.00000000000000"     
    write (unit_fix, *) "m_threshold_s =    50.000000000000000"     
    write (unit_fix, *) "m_threshold_t =    100.00000000000000"     
    write (unit_fix, *) "off_shell =            2"
    write (unit_fix, *) "t_channel =            6"
    write (unit_fix, *) "keep_nonresonant =  F"
    write (unit_fix, *) ""
    write (unit_fix, *) "  grove"
    write (unit_fix, *) "    tree 3 7"
    write (unit_fix, *) "      map 3 s_channel 23"
    write (unit_fix, *) "    tree 5 7"
    write (unit_fix, *) "    tree 6 7"
    write (unit_fix, *) "  grove"
    write (unit_fix, *) "    tree 9 11"
    write (unit_fix, *) "      map 9 t_channel 22"
    close (unit_fix)

    write (u, "(A)")
    write (u, "(A)")  "* Read phase-space file 'phs_forest_test.phs'"

    call syntax_phs_forest_init ()
    process_id = "foo"
    filename = "phs_forest_test.phs"
    call phs_forest_read &
         (forest, filename, process_id, 2, 3, model, found_process)

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters, flavors, equiv, momenta"
    write (u, "(A)") 
    
    call phs_forest_set_flavors (forest, flv)
    call phs_forest_set_parameters (forest, mapping_defaults, .false.)
    call phs_forest_setup_prt_combinations (forest)
    call phs_forest_set_equivalences (forest)
    call interaction_init (int, 2, 0, 3)
    call interaction_set_momentum (int, &
         vector4_moving (500._default, 500._default, 3), 1)
    call interaction_set_momentum (int, &
         vector4_moving (500._default,-500._default, 3), 2)
    call phs_forest_set_prt_in (forest, int)
    n_channel = 2
    x = 0
    x(:,n_channel) = [0.3, 0.4, 0.1, 0.9, 0.6]
    write (u, "(A)")  "   Input values:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  x(:,n_channel)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluating phase space"

    call phs_forest_evaluate_selected_channel (forest, &
         n_channel, active, sqrts, x, factor, volume, ok)
    call phs_forest_evaluate_other_channels (forest, &
         n_channel, active, sqrts, x, factor, combine=.true.)
    call phs_forest_get_prt_out (forest, int)
    write (u, "(A)")  "   Output values:"
    do ch = 1, 4
       write (u, "(3x,5(1x," // FMT_12 // "))")  x(:,ch)
    end do
    call interaction_write (int, u)
    write (u, "(A)")  "   Factors:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  factor
    write (u, "(A)")  "   Volume:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  volume
    call phs_forest_write (forest, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compute equivalences"

    n_channel = 4
    allocate (channel (n_channel))
    call phs_forest_get_equivalences (forest, &
         channel, .true.)
    do i = 1, n_channel
       write (u, "(1x,I0,':')", advance = "no")  ch       
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    call phs_forest_final (forest)
    call syntax_phs_forest_final ()
        
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_forest_1"    

  end subroutine phs_forest_1

@ %def phs_forest_1
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding phase space parameterizations}
If the phase space configuration is not found in the appropriate file,
we should generate one.

The idea is to construct all Feynman diagrams subject to certain
constraints which eliminate everything that is probably irrelevant for
the integration.  These Feynman diagrams (cascades) are grouped in
groves by finding equivalence classes related by symmetry and ordered
with respect to their importance (resonances).  Finally, the result
(or part of it) is written to file and used for the integration.

This module may eventually disappear and be replaced by CAML code.
In particular, we need here a set of Feynman rules (vertices with
particle codes, but not the factors).  Thus, the module works for the
Standard Model only.

Note that this module is stand-alone, it communicates to the main
program only via the generated ASCII phase-space configuration file.
<<[[cascades.f90]]>>=
<<File header>>

module cascades

<<Use kinds>>
  use kinds, only: TC, i8, i32
<<Use strings>>
  use io_units
  use format_defs, only: FMT_12, FMT_19
  use unit_tests
  use diagnostics
  use hashes
  use sorting
  use physics_defs, only: SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use physics_defs, only: UNDEFINED
  use model_data
  use flavors
  use phs_forests

<<Standard module head>>

<<Cascades: public>>

<<Cascades: parameters>>

<<Cascades: types>>

<<Cascades: interfaces>>

contains

<<Cascades: procedures>>

<<Cascades: tests>>

end module cascades
@ %def cascades
@ 
\subsection{The mapping modes}
The valid mapping modes, to be used below.  We will make use of the convention
that mappings of internal particles have a positive value.  Only for positive
values, the flavor code is propagated when combining cascades.
<<Mapping modes>>=
  integer, parameter :: &
       & EXTERNAL_PRT = -1, &
       & NO_MAPPING = 0, S_CHANNEL = 1, T_CHANNEL =  2, U_CHANNEL = 3, &
       & RADIATION = 4, COLLINEAR = 5, INFRARED = 6, &
       & STEP_MAPPING_E = 11, STEP_MAPPING_H = 12, &
       & ON_SHELL = 99
@ %def EXTERNAL_PRT
@ %def NO_MAPPING S_CHANNEL T_CHANNEL U_CHANNEL
@ %def RADIATION COLLINEAR INFRARED
@ %def STEP_MAPPING_E STEP_MAPPING_H
@ %def ON_SHELL
<<Cascades: parameters>>=
<<Mapping modes>>
@
\subsection{The cascade type}
A cascade is essentially the same as a decay tree (both definitions
may be merged in a later version).  It contains a linked tree of
nodes, each of which representing an internal particle.  In contrast
to decay trees, each node has a definite particle code.  These nodes
need not be modified, therefore we can use pointers and do not have to
copy them.  Thus, physically each cascades has only a single node, the
mother particle.  However, to be able to compare trees quickly, we
store in addition an array of binary codes which is always sorted in
ascending order.  This is accompanied by a corresponding list of
particle codes.  The index is the location of the corresponding
cascade in the cascade set, this may be used to access the daughters
directly.

The real mass is the particle mass belonging to the particle code.
The minimal mass is the sum of the real masses of all its daughters;
this is the kinematical cutoff.  The effective mass may be zero if the
particle mass is below a certain threshold; it may be the real mass if
the particle is resonant; or it may be some other value.

The logical [[t_channel]] is set if this a $t$-channel line, while
[[initial]] is true only for an initial particle.  Note that both
initial particles are also [[t_channel]] by definition, and that they
are distinguished by the direction of the tree:  One of them decays
and is the root of the tree, while the other one is one of the leaves.

The cascade is a list of nodes (particles) which are linked via the
[[daughter]] entries.  The node is the mother particle of
the decay cascade.  Much of the information in the nodes is repeated
in arrays, to be accessible more easily.  The arrays will be kept
sorted by binary codes.

The counter [[n_off_shell]] is increased for each internal line that
is neither resonant nor log-enhanced.  It is set to zero if the
current line is resonant, since this implies on-shell particle production
and subsequent decay.

The counter [[n_t_channel]] is non-negative once an initial particle
is included in the tree: then, it counts the number of $t$-channel lines.

The [[multiplicity]] is the number of branchings to follow until all
daughters are on-shell.  A resonant or non-decaying particle has
multiplicity one.  Merging nodes, the multiplicities add unless the
mother is a resonance.  An initial or final node has multiplicity
zero.

The arrays correspond to the subnode tree [[tree]] of the current
cascade.  PDG codes are stored only for those positions which are
resonant, with the exception of the last entry, i.e., the current node.
Other positions, in particular external legs, are assigned undefined
PDG code.

A cascade is uniquely identified by its tree, the tree of PDG codes,
and the tree of mappings.  The tree of resonances is kept only to mask
the PDG tree as described above.
<<Cascades: types>>=
  type :: cascade_t
     private
     ! counters
     integer :: index = 0
     integer :: grove = 0
     ! status
     logical :: active = .false.
     logical :: complete = .false.
     logical :: incoming = .false.
     ! this node
     integer(TC) :: bincode = 0
     type(flavor_t) :: flv
     integer :: pdg = UNDEFINED
     logical :: is_vector = .false.
     real(default) :: m_min = 0
     real(default) :: m_rea = 0
     real(default) :: m_eff = 0
     integer :: mapping = NO_MAPPING
     logical :: on_shell = .false.
     logical :: resonant = .false.
     logical :: log_enhanced = .false.
     logical :: t_channel = .false.
     ! global tree properties
     integer :: multiplicity = 0
     integer :: internal = 0
     integer :: n_off_shell = 0
     integer :: n_resonances = 0
     integer :: n_log_enhanced = 0
     integer :: n_t_channel = 0
     integer :: res_hash = 0
     ! the sub-node tree
     integer :: depth = 0
     integer(TC), dimension(:), allocatable :: tree
     integer, dimension(:), allocatable :: tree_pdg
     integer, dimension(:), allocatable :: tree_mapping
     logical, dimension(:), allocatable :: tree_resonant
     ! branch connections
     logical :: has_children = .false.
     type(cascade_t), pointer :: daughter1 => null ()
     type(cascade_t), pointer :: daughter2 => null ()
     type(cascade_t), pointer :: mother => null ()
     ! next in list
     type(cascade_t), pointer :: next => null ()
  end type cascade_t

@ %def cascade_t
<<Cascades: procedures>>=
  subroutine cascade_init (cascade, depth)
    type(cascade_t), intent(out) :: cascade
    integer, intent(in) :: depth
    integer, save :: index = 0
    index = cascade_index ()
    cascade%index = index
    cascade%depth = depth
    cascade%active = .true.
    allocate (cascade%tree (depth))
    allocate (cascade%tree_pdg (depth))
    allocate (cascade%tree_mapping (depth))
    allocate (cascade%tree_resonant (depth))
  end subroutine cascade_init
@ %def cascade_init
@ Keep and increment a global index
<<Cascades: procedures>>=
  function cascade_index (seed) result (index)
    integer :: index
    integer, intent(in), optional :: seed
    integer, save :: i = 0
    if (present (seed))  i = seed
    i = i + 1
    index = i
  end function cascade_index

@ %def cascade_index
@ We need three versions of writing cascades.  This goes to the
phase-space file:
<<Cascades: procedures>>=
  subroutine cascade_write_file_format (cascade, model, unit)
    type(cascade_t), intent(in) :: cascade
    class(model_data_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(flavor_t) :: flv
    integer :: u, i
1   format(3x,A,1x,40(1x,I4))
2   format(3x,A,1x,I3,1x,A,1x,I7,1x,'!',1x,A)
    u = given_output_unit (unit);  if (u < 0)  return
    call write_reduced (cascade%tree, u)
    write (u, "(A)")
    do i = 1, cascade%depth
       call flavor_init (flv, cascade%tree_pdg(i), model)
       select case (cascade%tree_mapping(i))
       case (NO_MAPPING, EXTERNAL_PRT)
       case (S_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 's_channel', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (T_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 't_channel', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (U_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 'u_channel', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (RADIATION)
          write(u,2) 'map', &
               cascade%tree(i), 'radiation', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (COLLINEAR)
          write(u,2) 'map', &
               cascade%tree(i), 'collinear', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (INFRARED)
          write(u,2) 'map', &
               cascade%tree(i), 'infrared ',  abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case (ON_SHELL)
          write(u,2) 'map', &
               cascade%tree(i), 'on_shell ', abs (cascade%tree_pdg(i)), &
               char (flavor_get_name (flv))
       case default
          call msg_bug (" Impossible mapping mode encountered")
       end select
    end do
  contains
    subroutine write_reduced (array, unit)
      integer(TC), dimension(:), intent(in) :: array
      integer, intent(in) :: unit
      integer :: i
      write (u, "(3x,A,1x)", advance="no")  "tree"
      do i = 1, size (array)
         if (decay_level (array(i)) > 1) then
            write (u, "(1x,I0)", advance="no")  array(i)
         end if
      end do
    end subroutine write_reduced

    elemental function decay_level (k) result (l)
      integer(TC), intent(in) :: k
      integer :: l
      integer :: i
      l = 0
      do i = 0, bit_size(k) - 1
         if (btest(k,i)) l = l + 1
      end do
    end function decay_level
    subroutine start_comment (u)
      integer, intent(in) :: u
      write(u, '(1x,A)', advance='no') '!'
    end subroutine start_comment
  end subroutine cascade_write_file_format

@ %def cascade_write_file_format
@ This creates metapost source for graphical display:
<<Cascades: procedures>>=
  subroutine cascade_write_graph_format (cascade, count, unit)
    type(cascade_t), intent(in) :: cascade
    integer, intent(in) :: count
    integer, intent(in), optional :: unit
    integer :: u
    integer(TC) :: mask
    type(string_t) :: left_str, right_str
    u = given_output_unit (unit);  if (u < 0)  return
    mask = 2**((cascade%depth+3)/2) - 1
    left_str = ""
    right_str = ""
    write (u, '(A)') "\begin{minipage}{105pt}"
    write (u, '(A)') "\vspace{30pt}"
    write (u, '(A)') "\begin{center}"
    write (u, '(A)') "\begin{fmfgraph*}(55,55)"
    call graph_write (cascade, mask)
    write (u, '(A)') "\fmfleft{" // char (extract (left_str, 2)) // "}"
    write (u, '(A)') "\fmfright{" // char (extract (right_str, 2)) // "}"
    write (u, '(A)') "\end{fmfgraph*}\\"
    write (u, '(A,I5,A)') "\fbox{$", count, "$}"
    write (u, '(A)') "\end{center}"
    write (u, '(A)') "\end{minipage}"
    write (u, '(A)') "%"
  contains
    recursive subroutine graph_write (cascade, mask, reverse)
      type(cascade_t), intent(in) :: cascade
      integer(TC), intent(in) :: mask
      logical, intent(in), optional :: reverse
      logical :: rev
      rev = .false.;  if (present(reverse))  rev = reverse
      if (cascade%has_children) then
         if (.not.rev) then
            call vertex_write (cascade, cascade%daughter1, mask)
            call vertex_write (cascade, cascade%daughter2, mask)
         else
            call vertex_write (cascade, cascade%daughter2, mask, .true.)
            call vertex_write (cascade, cascade%daughter1, mask, .true.)
         end if
         if (cascade%complete) then
            call vertex_write (cascade, cascade%mother, mask, .true.)
            write (u, '(A,I0,A)') "\fmfv{d.shape=square}{v0}"
         end if
      else
         if (cascade%incoming) then
            call external_write (cascade%bincode, &
                 flavor_get_tex_name (flavor_anti (cascade%flv)), left_str)
         else
            call external_write (cascade%bincode, &
                 flavor_get_tex_name (cascade%flv), right_str)
         end if
      end if
    end subroutine graph_write
    recursive subroutine vertex_write (cascade, daughter, mask, reverse)
      type(cascade_t), intent(in) :: cascade, daughter
      integer(TC), intent(in) :: mask
      logical, intent(in), optional :: reverse
      integer :: bincode
      if (cascade%complete) then
         bincode = 0
      else
         bincode = cascade%bincode
      end if
      call graph_write (daughter, mask, reverse)
      if (daughter%has_children) then
         call line_write (bincode, daughter%bincode, daughter%flv, &
              mapping=daughter%mapping)
      else
         call line_write (bincode, daughter%bincode, daughter%flv)
      end if
    end subroutine vertex_write
    subroutine line_write (i1, i2, flv, mapping)
      integer(TC), intent(in) :: i1, i2
      type(flavor_t), intent(in) :: flv
      integer, intent(in), optional :: mapping
      integer :: k1, k2
      type(string_t) :: prt_type
      select case (flavor_get_spin_type (flv))
      case (SCALAR);       prt_type = "plain"
      case (SPINOR);       prt_type = "fermion"
      case (VECTOR);       prt_type = "boson"
      case (VECTORSPINOR); prt_type = "fermion"
      case (TENSOR);       prt_type = "dbl_wiggly"
      case default;        prt_type = "dashes"
      end select
      if (flavor_is_antiparticle (flv)) then
         k1 = i2;  k2 = i1
      else
         k1 = i1;  k2 = i2
      end if
      if (present (mapping)) then
         select case (mapping)
         case (S_CHANNEL)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=blue,lab=\sm\blue$" // &
                 & char (flavor_get_tex_name (flv)) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (T_CHANNEL, U_CHANNEL)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=cyan,lab=\sm\cyan$" // &
                 & char (flavor_get_tex_name (flv)) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (RADIATION)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=green,lab=\sm\green$" // &
                 & char (flavor_get_tex_name (flv)) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (COLLINEAR)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=magenta,lab=\sm\magenta$" // &
                 & char (flavor_get_tex_name (flv)) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (INFRARED)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=red,lab=\sm\red$" // &
                 & char (flavor_get_tex_name (flv)) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case default
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=black}" // &
                 & "{v", k1, ",v", k2, "}"
         end select
      else
         write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & "}" // &
                 & "{v", k1, ",v", k2, "}"
      end if
    end subroutine line_write
    subroutine external_write (bincode, name, ext_str)
      integer(TC), intent(in) :: bincode
      type(string_t), intent(in) :: name
      type(string_t), intent(inout) :: ext_str
      character(len=20) :: str
      write (str, '(A2,I0)') ",v", bincode
      ext_str = ext_str // trim (str)
      write (u, '(A,I0,A,I0,A)') "\fmflabel{\sm$" &
        // char (name) &
        // "\,(", bincode, ")" &
        // "$}{v", bincode, "}"
    end subroutine external_write
  end subroutine cascade_write_graph_format

@ %def cascade_write_graph_format
@ This is for screen/debugging output:
<<Cascades: procedures>>=
  subroutine cascade_write (cascade, unit)
    type(cascade_t), intent(in) :: cascade
    integer, intent(in), optional :: unit
    integer :: u
    character(9) :: depth
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A,(1x,I7))") 'Cascade #', cascade%index
    write (u, "(A,(1x,I7))") '  Grove:       #', cascade%grove
    write (u, "(A,3(1x,L1))") '  act/cmp/inc:  ', &
         cascade%active, cascade%complete, cascade%incoming
    write (u, "(A,I0)") '  Bincode:      ', cascade%bincode
    write (u, "(A)", advance="no") '  Flavor:       '
    call flavor_write (cascade%flv, unit)
    write (u, "(A,I9)") '  Active flavor:', cascade%pdg
    write (u, "(A,L1)") '  Is vector:    ', cascade%is_vector
    write (u, "(A,3(1x," // FMT_19 // "))") '  Mass (m/r/e): ', &
         cascade%m_min, cascade%m_rea, cascade%m_eff
    write (u, "(A,I1)") '  Mapping:      ', cascade%mapping
    write (u, "(A,3(1x,L1))") '  res/log/tch:  ', &
         cascade%resonant, cascade%log_enhanced, cascade%t_channel
    write (u, "(A,(1x,I7))") '  Multiplicity: ', cascade%multiplicity
    write (u, "(A,2(1x,I7))") '  n intern/off: ', &
         cascade%internal, cascade%n_off_shell
    write (u, "(A,3(1x,I7))") '  n res/log/tch:', &
         cascade%n_resonances, cascade%n_log_enhanced, cascade%n_t_channel
    write (u, "(A,I7)") '  Depth:        ', cascade%depth
    write (depth, "(I7)") cascade%depth
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree:         ', cascade%tree
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree(PDG):    ', cascade%tree_pdg
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree(mapping):', cascade%tree_mapping
    write (u, "(A," // depth // "(1x,L1))") &
       '  Tree(res):    ', cascade%tree_resonant
    if (cascade%has_children) then
       write (u, "(A,I7,1x,I7)") '  Daughter1/2:  ', &
            cascade%daughter1%index, cascade%daughter2%index
    end if
    if (associated (cascade%mother)) then
       write (u, "(A,I7)") '  Mother:       ', cascade%mother%index
    end if
  end subroutine cascade_write

@ %def cascade_write
@ 
\subsection{Creating new cascades}
This initializes a single-particle cascade (external, final state).
The PDG entry in the tree is set undefined because the cascade is not
resonant.  However, the flavor entry is set, so the cascade flavor
is identified nevertheless.
<<Cascades: procedures>>=
  subroutine cascade_init_outgoing (cascade, flv, pos, m_thr)
    type(cascade_t), intent(out) :: cascade
    type(flavor_t), intent(in) :: flv
    integer, intent(in) :: pos
    real(default), intent(in) :: m_thr
    call cascade_init (cascade, 1)
    cascade%bincode = ibset (0_TC, pos-1)
    cascade%flv = flv
    cascade%pdg = abs (flavor_get_pdg (cascade%flv))
    cascade%is_vector = flavor_get_spin_type (flv) == VECTOR
    cascade%m_min = flavor_get_mass (flv)
    cascade%m_rea = cascade%m_min
    if (cascade%m_rea >= m_thr) then
       cascade%m_eff = cascade%m_rea
    end if
    cascade%on_shell = .true.
    cascade%multiplicity = 1
    cascade%tree(1) = cascade%bincode
    cascade%tree_pdg(1) = cascade%pdg
    cascade%tree_mapping(1) = EXTERNAL_PRT
    cascade%tree_resonant(1) = .false.
  end subroutine cascade_init_outgoing

@ %def cascade_init_outgoing
@ The same for an incoming line:
<<Cascades: procedures>>=
  subroutine cascade_init_incoming (cascade, flv, pos, m_thr)
    type(cascade_t), intent(out) :: cascade
    type(flavor_t), intent(in) :: flv
    integer, intent(in) :: pos
    real(default), intent(in) :: m_thr
    call cascade_init (cascade, 1)
    cascade%incoming = .true.
    cascade%bincode = ibset (0_TC, pos-1)
    cascade%flv = flavor_anti (flv)
    cascade%pdg = abs (flavor_get_pdg (flv))
    cascade%is_vector = flavor_get_spin_type (flv) == VECTOR
    cascade%m_min = flavor_get_mass (flv)
    cascade%m_rea = cascade%m_min
    if (cascade%m_rea >= m_thr) then
       cascade%m_eff = cascade%m_rea
    end if
    cascade%on_shell = .true.
    cascade%n_t_channel = 0
    cascade%n_off_shell = 0
    cascade%tree(1) = cascade%bincode
    cascade%tree_pdg(1) = cascade%pdg
    cascade%tree_mapping(1) = EXTERNAL_PRT
    cascade%tree_resonant(1) = .false.
  end subroutine cascade_init_incoming

@ %def cascade_init_outgoing
@
\subsection{Tools}
This function returns true if the two cascades share no common
external particle.  This is a requirement for joining them.
<<Cascades: interfaces>>=
  interface operator(.disjunct.)
     module procedure cascade_disjunct
  end interface

<<Cascades: procedures>>=
  function cascade_disjunct (cascade1, cascade2) result (flag)
    logical :: flag
    type(cascade_t), intent(in) :: cascade1, cascade2
    flag = iand (cascade1%bincode, cascade2%bincode) == 0
  end function cascade_disjunct

@ %def cascade_disjunct
@ %def .disjunct.
@ Compute a hash code for the resonance pattern of a cascade.  We count the
number of times each particle appears as a resonance.

We pack the PDG codes of the resonances in two arrays (s-channel and 
t-channel), sort them both, concatenate the results, transfer to
[[i8]] integers, and compute the hash code from this byte stream.
<<Cascades: procedures>>=
  subroutine cascade_assign_resonance_hash (cascade)
    type(cascade_t), intent(inout) :: cascade
    integer(i8), dimension(1) :: mold
    cascade%res_hash = hash (transfer &
         (concat (sort (pack (cascade%tree_pdg, &
                              cascade%tree_resonant)), &
                  sort (pack (cascade%tree_pdg, &
                              cascade%tree_mapping == T_CHANNEL .or. &
                              cascade%tree_mapping == U_CHANNEL))), &
          mold))
  end subroutine cascade_assign_resonance_hash

@ %def cascade_assign_resonance_hash
@ 
\subsection{Hash entries for cascades}
We will set up a hash array which contains keys of and pointers to
cascades.  We hold a list of cascade (pointers) within each bucket.
This is not for collision resolution, but for keeping similar, but
unequal cascades together.
<<Cascades: types>>=
  type :: cascade_p
     type(cascade_t), pointer :: cascade => null ()
     type(cascade_p), pointer :: next => null ()
  end type cascade_p

@ %def cascade_p
@ Here is the bucket or hash entry type:
<<Cascades: types>>=
  type :: hash_entry_t
     integer(i32) :: hashval = 0
     integer(i8), dimension(:), allocatable :: key
     type(cascade_p), pointer :: first => null ()
     type(cascade_p), pointer :: last => null ()
  end type hash_entry_t

@ %def hash_entry_t
@ Finalize: just deallocate the list; the contents are just pointers.
<<Cascades: procedures>>=
  subroutine hash_entry_final (hash_entry)
    type(hash_entry_t), intent(inout) :: hash_entry
    type(cascade_p), pointer :: current
    do while (associated (hash_entry%first))
       current => hash_entry%first
       hash_entry%first => current%next
       deallocate (current)
    end do
  end subroutine hash_entry_final

@ %def hash_entry_final
@ Output: concise format for debugging, just list cascade indices.
<<Cascades: procedures>>=
  subroutine hash_entry_write (hash_entry, unit)
    type(hash_entry_t), intent(in) :: hash_entry
    integer, intent(in), optional :: unit
    type(cascade_p), pointer :: current
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)", advance="no")  "Entry:"
    do i = 1, size (hash_entry%key)
       write (u, "(1x,I0)", advance="no")  hash_entry%key(i)
    end do
    write (u, "(1x,A)", advance="no")  "->"
    current => hash_entry%first
    do while (associated (current))
       write (u, "(1x,I7)", advance="no") current%cascade%index
       current => current%next
    end do
    write (u, *)
  end subroutine hash_entry_write

@ %def hash_entry_write
@ This function adds a cascade pointer to the bucket.  If [[ok]] is
present, check first if it is already there and return failure if yes.
If [[cascade_ptr]] is also present, set it to the current cascade if
successful.  If not, set it to the cascade that is already there.
<<Cascades: procedures>>=
  subroutine hash_entry_add_cascade_ptr (hash_entry, cascade, ok, cascade_ptr)
    type(hash_entry_t), intent(inout) :: hash_entry
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out), optional :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_p), pointer :: current
    if (present (ok)) then
       call hash_entry_check_cascade (hash_entry, cascade, ok, cascade_ptr)
       if (.not. ok)  return
    end if
    allocate (current)
    current%cascade => cascade
    if (associated (hash_entry%last)) then
       hash_entry%last%next => current
    else 
       hash_entry%first => current
    end if
    hash_entry%last => current
  end subroutine hash_entry_add_cascade_ptr

@ %def hash_entry_add_cascade_ptr
@ This function checks whether a cascade is already in the bucket.
For incomplete cascades, we look for an exact match. It should suffice
to verify the tree, the PDG codes, and the mapping modes.  This is the
information that is written to the phase space file.

For complete cascades, we ignore the PDG code at positions with
mappings infrared, collinear, or t/u-channel.  Thus a cascade which is
distinguished only by PDG code at such places, is flagged existent.
If the convention is followed that light particles come before heavier
ones (in the model definition), this ensures that the lightest
particle is kept in the appropriate place, corresponding to the
strongest peak.

For external cascades (incoming/outgoing) we take the PDG code into
account even though it is zeroed in the PDG-code tree.
<<Cascades: procedures>>=
  subroutine hash_entry_check_cascade (hash_entry, cascade, ok, cascade_ptr)
    type(hash_entry_t), intent(in), target :: hash_entry
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_p), pointer :: current
    integer, dimension(:), allocatable :: tree_pdg
    ok = .true.
    allocate (tree_pdg (size (cascade%tree_pdg)))
    if (cascade%complete) then
       where (cascade%tree_mapping == INFRARED .or. &
            cascade%tree_mapping == COLLINEAR .or. &
            cascade%tree_mapping == T_CHANNEL .or. &
            cascade%tree_mapping == U_CHANNEL)
          tree_pdg = 0
       elsewhere
          tree_pdg = cascade%tree_pdg
       end where
    else
       tree_pdg = cascade%tree_pdg
    end if
    current => hash_entry%first
    do while (associated (current))
       if (current%cascade%depth == cascade%depth) then
          if (all (current%cascade%tree == cascade%tree)) then
             if (all (current%cascade%tree_mapping == cascade%tree_mapping)) &
                  then
                if (all (current%cascade%tree_pdg .match. tree_pdg)) then
                   if (present (cascade_ptr))  cascade_ptr => current%cascade
                   ok = .false.;  return
                end if
             end if
          end if
       end if
       current => current%next
    end do
    if (present (cascade_ptr))  cascade_ptr => cascade
  end subroutine hash_entry_check_cascade

@ %def hash_entry_check_cascade
@ For PDG codes, we specify that the undefined code matches any code.
This is already defined for flavor objects, but here we need it for
the codes themselves.
<<Cascades: interfaces>>=
  interface operator(.match.)
     module procedure pdg_match
  end interface
<<Cascades: procedures>>=
  elemental function pdg_match (pdg1, pdg2) result (flag)
    logical :: flag
    integer(TC), intent(in) :: pdg1, pdg2
    select case (pdg1)
    case (0)
       flag = .true.
    case default
       select case (pdg2)
       case (0)
          flag = .true.
       case default
          flag = pdg1 == pdg2
       end select
    end select
  end function pdg_match

@ %def .match.
@ 
\subsection{The cascade set}
The cascade set will later be transformed into the decay forest.  It
is set up as a linked list.  In addition to the usual [[first]] and
[[last]] pointers, there is a [[first_t]] pointer which points to the
first t-channel cascade (after all s-channel cascades), and a
[[first_k]] pointer which points to the first final cascade (with a
keystone).

As an auxiliary device, the object contains a hash array with
associated parameters where an additional pointer is stored for each
cascade.  The keys are made from the relevant cascade data.  This hash
is used for fast detection (and thus avoidance) of double entries in
the cascade list.
<<Cascades: public>>=
  public :: cascade_set_t
<<Cascades: types>>=
  type :: cascade_set_t
     private
     class(model_data_t), pointer :: model
     integer :: n_in, n_out, n_tot
     type(flavor_t), dimension(:,:), allocatable :: flv
     integer :: depth_out, depth_tot
     real(default) :: sqrts = 0
     real(default) :: m_threshold_s = 0
     real(default) :: m_threshold_t = 0
     integer :: off_shell = 0
     integer :: t_channel = 0
     logical :: keep_nonresonant
     integer :: n_groves = 0
     ! The cascade list
     type(cascade_t), pointer :: first => null ()
     type(cascade_t), pointer :: last => null ()
     type(cascade_t), pointer :: first_t => null ()
     type(cascade_t), pointer :: first_k => null ()
     ! The hashtable
     integer :: n_entries = 0
     real :: fill_ratio = 0
     integer :: n_entries_max = 0
     integer(i32) :: mask = 0
     logical :: fatal_beam_decay = .true.
     type(hash_entry_t), dimension(:), allocatable :: entry
  end type cascade_set_t

@ %def cascade_set_t
@ Return true if there are cascades which are active and complete, so
the phase space file would be nonempty.
<<Cascades: public>>=
  public :: cascade_set_is_valid
<<Cascades: procedures>>=
  function cascade_set_is_valid (cascade_set) result (flag)
    logical :: flag
    type(cascade_set_t), intent(in) :: cascade_set
    type(cascade_t), pointer :: cascade
    flag = .false.
    cascade => cascade_set%first_k
    do while (associated (cascade))
       if (cascade%active .and. cascade%complete) then
          flag = .true.
          return
       end if
       cascade => cascade%next
    end do
  end function cascade_set_is_valid

@ %def cascade_set_is_valid
@ The initializer sets up the hash table with some initial size
guessed by looking at the number of external particles.  We choose 256
for 3 external particles and a factor of 4 for each additional
particle, limited at $2^{30}$=1G.
<<Cascades: parameters>>=
  real, parameter, public :: CASCADE_SET_FILL_RATIO = 0.1
<<Cascades: procedures>>=
  subroutine cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
        fatal_beam_decay, flv)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    type(flavor_t), dimension(:,:), intent(in), optional :: flv
    integer :: size_guess
    cascade_set%model => model
    cascade_set%n_in = n_in
    cascade_set%n_out = n_out
    cascade_set%n_tot = n_in + n_out
    if (present (flv)) then
       allocate (cascade_set%flv (size (flv, 1), size (flv, 2)))
       call flavor_init (cascade_set%flv, flavor_get_pdg (flv), model)
    end if
    select case (n_in)
    case (1);  cascade_set%depth_out = 2 * n_out - 3
    case (2);  cascade_set%depth_out = 2 * n_out - 1
    end select
    cascade_set%depth_tot = 2 * cascade_set%n_tot - 3
    cascade_set%sqrts = phs_par%sqrts
    cascade_set%m_threshold_s = phs_par%m_threshold_s
    cascade_set%m_threshold_t = phs_par%m_threshold_t
    cascade_set%off_shell = phs_par%off_shell
    cascade_set%t_channel = phs_par%t_channel
    cascade_set%keep_nonresonant = phs_par%keep_nonresonant
    cascade_set%fill_ratio = CASCADE_SET_FILL_RATIO
    size_guess = ishft (256, min (2 * (cascade_set%n_tot - 3), 22))
    cascade_set%n_entries_max = size_guess * cascade_set%fill_ratio
    cascade_set%mask = size_guess - 1
    allocate (cascade_set%entry (0:cascade_set%mask))
    cascade_set%fatal_beam_decay = fatal_beam_decay
  end subroutine cascade_set_init
    
@ %def cascade_set_init
@ The finalizer has to delete both the hash and the list.
<<Cascades: public>>=
  public :: cascade_set_final
<<Cascades: procedures>>=
  subroutine cascade_set_final (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: current
    integer :: i
    if (allocated (cascade_set%entry)) then
       do i = 0, cascade_set%mask
          call hash_entry_final (cascade_set%entry(i))
       end do
       deallocate (cascade_set%entry)
    end if
    do while (associated (cascade_set%first))
       current => cascade_set%first
       cascade_set%first => cascade_set%first%next
       deallocate (current)
    end do
  end subroutine cascade_set_final

@ %def cascade_set_final
@ Write the process in ASCII format, in columns that are headed by the
corresponding bincode.
<<Cascades: public>>=
  public :: cascade_set_write_process_bincode_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_process_bincode_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    integer, dimension(:), allocatable :: bincode, field_width
    integer :: n_in, n_out, n_tot, n_flv
    integer :: u, f, i, bc
    character(20) :: str
    type(string_t) :: fmt_head
    type(string_t), dimension(:), allocatable :: fmt_proc
    u = given_output_unit (unit);  if (u < 0)  return
    if (.not. allocated (cascade_set%flv)) return
    write (u, "('!',1x,A)")  "List of subprocesses with particle bincodes:"
    n_in  = cascade_set%n_in
    n_out = cascade_set%n_out
    n_tot = cascade_set%n_tot
    n_flv = size (cascade_set%flv, 2)
    allocate (bincode (n_tot), field_width (n_tot), fmt_proc (n_tot))
    bc = 1
    do i = 1, n_out
       bincode(n_in + i) = bc
       bc = 2 * bc
    end do
    do i = n_in, 1, -1
       bincode(i) = bc
       bc = 2 * bc
    end do       
    do i = 1, n_tot
       write (str, "(I0)")  bincode(i)
       field_width(i) = len_trim (str)
       do f = 1, n_flv
          field_width(i) = max (field_width(i), &
               len (flavor_get_name (cascade_set%flv(i,f))))
       end do
    end do
    fmt_head = "('!'"
    do i = 1, n_tot
       fmt_head = fmt_head // ",1x,"
       fmt_proc(i) = "(1x,"
       write (str, "(I0)")  field_width(i)
       fmt_head = fmt_head // "I" // trim(str)
       fmt_proc(i) = fmt_proc(i) // "A" // trim(str)
       if (i == n_in) then
          fmt_head = fmt_head // ",1x,'  '"
       end if
    end do
    fmt_proc = fmt_proc // ")"
    fmt_head = fmt_head // ")"
    write (u, char (fmt_head))  bincode
    do f = 1, n_flv
       write (u, "('!')", advance="no")
       do i = 1, n_tot
          write (u, char (fmt_proc(i)), advance="no") &
               char (flavor_get_name (cascade_set%flv(i,f)))
          if (i == n_in)  write (u, "(1x,'=>')", advance="no")
       end do
       write (u, *)
    end do
    write (u, char (fmt_head))  bincode
  end subroutine cascade_set_write_process_bincode_format

@ %def cascade_set_write_process_tex_format
@ Write the process as a \LaTeX\ expression.
<<Cascades: procedures>>=
  subroutine cascade_set_write_process_tex_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    integer :: u, f, i
    u = given_output_unit (unit);  if (u < 0)  return
    if (.not. allocated (cascade_set%flv)) return
    write (u, "(A)")  "\begin{align*}"
    do f = 1, size (cascade_set%flv, 2)
       do i = 1, cascade_set%n_in
          if (i > 1)  write (u, "(A)", advance="no") "\quad "
          write (u, "(A)", advance="no") &
               char (flavor_get_tex_name (cascade_set%flv(i,f)))
       end do
       write (u, "(A)", advance="no")  "\quad &\to\quad "
       do i = cascade_set%n_in + 1, cascade_set%n_tot
          if (i > cascade_set%n_in + 1)  write (u, "(A)", advance="no") "\quad "
          write (u, "(A)", advance="no") &
               char (flavor_get_tex_name (cascade_set%flv(i,f)))
       end do
       if (f < size (cascade_set%flv, 2)) then
          write (u, "(A)")  "\\"
       else
          write (u, "(A)")  ""
       end if
    end do       
    write (u, "(A)")  "\end{align*}"
  end subroutine cascade_set_write_process_tex_format

@ %def cascade_set_write_process_tex_format
@ Three output routines: phase-space file, graph source code, and
screen output.

This version generates the phase space file.  It deals only with
complete cascades.
<<Cascades: public>>=
  public :: cascade_set_write_file_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_file_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    type(cascade_t), pointer :: cascade
    integer :: u, grove, count
    logical :: first_in_grove
    u = given_output_unit (unit);  if (u < 0)  return
    count = 0
    do grove = 1, cascade_set%n_groves
       first_in_grove = .true.
       cascade => cascade_set%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                if (first_in_grove) then
                   first_in_grove = .false.
                   write (u, *)
                   write (u, "(1x,'!',1x,A,1x,I0,A)", advance='no') &
                      'Multiplicity =', cascade%multiplicity, ","
                   select case (cascade%n_resonances)
                   case (0)
                      write (u, '(1x,A)', advance='no') 'no resonances, '
                   case (1)
                      write (u, '(1x,A)', advance='no') '1 resonance,  '
                   case default
                      write (u, '(1x,I0,1x,A)', advance='no') &
                           cascade%n_resonances, 'resonances, '
                   end select
                   write (u, '(1x,I0,1x,A)', advance='no') &
                        cascade%n_log_enhanced, 'logs, '
                   write (u, '(1x,I0,1x,A)', advance='no') &
                        cascade%n_off_shell, 'off-shell, '
                   select case (cascade%n_t_channel)
                   case (0);  write (u, '(1x,A)') 's-channel graph'
                   case (1);  write (u, '(1x,A)') '1 t-channel line'
                   case default
                      write(u,'(1x,I0,1x,A)') &
                           cascade%n_t_channel, 't-channel lines'
                   end select
                   write (u, '(1x,A,I0)') 'grove #', grove
                end if
                count = count + 1
                write (u, "(1x,'!',1x,A,I0)")  "Channel #", count
                call cascade_write_file_format (cascade, cascade_set%model, u)
             end if
          end if
          cascade => cascade%next
       end do
    end do
  end subroutine cascade_set_write_file_format

@ %def cascade_set_write_file_format
@ This is the graph output format, the driver-file
<<Cascades: public>>=
  public :: cascade_set_write_graph_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_graph_format &
      (cascade_set, filename, process_id, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    type(string_t), intent(in) :: filename, process_id
    integer, intent(in), optional :: unit
    type(cascade_t), pointer :: cascade
    integer :: u, grove, count, pgcount
    logical :: first_in_grove
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(A)') "\documentclass[10pt]{article}"
    write (u, '(A)') "\usepackage{amsmath}"
    write (u, '(A)') "\usepackage{feynmp}"
    write (u, '(A)') "\usepackage{url}"
    write (u, '(A)') "\usepackage{color}"
    write (u, *)
    write (u, '(A)') "\textwidth 18.5cm"
    write (u, '(A)') "\evensidemargin -1.5cm"
    write (u, '(A)') "\oddsidemargin -1.5cm"
    write (u, *)
    write (u, '(A)') "\newcommand{\blue}{\color{blue}}"
    write (u, '(A)') "\newcommand{\green}{\color{green}}"
    write (u, '(A)') "\newcommand{\red}{\color{red}}"
    write (u, '(A)') "\newcommand{\magenta}{\color{magenta}}"
    write (u, '(A)') "\newcommand{\cyan}{\color{cyan}}"
    write (u, '(A)') "\newcommand{\sm}{\footnotesize}"
    write (u, '(A)') "\setlength{\parindent}{0pt}"
    write (u, '(A)') "\setlength{\parsep}{20pt}"
    write (u, *)
    write (u, '(A)') "\begin{document}"
    write (u, '(A)') "\begin{fmffile}{" // char (filename) // "}"
    write (u, '(A)') "\fmfcmd{color magenta; magenta = red + blue;}"
    write (u, '(A)') "\fmfcmd{color cyan; cyan = green + blue;}"
    write (u, '(A)') "\begin{fmfshrink}{0.5}"
    write (u, '(A)') "\begin{flushleft}"
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{\large\texttt{WHIZARD} phase space channels}" // &
         & "\hfill\today"
    write (u, *)
    write (u, '(A)') "\vspace{10pt}"
    write (u, '(A)') "\noindent" // &
         & "\textbf{Process:} \url{" // char (process_id) // "}"
    call cascade_set_write_process_tex_format (cascade_set, u)
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{Note:} These are pseudo Feynman graphs that " 
    write (u, '(A)') "visualize phase-space parameterizations " // &
         & "(``integration channels'').  "
    write (u, '(A)') "They do \emph{not} indicate Feynman graphs used for the " // &
	 & "matrix element."
    write (u, *)
    write (u, '(A)') "\textbf{Color code:} " // &
         & "{\blue resonance,} " // &
         & "{\cyan t-channel,} " // &
         & "{\green radiation,} "
    write (u, '(A)') "{\red infrared,} " // &
         & "{\magenta collinear,} " // &
         & "external/off-shell"
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{Black square:} Keystone, indicates ordering of " // &
         & "phase space parameters."
    write (u, *)
    write (u, '(A)') "\vspace{-20pt}"
    count = 0
    pgcount = 0
    do grove = 1, cascade_set%n_groves
       first_in_grove = .true.
       cascade => cascade_set%first
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                if (first_in_grove) then
                   first_in_grove = .false.
                   write (u, *)
                   write (u, '(A)') "\vspace{20pt}"
                   write (u, '(A)') "\begin{tabular}{l}"
                   write (u, '(A,I5,A)') &
                        & "\fbox{\bf Grove \boldmath$", grove, "$} \\[10pt]"
                   write (u, '(A,I1,A)') "Multiplicity: ", &
                        cascade%multiplicity, "\\"
                   write (u, '(A,I1,A)') "Resonances:   ", &
                        cascade%n_resonances, "\\"
                   write (u, '(A,I1,A)') "Log-enhanced: ", &
                        cascade%n_log_enhanced, "\\"
                   write (u, '(A,I1,A)') "Off-shell:    ", &
                        cascade%n_off_shell, "\\"
                   write (u, '(A,I1,A)') "t-channel:    ", &
                        cascade%n_t_channel, ""
                   write (u, '(A)') "\end{tabular}"
                end if
                count = count + 1
                call cascade_write_graph_format (cascade, count, unit)
                if (pgcount >= 250) then
                   write (u, '(A)') "\clearpage"
                   pgcount = 0
                end if
             end if
          end if
          cascade => cascade%next
       end do
    end do
    write (u, '(A)') "\end{flushleft}"
    write (u, '(A)') "\end{fmfshrink}"
    write (u, '(A)') "\end{fmffile}"
    write (u, '(A)') "\end{document}"
 end subroutine cascade_set_write_graph_format

@ %def cascade_set_write_graph_format
@ This is for screen output and debugging:
<<Cascades: public>>=
  public :: cascade_set_write
<<Cascades: procedures>>=
  subroutine cascade_set_write (cascade_set, unit, active_only, complete_only)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: active_only, complete_only
    logical :: active, complete
    type(cascade_t), pointer :: cascade
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    active = .true.;  if (present (active_only))  active = active_only
    complete = .false.;  if (present (complete_only))  complete = complete_only
    write (u, "(A)") "Cascade set:"
    write (u, "(3x,A)", advance="no")  "Model:"
    if (associated (cascade_set%model)) then
       write (u, "(1x,A)") char (cascade_set%model%get_name ())
    else
       write (u, "(1x,A)") "[none]"
    end if
    write (u, "(3x,A)", advance="no")  "n_in/out/tot  ="
    write (u, "(3(1x,I7))")  &
         cascade_set%n_in, cascade_set%n_out, cascade_set%n_tot
    write (u, "(3x,A)", advance="no")  "depth_out/tot ="
    write (u, "(2(1x,I7))")  cascade_set%depth_out, cascade_set%depth_tot
    write (u, "(3x,A)", advance="no")  "mass thr(s/t) ="
    write (u, "(2(1x," // FMT_19 // "))")  &
         cascade_set%m_threshold_s, cascade_set%m_threshold_t
    write (u, "(3x,A)", advance="no")  "off shell     ="
    write (u, "(1x,I7)")  cascade_set%off_shell
    write (u, "(3x,A)", advance="no")  "keep_nonreson ="
    write (u, "(1x,L1)")  cascade_set%keep_nonresonant
    write (u, "(3x,A)", advance="no")  "n_groves      ="
    write (u, "(1x,I7)")  cascade_set%n_groves
    write (u, "(A)")
    write (u, "(A)") "Cascade list:"
    if (associated (cascade_set%first)) then
       cascade => cascade_set%first
       do while (associated (cascade))
          if (active .and. .not. cascade%active)  cycle
          if (complete .and. .not. cascade%complete)  cycle
          call cascade_write (cascade, unit)
          cascade => cascade%next
       end do
    else
       write (u, "(A)") "[empty]"
    end if
    write (u, "(A)") "Hash array"
    write (u, "(3x,A)", advance="no")  "n_entries     ="
    write (u, "(1x,I7)")  cascade_set%n_entries
    write (u, "(3x,A)", advance="no")  "fill_ratio    ="
    write (u, "(1x," // FMT_12 // ")")  cascade_set%fill_ratio
    write (u, "(3x,A)", advance="no")  "n_entries_max ="
    write (u, "(1x,I7)")  cascade_set%n_entries_max
    write (u, "(3x,A)", advance="no")  "mask          ="
    write (u, "(1x,I0)")  cascade_set%mask
    do i = 0, ubound (cascade_set%entry, 1)
       if (allocated (cascade_set%entry(i)%key)) then
          write (u, "(1x,I7)") i
          call hash_entry_write (cascade_set%entry(i), u)
       end if
    end do
  end subroutine cascade_set_write

@ %def cascade_set_write
@ 
\subsection{Adding cascades}
Add a deep copy of a cascade to the set.  The copy has all content of the
original, but the pointers are nullified.  We do not care whether insertion
was successful or not.  The pointer argument, if present, is assigned to the
input cascade, or to the hash entry if it is already present.

The procedure is recursive: any daughter or mother entries are also
deep-copied and added to the cascade set before the current copy is added.
<<Cascades: procedures>>=
  recursive subroutine cascade_set_add_copy &
       (cascade_set, cascade_in, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in) :: cascade_in
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_t), pointer :: cascade
    logical :: ok
    allocate (cascade)
    cascade = cascade_in
    if (associated (cascade_in%daughter1))  call cascade_set_add_copy &
         (cascade_set, cascade_in%daughter1, cascade%daughter1)
    if (associated (cascade_in%daughter2))  call cascade_set_add_copy &
         (cascade_set, cascade_in%daughter2, cascade%daughter2)
    if (associated (cascade_in%mother))  call cascade_set_add_copy &
         (cascade_set, cascade_in%mother, cascade%mother)
    cascade%next => null ()
    call cascade_set_add (cascade_set, cascade, ok, cascade_ptr)
    if (.not. ok)  deallocate (cascade)
  end subroutine cascade_set_add_copy

@ %def cascade_set_add_copy
@ Add a cascade to the set.  This does not deep-copy.  We first try to insert
it in the hash array.  If successful, add it to the list.  Failure indicates
that it is already present, and we drop it.

The hash key is built solely from the tree array, so neither particle
codes nor resonances count, just topology.

Technically, hash and list receive only pointers, so the cascade can
be considered as being in either of both.  We treat it as part of the
list.
<<Cascades: procedures>>=
  subroutine cascade_set_add (cascade_set, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i8), dimension(1) :: mold
    call cascade_set_hash_insert &
         (cascade_set, transfer (cascade%tree, mold), cascade, ok, cascade_ptr)
    if (ok)  call cascade_set_list_add (cascade_set, cascade)
  end subroutine cascade_set_add

@ %def cascade_set_add
@ Add a new cascade to the list:
<<Cascades: procedures>>=
  subroutine cascade_set_list_add (cascade_set, cascade)
    type(cascade_set_t), intent(inout) :: cascade_set
    type(cascade_t), intent(in), target :: cascade
    if (associated (cascade_set%last)) then
       cascade_set%last%next => cascade
    else
       cascade_set%first => cascade
    end if
    cascade_set%last => cascade
  end subroutine cascade_set_list_add

@ %def cascade_set_list_add
@ Add a cascade entry to the hash array:
<<Cascades: procedures>>=
  subroutine cascade_set_hash_insert &
       (cascade_set, key, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer(i8), dimension(:), intent(in) :: key
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i32) :: h
    if (cascade_set%n_entries >= cascade_set%n_entries_max) &
         call cascade_set_hash_expand (cascade_set)
    h = hash (key)
    call cascade_set_hash_insert_rec &
         (cascade_set, h, h, key, cascade, ok, cascade_ptr)
  end subroutine cascade_set_hash_insert

@ %def cascade_set_hash_insert
@ Double the hashtable size when necesssary:
<<Cascades: procedures>>=
  subroutine cascade_set_hash_expand (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(hash_entry_t), dimension(:), allocatable, target :: table_tmp
    type(cascade_p), pointer :: current
    integer :: i, s
    allocate (table_tmp (0:cascade_set%mask))
    table_tmp = cascade_set%entry
    deallocate (cascade_set%entry)
    s = 2 * size (table_tmp)
    cascade_set%n_entries = 0
    cascade_set%n_entries_max = s * cascade_set%fill_ratio
    cascade_set%mask = s - 1
    allocate (cascade_set%entry (0:cascade_set%mask))
    do i = 0, ubound (table_tmp, 1)
       current => table_tmp(i)%first
       do while (associated (current))
          call cascade_set_hash_insert_rec &
               (cascade_set, table_tmp(i)%hashval, table_tmp(i)%hashval, &
                table_tmp(i)%key, current%cascade)
          current => current%next
       end do
    end do
  end subroutine cascade_set_hash_expand

@ %def cascade_set_hash_expand
@ Insert the cascade at the bucket determined by the hash value.  If
the bucket is filled, check first for a collision (unequal keys).  In
that case, choose the following bucket and repeat.  Otherwise, add the
cascade to the bucket.

If the bucket is empty, record the hash value, allocate and store the
key, and then add the cascade to the bucket.

If [[ok]] is present, before insertion we check whether the cascade is
already stored, and return failure if yes.
<<Cascades: procedures>>=
  recursive subroutine cascade_set_hash_insert_rec &
       (cascade_set, h, hashval, key, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout) :: cascade_set
    integer(i32), intent(in) :: h, hashval
    integer(i8), dimension(:), intent(in) :: key
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out), optional :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i32) :: i
    i = iand (h, cascade_set%mask)
    if (allocated (cascade_set%entry(i)%key)) then
       if (size (cascade_set%entry(i)%key) /= size (key)) then
          call cascade_set_hash_insert_rec &
               (cascade_set, h + 1, hashval, key, cascade, ok, cascade_ptr)
       else if (any (cascade_set%entry(i)%key /= key)) then
          call cascade_set_hash_insert_rec &
               (cascade_set, h + 1, hashval, key, cascade, ok, cascade_ptr)
       else
          call hash_entry_add_cascade_ptr &
               (cascade_set%entry(i), cascade, ok, cascade_ptr)
       end if
    else
       cascade_set%entry(i)%hashval = hashval
       allocate (cascade_set%entry(i)%key (size (key)))
       cascade_set%entry(i)%key = key
       call hash_entry_add_cascade_ptr &
            (cascade_set%entry(i), cascade, ok, cascade_ptr)
       cascade_set%n_entries = cascade_set%n_entries + 1
    end if
  end subroutine cascade_set_hash_insert_rec

@ %def cascade_set_hash_insert_rec
@ 
\subsection{External particles}
We want to initialize the cascade set with the outgoing particles.  In
case of multiple processes, initial cascades are prepared for all of
them.  The hash array check ensures that no particle appears more than
once at the same place.
<<Cascades: interfaces>>=
  interface cascade_set_add_outgoing
     module procedure cascade_set_add_outgoing1
     module procedure cascade_set_add_outgoing2
  end interface
 
<<Cascades: procedures>>=
  subroutine cascade_set_add_outgoing2 (cascade_set, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(flavor_t), dimension(:,:), intent(in) :: flv
    integer :: pos, prc, n_out, n_prc
    type(cascade_t), pointer :: cascade
    logical :: ok
    n_out = size (flv, dim=1)
    n_prc = size (flv, dim=2)
    do prc = 1, n_prc
       do pos = 1, n_out
          allocate (cascade)
          call cascade_init_outgoing &
               (cascade, flv(pos,prc), pos, cascade_set%m_threshold_s)
          call cascade_set_add (cascade_set, cascade, ok)
          if (.not. ok) then
             deallocate (cascade)
          end if
       end do
    end do
  end subroutine cascade_set_add_outgoing2

  subroutine cascade_set_add_outgoing1 (cascade_set, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(flavor_t), dimension(:), intent(in) :: flv
    integer :: pos, n_out
    type(cascade_t), pointer :: cascade
    logical :: ok
    n_out = size (flv, dim=1)
    do pos = 1, n_out
       allocate (cascade)
       call cascade_init_outgoing &
            (cascade, flv(pos), pos, cascade_set%m_threshold_s)
       call cascade_set_add (cascade_set, cascade, ok)
       if (.not. ok) then
          deallocate (cascade)
       end if
    end do
  end subroutine cascade_set_add_outgoing1

@ %def cascade_set_add_outgoing
@ The incoming particles are added one at a time.  Nevertheless, we
may have several processes which are looped over.  At the first
opportunity, we set the pointer [[first_t]] in the cascade set which
should point to the first t-channel cascade.

Return the indices of the first and last cascade generated.
<<Cascades: interfaces>>=
  interface cascade_set_add_incoming
     module procedure cascade_set_add_incoming0
     module procedure cascade_set_add_incoming1
  end interface
 
<<Cascades: procedures>>=
  subroutine cascade_set_add_incoming1 (cascade_set, n1, n2, pos, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(out) :: n1, n2
    integer, intent(in) :: pos
    type(flavor_t), dimension(:), intent(in) :: flv
    integer :: prc, n_prc
    type(cascade_t), pointer :: cascade
    logical :: ok
    n1 = 0
    n2 = 0
    n_prc = size (flv)
    do prc = 1, n_prc
       allocate (cascade)
       call cascade_init_incoming &
            (cascade, flv(prc), pos, cascade_set%m_threshold_t)
       call cascade_set_add (cascade_set, cascade, ok)
       if (ok) then
          if (n1 == 0)  n1 = cascade%index
          n2 = cascade%index
          if (.not. associated (cascade_set%first_t)) then
             cascade_set%first_t => cascade
          end if
       else
          deallocate (cascade)
       end if
    end do
  end subroutine cascade_set_add_incoming1

  subroutine cascade_set_add_incoming0 (cascade_set, n1, n2, pos, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(out) :: n1, n2
    integer, intent(in) :: pos
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade
    logical :: ok
    n1 = 0
    n2 = 0
    allocate (cascade)
    call cascade_init_incoming &
         (cascade, flv, pos, cascade_set%m_threshold_t)
    call cascade_set_add (cascade_set, cascade, ok)
    if (ok) then
       if (n1 == 0)  n1 = cascade%index
       n2 = cascade%index
       if (.not. associated (cascade_set%first_t)) then
          cascade_set%first_t => cascade
       end if
    else
       deallocate (cascade)
    end if
  end subroutine cascade_set_add_incoming0

@ %def cascade_set_add_incoming
@ 
\subsection{Cascade combination I: flavor assignment}
We have two disjunct cascades, now use the vertex table to determine
the possible flavors of the combination cascade.  For each
possibility, try to generate a new cascade.  The total cascade depth
has to be one less than the limit, because this is reached by setting
the keystone.
<<Cascades: procedures>>=
  subroutine cascade_match_pair (cascade_set, cascade1, cascade2, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    logical, intent(in) :: s_channel
    integer, dimension(:), allocatable :: pdg3
    integer :: i, depth_max
    type(flavor_t) :: flv
    if (s_channel) then
       depth_max = cascade_set%depth_out
    else
       depth_max = cascade_set%depth_tot
    end if
    if (cascade1%depth + cascade2%depth < depth_max) then
       call cascade_set%model%match_vertex ( &
            flavor_get_pdg (cascade1%flv), &
            flavor_get_pdg (cascade2%flv), &
            pdg3)
       do i = 1, size (pdg3)
          call flavor_init (flv, pdg3(i), cascade_set%model)
          if (s_channel) then
             call cascade_combine_s (cascade_set, cascade1, cascade2, flv)
          else
             call cascade_combine_t (cascade_set, cascade1, cascade2, flv)
          end if
       end do
       deallocate (pdg3)
    end if
  end subroutine cascade_match_pair

@ %def cascade_match_pair
@ The triplet version takes a third cascade, and we check whether this
triplet has a matching vertex in the database.  If yes, we make a
keystone cascade.
<<Cascades: procedures>>=
  subroutine cascade_match_triplet &
       (cascade_set, cascade1, cascade2, cascade3, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    logical, intent(in) :: s_channel
    integer :: depth_max
    depth_max = cascade_set%depth_tot
    if (cascade1%depth + cascade2%depth + cascade3%depth == depth_max) then
       if (cascade_set%model%check_vertex ( &
            flavor_get_pdg (cascade1%flv), &
            flavor_get_pdg (cascade2%flv), &
            flavor_get_pdg (cascade3%flv))) then
          call cascade_combine_keystone &
               (cascade_set, cascade1, cascade2, cascade3, s_channel)
       end if
    end if
  end subroutine cascade_match_triplet

@ %def cascade_match_triplet
@
\subsection{Cascade combination II: kinematics setup and check}
Having three matching flavors, we start constructing the combination
cascade.  We look at the mass hierarchies and determine whether the
cascade is to be kept.  In passing we set mapping modes, resonance
properties and such.

If successful, the cascade is finalized.  For a resonant cascade, we
prepare in addition a copy without the resonance.
<<Cascades: procedures>>=
  subroutine cascade_combine_s (cascade_set, cascade1, cascade2, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade3, cascade4
    logical :: keep
    keep = .false.
    allocate (cascade3)
    call cascade_init (cascade3, cascade1%depth + cascade2%depth + 1)
    cascade3%bincode = ior (cascade1%bincode, cascade2%bincode)
    cascade3%flv = flavor_anti (flv)
    cascade3%pdg = abs (flavor_get_pdg (cascade3%flv))
    cascade3%is_vector = flavor_get_spin_type (flv) == VECTOR
    cascade3%m_min = cascade1%m_min + cascade2%m_min
    cascade3%m_rea = flavor_get_mass (flv)
    if (cascade3%m_rea > cascade_set%m_threshold_s) then
       cascade3%m_eff = cascade3%m_rea
    end if
    ! Potentially resonant cases [sqrts = m_rea for on-shell decay]
    if (cascade3%m_rea > cascade3%m_min &
         .and. cascade3%m_rea <= cascade_set%sqrts) then
       if (flavor_get_width (flv) /= 0) then
          if (cascade1%on_shell .or. cascade2%on_shell) then
             keep = .true.
             cascade3%mapping = S_CHANNEL
             cascade3%resonant = .true.
          end if
       else
          call warn_decay (flv)
       end if
    ! Collinear and IR singular cases
    else if (cascade3%m_rea < cascade_set%sqrts) then
       ! Massless splitting
       if (cascade1%m_eff == 0 .and. cascade2%m_eff == 0 &
            .and. cascade3%depth <= 3) then
          keep = .true.
          cascade3%log_enhanced = .true.
          if (cascade3%is_vector) then
             if (cascade1%is_vector .and. cascade2%is_vector) then
                cascade3%mapping = COLLINEAR   ! three-vector-vertex
             else
                cascade3%mapping = INFRARED    ! vector splitting into matter
             end if
          else
             if (cascade1%is_vector .or. cascade2%is_vector) then
                cascade3%mapping = COLLINEAR   ! vector radiation off matter
             else
                cascade3%mapping = INFRARED    ! scalar radiation/splitting
             end if
          end if
       ! IR radiation off massive particle
       else if (cascade3%m_eff > 0 .and. cascade1%m_eff > 0 &
            .and. cascade2%m_eff == 0 &
            .and. (cascade1%on_shell .or. cascade1%mapping == RADIATION) &
            .and. abs (cascade3%m_eff - cascade1%m_eff) &
                       < cascade_set%m_threshold_s) &
            then
          keep = .true.
          cascade3%log_enhanced = .true.
          cascade3%mapping = RADIATION
       else if (cascade3%m_eff > 0 .and. cascade2%m_eff > 0 &
            .and. cascade1%m_eff == 0 &
            .and. (cascade2%on_shell .or. cascade2%mapping == RADIATION) &
            .and. abs (cascade3%m_eff - cascade2%m_eff) &
                  < cascade_set%m_threshold_s) &
            then
          keep = .true.
          cascade3%log_enhanced = .true.
          cascade3%mapping = RADIATION
       end if
    end if
    ! Non-singular cases, including failed resonances
    if (.not. keep) then
       ! Two on-shell particles from a virtual mother
       if (cascade1%on_shell .or. cascade2%on_shell) then
          keep = .true.
          cascade3%m_eff = max (cascade3%m_min, &
                                cascade1%m_eff + cascade2%m_eff)
          if (cascade3%m_eff < cascade_set%m_threshold_s) then
             cascade3%m_eff = 0
          end if
       end if
    end if
    ! Complete and register the cascade (two in case of resonance)
    if (keep) then
       cascade3%on_shell = cascade3%resonant .or. cascade3%log_enhanced
       if (cascade3%resonant) then
          cascade3%pdg = abs (flavor_get_pdg (cascade3%flv))
	  if (cascade_set%keep_nonresonant) then
             allocate (cascade4)
             cascade4 = cascade3
             cascade4%index = cascade_index ()
             cascade4%pdg = UNDEFINED
             cascade4%mapping = NO_MAPPING
             cascade4%resonant = .false.
             cascade4%on_shell = .false.
          end if      
	  cascade3%m_min = cascade3%m_rea
          call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
	  if (cascade_set%keep_nonresonant) then
             call cascade_fusion (cascade_set, cascade1, cascade2, cascade4)
          end if
       else
          call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
       end if
    else
       deallocate (cascade3)
    end if
  contains
    subroutine warn_decay (flv)
      type(flavor_t), intent(in) :: flv
      integer :: i
      integer, dimension(MAX_WARN_RESONANCE), save :: warned_code = 0
      LOOP_WARNED: do i = 1, MAX_WARN_RESONANCE
         if (warned_code(i) == 0) then
            warned_code(i) = flavor_get_pdg (flv)
            write (msg_buffer, "(A)") &
                 & " Intermediate decay of zero-width particle " &
                 & // char (flavor_get_name (flv)) &
                 & // " may be possible."
            call msg_warning
            exit LOOP_WARNED
         else if (warned_code(i) == flavor_get_pdg (flv)) then
            exit LOOP_WARNED
         end if
      end do LOOP_WARNED
    end subroutine warn_decay
  end subroutine cascade_combine_s

@ %def cascade_combine_s
<<Cascades: parameters>>=
  integer, parameter, public :: MAX_WARN_RESONANCE = 50
@ %def MAX_WARN_RESONANCE
@ This is the t-channel version.  [[cascade1]] is t-channel and
contains the seed, [[cascade2]] is s-channel.  We check for
kinematically allowed beam decay (which is a fatal error), or massless
splitting / soft radiation.  The cascade is kept in all remaining
cases and submitted for registration.
<<Cascades: procedures>>=
  subroutine cascade_combine_t (cascade_set, cascade1, cascade2, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade3
    allocate (cascade3)
    call cascade_init (cascade3, cascade1%depth + cascade2%depth + 1)
    cascade3%bincode = ior (cascade1%bincode, cascade2%bincode)
    cascade3%flv = flavor_anti (flv)
    cascade3%pdg = abs (flavor_get_pdg (cascade3%flv))
    cascade3%is_vector = flavor_get_spin_type (flv) == VECTOR
    if (cascade1%incoming) then
       cascade3%m_min = cascade2%m_min
    else
       cascade3%m_min = cascade1%m_min + cascade2%m_min
    end if
    cascade3%m_rea = flavor_get_mass (flv)
    if (cascade3%m_rea > cascade_set%m_threshold_t) then
       cascade3%m_eff = max (cascade3%m_rea, cascade2%m_eff)
    else if (cascade2%m_eff > cascade_set%m_threshold_t) then
       cascade3%m_eff = cascade2%m_eff
    else
       cascade3%m_eff = 0
    end if
    ! Allowed decay of beam particle
    if (cascade1%incoming &
         .and. cascade1%m_rea > cascade2%m_rea + cascade3%m_rea) then
         call beam_decay (cascade_set%fatal_beam_decay)
    ! Massless splitting
    else if (cascade1%m_eff == 0 &
         .and. cascade2%m_eff < cascade_set%m_threshold_t &
         .and. cascade3%m_eff == 0) then
       cascade3%mapping = U_CHANNEL
       cascade3%log_enhanced = .true.
    ! IR radiation off massive particle
    else if (cascade1%m_eff /= 0 .and. cascade2%m_eff == 0 &
         .and. cascade3%m_eff /= 0 &
         .and. (cascade1%on_shell .or. cascade1%mapping == RADIATION) &
         .and. abs (cascade1%m_eff - cascade3%m_eff) &
               < cascade_set%m_threshold_t) &
         then
       cascade3%pdg = abs (flavor_get_pdg (flv))
       cascade3%log_enhanced = .true.
       cascade3%mapping = RADIATION
    end if
    cascade3%t_channel = .true.
    call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
  contains
    subroutine beam_decay (fatal_beam_decay)
      logical, intent(in) :: fatal_beam_decay
      write (msg_buffer, "(1x,A,1x,'->',1x,A,1x,A)") &
           char (flavor_get_name (cascade1%flv)), &
           char (flavor_get_name (cascade3%flv)), &
           char (flavor_get_name (cascade2%flv))
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (flavor_get_name (cascade1%flv)), cascade1%m_rea
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (flavor_get_name (cascade3%flv)), cascade3%m_rea
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (flavor_get_name (cascade2%flv)), cascade2%m_rea
      call msg_message
      if (fatal_beam_decay) then
         call msg_fatal (" Phase space: Initial beam particle can decay")
      else
         call msg_warning (" Phase space: Initial beam particle can decay")
      end if 
    end subroutine beam_decay
  end subroutine cascade_combine_t

@ %def cascade_combine_t
@ Here we complete a decay cascade.  The third input is the
single-particle cascade for the initial particle.  There is no
resonance or mapping assignment.  The only condition for keeping the
cascade is the mass sum of the final state, which must be less than
the available energy.

Two modifications are necessary for scattering cascades: a pure
s-channel diagram (cascade1 is the incoming particle) do not have a
logarithmic mapping at top-level.  And in a t-channel diagram, the
last line exchanged is mapped t-channel, not u-channel.  Finally, we
can encounter the case of a $2\to 1$ process, where cascade1 is
incoming, and cascade2 is the outgoing particle.  In all three cases
we register a new cascade with the modified mapping.
<<Cascades: procedures>>=
  subroutine cascade_combine_keystone &
       (cascade_set, cascade1, cascade2, cascade3, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    logical, intent(in) :: s_channel
    type(cascade_t), pointer :: cascade4, cascade0
    logical :: keep, ok
    keep = .false.
    allocate (cascade4)
    call cascade_init &
         (cascade4, cascade1%depth + cascade2%depth + cascade3%depth)
    cascade4%complete = .true.
    if (s_channel) then
       cascade4%bincode = ior (cascade1%bincode, cascade2%bincode)
    else
       cascade4%bincode = cascade3%bincode
    end if
    cascade4%flv = cascade3%flv
    cascade4%pdg = cascade3%pdg
    cascade4%mapping = EXTERNAL_PRT
    cascade4%is_vector = cascade3%is_vector
    cascade4%m_min = cascade1%m_min + cascade2%m_min
    cascade4%m_rea = cascade3%m_rea
    cascade4%m_eff = cascade3%m_rea
    if (cascade4%m_min < cascade_set%sqrts) then
       keep = .true.
    end if
    if (keep) then
       if (cascade1%incoming .and. cascade2%log_enhanced) then
          allocate (cascade0)
          cascade0 = cascade2
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = NO_MAPPING
          cascade0%log_enhanced = .false.
          cascade0%n_log_enhanced = cascade0%n_log_enhanced - 1
          cascade0%tree_mapping(cascade0%depth) = NO_MAPPING
          call cascade_keystone &
               (cascade_set, cascade1, cascade0, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else if (cascade1%t_channel .and. cascade1%mapping == U_CHANNEL) then
          allocate (cascade0)
          cascade0 = cascade1
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = T_CHANNEL
          cascade0%tree_mapping(cascade0%depth) = T_CHANNEL
          call cascade_keystone &
               (cascade_set, cascade0, cascade2, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else if (cascade1%incoming .and. cascade2%depth == 1) then
          allocate (cascade0)
          cascade0 = cascade2
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = ON_SHELL
          cascade0%tree_mapping(cascade0%depth) = ON_SHELL
          call cascade_keystone &
               (cascade_set, cascade1, cascade0, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else
          call cascade_keystone &
               (cascade_set, cascade1, cascade2, cascade3, cascade4, ok)
       end if
    else
       deallocate (cascade4)
    end if
  end subroutine cascade_combine_keystone

@ %def cascade_combine_keystone
@
\subsection{Cascade combination III: node connections and tree fusion}
Here we assign global tree properties.  If the allowed number of
off-shell lines is exceeded, discard the new cascade.  Otherwise,
assign the trees, sort them, and assign connections.  Finally, append
the cascade to the list.  This may fail (because in the hash array
there is already an equivalent cascade).  On failure, discard the
cascade.
<<Cascades: procedures>>=
  subroutine cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(cascade_t), pointer :: cascade3
    integer :: i1, i2, i3, i4
    logical :: ok
    cascade3%internal = (cascade3%depth - 3) / 2
    if (cascade3%resonant) then
       cascade3%multiplicity = 1
       cascade3%n_resonances = &
            cascade1%n_resonances + cascade2%n_resonances + 1
    else
       cascade3%multiplicity = cascade1%multiplicity + cascade2%multiplicity
       cascade3%n_resonances = cascade1%n_resonances + cascade2%n_resonances
    end if
    if (cascade3%log_enhanced) then
       cascade3%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced + 1
    else
       cascade3%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced
    end if
    if (cascade3%resonant) then
       cascade3%n_off_shell = 0    
    else if (cascade3%log_enhanced) then
       cascade3%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell
    else
       cascade3%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell + 1
    end if
    if (cascade3%t_channel) then
       cascade3%n_t_channel = cascade1%n_t_channel + 1
    end if
    if (cascade3%n_off_shell > cascade_set%off_shell) then
       deallocate (cascade3)
    else if (cascade3%n_t_channel > cascade_set%t_channel) then
       deallocate (cascade3)
    else
       i1 = cascade1%depth
       i2 = i1 + 1
       i3 = i1 + cascade2%depth
       i4 = cascade3%depth
       cascade3%tree(:i1) = cascade1%tree
       where (cascade1%tree_mapping > NO_MAPPING)
          cascade3%tree_pdg(:i1) = cascade1%tree_pdg
       elsewhere
          cascade3%tree_pdg(:i1) = UNDEFINED
       end where
       cascade3%tree_mapping(:i1) = cascade1%tree_mapping
       cascade3%tree_resonant(:i1) = cascade1%tree_resonant
       cascade3%tree(i2:i3) = cascade2%tree
       where (cascade2%tree_mapping > NO_MAPPING)
          cascade3%tree_pdg(i2:i3) = cascade2%tree_pdg
       elsewhere
          cascade3%tree_pdg(i2:i3) = UNDEFINED
       end where
       cascade3%tree_mapping(i2:i3) = cascade2%tree_mapping
       cascade3%tree_resonant(i2:i3) = cascade2%tree_resonant
       cascade3%tree(i4) = cascade3%bincode
       cascade3%tree_pdg(i4) = cascade3%pdg
       cascade3%tree_mapping(i4) = cascade3%mapping
       cascade3%tree_resonant(i4) = cascade3%resonant
       call tree_sort (cascade3%tree, &
            cascade3%tree_pdg, cascade3%tree_mapping, cascade3%tree_resonant)
       cascade3%has_children = .true.
       cascade3%daughter1 => cascade1
       cascade3%daughter2 => cascade2
       call cascade_set_add (cascade_set, cascade3, ok)
       if (.not. ok)  deallocate (cascade3)
    end if
  end subroutine cascade_fusion

@ %def cascade_fusion
@ Here we combine a cascade pair with an incoming particle, i.e., we
set a keystone.  Otherwise, this is similar.  On the first
opportunity, we set the [[first_k]] pointer in the cascade set.
<<Cascades: procedures>>=
  subroutine cascade_keystone &
       (cascade_set, cascade1, cascade2, cascade3, cascade4, ok)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    type(cascade_t), pointer :: cascade4
    logical, intent(out) :: ok
    integer :: i1, i2, i3, i4
    cascade4%internal = (cascade4%depth - 3) / 2
    cascade4%multiplicity = cascade1%multiplicity + cascade2%multiplicity
    cascade4%n_resonances = cascade1%n_resonances + cascade2%n_resonances
    cascade4%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell
    cascade4%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced
    cascade4%n_t_channel = cascade1%n_t_channel + cascade2%n_t_channel
    if (cascade4%n_off_shell > cascade_set%off_shell) then
       deallocate (cascade4)
       ok = .false.
    else if (cascade4%n_t_channel > cascade_set%t_channel) then
       deallocate (cascade4)
       ok = .false.
    else
       i1 = cascade1%depth
       i2 = i1 + 1
       i3 = i1 + cascade2%depth
       i4 = cascade4%depth
       cascade4%tree(:i1) = cascade1%tree
       where (cascade1%tree_mapping > NO_MAPPING)
          cascade4%tree_pdg(:i1) = cascade1%tree_pdg
       elsewhere
          cascade4%tree_pdg(:i1) = UNDEFINED
       end where
       cascade4%tree_mapping(:i1) = cascade1%tree_mapping
       cascade4%tree_resonant(:i1) = cascade1%tree_resonant
       cascade4%tree(i2:i3) = cascade2%tree
       where (cascade2%tree_mapping > NO_MAPPING)
          cascade4%tree_pdg(i2:i3) = cascade2%tree_pdg
       elsewhere
          cascade4%tree_pdg(i2:i3) = UNDEFINED
       end where
       cascade4%tree_mapping(i2:i3) = cascade2%tree_mapping
       cascade4%tree_resonant(i2:i3) = cascade2%tree_resonant
       cascade4%tree(i4) = cascade4%bincode
       cascade4%tree_pdg(i4) = UNDEFINED
       cascade4%tree_mapping(i4) = cascade4%mapping
       cascade4%tree_resonant(i4) = .false.
       call tree_sort (cascade4%tree, &
            cascade4%tree_pdg, cascade4%tree_mapping, cascade4%tree_resonant)
       cascade4%has_children = .true.
       cascade4%daughter1 => cascade1
       cascade4%daughter2 => cascade2
       cascade4%mother => cascade3
       call cascade_set_add (cascade_set, cascade4, ok)
       if (ok) then
          if (.not. associated (cascade_set%first_k)) then
             cascade_set%first_k => cascade4
          end if
       else
          deallocate (cascade4)
       end if
    end if
  end subroutine cascade_keystone

@ %def cascade_keystone
@ 
Sort a tree (array of binary codes) and particle code array
simultaneously, by ascending binary codes.  A convenient method is to
use the [[maxloc]] function iteratively, to find and remove the
largest entry in the tree array one by one.
<<Cascades: procedures>>=
  subroutine tree_sort (tree, pdg, mapping, resonant)
    integer(TC), dimension(:), intent(inout) :: tree
    integer, dimension(:), intent(inout) :: pdg, mapping
    logical, dimension(:), intent(inout) :: resonant
    integer(TC), dimension(size(tree)) :: tree_tmp
    integer, dimension(size(pdg)) :: pdg_tmp, mapping_tmp
    logical, dimension(size(resonant)) :: resonant_tmp
    integer, dimension(1) :: pos
    integer :: i
    tree_tmp = tree
    pdg_tmp = pdg
    mapping_tmp = mapping
    resonant_tmp = resonant
    do i = size(tree),1,-1
       pos = maxloc (tree_tmp)
       tree(i) = tree_tmp (pos(1))
       pdg(i) = pdg_tmp (pos(1))
       mapping(i) = mapping_tmp (pos(1))
       resonant(i) = resonant_tmp (pos(1))
       tree_tmp(pos(1)) = 0
    end do
  end subroutine tree_sort

@ %def tree_sort
@ 
\subsection{Cascade set generation}
These procedures loop over cascades and build up the cascade set.  After each
iteration of the innermost loop, we set a breakpoint.

s-channel: We use a nested scan to combine all cascades with all other
cascades.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_s (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    cascade1 => cascade_set%first
    LOOP1: do while (associated (cascade1))
       cascade2 => cascade_set%first
       LOOP2: do while (associated (cascade2))
          if (cascade2%index >= cascade1%index)  exit LOOP2
          if (cascade1 .disjunct. cascade2) then
             call cascade_match_pair (cascade_set, cascade1, cascade2, .true.)
          end if
          call terminate_now_if_signal ()
          cascade2 => cascade2%next
       end do LOOP2
       cascade1 => cascade1%next
    end do LOOP1
  end subroutine cascade_set_generate_s

@ %def cascade_set_generate_s
@ The t-channel cascades are directed and have a seed (one of the
incoming particles) and a target (the other one).  We loop over all
possible seeds and targets.  Inside this, we loop over all t-channel
cascades ([[cascade1]]) and s-channel cascades ([[cascade2]]) and try
to combine them.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_t (cascade_set, pos_seed, pos_target)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(in) :: pos_seed, pos_target
    type(cascade_t), pointer :: cascade_seed, cascade_target
    type(cascade_t), pointer :: cascade1, cascade2
    integer(TC) :: bc_seed, bc_target
    bc_seed = ibset (0_TC, pos_seed-1)
    bc_target = ibset (0_TC, pos_target-1)
    cascade_seed => cascade_set%first_t
    LOOP_SEED: do while (associated (cascade_seed))
       if (cascade_seed%bincode == bc_seed) then
          cascade_target => cascade_set%first_t
          LOOP_TARGET: do while (associated (cascade_target))
             if (cascade_target%bincode == bc_target) then
                cascade1 => cascade_set%first_t
                LOOP_T: do while (associated (cascade1))
                   if ((cascade1 .disjunct. cascade_target) &
                        .and. .not. (cascade1 .disjunct. cascade_seed)) then
                      cascade2 => cascade_set%first
                      LOOP_S: do while (associated (cascade2))
                         if ((cascade2 .disjunct. cascade_target) &
                              .and. (cascade2 .disjunct. cascade1)) then
                            call cascade_match_pair &
                                 (cascade_set, cascade1, cascade2, .false.)
                         end if
                         call terminate_now_if_signal ()
                         cascade2 => cascade2%next
                      end do LOOP_S
                   end if
                   call terminate_now_if_signal ()
                   cascade1 => cascade1%next
                end do LOOP_T
             end if
             call terminate_now_if_signal ()
             cascade_target => cascade_target%next
          end do LOOP_TARGET
       end if
       call terminate_now_if_signal ()
       cascade_seed => cascade_seed%next
    end do LOOP_SEED
  end subroutine cascade_set_generate_t
                   
@ %def cascade_set_generate_t
@ This part completes the phase space for decay processes.  It is
similar to s-channel cascade generation, but combines two cascade with
the particular cascade of the incoming particle.  This particular
cascade is expected to be pointed at by [[first_t]].
<<Cascades: procedures>>=
  subroutine cascade_set_generate_decay (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    type(cascade_t), pointer :: cascade_in
    cascade_in => cascade_set%first_t
    cascade1 => cascade_set%first
    do while (associated (cascade1))
       if (cascade1 .disjunct. cascade_in) then
          cascade2 => cascade1%next
          do while (associated (cascade2))
             if ((cascade2 .disjunct. cascade1) &
                  .and. (cascade2 .disjunct. cascade_in)) then
                call cascade_match_triplet (cascade_set, &
                     cascade1, cascade2, cascade_in, .true.)
             end if
             call terminate_now_if_signal ()
             cascade2 => cascade2%next
          end do
       end if
       call terminate_now_if_signal ()
       cascade1 => cascade1%next
    end do
  end subroutine cascade_set_generate_decay

@ %def cascade_set_generate_decay
@ This part completes the phase space for scattering processes.  We
combine a t-channel cascade (containing the seed) with a s-channel
cascade and the target.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_scattering &
       (cascade_set, ns1, ns2, nt1, nt2, pos_seed, pos_target)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(in) :: pos_seed, pos_target
    integer, intent(in) :: ns1, ns2, nt1, nt2
    type(cascade_t), pointer :: cascade_seed, cascade_target
    type(cascade_t), pointer :: cascade1, cascade2
    integer(TC) :: bc_seed, bc_target
    bc_seed = ibset (0_TC, pos_seed-1)
    bc_target = ibset (0_TC, pos_target-1)
    cascade_seed => cascade_set%first_t
    LOOP_SEED: do while (associated (cascade_seed))
       if (cascade_seed%index < ns1) then
          cascade_seed => cascade_seed%next
          cycle LOOP_SEED
       else if (cascade_seed%index > ns2) then
          exit LOOP_SEED
       else if (cascade_seed%bincode == bc_seed) then
          cascade_target => cascade_set%first_t
          LOOP_TARGET: do while (associated (cascade_target))
             if (cascade_target%index < nt1) then
                cascade_target => cascade_target%next
                cycle LOOP_TARGET
             else if (cascade_target%index > nt2) then
                exit LOOP_TARGET
             else if (cascade_target%bincode == bc_target) then
                cascade1 => cascade_set%first_t
                LOOP_T: do while (associated (cascade1))
                   if ((cascade1 .disjunct. cascade_target) &
                        .and. .not. (cascade1 .disjunct. cascade_seed)) then
                      cascade2 => cascade_set%first
                      LOOP_S: do while (associated (cascade2))
                         if ((cascade2 .disjunct. cascade_target) &
                              .and. (cascade2 .disjunct. cascade1)) then
                            call cascade_match_triplet (cascade_set, &
                                 cascade1, cascade2, cascade_target, .false.)
                         end if
                         call terminate_now_if_signal ()
                         cascade2 => cascade2%next
                      end do LOOP_S
                   end if
                   call terminate_now_if_signal ()
                   cascade1 => cascade1%next
                end do LOOP_T
             end if
             call terminate_now_if_signal ()
             cascade_target => cascade_target%next
          end do LOOP_TARGET
       end if
       call terminate_now_if_signal ()
       cascade_seed => cascade_seed%next
    end do LOOP_SEED
  end subroutine cascade_set_generate_scattering
    
@ %def cascade_set_generate_scattering
@ 
\subsection{Groves}
Before assigning groves, assign hashcodes to the resonance patterns, so they
can easily be compared.
<<Cascades: procedures>>=
  subroutine cascade_set_assign_resonance_hash (cascade_set)
    type(cascade_set_t), intent(inout) :: cascade_set
    type(cascade_t), pointer :: cascade
    cascade => cascade_set%first_k
    do while (associated (cascade))
       call cascade_assign_resonance_hash (cascade)
       cascade => cascade%next
    end do
  end subroutine cascade_set_assign_resonance_hash

@ %def cascade_assign_resonance_hash
@ After all cascades are recorded, we group the complete cascades in
groves.  A grove consists of cascades with identical multiplicity,
number of resonances, log-enhanced, t-channel lines, and resonance flavors.
<<Cascades: procedures>>=
  subroutine cascade_set_assign_groves (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    integer :: multiplicity
    integer :: n_resonances, n_log_enhanced, n_t_channel, n_off_shell
    integer :: res_hash
    integer :: grove
    grove = 0
    cascade1 => cascade_set%first_k
    do while (associated (cascade1))
       if (cascade1%active .and. cascade1%complete &
            .and. cascade1%grove == 0) then
          grove = grove + 1
          cascade1%grove = grove
          multiplicity = cascade1%multiplicity
          n_resonances = cascade1%n_resonances
          n_log_enhanced = cascade1%n_log_enhanced
	  n_off_shell = cascade1%n_off_shell
          n_t_channel = cascade1%n_t_channel
	  res_hash = cascade1%res_hash
          cascade2 => cascade1%next
          do while (associated (cascade2))
             if (cascade2%grove == 0) then
                if (cascade2%multiplicity == multiplicity &
                     .and. cascade2%n_resonances == n_resonances &
                     .and. cascade2%n_log_enhanced == n_log_enhanced &
                     .and. cascade2%n_off_shell == n_off_shell &
                     .and. cascade2%n_t_channel == n_t_channel &
                     .and. cascade2%res_hash == res_hash) then
                   cascade2%grove = grove
                end if
             end if
             call terminate_now_if_signal ()
             cascade2 => cascade2%next
          end do
       end if
       call terminate_now_if_signal ()
       cascade1 => cascade1%next
    end do
    cascade_set%n_groves = grove
  end subroutine cascade_set_assign_groves

@ %def cascade_set_assign_groves
@ 
\subsection{Generate the phase space file}
Generate a complete phase space configuration.  

For each flavor assignment: First, all s-channel
graphs that can be built up from the outgoing particles.  Then we
distinguish (1) decay, where we complete the s-channel graphs by
connecting to the input line, and (2) scattering, where we now
generate t-channel graphs by introducing an incoming particle, and
complete this by connecting to the other incoming particle.

After all cascade sets have been generated, merge them into a common set.
This eliminates redunancies between flavor assignments.
<<Cascades: public>>=
  public :: cascade_set_generate
<<Cascades: procedures>>=
  subroutine cascade_set_generate &
       (cascade_set, model, n_in, n_out, flv, phs_par, fatal_beam_decay)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(flavor_t), dimension(:,:), intent(in) :: flv
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    type(cascade_set_t), dimension(:), allocatable :: cset
    type(cascade_t), pointer :: cascade
    integer :: i
    if (phase_space_vanishes (phs_par%sqrts, n_in, flv))  return
    call cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
       fatal_beam_decay, flv)
    allocate (cset (size (flv, 2)))
    do i = 1, size (cset)
       call cascade_set_generate_single (cset(i), &
            model, n_in, n_out, flv(:,i), phs_par, fatal_beam_decay)
       cascade => cset(i)%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             call cascade_set_add_copy (cascade_set, cascade)
          end if
          cascade => cascade%next
       end do
       call cascade_set_final (cset(i))
    end do	     
    cascade_set%first_k => cascade_set%first
    call cascade_set_assign_resonance_hash (cascade_set)
    call cascade_set_assign_groves (cascade_set)
  end subroutine cascade_set_generate

@ %def cascade_set_generate
@ This generates phase space for a single channel, without assigning groves.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_single (cascade_set, &
      model, n_in, n_out, flv, phs_par, fatal_beam_decay)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(flavor_t), dimension(:), intent(in) :: flv
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    integer :: n11, n12, n21, n22
    call cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
       fatal_beam_decay)
    call cascade_set_add_outgoing (cascade_set, flv(n_in+1:))
    call cascade_set_generate_s (cascade_set)
    select case (n_in)
    case(1)
       call cascade_set_add_incoming &
            (cascade_set, n11, n12, n_out + 1, flv(1))
       call cascade_set_generate_decay (cascade_set)
    case(2)
       call cascade_set_add_incoming &
            (cascade_set, n11, n12, n_out + 1, flv(2))
       call cascade_set_add_incoming &
            (cascade_set, n21, n22, n_out + 2, flv(1))
       call cascade_set_generate_t (cascade_set, n_out + 1, n_out + 2)
       call cascade_set_generate_t (cascade_set, n_out + 2, n_out + 1)
       call cascade_set_generate_scattering &
            (cascade_set, n11, n12, n21, n22, n_out + 1, n_out + 2)
       call cascade_set_generate_scattering &
            (cascade_set, n21, n22, n11, n12, n_out + 2, n_out + 1)
    end select
  end subroutine cascade_set_generate_single

@ %def cascade_set_generate_single
@ Sanity check: Before anything else is done, check if there could
possibly be any phase space.
<<Cascades: procedures>>=
  function phase_space_vanishes (sqrts, n_in, flv) result (flag)
    logical :: flag
    real(default), intent(in) :: sqrts
    integer, intent(in) :: n_in
    type(flavor_t), dimension(:,:), intent(in) :: flv
    real(default), dimension(:,:), allocatable :: mass
    real(default), dimension(:), allocatable :: mass_in, mass_out
    integer :: n_prt, n_flv
    flag = .false.
    if (sqrts <= 0) then
       call msg_error ("Phase space vanishes (sqrts must be positive)")
       flag = .true.;  return
    end if
    n_prt = size (flv, 1)
    n_flv = size (flv, 2)
    allocate (mass (n_prt, n_flv), mass_in (n_flv), mass_out (n_flv))
    mass = flavor_get_mass (flv)
    mass_in = sum (mass(:n_in,:), 1)
    mass_out = sum (mass(n_in+1:,:), 1)
    if (any (mass_in > sqrts)) then
       call msg_error ("Mass sum of incoming particles " &
            // "is more than available energy")
       flag = .true.;  return
    end if
    if (any (mass_out > sqrts)) then
       call msg_error ("Mass sum of outgoing particles " &
            // "is more than available energy")
       flag = .true.;  return
    end if
  end function phase_space_vanishes
       
@ %def phase_space_vanishes
@ 
\subsection{Unit tests}
<<Cascades: public>>=
  public :: cascade_test
<<Cascades: procedures>>=
  subroutine cascade_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Cascades: execute tests>>
  end subroutine cascade_test

@ %def cascade_test
@ Checking the basic setup up of the phase space cascade parameterizations. 
<<Cascades: execute tests>>=
  call test (cascade_1, "cascade_1", &
       "check cascade setup", &
       u, results)
<<Cascades: tests>>=
  subroutine cascade_1 (u)  
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(5,2) :: flv
    type(cascade_set_t) :: cascade_set
    type(phs_parameters_t) :: phs_par

    write (u, "(A)")  "* Test output: Cascades"
    write (u, "(A)")  "*   Purpose: test cascade phase space functions"
    write (u, "(A)")  
    
    write (u, "(A)")  "* Initializing"
    write (u, "(A)")    
    
    call model%init_sm_test ()

    call flavor_init (flv(1,1), 2, model)
    call flavor_init (flv(2,1),-2, model)
    call flavor_init (flv(3,1), 1, model)
    call flavor_init (flv(4,1),-1, model)
    call flavor_init (flv(5,1),21, model)
    call flavor_init (flv(1,2), 2, model)
    call flavor_init (flv(2,2),-2, model)
    call flavor_init (flv(3,2), 2, model)
    call flavor_init (flv(4,2),-2, model)
    call flavor_init (flv(5,2),21, model)
    phs_par%sqrts = 1000._default
    phs_par%off_shell = 2
    
    write (u, "(A)")
    write (u, "(A)")  "* Generating the cascades"
    write (u, "(A)")
    
    call cascade_set_generate (cascade_set, model, 2, 3, flv, phs_par,.true.)
    call cascade_set_write (cascade_set, u)
    call cascade_set_write_file_format (cascade_set, u)

    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")
    
    call cascade_set_final (cascade_set)
    call model%final ()
    
    write (u, *)
    write (u, "(A)")  "* Test output end: cascade_1"
        
  end subroutine cascade_1

@ %def cascade_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WOOD phase space}

This is the module that interfaces the [[phs_forests]] phase-space
treatment and the [[cascades]] module for generating phase-space
channels.  As an extension of the [[phs_base]] abstract type,
the phase-space configuration and instance implement the standard API.

(Currently, this is the only generic phase-space implementation of
\whizard.  For trivial two-particle phase space, there is
[[phs_wood]] as an alternative.)
<<[[phs_wood.f90]]>>=
<<File header>>

module phs_wood

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use unit_tests
  use diagnostics
  use os_interface
  use md5
  use lorentz
  use model_data
  use flavors
  use process_constants
  use sf_mappings
  use sf_base
  use phs_base
  use mappings
  use phs_forests
  use cascades

<<Standard module head>>

<<PHS wood: public>>

<<PHS wood: types>>

contains

<<PHS wood: procedures>>

<<PHS wood: tests>>

end module phs_wood
@ %def phs_wood
@
\subsection{Configuration}
<<PHS wood: public>>=
  public :: phs_wood_config_t
<<PHS wood: types>>=
  type, extends (phs_config_t) :: phs_wood_config_t
     character(32) :: md5sum_forest = ""
     integer :: io_unit = 0
     logical :: io_unit_keep_open = .false.
     logical :: use_equivalences = .false.
     logical :: fatal_beam_decay = .true.
     type(mapping_defaults_t) :: mapping_defaults
     type(phs_parameters_t) :: par
     type(string_t) :: run_id 
     type(cascade_set_t), allocatable :: cascade_set
     type(phs_forest_t) :: forest
     type(os_data_t) :: os_data
   contains
   <<PHS wood: phs wood config: TBP>>
  end type phs_wood_config_t
  
@ %def phs_wood_config_t
@ Finalizer.  We should delete the cascade set and the forest subobject.

Also close the I/O unit, just in case.  (We assume that [[io_unit]] is
not standard input/output.)
<<PHS wood: phs wood config: TBP>>=
  procedure :: final => phs_wood_config_final
<<PHS wood: procedures>>=
  subroutine phs_wood_config_final (object)
    class(phs_wood_config_t), intent(inout) :: object
    logical :: opened
    if (object%io_unit /= 0) then
       inquire (unit = object%io_unit, opened = opened)
       if (opened)  close (object%io_unit)
    end if
    call object%clear_phase_space ()
    call phs_forest_final (object%forest)
  end subroutine phs_wood_config_final
  
@ %def phs_wood_config_final
@ Output.  The contents of the PHS forest are not printed explicitly.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write => phs_wood_config_write
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write (object, unit)
    class(phs_wood_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") &
         "Partonic phase-space configuration (phase-space forest):"
    call object%base_write (unit)
    write (u, "(1x,A)")    "Phase-space configuration parameters:"
    call phs_parameters_write (object%par, u)
    call object%mapping_defaults%write (u)
    write (u, "(3x,A,A,A)")  "Run ID: '", char (object%run_id), "'"
  end subroutine phs_wood_config_write
  
@ %def phs_wood_config_write
@ Print the PHS forest contents.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write_forest => phs_wood_config_write_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write_forest (object, unit)
    class(phs_wood_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call phs_forest_write (object%forest, u)
  end subroutine phs_wood_config_write_forest
  
@ %def phs_wood_config_write_forest
@ Set the phase-space parameters that the configuration generator requests.
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_parameters => phs_wood_config_set_parameters
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_parameters (phs_config, par)
    class(phs_wood_config_t), intent(inout) :: phs_config
    type(phs_parameters_t), intent(in) :: par
    phs_config%par = par
  end subroutine phs_wood_config_set_parameters

@ %def phs_wood_config_set_parameters
@ Enable the generation of channel equivalences (when calling [[configure]]).
<<PHS wood: phs wood config: TBP>>=
  procedure :: enable_equivalences => phs_wood_config_enable_equivalences
<<PHS wood: procedures>>=
  subroutine phs_wood_config_enable_equivalences (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    phs_config%use_equivalences = .true.
  end subroutine phs_wood_config_enable_equivalences
  
@ %def phs_wood_config_enable_equivalences
@ Set the phase-space mapping parameters that the configuration generator
requests.g
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_mapping_defaults => phs_wood_config_set_mapping_defaults
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_mapping_defaults (phs_config, mapping_defaults)
    class(phs_wood_config_t), intent(inout) :: phs_config
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    phs_config%mapping_defaults = mapping_defaults
  end subroutine phs_wood_config_set_mapping_defaults

@ %def phs_wood_config_set_mapping_defaults
@ Define the input stream for the phase-space file as an open logical unit.
The unit must be connected.
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_input => phs_wood_config_set_input
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_input (phs_config, unit)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in) :: unit
    phs_config%io_unit = unit
    rewind (unit)
  end subroutine phs_wood_config_set_input
  
@ %def phs_wood_config_set_input
@ 
\subsection{Phase-space generation}
This subroutine generates a phase space configuration using the
[[cascades]] module.   Note that this may take time, and the
[[cascade_set]] subobject may consume a large amount of memory.
<<PHS wood: phs wood config: TBP>>=
  procedure :: generate_phase_space => phs_wood_config_generate_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_generate_phase_space (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer :: off_shell, extra_off_shell
    call msg_message ("Phase space: generating configuration ...")
    off_shell = phs_config%par%off_shell
    allocate (phs_config%cascade_set)
    do extra_off_shell = 0, max (phs_config%n_tot - 3, 0)
       phs_config%par%off_shell = off_shell + extra_off_shell
       call cascade_set_generate (phs_config%cascade_set, &
            phs_config%model, phs_config%n_in, phs_config%n_out, &
            phs_config%flv, &
            phs_config%par, phs_config%fatal_beam_decay)
       if (cascade_set_is_valid (phs_config%cascade_set)) then
          exit
       else
          call msg_message ("Phase space: ... failed.  &
               &Increasing phs_off_shell ...")
       end if
    end do
    if (cascade_set_is_valid (phs_config%cascade_set)) then
       call msg_message ("Phase space: ... success.")
    else
       call msg_fatal ("Phase-space: generation failed")
    end if
  end subroutine phs_wood_config_generate_phase_space
    
@ %def phs_wood_config_generate_phase_space
@ Using the generated phase-space configuration, write an appropriate
phase-space file to the stored (or explicitly specified) I/O unit.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write_phase_space => phs_wood_config_write_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write_phase_space (phs_config, &
       filename_vis, unit)
    class(phs_wood_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    type(string_t), intent(in), optional :: filename_vis
    type(string_t) :: setenv_tex, setenv_mp, pipe, pipe_dvi
    integer :: u, unit_tex, unit_dev, status   
    if (allocated (phs_config%cascade_set)) then
       if (present (unit)) then
          u = unit
       else
          u = phs_config%io_unit
       end if
       write (u, "(1x,A,A)") "process ", char (phs_config%id)
       write (u, "(A)")
       call cascade_set_write_process_bincode_format (phs_config%cascade_set, u)
       write (u, "(A)")
       write (u, "(3x,A,A,A32,A)") "md5sum_process    = ", &
            '"', phs_config%md5sum_process, '"'
       write (u, "(3x,A,A,A32,A)") "md5sum_model_par  = ", &
            '"', phs_config%md5sum_model_par, '"'
       write (u, "(3x,A,A,A32,A)") "md5sum_phs_config = ", &
            '"', phs_config%md5sum_phs_config, '"'
       call phs_parameters_write (phs_config%par, u)
       call cascade_set_write_file_format (phs_config%cascade_set, u)
       if (phs_config%vis_channels) then 
          unit_tex = free_unit ()
          open (unit=unit_tex, file=char(filename_vis // ".tex"), &
               action="write", status="replace")      
          call cascade_set_write_graph_format (phs_config%cascade_set, &
               filename_vis // "-graphs", phs_config%id, unit_tex)
          close (unit_tex)      
          call msg_message ("Phase space: visualizing channels in file " & 
               // char(trim(filename_vis)) // "...")
          if (phs_config%os_data%event_analysis_ps) then
             BLOCK: do
                unit_dev = free_unit ()
                open (file = "/dev/null", unit = unit_dev, &
                     action = "write", iostat = status)
                if (status /= 0) then
                   pipe = ""
                   pipe_dvi = ""
                else
                   pipe = " > /dev/null"
                   pipe_dvi = " 2>/dev/null 1>/dev/null"
                end if
                close (unit_dev)
                if (phs_config%os_data%whizard_texpath /= "") then
                   setenv_tex = "TEXINPUTS=" // &
                        phs_config%os_data%whizard_texpath // ":$TEXINPUTS "
                   setenv_mp = "MPINPUTS=" // &
                        phs_config%os_data%whizard_texpath // ":$MPINPUTS "
                else
                   setenv_tex = ""
                   setenv_mp = ""
                end if
                call os_system_call (setenv_tex // &
                     phs_config%os_data%latex // " " // &
                     filename_vis // ".tex " // pipe, status)
                if (status /= 0)  exit BLOCK
                if (phs_config%os_data%mpost /= "") then
                   call os_system_call (setenv_mp // &
                        phs_config%os_data%mpost // " " // &
                        filename_vis // "-graphs.mp" // pipe, status)
                else 
                   call msg_fatal ("Could not use MetaPOST.")
                end if
                if (status /= 0)  exit BLOCK
                call os_system_call (setenv_tex // &
                     phs_config%os_data%latex // " " // &
                     filename_vis // ".tex" // pipe, status)
                if (status /= 0)  exit BLOCK
                call os_system_call &
                     (phs_config%os_data%dvips // " -o " // filename_vis &
                     // ".ps " // filename_vis // ".dvi" // pipe_dvi, status)
                if (status /= 0)  exit BLOCK
                if (phs_config%os_data%event_analysis_pdf) then
                   call os_system_call (phs_config%os_data%ps2pdf // " " // &
                        filename_vis // ".ps", status)
                   if (status /= 0)  exit BLOCK
                end if
                exit BLOCK
             end do BLOCK
             if (status /= 0) then
                call msg_error ("Unable to compile analysis output file")
             end if
          end if
       end if
    else
       call msg_fatal ("Phase-space configuration: &
            &no phase space object generated")
    end if
  end subroutine phs_wood_config_write_phase_space
       
@ %def phs_config_write_phase_space
@ Clear the phase-space configuration.  This is useful since the
object may become \emph{really} large.
<<PHS wood: phs wood config: TBP>>=
  procedure :: clear_phase_space => phs_wood_config_clear_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_clear_phase_space (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    if (allocated (phs_config%cascade_set)) then
       call cascade_set_final (phs_config%cascade_set)
       deallocate (phs_config%cascade_set)
    end if
  end subroutine phs_wood_config_clear_phase_space
  
@ %def phs_wood_config_clear_phase_space
@
\subsection{Phase-space configuration}
We read the phase-space configuration from the stored I/O unit.  If
this is not set, we assume that we have to generate a phase space
configuration.  When done, we open a scratch file and write the
configuration.

If [[rebuild]] is set, we should trash any existing phase space file
and build a new one.  Otherwise, we try to use an old one, which we
check for existence and integrity.  If [[ignore_mismatch]] is set, we
reuse an existing file even if it does not match the current setup.
<<PHS wood: phs wood config: TBP>>=
  procedure :: configure => phs_wood_config_configure
<<PHS wood: procedures>>=
  subroutine phs_wood_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_wood_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(string_t), intent(inout), optional :: nlo_type
    type(string_t) :: filename, filename_vis
    logical :: variable_limits
    logical :: ok, exist, found, check, match, rebuild_phs
    integer :: g, c0, c1, n
    if (present (nlo_type)) then
      phs_config%nlo_type = nlo_type
    else
      phs_config%nlo_type = 'Born'
    end if
    phs_config%sqrts = sqrts
    phs_config%par%sqrts = sqrts
    if (present (sqrts_fixed)) &
         phs_config%sqrts_fixed = sqrts_fixed
    if (present (cm_frame)) &
         phs_config%cm_frame = cm_frame
    if (present (azimuthal_dependence)) &
         phs_config%azimuthal_dependence = azimuthal_dependence
    if (present (rebuild)) then
       rebuild_phs = rebuild
    else
       rebuild_phs = .true.
    end if
    if (present (ignore_mismatch)) then
       check = .not. ignore_mismatch
       if (ignore_mismatch) &
            call msg_warning ("Reading phs file: MD5 sum check disabled")
    else
       check = .true.
    end if
    phs_config%md5sum_forest = ""
    call phs_config%compute_md5sum ()
    if (phs_config%io_unit == 0) then
       if (phs_config%run_id /= "") then
          filename = phs_config%id // "." // phs_config%run_id // ".phs"
          filename_vis = phs_config%id // "." // phs_config%run_id // "_phs"
       else
          filename = phs_config%id // ".phs"
          filename_vis = phs_config%id // "_phs"          
       end if
       if (.not. rebuild_phs) then
          if (check) then
             call phs_config%read_phs_file (exist, found, match)
             rebuild_phs = .not. (exist .and. found .and. match)
          else
             call phs_config%read_phs_file (exist, found)
             rebuild_phs = .not. (exist .and. found)
          end if
       end if
       if (rebuild_phs) then
          call phs_config%generate_phase_space ()
          phs_config%io_unit = free_unit ()
          if (phs_config%id /= "") then
             call msg_message ("Phase space: writing configuration file '" &
                  // char (filename) // "'")
             open (phs_config%io_unit, file = char (filename), &
                  status = "replace", action = "readwrite")
          else
             open (phs_config%io_unit, status = "scratch", action = "readwrite")
          end if
          call phs_config%write_phase_space (filename_vis)
          rewind (phs_config%io_unit)
       else
          call msg_message ("Phase space: keeping configuration file '" &
               // char (filename) // "'")
       end if
    end if
    if (phs_config%io_unit == 0) then
       ok = .true.
    else
      call phs_forest_read (phs_config%forest, phs_config%io_unit, &
            phs_config%id, phs_config%n_in, phs_config%n_out, &
            phs_config%model, ok)
       if (.not. phs_config%io_unit_keep_open) then
          close (phs_config%io_unit)
          phs_config%io_unit = 0
       end if
    end if
    if (ok) then
       call phs_forest_set_flavors (phs_config%forest, phs_config%flv(:,1))
       variable_limits = .not. phs_config%cm_frame
       call phs_forest_set_parameters &
            (phs_config%forest, phs_config%mapping_defaults, variable_limits)
       call phs_forest_setup_prt_combinations (phs_config%forest)
       phs_config%n_channel = phs_forest_get_n_channels (phs_config%forest)
       phs_config%n_par = phs_forest_get_n_parameters (phs_config%forest)
       allocate (phs_config%channel (phs_config%n_channel))
       if (phs_config%use_equivalences) then
          call phs_forest_set_equivalences (phs_config%forest)
          call phs_forest_get_equivalences (phs_config%forest, &
               phs_config%channel, phs_config%azimuthal_dependence)
          phs_config%provides_equivalences = .true.
       end if
       call phs_forest_set_s_mappings (phs_config%forest)
       call phs_config%record_on_shell ()
       if (phs_config%mapping_defaults%enable_s_mapping) then
          call phs_config%record_s_mappings ()
       end if
       allocate (phs_config%chain (phs_config%n_channel), source = 0)
       do g = 1, phs_forest_get_n_groves (phs_config%forest)
          call phs_forest_get_grove_bounds (phs_config%forest, g, c0, c1, n)
          phs_config%chain (c0:c1) = g
       end do
       phs_config%provides_chains = .true.
       call phs_config%compute_md5sum_forest ()
    else
       write (msg_buffer, "(A,A,A)") &
            "Phase space: process '", &
            char (phs_config%id), "' not found in configuration file"
       call msg_fatal ()
    end if
  end subroutine phs_wood_config_configure
  
@ %def phs_wood_config_configure
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: reshuffle_flavors => phs_wood_config_reshuffle_flavors
<<PHS wood: procedures>>=
  subroutine phs_wood_config_reshuffle_flavors (phs_config, reshuffle, flv_extra)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in), dimension(:), allocatable :: reshuffle
    type(flavor_t), intent(in) :: flv_extra
    call phs_forest_set_flavors (phs_config%forest, phs_config%flv(:,1), reshuffle, flv_extra)
  end subroutine phs_wood_config_reshuffle_flavors

@ %def phs_wood_config_reshuffle_flavors
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_momentum_links => phs_wood_config_set_momentum_links
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_momentum_links (phs_config, reshuffle)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in), dimension(:), allocatable :: reshuffle
    call phs_forest_set_momentum_links (phs_config%forest, reshuffle)
  end subroutine phs_wood_config_set_momentum_links

@ %def phs_wood_config_set_momentum_links
@ Identify resonances which are marked by s-channel mappings for the
whole phase space and report them to the channel array.
<<PHS wood: phs wood config: TBP>>=
  procedure :: record_s_mappings => phs_wood_config_record_s_mappings
<<PHS wood: procedures>>=
  subroutine phs_wood_config_record_s_mappings (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical :: flag
    real(default) :: mass, width
    integer :: c
    do c = 1, phs_config%n_channel
       call phs_forest_get_s_mapping (phs_config%forest, c, flag, mass, width)
       if (flag) then
          if (mass == 0) then
             call msg_fatal ("Phase space: s-channel resonance " &
                  // " has zero mass")
          end if
          if (width == 0) then
             call msg_fatal ("Phase space: s-channel resonance " &
                  // " has zero width")
          end if
          call phs_config%channel(c)%set_resonant (mass, width)
       end if
    end do
  end subroutine phs_wood_config_record_s_mappings

@ %def phs_wood_config_record_s_mappings
@ Identify on-shell mappings for the whole phase space and report them
to the channel array.
<<PHS wood: phs wood config: TBP>>=
  procedure :: record_on_shell => phs_wood_config_record_on_shell
<<PHS wood: procedures>>=
  subroutine phs_wood_config_record_on_shell (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical :: flag
    real(default) :: mass
    integer :: c
    do c = 1, phs_config%n_channel
       call phs_forest_get_on_shell (phs_config%forest, c, flag, mass)
       if (flag) then
          call phs_config%channel(c)%set_on_shell (mass)
       end if
    end do
  end subroutine phs_wood_config_record_on_shell

@ %def phs_wood_config_record_on_shell
@ The MD5 sum of the forest is computed in addition to the MD5 sum of
the configuration.  The reason is that the forest may depend on a
user-provided external file.  On the other hand, this MD5 sum encodes
all information that is relevant for further processing.  Therefore,
the [[get_md5sum]] method returns this result, once it is available.
<<PHS wood: phs wood config: TBP>>=
  procedure :: compute_md5sum_forest => phs_wood_config_compute_md5sum_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_config_compute_md5sum_forest (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer :: u
    u = free_unit ()
    open (u, status = "scratch", action = "readwrite")
    call phs_config%write_forest (u)
    rewind (u)
    phs_config%md5sum_forest = md5sum (u)
    close (u)
  end subroutine phs_wood_config_compute_md5sum_forest
  
@ %def phs_wood_config_compute_md5sum_forest
@ Return the most relevant MD5 sum.  This overrides the method of the
base type.
<<PHS wood: phs wood config: TBP>>=
  procedure :: get_md5sum => phs_wood_config_get_md5sum
<<PHS wood: procedures>>=
  function phs_wood_config_get_md5sum (phs_config) result (md5sum)
    class(phs_wood_config_t), intent(in) :: phs_config
    character(32) :: md5sum
    if (phs_config%md5sum_forest /= "") then
       md5sum = phs_config%md5sum_forest
    else
       md5sum = phs_config%md5sum_phs_config
    end if
  end function phs_wood_config_get_md5sum
 
@ %def phs_wood_config_get_md5sum 
@ Check whether a phase-space configuration for the current process exists.
We look for the phase-space file that should correspond to the current
process.  If we find it, we check the MD5 sums stored in the file against the
MD5 sums in the current configuration (if required).

If successful, read the PHS file.
<<PHS wood: phs wood config: TBP>>=
  procedure :: read_phs_file => phs_wood_read_phs_file
<<PHS wood: procedures>>=
  subroutine phs_wood_read_phs_file (phs_config, exist, found, match)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical, intent(out) :: exist
    logical, intent(out) :: found
    logical, intent(out), optional :: match
    type(string_t) :: filename
    integer :: u
    filename = phs_config%id // ".phs"
    inquire (file = char (filename), exist = exist)
    if (exist) then
       u = free_unit ()
       open (u, file = char (filename), action = "read", status = "old")
       call phs_forest_read (phs_config%forest, u, &
            phs_config%id, phs_config%n_in, phs_config%n_out, &
            phs_config%model, found, &
            phs_config%md5sum_process, &
            phs_config%md5sum_model_par, &
            phs_config%md5sum_phs_config, &
            match = match)
       close (u)
    else
       found = .false.
       if (present (match))  match = .false.
    end if
  end subroutine phs_wood_read_phs_file
    
@ %def phs_wood_read_phs_file
@ Startup message, after configuration is complete.
<<PHS wood: phs wood config: TBP>>=
  procedure :: startup_message => phs_wood_config_startup_message
<<PHS wood: procedures>>=
  subroutine phs_wood_config_startup_message (phs_config, unit)
    class(phs_wood_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    integer :: n_groves, n_eq
    n_groves = phs_forest_get_n_groves (phs_config%forest)
    n_eq = phs_forest_get_n_equivalences (phs_config%forest)
    call phs_config%base_startup_message (unit)
    if (phs_config%n_channel == 1) then
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channel, collected in ", n_groves, &
            " grove."
    else if (n_groves == 1) then
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channels, collected in ", n_groves, &
            " grove." 
       else
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channels, collected in ", &
            phs_forest_get_n_groves (phs_config%forest), &
            " groves."
    end if
    call msg_message (unit = unit)    
    if (phs_config%use_equivalences) then
       if (n_eq == 1) then 
          write (msg_buffer, "(A,I0,A)") &
               "Phase space: Using ", n_eq, &
               " equivalence between channels."
       else
          write (msg_buffer, "(A,I0,A)") &
               "Phase space: Using ", n_eq, &
               " equivalences between channels."          
       end if
    else
       write (msg_buffer, "(A)") &
            "Phase space: no equivalences between channels used."
    end if
    call msg_message (unit = unit)
    write (msg_buffer, "(A,2(1x,I0,1x,A))") &
         "Phase space: wood"
    call msg_message (unit = unit)
  end subroutine phs_wood_config_startup_message
    
@ %def phs_wood_config_startup_message
@ Allocate an instance: the actual phase-space object.
<<PHS wood: phs wood config: TBP>>=
  procedure, nopass :: allocate_instance => phs_wood_config_allocate_instance
<<PHS wood: procedures>>=
  subroutine phs_wood_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_wood_t :: phs)
  end subroutine phs_wood_config_allocate_instance
  
@ %def phs_wood_config_allocate_instance
@
\subsection{Kinematics implementation}
We generate $\cos\theta$ and $\phi$ uniformly, covering the solid angle.
<<PHS wood: public>>=
  public :: phs_wood_t
<<PHS wood: types>>=
  type, extends (phs_t) :: phs_wood_t
     real(default) :: sqrts = 0
     type(phs_forest_t) :: forest
   contains
   <<PHS wood: phs wood: TBP>>
  end type phs_wood_t
  
@ %def phs_wood_t
@ Output.  The [[verbose]] setting is irrelevant, we just display the contents
of the base object.
<<PHS wood: phs wood: TBP>>=
  procedure :: write => phs_wood_write
<<PHS wood: procedures>>=
  subroutine phs_wood_write (object, unit, verbose)
    class(phs_wood_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
  end subroutine phs_wood_write
    
@ %def phs_wood_write
@ Write the forest separately.
<<PHS wood: phs wood: TBP>>=
  procedure :: write_forest => phs_wood_write_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_write_forest (object, unit)
    class(phs_wood_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call phs_forest_write (object%forest, u)
  end subroutine phs_wood_write_forest
  
@ %def phs_wood_write_forest
@ Finalizer.
<<PHS wood: phs wood: TBP>>=
  procedure :: final => phs_wood_final
<<PHS wood: procedures>>=
  subroutine phs_wood_final (object)
    class(phs_wood_t), intent(inout) :: object
    call phs_forest_final (object%forest)
  end subroutine phs_wood_final
  
@ %def phs_wood_final
@ Initialization.  We allocate arrays ([[base_init]]) and adjust the
phase-space volume.  The two-particle phase space volume is
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.55294034614 \times 10^{-5}
\end{equation}
independent of the particle masses.
<<PHS wood: phs wood: TBP>>=
  procedure :: init => phs_wood_init
<<PHS wood: procedures>>=
  subroutine phs_wood_init (phs, phs_config)
    class(phs_wood_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    select type (phs_config)
    type is (phs_wood_config_t)
       phs%forest = phs_config%forest
    end select
  end subroutine phs_wood_init
  
@ %def phs_wood_init
@ 
\subsection{Evaluation}
We compute the outgoing momenta from the incoming momenta and
the input parameter set [[r_in]] in channel [[r_in]].  We also compute the
[[r]] parameters and Jacobians [[f]] for all other channels.

We do \emph{not} need to a apply a transformation from/to the c.m.\ frame,
because in [[phs_base]] the momenta are already boosted to the c.m.\ frame
before assigning them in the [[phs]] object, and inversely boosted when
extracting them.
<<PHS wood: phs wood: TBP>>=
  procedure :: evaluate_selected_channel => phs_wood_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_wood_evaluate_other_channels
<<PHS wood: procedures>>=
  subroutine phs_wood_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_wood_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    logical :: ok
    phs%q_defined = .false.
    if (phs%p_defined) then
       call phs_forest_set_prt_in (phs%forest, phs%p)
       phs%r(:,c_in) = r_in
       call phs_forest_evaluate_selected_channel (phs%forest, &
            c_in, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, phs%volume, ok)
       if (ok) then
          phs%q = phs_forest_get_momenta_out (phs%forest)
          phs%q_defined = .true.
       end if
    end if
  end subroutine phs_wood_evaluate_selected_channel
  
  subroutine phs_wood_evaluate_other_channels (phs, c_in)
    class(phs_wood_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    if (phs%q_defined) then
       call phs_forest_evaluate_other_channels (phs%forest, &
            c_in, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, combine=.true.)
       phs%r_defined = .true.
    end if
  end subroutine phs_wood_evaluate_other_channels
  
@ %def phs_wood_evaluate_selected_channel
@ %def phs_wood_evaluate_other_channels
@ Inverse evaluation.
<<PHS wood: phs wood: TBP>>=
  procedure :: inverse => phs_wood_inverse
<<PHS wood: procedures>>=
  subroutine phs_wood_inverse (phs)
    class(phs_wood_t), intent(inout) :: phs
    if (phs%p_defined .and. phs%q_defined) then
       call phs_forest_set_prt_in (phs%forest, phs%p)
       call phs_forest_set_prt_out (phs%forest, phs%q)
       call phs_forest_recover_channel (phs%forest, &
            1, &
            phs%sqrts_hat, phs%r, phs%f, phs%volume)
       call phs_forest_evaluate_other_channels (phs%forest, &
            1, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, combine=.false.)
       phs%r_defined = .true.
    end if
  end subroutine phs_wood_inverse
  
@ %def phs_wood_inverse
@
\subsection{Unit tests}
<<PHS wood: public>>=
  public :: phs_wood_test
<<PHS wood: tests>>=
  subroutine phs_wood_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS wood: execute tests>>
  end subroutine phs_wood_test
  
@ %def phs_wood_test
<<PHS wood: public>>=
  public :: phs_wood_vis_test
<<PHS wood: tests>>=
  subroutine phs_wood_vis_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS wood: execute vis tests>>
  end subroutine phs_wood_vis_test
  
@ %def phs_wood_vis_test
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.  Also
check the [[azimuthal_dependence]] flag.

This auxiliary routine writes a phase-space configuration file to unit
[[u_phs]].
<<PHS wood: public>>=
  public :: write_test_phs_file
<<PHS wood: tests>>=
  subroutine write_test_phs_file (u_phs, procname)
    integer, intent(in) :: u_phs
    type(string_t), intent(in), optional :: procname
    if (present (procname)) then
       write (u_phs, "(A,A)")  "process ", char (procname)
    else
       write (u_phs, "(A)")  "process testproc"
    end if
    write (u_phs, "(A,A)")  "   md5sum_process    = ", '""'
    write (u_phs, "(A,A)")  "   md5sum_model_par  = ", '""'
    write (u_phs, "(A,A)")  "   md5sum_phs_config = ", '""'
    write (u_phs, "(A)")  "   sqrts         = 1000"
    write (u_phs, "(A)")  "   m_threshold_s =   50"    
    write (u_phs, "(A)")  "   m_threshold_t =  100"    
    write (u_phs, "(A)")  "   off_shell = 2"
    write (u_phs, "(A)")  "   t_channel = 6"
    write (u_phs, "(A)")  "   keep_nonresonant = T"
    write (u_phs, "(A)")  "  grove #1"
    write (u_phs, "(A)")  "    tree 3"
  end subroutine write_test_phs_file

@ %def write_test_phs_file
@
<<PHS wood: execute tests>>=
  call test (phs_wood_1, "phs_wood_1", &
       "phase-space configuration", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    type(mapping_defaults_t) :: mapping_defaults
    real(default) :: sqrts
    integer :: u_phs, iostat
    character(32) :: buffer
    
    write (u, "(A)")  "* Test output: phs_wood_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_1"), process_data)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_1"))
    rewind (u_phs)
    do
       read (u_phs, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup phase-space configuration object"
    write (u, "(A)")

    mapping_defaults%step_mapping = .false.

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
       call phs_data%set_mapping_defaults (mapping_defaults)
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)
       
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_1"

  end subroutine phs_wood_1

@ %def phs_wood_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS wood: execute tests>>=
  call test (phs_wood_2, "phs_wood_2", &
       "phase-space evaluation", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: phs_wood_2"
    write (u, "(A)")  "*   Purpose: test simple single-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flavor_init (flv, 25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_2"), process_data)
    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_2"))
    rewind (u_phs)

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv)**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.125, 0.5"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.125_default, 0.5_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_t)
       call phs%write_forest (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    call phs%final ()
    deallocate (phs)
    
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_t)
       call phs%write_forest (u)
    end select
    
    call phs%final ()
    deallocate (phs)
    
    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_2"

  end subroutine phs_wood_2

@ %def phs_wood_2
@
\subsubsection{Phase-space generation}
Generate phase space for a simple process.
<<PHS wood: execute tests>>=
  call test (phs_wood_3, "phs_wood_3", &
       "phase-space generation", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
    integer :: iostat
    character(80) :: buffer
   
    write (u, "(A)")  "* Test output: phs_wood_3"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_3"), process_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%io_unit_keep_open = .true.
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    select type (phs_data)
    type is (phs_wood_config_t)
       rewind (phs_data%io_unit)
       do
          read (phs_data%io_unit, "(A)", iostat = iostat)  buffer
          if (iostat /= 0)  exit
          write (u, "(A)") trim (buffer)
       end do
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_3"

  end subroutine phs_wood_3

@ %def phs_wood_3
@
\subsubsection{Nontrivial process}
Generate phase space for a $2\to 3$ process.
<<PHS wood: execute tests>>=
  call test (phs_wood_4, "phs_wood_4", &
       "nontrivial process", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable, target :: phs_data
    integer :: iostat
    character(80) :: buffer
    class(phs_t), pointer :: phs => null ()
    real(default) :: E, pL
    type(vector4_t), dimension(2) :: p
    type(vector4_t), dimension(3) :: q
   
    write (u, "(A)")  "* Test output: phs_wood_4"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    process_data%id = "phs_wood_4"
    process_data%model_name = "Test"
    process_data%n_in = 2
    process_data%n_out = 3
    process_data%n_flv = 1
    allocate (process_data%flv_state (process_data%n_in + process_data%n_out, &
         process_data%n_flv))
    process_data%flv_state(:,1) = [25, 25, 25, 6, -6]

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%io_unit_keep_open = .true.
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    select type (phs_data)
    type is (phs_wood_config_t)
       rewind (phs_data%io_unit)
       do
          read (phs_data%io_unit, "(A)", iostat = iostat)  buffer
          if (iostat /= 0)  exit
          write (u, "(A)") trim (buffer)
       end do
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       E = phs_data%sqrts / 2
       pL = sqrt (E**2 - flavor_get_mass (phs_data%flv(1,1))**2)
    end select
    p(1) = vector4_moving (E, pL, 3)
    p(2) = vector4_moving (E, -pL, 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.1, 0.2, 0.3, 0.4, 0.5"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, &
         [0.1_default, 0.2_default, 0.3_default, 0.4_default, 0.5_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    call phs%final ()
    deallocate (phs)
    
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs%final ()
    deallocate (phs)

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_4"

  end subroutine phs_wood_4

@ %def phs_wood_4
@
\subsubsection{Equivalences}
Generate phase space for a simple process, including channel equivalences.
<<PHS wood: execute tests>>=
  call test (phs_wood_5, "phs_wood_5", &
       "equivalences", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
   
    write (u, "(A)")  "* Test output: phs_wood_5"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_5"), process_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       call phs_data%enable_equivalences ()
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_5"

  end subroutine phs_wood_5

@ %def phs_wood_5
@
\subsubsection{MD5 sum checks}
Generate phase space for a simple process.  Repeat this with and without
parameter change.
<<PHS wood: execute tests>>=
  call test (phs_wood_6, "phs_wood_6", &
       "phase-space generation", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_6 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
    logical :: exist, found, match
    integer :: u_phs
    character(*), parameter :: filename = "phs_wood_6_p.phs"
   
    write (u, "(A)")  "* Test output: phs_wood_6"
    write (u, "(A)")  "*   Purpose: generate and check  phase-space file"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_6"), process_data)
    process_data%id = "phs_wood_6_p"
    process_data%md5sum = "1234567890abcdef1234567890abcdef"
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
    end select

    write (u, "(A)")  "* Remove previous phs file, if any"
    write (u, "(A)")

    inquire (file = filename, exist = exist)
    if (exist) then
       u_phs = free_unit ()
       open (u_phs, file = filename, action = "write")
       close (u_phs, status = "delete")
    end if

    write (u, "(A)")  "* Check phase-space file (should fail)"
    write (u, "(A)")
    
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    write (u, "(A)")
    write (u, "(A)")  "* Check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify sqrts and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 500
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify process and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    process_data%md5sum = "77777777777777777777777777777777"
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify phs parameter and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    process_data%md5sum = "1234567890abcdef1234567890abcdef"
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    phs_par%off_shell = 17
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify model parameter and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call model%set_par (var_str ("ms"), 100._default)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    phs_par%off_shell = 1
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_6"

  end subroutine phs_wood_6

@ %def phs_wood_6
@
<<PHS wood: execute vis tests>>=
  call test (phs_wood_vis_1, "phs_wood_vis_1", &
       "visualizing phase space channels", &
       u, results)
<<PHS wood: tests>>=
  subroutine phs_wood_vis_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    type(mapping_defaults_t) :: mapping_defaults
    type(string_t) :: vis_file, pdf_file, ps_file
    real(default) :: sqrts
    logical :: exist, exist_pdf, exist_ps
    integer :: u_phs, iostat, u_vis
    character(95) :: buffer
    
    write (u, "(A)")  "* Test output: phs_wood_vis_1"
    write (u, "(A)")  "*   Purpose: visualizing the &
         &phase-space configuration"
    write (u, "(A)")
    
    call os_data_init (os_data)
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_vis_1"), process_data)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_vis_1"))
    rewind (u_phs)
    do
       read (u_phs, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup phase-space configuration object"
    write (u, "(A)")

    mapping_defaults%step_mapping = .false.

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
       call phs_data%set_mapping_defaults (mapping_defaults)
       phs_data%os_data = os_data
       phs_data%io_unit = 0
       phs_data%io_unit_keep_open = .true.
       phs_data%vis_channels = .true.
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)
       
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select
    
    vis_file = "phs_wood_vis_1_phs.tex"
    ps_file  = "phs_wood_vis_1_phs.ps"
    pdf_file = "phs_wood_vis_1_phs.pdf"    
    inquire (file = char (vis_file), exist = exist)
    if (exist) then
       u_vis = free_unit ()
       open (u_vis, file = char (vis_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_vis, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_vis)
    else
       write (u, "(A)")  "[Visualize LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[Visualize Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[Visualize Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[Visualize PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[Visualize PDF file is missing/non-regular]"
    end if        
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_vis_1"

  end subroutine phs_wood_vis_1

@ %def phs_wood_vis_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Random-Number Generator Implementation}

The integration and event generation modules need a random-number
generator.  Here, we provide a concrete implementation.
\begin{description}
\item[Module [[rng_tao]]:]
  Implementation as an interface to the TAO random number generator
  which the VAMP package provides.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TAO Random-Number Generator}
This module provides an implementation for the generic random-number
generator.  Actually, we interface the TAO random-number generator
which is available via the VAMP package.
<<[[rng_tao.f90]]>>=
<<File header>>

module rng_tao

  use kinds
  use io_units
  use format_utils, only: write_indent
  use unit_tests
  use tao_random_numbers !NODEP!

  use rng_base
  
<<Standard module head>>

<<RNG tao: public>>

<<RNG tao: types>>

contains
  
<<RNG tao: procedures>>

<<RNG tao: tests>>

end module rng_tao
@ %def rng_tao
@
\subsection{Generator type}
The rng object is actually the state of the random-number generator.
The methods initialize/reset and call the generator for this state.

We keep the seed, in case we want to recover it later, and count the
number of calls since seeding.
<<RNG tao: public>>=
  public :: rng_tao_t
<<RNG tao: types>>=
  type, extends (rng_t) :: rng_tao_t
     integer :: seed = 0
     integer :: n_calls = 0
     type(tao_random_state) :: state
   contains
   <<RNG tao: rng tao: TBP>>
  end type rng_tao_t

@ %def rng_tao_t
@ Output: Display seed and number of calls.
<<RNG tao: rng tao: TBP>>=
  procedure :: write => rng_tao_write
<<RNG tao: procedures>>=
  subroutine rng_tao_write (rng, unit, indent)
    class(rng_tao_t), intent(in) :: rng
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A)")  "TAO random-number generator:"
    call write_indent (u, ind)
    write (u, "(2x,A,I0)")  "seed  = ", rng%seed
    call write_indent (u, ind)
    write (u, "(2x,A,I0)")  "calls = ", rng%n_calls
  end subroutine rng_tao_write
  
@ %def rng_tao_write
@ The [[init]] method initializes the generator and sets a seed.
We should implement the interface such that a single integer is
sufficient for a seed.

The seed may be omitted.  The default seed is 0.
<<RNG tao: rng tao: TBP>>=
  procedure :: init => rng_tao_init
<<RNG tao: procedures>>=
  subroutine rng_tao_init (rng, seed)
    class(rng_tao_t), intent(out) :: rng
    integer, intent(in), optional :: seed
    if (present (seed))  rng%seed = seed
    call tao_random_create (rng%state, rng%seed)
  end subroutine rng_tao_init
  
@ %def rng_tao_init
@ The [[final]] method deallocates memory where necessary and allows
for another call of [[init]] to reset the generator.
<<RNG tao: rng tao: TBP>>=
  procedure :: final => rng_tao_final
<<RNG tao: procedures>>=
  subroutine rng_tao_final (rng)
    class(rng_tao_t), intent(inout) :: rng
    call tao_random_destroy (rng%state)
  end subroutine rng_tao_final
  
@ %def rng_tao_final 
@ These routines generate a single and an array of default-precision
random numbers, respectively.

We have to convert from explicit double to abstract default
precision.  Under normal conditions, both are equivalent, however.
Unless, someone decides to do single precision, there is always
an interface for [[tao_random_numbers]].
<<RNG tao: rng tao: TBP>>=
  procedure :: generate_single => rng_tao_generate_single
  procedure :: generate_array => rng_tao_generate_array
<<RNG tao: procedures>>=
  subroutine rng_tao_generate_single (rng, x)
    class(rng_tao_t), intent(inout) :: rng
    real(default), intent(out) :: x
    real(default) :: r
    call tao_random_number (rng%state, r)
    x = r
    rng%n_calls = rng%n_calls + 1
  end subroutine rng_tao_generate_single
  
  subroutine rng_tao_generate_array (rng, x)
    class(rng_tao_t), intent(inout) :: rng
    real(default), dimension(:), intent(out) :: x
    real(default) :: r
    integer :: i
    do i = 1, size (x)
       call tao_random_number (rng%state, r)
       x(i) = r
    end do
    rng%n_calls = rng%n_calls + size (x)
  end subroutine rng_tao_generate_array
  
@ %def rng_tao_generate_single rng_tao_generate_array
@
\subsubsection{Factory}
This factory makes [[rng_tao_t]] generators, initialized with the seeds
\begin{equation}
  s_i = s_0 * 2^{16} + i
\end{equation}
where $s_0$ is the seed (a 16-bit integer) given to the factory
object, and $i$ is the index in the generated sequence of generators,
starting with zero.
<<RNG tao: public>>=
  public :: rng_tao_factory_t
<<RNG tao: types>>=
  type, extends (rng_factory_t) :: rng_tao_factory_t
     integer(i16) :: s = 0
     integer(i16) :: i = 0
   contains
   <<RNG tao: rng tao factory: TBP>>
  end type rng_tao_factory_t
  
@ %def rng_tao_factory_t
@ Output.
<<RNG tao: rng tao factory: TBP>>=
  procedure :: write => rng_tao_factory_write
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_write (object, unit)
    class(rng_tao_factory_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,2(I0,A))") &
         "RNG factory: tao (", object%s, ",", object%i, ")"
  end subroutine rng_tao_factory_write

@ %def rng_tao_factory_write
@ Initialize, translating the given seed.
<<RNG tao: rng tao factory: TBP>>=
  procedure :: init => rng_tao_factory_init
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_init (factory, seed)
    class(rng_tao_factory_t), intent(out) :: factory
    integer(i16), intent(in), optional :: seed
    if (present (seed))  factory%s = seed
  end subroutine rng_tao_factory_init
    
@ %def rng_tao_factory_init
<<RNG tao: rng tao factory: TBP>>=
  procedure :: make => rng_tao_factory_make
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_make (factory, rng)
    class(rng_tao_factory_t), intent(inout) :: factory
    class(rng_t), intent(out), allocatable :: rng
    allocate (rng_tao_t :: rng)
    select type (rng)
    type is (rng_tao_t)
       call rng%init (factory%s * 65536 + factory%i)
       factory%i = int (factory%i + 1, kind = i16)
    end select
  end subroutine rng_tao_factory_make

@ %def rng_tao_factory_make
@
\subsection{Unit tests}
<<RNG tao: public>>=
  public :: rng_tao_test
<<RNG tao: tests>>=
  subroutine rng_tao_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<RNG tao: execute tests>>
  end subroutine rng_tao_test
  
@ %def rng_tao_test
@
\subsubsection{Generator check}
Initialize the generator and draw random numbers.
<<RNG tao: execute tests>>=
  call test (rng_tao_1, "rng_tao_1", &
       "rng initialization and call", &
       u, results)
<<RNG tao: tests>>=
  subroutine rng_tao_1 (u)
    integer, intent(in) :: u
    class(rng_t), allocatable, target :: rng

    real(default) :: x
    real(default), dimension(2) :: x2
    
    write (u, "(A)")  "* Test output: rng_tao_1"
    write (u, "(A)")  "*   Purpose: initialize and call the TAO random-number &
         &generator"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize generator (default seed)"
    write (u, "(A)")

    allocate (rng_tao_t :: rng)
    call rng%init ()
    
    call rng%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Get random number"
    write (u, "(A)")
    
    call rng%generate (x)
    write (u, "(A,2(1x,F9.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Get random number pair"
    write (u, "(A)")
    
    call rng%generate (x2)
    write (u, "(A,2(1x,F9.7))")  "x =", x2
    
    write (u, "(A)")
    call rng%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
        
    call rng%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_tao_1"
    
  end subroutine rng_tao_1
    
@ %def rng_tao_1
@
\subsubsection{Factory check}
Set up a factory and spawn generators.
<<RNG tao: execute tests>>=
  call test (rng_tao_2, "rng_tao_2", &
       "rng factory", &
       u, results)
<<RNG tao: tests>>=
  subroutine rng_tao_2 (u)
    integer, intent(in) :: u
    type(rng_tao_factory_t) :: rng_factory
    class(rng_t), allocatable :: rng
    real(default) :: x
    
    write (u, "(A)")  "* Test output: rng_tao_2"
    write (u, "(A)")  "*   Purpose: initialize and use a rng factory"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize factory"
    write (u, "(A)")

    call rng_factory%init ()
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Make a generator"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)

    write (u, "(A)")
    write (u, "(A)")  "* Repeat"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)

    write (u, *)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize factory with different seed"
    write (u, "(A)")

    call rng_factory%init (1_i16)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Make a generator"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)
    
    write (u, *)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_tao_2"
    
  end subroutine rng_tao_2
    
@ %def rng_tao_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NLO Calculations using FKS Subtraction}
\section{Creating the real flavor structure}
<<[[radiation_generator.f90]]>>=
<<File header>>

module radiation_generator

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use os_interface
  use models
  use pdg_arrays
  use particle_specifiers
  use auto_components
  use physics_defs

  implicit none
  private

<<radiation generator: public>>
  
<<radiation generator: types>>

<<radiation generator: interfaces>>

contains

<<radiation generator: procedures>>

end module radiation_generator
@ %def radiation_generator
@
<<radiation generator: types>>=
  type :: pdg_sorter_t
     integer :: pdg
  end type pdg_sorter_t

  type, extends (pdg_sorter_t) :: pdg_sorter_born_t
     logical :: checked
  end type pdg_sorter_born_t

  type, extends (pdg_sorter_t) :: pdg_sorter_real_t
     integer :: associated_born 
  end type pdg_sorter_real_t

@ %def pdg_sorter
@
<<radiation generator: types>>=
  type :: pdg_states_t
    type(pdg_array_t), dimension(:), allocatable :: pdg
    type(pdg_states_t), pointer :: next
    integer :: n_particles
  contains
  <<radiation generator: pdg states: TBP>>
  end type pdg_states_t

@ %def pdg_states_t
@
<<radiation generator: public>>=
  public :: radiation_generator_init
<<radiation generator: interfaces>>=
  interface radiation_generator_init
     module procedure radiation_generator_init_pdg_list
     module procedure radiation_generator_init_pdg_array
  end interface

@ %def radiation_generator_init_interface
@
<<radiation generator: public>>=
  public :: radiation_generator_t
<<radiation generator: types>>=
  type :: radiation_generator_t
    logical :: qcd_enabled = .false.
    logical :: qed_enabled = .false.
    logical :: is_gluon = .false.
    logical :: fs_gluon = .false.
    type(pdg_list_t) :: pl_in, pl_out
    type(split_constraints_t) :: constraints
    integer :: n_tot
    integer :: n_out
    integer :: n_loops
    integer :: n_light_quarks
    real(default) :: mass_sum
    type(model_t), pointer :: radiation_model
    type(pdg_states_t) :: pdg_raw
    type(pdg_array_t), dimension(:), allocatable :: pdg_in_born, pdg_out_born
  contains
  <<radiation generator: radiation generator: TBP>>
  end type radiation_generator_t

@
@ %def radiation_generator_t 
<<radiation generator: pdg states: TBP>>=
  procedure :: init => pdg_states_init
<<radiation generator: procedures>>=
  subroutine pdg_states_init (states)
    class(pdg_states_t), intent(inout) :: states
    nullify (states%next)
  end subroutine pdg_states_init

@ %def pdg_states_init
@
<<radiation generator: pdg states: TBP>>=
  procedure :: add => pdg_states_add
<<radiation generator: procedures>>=
  subroutine pdg_states_add (states, pdg)
    class(pdg_states_t), intent(inout), target :: states
    type(pdg_array_t), dimension(:), intent(in) :: pdg
    type(pdg_states_t), pointer :: current_state
    select type (states)
    type is (pdg_states_t)
      current_state => states
      do
        if (associated (current_state%next)) then
          current_state => current_state%next
        else
          allocate (current_state%next)
          nullify(current_state%next%next)
          current_state%pdg = pdg
          exit
        end if
      end do
    end select
  end subroutine pdg_states_add

@ %def pdg_states_add
@
<<radiation generator: pdg states: TBP>>=
  procedure :: get_n_states => pdg_states_get_n_states
<<radiation generator: procedures>>=
  function pdg_states_get_n_states (states) result (n)
    class(pdg_states_t), intent(in), target :: states
    integer :: n
    type(pdg_states_t), pointer :: current_state
    n = 0
    select type(states)
    type is (pdg_states_t)
      current_state => states
      do
        if (associated (current_state%next)) then
          n = n+1
          current_state => current_state%next
        else
          exit
        end if
      end do
    end select
  end function pdg_states_get_n_states

@ %def pdg_states_get_n_states
@
<<radiation generator: procedures>>=
  subroutine radiation_generator_init_pdg_list &
       (generator, qcd, qed, pl_in, pl_out)
    type(radiation_generator_t), intent(inout) :: generator
    logical, intent(in), optional :: qcd, qed
    type(pdg_list_t), intent(in) :: pl_in, pl_out
    if (present (qcd))  generator%qcd_enabled = qcd
    if (present (qed))  generator%qed_enabled = qed
    generator%pl_in = pl_in
    generator%pl_out = pl_out
    generator%is_gluon = pl_in%search_for_particle (GLUON)
    generator%fs_gluon = pl_out%search_for_particle (GLUON)
    call generator%pdg_raw%init ()
  end subroutine radiation_generator_init_pdg_list

  subroutine radiation_generator_init_pdg_array &
       (generator, qcd, qed, pdg_in, pdg_out)
    type(radiation_generator_t), intent(inout) :: generator
    logical, intent(in), optional :: qcd, qed
    type(pdg_array_t), intent(in), dimension(:), allocatable :: pdg_in, pdg_out
    type(pdg_list_t) :: pl_in, pl_out
    integer :: i
    call pl_in%init(size (pdg_in))    
    call pl_out%init(size (pdg_out))
    do i = 1, size (pdg_in)
       call pl_in%set (i, pdg_in(i))
    end do
    do i = 1, size (pdg_out)
       call pl_out%set (i, pdg_out(i))
    end do
    call radiation_generator_init (generator, qcd, qed, pl_in, pl_out)
  end subroutine radiation_generator_init_pdg_array

@ %def radiation_generator_init_pdg_list radiation_generator_init_pdg_array
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: init_radiation_model => &
                    radiation_generator_init_radiation_model
<<radiation generator: procedures>>=
  subroutine radiation_generator_init_radiation_model (generator, os_data)
    class(radiation_generator_t), intent(inout) :: generator
    type(os_data_t), intent(in) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    call model_list%read_model (var_str ("SM_rad"), var_str ("SM_rad.mdl"), &
                                os_data, model)
    generator%radiation_model => model
  end subroutine radiation_generator_init_radiation_model

@ %def radiation_generator_init_radiation_model
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: set_n => radiation_generator_set_n
<<radiation generator: procedures>>=
  subroutine radiation_generator_set_n (generator, n_in, n_out, n_loops)
    class(radiation_generator_t), intent(inout) :: generator
    integer, intent(in) :: n_in, n_out, n_loops
    generator%n_tot = n_in + n_out + 1
    generator%n_out = n_out
    generator%n_loops = n_loops
  end subroutine radiation_generator_set_n

@ %def radiation_generator_set_n
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: set_constraints => radiation_generator_set_constraints
<<radiation generator: procedures>>=
  subroutine radiation_generator_set_constraints &
       (generator, set_n_loop, set_mass_sum, &
        set_selected_particles, set_required_particles)
    class(radiation_generator_t), intent(inout), target :: generator
    logical, intent(in) :: set_n_loop   
    logical, intent(in) :: set_mass_sum
    logical, intent(in) :: set_selected_particles
    logical, intent(in) :: set_required_particles
    integer :: i, n, n_constraints
    type(pdg_list_t) :: pl_req, pl_insert
    type(pdg_array_t) :: pdg_gluon, pdg_photon
    type(pdg_array_t) :: pdg_add, pdg_tmp
    integer :: i_skip
    i_skip = -1
    
    n_constraints = 1 + count([set_n_loop, set_mass_sum, &
         set_selected_particles, set_required_particles])
    associate (constraints => generator%constraints)
      n = 1
      call constraints%init (n_constraints)
      call constraints%set (n, constrain_n_tot (generator%n_tot))
      n = n+1
      if (set_n_loop) then
         call constraints%set (n, constrain_n_loop(generator%n_loops))
         n = n+1
      end if 
      if (set_mass_sum) then
        call constraints%set (n, constrain_mass_sum(generator%mass_sum))
        n = n+1
      end if
      if (set_required_particles) then
        if (generator%fs_gluon) then
           do i = 1, generator%n_out
              pdg_tmp = generator%pl_out%get(i)
              if (pdg_tmp%search_for_particle (GLUON)) then
                 i_skip = i
                 exit
              end if
           end do
           call pl_req%init (generator%n_out-1)
        else
           call pl_req%init (generator%n_out)
        end if
        do i = 1, generator%n_out
           if (i == i_skip) cycle
           call pl_req%set (i, generator%pl_out%get(i))
        end do          
        call constraints%set (n, constrain_require (pl_req))
        n = n+1
      end if
      if (set_selected_particles) then
        call pl_insert%init (generator%n_out+1)
        do i = 1, generator%n_out
           call pl_insert%set(i, generator%pl_out%get(i))
        end do
        pdg_gluon = GLUON; pdg_photon = PHOTON
        if (generator%fs_gluon .and. generator%qcd_enabled) then
           do i = 1, generator%n_light_quarks
              pdg_tmp = i
              pdg_add = pdg_add // pdg_tmp
           end do
        end if
        if (generator%qcd_enabled) pdg_add = pdg_add // pdg_gluon
        if (generator%qed_enabled) pdg_add = pdg_add // pdg_photon
        call pl_insert%set (generator%n_out+1, pdg_add)
        call constraints%set (n, constrain_insert (pl_insert))
      end if
    end associate

  end subroutine radiation_generator_set_constraints

@ %def radiation_generator_set_constraints
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: generate => radiation_generator_generate
<<radiation generator: procedures>>=
  subroutine radiation_generator_generate (generator, prt_tot_in, prt_tot_out)
    type :: prt_array_t
       type(string_t), dimension(:), allocatable :: prt
    end type
    integer, parameter :: n_flv_max = 10
    class(radiation_generator_t), intent(inout) :: generator
    type(string_t), intent(out), dimension(:), allocatable :: prt_tot_in, prt_tot_out
    type(prt_array_t), dimension(n_flv_max) :: prt_in, prt_out
    type(prt_array_t), dimension(n_flv_max) :: prt_out0
    type(pdg_array_t), dimension(:), allocatable :: pdg_tmp, pdg_out, pdg_in, pdg_raw
    type(if_table_t) :: if_table
    type(pdg_list_t), dimension(:), allocatable :: pl_in, pl_out
    integer :: i, j
    integer, dimension(:), allocatable :: reshuffle_list
    logical :: found
    integer :: flv = 0
    integer :: n_out
    type(string_t), dimension(:), allocatable :: buf

    allocate (pl_in (1), pl_out (1))
    found = .false.
 
    pl_in(1) = generator%pl_in
    pl_out(1) = generator%pl_out
    
    call pl_in(1)%create_pdg_array (pdg_in)
    call pl_out(1)%create_pdg_array (pdg_out)
    call generator%save_born_raw (pdg_in, pdg_out)

    call if_table%init &
         (generator%radiation_model, pl_in, pl_out, generator%constraints)
    call if_table%radiate (generator%constraints)

    allocate (pdg_raw (generator%n_tot))

    do i = 1, if_table%get_length ()
      call if_table%get_pdg_out (i, pdg_tmp)
      if (size (pdg_tmp) == generator%n_tot) then
         call if_table%get_particle_string (i, 2, prt_tot_in, prt_out0(flv+1)%prt)
         call pdg_reshuffle (pdg_out, pdg_tmp, reshuffle_list)
         pdg_raw(1:2) = pdg_tmp(1:2)
         do j = 1, size (reshuffle_list)
            pdg_raw(reshuffle_list(j)+2) = pdg_tmp(j+2)
         end do
         call generator%pdg_raw%add (pdg_raw)
         found = .true.
         flv = flv+1
      end if
    end do

    if (found) then
      do i = 1, flv
         allocate (prt_out(i)%prt (generator%n_tot-2))
      end do
      allocate (prt_tot_out (generator%n_tot-2))
      allocate (buf (generator%n_tot-2))
      buf = ""

      do j = 1, flv
         do i = 1, size (reshuffle_list)
            prt_out(j)%prt(reshuffle_list(i)) = prt_out0(j)%prt(i)
            buf(i) = buf(i) // prt_out(j)%prt(i)
            if (j /= flv) buf(i) = buf(i) // ":"
         end do
      end do
      prt_tot_out = buf
    else
      call msg_fatal ("No QCD corrections for this process!")
    end if
    deallocate (pdg_raw)
  contains
    subroutine pdg_reshuffle (pdg_born, pdg_real, list)
      type(pdg_array_t), intent(in), dimension(:) :: pdg_born, pdg_real
      integer, intent(out), dimension(:), allocatable :: list
      type(pdg_sorter_born_t), dimension(:), allocatable :: sort_born
      type(pdg_sorter_real_t), dimension(:), allocatable :: sort_real
      integer :: i, i_min
      integer :: n_born, n_real
      integer :: ib, ir
      logical :: check
      integer, parameter :: n_in = 2
 
      n_born = size (pdg_born); n_real = size (pdg_real)
      allocate (list (n_real-n_in))
      allocate (sort_born (n_born))
      allocate (sort_real (n_real-n_in))

      sort_born%pdg = pdg_born%get ()
      sort_real%pdg = pdg_real(3:n_real)%get ()
      sort_born%checked = .false.
      sort_real%associated_born = 0

      do ib = 1, n_born
         sort_born(ib)%checked = any (sort_born(ib)%pdg == sort_real%pdg)
         if (sort_born(ib)%checked) then
            do ir = 1, n_real-2
               if (sort_born(ib)%pdg == sort_real(ir)%pdg) then
                  sort_real(ir)%associated_born = ib
                  exit
               end if
            end do
         end if
      end do

      i_min = maxval (sort_real%associated_born) + 1

      do ir = 1, n_real-2
         if (sort_real(ir)%associated_born == 0) then
            sort_real(ir)%associated_born = i_min
            i_min = i_min+1
         end if
      end do

      list = sort_real%associated_born

    end subroutine pdg_reshuffle 
         
  end subroutine radiation_generator_generate

@ %def radiation_generator_generate
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: get_raw_states => radiation_generator_get_raw_states
<<radiation generator: procedures>>=
  function radiation_generator_get_raw_states (generator) result (raw_states)
    class(radiation_generator_t), intent(in), target :: generator
    integer, dimension(:,:), allocatable :: raw_states
    type(pdg_states_t), pointer :: state
    integer :: n_states, n_particles
    integer :: i_state
    integer :: j
    state => generator%pdg_raw
    n_states = generator%pdg_raw%get_n_states ()
    n_particles = size (generator%pdg_raw%pdg)
    allocate (raw_states (n_particles, n_states))
    do i_state = 1, n_states
      do j = 1, n_particles
        raw_states (j, i_state) = state%pdg(j)%get ()
      end do
        state => state%next
    end do
  end function radiation_generator_get_raw_states

@ %def radiation_generator_get_raw_states
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: save_born_raw => radiation_generator_save_born_raw
<<radiation generator: procedures>>=
  subroutine radiation_generator_save_born_raw (generator, pdg_in, pdg_out)
    class(radiation_generator_t), intent(inout) :: generator
    type(pdg_array_t), dimension(:), allocatable, intent(in) :: pdg_in, pdg_out
    integer :: i
    !!! !!! !!! Explicit allocation due to gfortran 4.7.4 
    allocate (generator%pdg_in_born (size (pdg_in)))
    do i = 1, size (pdg_in)
       generator%pdg_in_born(i) = pdg_in(i)
    end do
    allocate (generator%pdg_out_born (size (pdg_out)))
    do i = 1, size (pdg_out)
       generator%pdg_out_born(i) = pdg_out(i)
    end do
  end subroutine radiation_generator_save_born_raw

@ %def radiation_generator_save_born_raw
@
<<radiation generator: radiation generator: TBP>>=
  procedure :: get_born_raw => radiation_generator_get_born_raw
<<radiation generator: procedures>>=
  function radiation_generator_get_born_raw (generator) result (flv_born)
    class(radiation_generator_t), intent(in) :: generator
    integer, dimension(:,:), allocatable :: flv_born
    integer :: i_part, n_particles
    n_particles = size (generator%pdg_in_born) + size (generator%pdg_out_born)
    allocate (flv_born (n_particles, 1))
    flv_born(1,1) = generator%pdg_in_born(1)%get ()
    flv_born(2,1) = generator%pdg_in_born(2)%get ()
    do i_part = 3, n_particles
      flv_born(i_part, 1) = generator%pdg_out_born(i_part-2)%get ()
    end do
  end function radiation_generator_get_born_raw

@ %def radiation_generator_get_born_raw
@
\section{Identifying singular regions}
In the FKS subtraction scheme, the phase space is decomposed into
disjoint singular regions, such that 
\begin{equation}
\label{eq:S_complete}
  \sum_i \mathcal{S}_i + \sum_{ij}\mathcal{S}_{ij} = 1.
\end{equation}
The quantities $\mathcal{S}_i$ and $\mathcal{S}_{ij}$ are functions of
phase space corresponding to a pair of particles indices which can
make up a divergent phase space region. We call such an index pair a
fundamental tuple. For example, the process $e^+ \, e^- \rightarrow u
\, \bar{u} \, g$ has two singular regions, $(3,5)$ and $(4,5)$,
indicating that the gluon can be soft or collinear with respect to
either the quark or the anti-quark. Therefore, the functions $S_{ij}$
have to be chosen in such a way that their contribution makes up most
of \eqref{eq:S_complete} in phase-space configurations where
(final-state) particle $j$ is collinear to particle $i$ or/and
particle $j$ is soft. The functions $S_i$ is the corresponding
quantity for initial-state divergences.

As a singular region we understand the collection of real flavor
structures associated with an emitter and a list of all possible
fundamental tuples. As an example, consider the process $e^+ \, e^-
\rightarrow u \, \bar{u} \, g$. At next-to-leading order, processes
with an additionally radiated particle have to be considered. In this
case, these are $e^+ \, e^- \rightarrow u \, \bar{u}, \, g \, g$, 
and $e^+ \, e^- \rightarrow u \, \bar{u} \, u \, \bar{u}$ (or the same
process with any other quark). Table \ref{table:singular regions} sums
up all possible singular regions for this problem. 
\begin{table}
\label{table:singular regions}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{flst\_alr} & \texttt{emi} &
  \texttt{ftuple\_list}\\ \hline 
  1 & [-11,11,2,-2,21,21] & 3 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  2 & [-11,11,2,-2,21,21] & 4 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  3 & [-11,11,2,-2,21,21] & 5 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  4 & [-11,11,2,-2,2,-2]  & 5 & {(5,6)} \\ 
  \hline
\end{tabular}
\caption{List of singular regions. The particles are represented by
  their PDG codes. The third column contains the emitter for the
  specific singular region. For the process involving an additional
  gluon, the gluon can either be emitted from one of the quarks or
  from the first gluon. Each emitter yields the same list of
  fundamental tuples, five in total. The last singular region
  corresponds to the process where the gluon splits up into two
  quarks. Here, there is only one fundamental tuple, corresponding to
  a singular configuration of the momenta of the additional quarks.} 
\end{table}
\\
\begin{table}
\label{table:ftuples and flavors}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{ftuple} & \texttt{emitter} &
  \texttt{flst\_alr} \\ \hline 
  1 & $(3,5)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  2 & $(4,5)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  3 & $(3,6)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  4 & $(4,6)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  5 & $(5,6)$ & 5 & [-11,11,2,-2,21,21] \\ \hline
  6 & $(5,6)$ & 5 & [-11,11,2,-2,2,-2] \\ \hline
\end{tabular}
\caption{Initial list of singular regions}
\end{table}
Thus, during the preparation of a NLO-calculation, the possible
singular regions have to be identified. [[fks_regions.f90]] deals 
with this issue.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[fks_regions.f90]]>>=
<<File header>>

module fks_regions

  use kinds
  use io_units
<<Use strings>>
  use constants
  use diagnostics
  use flavors
  use process_constants
  use lorentz
  use pdg_arrays
  use models

<<Standard module head>>

<<fks regions: public>>

<<fks regions: types>>

<<fks regions: interfaces>>

contains

<<fks regions: procedures>>

end module fks_regions
@ %def fks_regions
@ We group the indices of the emitting and the radiated particle in
the [[ftuple]]-object. 
<<fks regions: public>>=
  public :: ftuple_t
<<fks regions: types>>=
  type :: ftuple_t 
    integer, dimension(2) :: ireg
  contains
    <<fks regions: ftuple: TBP>> 
  end type ftuple_t
  
@ %def ftuple_t
@ 
<<fks regions: ftuple: TBP>>=
  procedure :: write => ftuple_write
<<fks regions: procedures>>=
  subroutine ftuple_write (ftuple, unit)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(A1,I1,A1,I1,A1)") &
         '(', ftuple%ireg(1), ',', ftuple%ireg(2), ')'
  end subroutine ftuple_write

@ %def ftuple_write
@
<<fks regions: ftuple: TBP>>=
  procedure :: get => ftuple_get
<<fks regions: procedures>>=
  subroutine ftuple_get (ftuple, pos1, pos2)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(out) :: pos1, pos2
    pos1 = ftuple%ireg(1)
    pos2 = ftuple%ireg(2)
  end subroutine ftuple_get

@ %def ftuple_get
@
<<fks regions: ftuple: TBP>>=
  procedure :: set => ftuple_set
<<fks regions: procedures>>=
  subroutine ftuple_set (ftuple, pos1, pos2)
    class(ftuple_t) :: ftuple
    integer pos1, pos2
    ftuple%ireg(1) = pos1
    ftuple%ireg(2) = pos2
  end subroutine ftuple_set

@ %def ftuple_set
@
<<fks regions: ftuple: TBP>>=
  procedure :: has_particle => ftuple_has_particle
<<fks regions: procedures>>=
  function ftuple_has_particle (ftuple, part) result (res)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(in) :: part
    logical :: res
    res = ftuple%ireg(1) == part .or. ftuple%ireg(2) == part 
  end function ftuple_has_particle

@ %def ftuple_has_particle
@ Each singular region can have a different number of
emitter-radiation pairs. This is coped with using the linked list
[[ftuple_list]]. 
<<fks regions: types>>=
  type :: ftuple_list_t
    integer :: index
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: next
    type(ftuple_list_t), pointer :: prev
    type(ftuple_list_t), pointer :: equiv
  contains
   <<fks regions: ftuple list: TBP>>
  end type ftuple_list_t

@ %def ftuple_list_t
@
<<fks regions: ftuple list: TBP>>=
  procedure :: init => ftuple_list_init
<<fks regions: procedures>>=  
  subroutine ftuple_list_init (list)
    class(ftuple_list_t), intent(inout) :: list
    list%index = 0
    nullify (list%next)
    nullify (list%prev)
    nullify (list%equiv)
  end subroutine ftuple_list_init

@ %def ftuple_list_init
@
<<fks regions: ftuple list: TBP>>=
  procedure :: write => ftuple_list_write
<<fks regions: procedures>>=
  subroutine ftuple_list_write (list)
    class(ftuple_list_t), intent(in), target :: list
    type(ftuple_list_t), pointer :: current
    select type (list)
    type is (ftuple_list_t)
    current => list
    do
      call current%ftuple%write
      if (associated (current%next)) then
        current => current%next
      else
        exit
      end if
    end do
    end select
  end subroutine ftuple_list_write

@ %def ftuple_list_write
@
<<fks regions: ftuple list: TBP>>=
  procedure :: append => ftuple_list_append
<<fks regions: procedures>>=
  subroutine ftuple_list_append (list, ftuple) 
   class(ftuple_list_t), intent(inout), target :: list
   type(ftuple_t), intent(in) :: ftuple
   type(ftuple_list_t), pointer :: current

   select type (list)
   type is (ftuple_list_t)
   if (list%index == 0) then
      nullify(list%next)
      list%index = 1
      list%ftuple = ftuple
   else
      current => list
      do
       if (associated (current%next)) then
         current => current%next
       else
         allocate (current%next)
         nullify (current%next%next)
         nullify (current%next%equiv)
         current%next%prev => current
         current%next%index = current%index + 1
         current%next%ftuple = ftuple
         exit
       end if
     end do
   end if
   end select
  end subroutine ftuple_list_append

@ %def ftuple_list_append
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_n_tuples => ftuple_list_get_n_tuples
<<fks regions: procedures>>=
  function ftuple_list_get_n_tuples (list) result(n_tuples)
    class(ftuple_list_t), intent(inout), target :: list
    integer :: n_tuples
    type(ftuple_list_t), pointer :: current
    select type (list)
    type is (ftuple_list_t)
      current => list
      n_tuples = 1
      do 
        if (associated (current%next)) then
          current => current%next
          n_tuples = n_tuples + 1
        else
          exit
        end if
       end do
    end select
  end function ftuple_list_get_n_tuples

@ %def ftuple_list_get_n_tuples
@ 
<<fks regions: ftuple list: TBP>>=
  procedure :: get_entry => ftuple_list_get_entry
<<fks regions: procedures>>=
  function ftuple_list_get_entry(list, index) result(entry)
   class(ftuple_list_t), intent(inout), target :: list
   integer, intent(in) :: index
   type(ftuple_list_t), pointer :: entry
   type(ftuple_list_t), pointer :: current
   integer :: i
   select type (list)
   type is (ftuple_list_t)
   current => list
   if (index <= list%get_n_tuples ()) then
   if (index == 1) then
     entry => current
   else
     do i=1,index-1
       current => current%next
     end do
     entry => current
   end if
   else
     ! print *, 'index: ', index, 'nregions: ', &
     !    list%get_n_tuples () !!! Debugging
     call msg_fatal &
          ("Index must be smaller or equal than the total number of regions!")
   end if
   end select  
  end function ftuple_list_get_entry

@ %def ftuple_list_get_entry
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_ftuple => ftuple_list_get_ftuple
<<fks regions: procedures>>=
  function ftuple_list_get_ftuple (list, index)  result (ftuple)
    class(ftuple_list_t), intent(inout) :: list
    integer, intent(in) :: index
    type(ftuple_t) :: ftuple
    type(ftuple_list_t) :: entry
    entry = list%get_entry (index)
    ftuple = entry%ftuple
  end function ftuple_list_get_ftuple

@ %def ftuple_list_get_ftuple
@
<<fks regions: ftuple list: TBP>>=
  procedure :: set_equiv => ftuple_list_set_equiv
<<fks regions: procedures>>=
  subroutine ftuple_list_set_equiv (list, i1, i2)
    class(ftuple_list_t), intent(inout) :: list
    integer, intent(in) :: i1, i2
    type(ftuple_list_t), pointer :: list1, list2
    select type (list)
    type is (ftuple_list_t)
    list1 => list%get_entry (i1)
    list2 => list%get_entry (i2)
    list1%equiv => list2
    end select
  end subroutine ftuple_list_set_equiv

@ %def ftuple_list_set_equiv 
@
<<fks regions: ftuple list: TBP>>=
  procedure :: check_equiv => ftuple_list_check_equiv
<<fks regions: procedures>>=
  function ftuple_list_check_equiv(list, i1, i2) result(eq)
    class(ftuple_list_t), intent(inout) :: list
    integer, intent(in) :: i1, i2
    logical :: eq
    type(ftuple_list_t), pointer :: current
    select type (list)
    type is (ftuple_list_t)
      current => list%get_entry (i1)
      do
        if (associated (current%equiv)) then
          current => current%equiv
          if (current%index == i2) then
            eq = .true.
            exit
          end if
        else
          eq = .false.
          exit
        end if
      end do
    end select
  end function ftuple_list_check_equiv

@ %def ftuple_list_check_equiv
@ Class for working with the flavor specification arrays.
<<fks regions: public>>=
  public :: flv_structure_t
<<fks regions: types>>=
  type :: flv_structure_t
    integer, dimension(:), allocatable :: flst
    integer :: nlegs
  contains
    procedure :: init => flv_structure_init
    procedure :: write => flv_structure_write
    procedure :: get_nlegs => flv_structure_get_nlegs
    procedure :: remove_particle => flv_structure_remove_particle
    procedure :: insert_particle => flv_structure_insert_particle
    procedure :: valid_pair => flv_structure_valid_pair
    procedure :: create_uborn => flv_structure_create_uborn
  end type flv_structure_t

@ %def flv_structure_t
@ Returns \texttt{true} if the two particles at position \texttt{i}
and \texttt{j} in the flavor array can originate from the same
splitting. For this purpose, the function first checks whether the splitting is
allowed at all. If this is the case, the emitter is removed from the
flavor array. If the resulting array is equivalent to the Born flavor
structure \texttt{flv\_born}, the pair is accepted as a valid
splitting. 
<<fks regions: procedures>>=
  function flv_structure_valid_pair &
       (flv_real,i,j, flv_born, model) result (valid)
    class(flv_structure_t), intent(in) :: flv_real
    integer, intent(in) :: i,j
    type(flv_structure_t), intent(in) :: flv_born
    type(model_t), intent(in) :: model
    logical :: valid
    integer :: k, n_orig
    type(flv_structure_t) :: flv_test
    integer, dimension(:), allocatable :: flv_orig, flv_orig2
    valid = .false.
@ 
First check whether the splitting is possible. The array
[[flv_orig]] contains all particles which share a vertex with the
particles at position [[i]] and [[j]]. If its size is equal to zero,
no splitting is possible and the subroutine is exited. 
<<fks regions: procedures>>=
    call model%match_vertex &
         (flv_real%flst(i), flv_real%flst(j), flv_orig)
    n_orig = size (flv_orig)
    if (n_orig == 0) then
      return
    else
@ 
For a quark emitting a gluon, [[flv_orig]] contains the PDG code of
the anti-quark. To be on the safe side, a second array is created,
which contains both the positively and negatively signed PDG
codes. Then, the origial tuple $(i,j)$ is removed from the real flavor
structure and the particles in [[flv_orig2]] are inserted. 
If the resulting Born configuration is equal to the underlying Born
configuration, up to a permutation of final-state particles, the tuple
$(i,j)$ is accepted as valid. 
<<fks regions: procedures>>=
      allocate (flv_orig2 (2*n_orig))
      flv_orig2 (1:n_orig) = flv_orig
      flv_orig2 (n_orig+1:2*n_orig) = -flv_orig
      do k = 1, 2*n_orig
        flv_test = flv_real%insert_particle (i,j,flv_orig2(k))
        valid = flv_born == flv_test
        if (valid) return
      end do
    end if
  end function flv_structure_valid_pair

@ %def flv_structure_valid_pair
@ This function checks whether two flavor arrays are the same up to a
permutation of the final-state particles 
<<fks regions: procedures>>=
  function flv_structure_equivalent (flv1, flv2) result(equiv)
    type(flv_structure_t), intent(in) :: flv1, flv2
    logical :: equiv
    integer :: i, j, n
    integer :: f1, f2
    logical, dimension(:), allocatable :: present, checked
    n = size (flv1%flst)
    equiv = .true.
    if (n /= size (flv2%flst)) then
      call msg_fatal &
           ('flv_structure_equivalent: flavor arrays do not have equal lengths')
    else
      allocate (present(n))
      allocate (checked(n))
        do i=1,n
	   present(i) = .false.
           checked(i) = .false.
        end do
	do i=1,n
   	  do j=1,n
          if (flv1%flst(i) == flv2%flst(j) .and. .not. checked(j)) then 
	      present(i) = .true.
              checked(j) = .true.
              exit
	    end if
 	  end do
  	end do
        do i=1,n
	  if(.not.present(i)) equiv = .false.
	end do
    end if	
  end function flv_structure_equivalent

@ %def flv_structure_equivalent
@ Returs a new flavor array with the particle at position
\texttt{index} removed. 
<<fks regions: procedures>>=
  function flv_structure_remove_particle (flv1, index) result(flv2)
    class(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: index   
    type(flv_structure_t) :: flv2
    integer :: n1, n2
    n1 = size (flv1%flst)
    n2 = n1-1
    if (allocated (flv2%flst)) then
      deallocate (flv2%flst)
    end if
    allocate (flv2%flst (n2))
    if (index == 1) then
      flv2%flst(1:n2) = flv1%flst(2:n1)
    else if (index == n1) then
      flv2%flst(1:n2) = flv1%flst(1:n2)
    else
      flv2%flst(1:index-1) = flv1%flst(1:index-1)
      flv2%flst(index:n2) = flv1%flst(index+1:n1)
    end if
  end function flv_structure_remove_particle

@ %def flv_structure_remove_particle 
@ Removes the paritcles at position i1 and i2 and inserts a new
particle at position i1. 
<<fks regions: procedures>>=
  function flv_structure_insert_particle (flv1, i1, i2, particle) result (flv2)
    class(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: i1, i2, particle
    type(flv_structure_t) :: flv2
    type(flv_structure_t) :: flv_tmp
    integer :: n1, n2
    n1 = size (flv1%flst)
    n2 = n1-1
    allocate (flv2%flst(n2))
    if (i1 < i2) then
      flv_tmp = flv1%remove_particle (i1)
      flv_tmp = flv_tmp%remove_particle (i2-1)
    else if(i2 < i1) then
      flv_tmp = flv1%remove_particle(i2)
      flv_tmp = flv_tmp%remove_particle(i1-1)
    else
      stop 'Error: i1 == i2 is nonsense!'
    end if
    if (i1 == 1) then
      flv2%flst(1) = particle
      flv2%flst(2:n2) = flv_tmp%flst(1:n2-1)
    else if (i1 == n1 .or. i1 == n2) then
      flv2%flst(1:n2-1) = flv_tmp%flst(1:n2-1)
      flv2%flst(n2) = particle
    else
      flv2%flst(1:i1-1) = flv_tmp%flst(1:i1-1)
      flv2%flst(i1) = particle
      flv2%flst(i1+1:n2) = flv_tmp%flst(i1:n2-1)
    end if
  end function flv_structure_insert_particle 

@ %def flv_structure_insert_particle
@ Returns the number of particles in a flavor array
<<fks regions: procedures>>=
  function flv_structure_get_nlegs (flv) result(n)
    class(flv_structure_t), intent(in) :: flv
    integer :: n
    n = flv%nlegs
  end function flv_structure_get_nlegs

@ %def flv_structure_get_nlegs
@ Initializer for flavor structures
<<fks regions: procedures>>=
  subroutine flv_structure_init (flv, aval)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in), dimension(:) :: aval
    integer :: n
    n = size (aval)
    allocate (flv%flst (n))
    flv%flst(1:n) = aval(1:n)
    flv%nlegs = n
  end subroutine flv_structure_init

@ %def flv_structure_init
@
<<fks regions: procedures>>=
  subroutine flv_structure_write (flv, unit)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (unit); if (u < 0) return
    write (u, '(A1)',advance = 'no') '['
    do i = 1, size(flv%flst)-1
      write (u, '(I3,A1)', advance = 'no') flv%flst(i), ','
    end do
    write (u, '(I3,A1)') flv%flst(i), ']'
  end subroutine flv_structure_write

@ %def flv_structure_write
@ Creates the underlying Born flavor structure for a given real flavor
structure if the particle at position \texttt{emitter} is removed 
<<fks regions: procedures>>=
  function flv_structure_create_uborn (flst_alr, emitter) result(flst_uborn)
    class(flv_structure_t), intent(in) :: flst_alr
    integer, intent(in) :: emitter
    type(flv_structure_t) :: flst_uborn
    integer n_alr, n_uborn
    n_alr = size(flst_alr%flst)
    n_uborn = n_alr-1
    allocate (flst_uborn%flst (n_uborn))
    if (emitter > 2) then
      if (flst_alr%flst(n_alr) == 21) then
         !!! Emitted particle is a gluon => just remove it
         flst_uborn = flst_alr%remove_particle(n_alr)
         !!! Emission type is a gluon splitting into two quars
      else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
               is_quark (abs(flst_alr%flst(n_alr-1))) .and. &
               flst_alr%flst(n_alr) + flst_alr%flst(n_alr-1) == 0) then
         flst_uborn = flst_alr%insert_particle(n_alr-1,n_alr,21)
      end if
     else
        if (flst_alr%flst(n_alr) == 21) then
           flst_uborn = flst_alr%remove_particle(n_alr)
        else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
                  is_gluon (abs(flst_alr%flst(emitter)))) then
           flst_uborn = &
                flst_alr%insert_particle (emitter,n_alr,-flst_alr%flst(n_alr))
        else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
                  is_quark (abs(flst_alr%flst(emitter))) .and. &
                  flst_alr%flst(n_alr) == flst_alr%flst(emitter)) then
           flst_uborn = flst_alr%insert_particle(emitter,n_alr,21)
        end if
     end if
  end function flv_structure_create_uborn

@ %def flv_structure_create_uborn
@
<<fks regions: procedures>>=
  subroutine flv_structure_create_transition (flst1, flst2, list, req)
    type(flv_structure_t), intent(in) :: flst1, flst2
    integer, intent(out), dimension(:), allocatable :: list
    logical, intent(out) :: req
    logical, dimension(:), allocatable :: found
    integer, dimension(:), allocatable :: ref
    integer :: index, n_legs
    integer :: i, j
    if (.not. flst1 == flst2) return
    n_legs = flst1%get_nlegs ()
    allocate (list (n_legs), found (n_legs), ref (n_legs))
    found = .false.
    do i = 1, n_legs
      do j = 1, n_legs
        if (flst1%flst(i) == flst2%flst(j) .and. .not. found (j)) then
          list(i) = j
          found(j) = .true.
          exit
        end if
      end do
      ref(i) = i
    end do
    req = .not. all (list == ref) 
  end subroutine flv_structure_create_transition

@ %def flv_structure_create_transition
@ 
<<fks regions: public>>=
  public :: singular_region_t
<<fks regions: types>>=
  type :: singular_region_t
    integer :: alr
    type(flv_structure_t) :: flst_real
    type(flv_structure_t) :: flst_uborn
    integer :: mult
    integer :: emitter
    integer :: nregions
    type(ftuple_t), dimension(:), allocatable :: flst_allreg
    integer :: uborn_index
  contains
  <<fks regions: singular region: TBP>>
  end type singular_region_t

@ %def singular_region_t
@
<<fks regions: types>>=
  type, abstract :: fks_mapping_t
     real(default) :: sumdij
     real(default) :: sumdij_soft
  contains
  <<fks regions: fks mapping: TBP>>
  end type fks_mapping_t

@ %def fks_mapping_t
@
<<fks regions: public>>=
  public :: fks_mapping_default_t
<<fks regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_default_t
    real(default) :: exp_1, exp_2
  contains
  <<fks regions: fks mapping 1: TBP>>
  end type fks_mapping_default_t

@ %def fks_mapping_default_t
@
<<fks regions: interfaces>>=
  interface operator(==)
    module procedure flv_structure_equivalent
  end interface

@ %def operator_equiv

<<fks regions: public>>=
  public :: region_data_t
<<fks regions: types>>=
  type :: region_data_t
    type(singular_region_t), dimension(:), allocatable :: regions
    type(flv_structure_t), dimension(:), allocatable :: flv_born
    type(flv_structure_t), dimension(:), allocatable :: flv_real
    integer, dimension(:), allocatable :: emitters
    integer :: n_emitters
    integer :: n_flv_born
    integer :: n_flv_real
    integer :: nlegs_born
    integer :: nlegs_real
    type(flavor_t) :: flv_extra
    class(fks_mapping_t), allocatable :: fks_mapping
  contains
  <<fks regions: reg data: TBP>>
  end type region_data_t

@ %def region_data_t
@
<<fks regions: reg data: TBP>>=
  procedure :: init => region_data_init
<<fks regions: procedures>>=
  subroutine region_data_init (reg_data, model, flavor_born, &
                               flavor_real, mapping_type)
    class(region_data_t), intent(inout) :: reg_data
    type(model_t), intent(in) :: model
    integer, intent(inout), dimension(:,:), allocatable :: &
         flavor_born, flavor_real
    integer, intent(in) :: mapping_type
    integer, dimension(:), allocatable :: current_flavor
    type(ftuple_list_t), dimension(:), allocatable :: ftuples
    integer, dimension(:), allocatable :: emitter
    type(flv_structure_t), dimension(:), allocatable :: flst_alr
    integer :: i
    reg_data%n_flv_born = size(flavor_born(1,:))
    reg_data%n_flv_real = size(flavor_real(1,:))
    reg_data%nlegs_born = size(flavor_born(:,1))
    reg_data%nlegs_real = reg_data%nlegs_born + 1
    allocate (reg_data%flv_born (reg_data%n_flv_born))
    allocate (reg_data%flv_real (reg_data%n_flv_real))
    allocate (current_flavor (reg_data%n_flv_born))
    do i = 1, reg_data%n_flv_born
      current_flavor = flavor_born(:,i)
      call reg_data%flv_born(i)%init (current_flavor)
    end do
    deallocate (current_flavor)
    allocate (current_flavor (reg_data%n_flv_real))
    do i = 1, reg_data%n_flv_real
      current_flavor = flavor_real(:,i)
      call reg_data%flv_real(i)%init (current_flavor)
    end do   

    select case (mapping_type)
    case (1)
       allocate (fks_mapping_default_t :: reg_data%fks_mapping)
    case default
       call msg_fatal ("Init region_data: FKS mapping not implemented!")
    end select

    call flavor_init (reg_data%flv_extra, &
                      reg_data%flv_real(1)%flst(reg_data%nlegs_real), &
                      model)
    call reg_data%find_regions (model, ftuples, emitter, flst_alr)
    call reg_data%init_regions (ftuples, emitter, flst_alr)
    call reg_data%find_emitters ()
    call reg_data%write_file
  end subroutine region_data_init

@ %def region_data_init
@ Creates a list containing the emitter of each singular region.
<<fks regions: reg data: TBP>>=
  procedure :: get_emitters => region_data_get_emitters
<<fks regions: procedures>>=
  function region_data_get_emitters (reg_data) result(emitters)
    class(region_data_t), intent(inout) :: reg_data
    integer, dimension(:), allocatable :: emitters
    integer :: i
    allocate (emitters (size (reg_data%regions)))
    do i = 1, size (reg_data%regions)
       emitters(i) = reg_data%regions(i)%emitter
    end do
  end function region_data_get_emitters

@ %def region_data_get_emitters
@ Returns $S_i = \frac{1}{\mathcal{D}d_i}$ or $S_{ij} =
\frac{1}{\mathcal{D}d_{ij}}$ for one particular singular region.  At
this point, the flavor array should be rearranged in such a way that
the emitted particle is at the last position of 
the flavor structure list.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue => region_data_get_svalue
<<fks regions: procedures>>=
  function region_data_get_svalue (reg_data, p, alr, emitter) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(inout), dimension(:), allocatable :: p
    integer, intent(in) :: alr, emitter
    real(default) :: sval
    associate (map => reg_data%fks_mapping) 
      map%sumdij = map%compute_sumdij (reg_data%regions(alr), p)
      sval = map%svalue (p, emitter, reg_data%nlegs_real)
    end associate
  end function region_data_get_svalue

@ %def region_data_get_svalue
@ The same as above, but for the soft limit.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue_soft => region_data_get_svalue_soft
<<fks regions: procedures>>=
  function region_data_get_svalue_soft &
       (reg_data, p, p_soft, alr, emitter) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(inout), dimension(:), allocatable :: p
    type(vector4_t), intent(inout) :: p_soft
    integer, intent(in) :: alr, emitter
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
      map%sumdij_soft = &
      map%compute_sumdij_soft (reg_data%regions(alr), p, p_soft)
      sval = map%svalue_soft (p, p_soft, emitter)
    end associate
  end function region_data_get_svalue_soft

@ %def region_data_get_svalue_soft  
@ This subroutine starts with a specification of $N$- and
$N+1$-particle configurations, [[flst_born]] and [[flst_real]], saved
in [[reg_data]]. From these, it creates a list of fundamental tuples,
a list of emitters and a list containing the $N+1$-particle
configuration, rearranged  in such a way that the emitter-radiation
pair is last ([[flst_alr]]). For the $e^+ \, e^- \, \rightarrow u \,
\bar{u} \, g$- example, the generated objects are shown in table
\ref{table:ftuples and flavors}. Note that at this point, [[flst_alr]]
is arranged in such a way that the emitter can only be equal to
$n_{legs}-1$ for final-state radiation or 0, 1, or 2 for initial-state
radiation. Further, it occurs that regions can be equivalent. For
example in table \ref{table:ftuples and flavors} the regions
correpsonding to \texttt{alr} = 1 and \texttt{alr} = 3 as well as
\texttt{alr} = 2 and \texttt{alr} = 4 describe the same physics and
are therefore equivalent. 
@ 
<<fks regions: reg data: TBP>>=
  procedure :: find_regions => region_data_find_regions
<<fks regions: procedures>>=
  subroutine region_data_find_regions &
       (reg_data, model, ftuples, emitter, flst_alr)
    class(region_data_t), intent(in) :: reg_data
    type(model_t), intent(in) :: model
    type(ftuple_list_t), intent(out), dimension(:), allocatable :: ftuples
    integer, intent(out), dimension(:), allocatable :: emitter
    type(flv_structure_t), intent(out), dimension(:), allocatable :: flst_alr
    type(ftuple_t) :: current_ftuple
    integer, dimension(:), allocatable :: emitter_tmp
    type(flv_structure_t), dimension(:), allocatable :: flst_alr_tmp
    integer :: nreg, nborn, nreal
    integer :: nlegreal
    integer, parameter :: maxnregions = 100
    integer :: i, j, k, l, n

    associate (flv_born => reg_data%flv_born)
      associate (flv_real => reg_data%flv_real)
        nborn = size (flv_born)
        nreal = size (flv_real)
        nlegreal = size (flv_real(1)%flst)
        allocate (ftuples (nreal))
        allocate (emitter_tmp (maxnregions))
        allocate (flst_alr_tmp (maxnregions))
        n = 0

        ITERATE_REAL_FLAVOR: do l = 1, nreal
           call ftuples(l)%init     
<<fks: check final state emissions>>  
<<fks: check initial state emissions>>
        end do ITERATE_REAL_FLAVOR

        nreg = n

      end associate
    end associate

    allocate (flst_alr (nreg))
    allocate (emitter (nreg))
    flst_alr(1:nreg) = flst_alr_tmp(1:nreg)
    emitter(1:nreg) = emitter_tmp(1:nreg)
  end subroutine region_data_find_regions 

@ %def region_data_find_regions
@ First check final state emissions
<<fks: check final state emissions>>=
           do i = 3, nlegreal
             do j = i+1, nlegreal
               do k = 1, nborn
                 if (flv_real(l)%valid_pair(i,j, flv_born(k), model) &
                     .or. flv_real(l)%valid_pair(j,i,flv_born(k), model)) then
                   n = n+1
                   if(flv_real(l)%valid_pair(i,j, flv_born(k), model)) then
                     flst_alr_tmp(n) = create_alr (flv_real(l),i,j)
                   else
                     flst_alr_tmp(n) = create_alr (flv_real(l),j,i)
                   end if
                   call current_ftuple%set (i,j)
                   call ftuples(l)%append (current_ftuple)
                   emitter_tmp(n) = nlegreal - 1
                   exit
                 end if
               end do
             end do
@ Check initial-state emissions. It suffices to just check the
final-state of the first and the initial-state of the second array. 
<<fks: check initial state emissions>>=
             do k = 1, nborn
               if (flv_real(l)%valid_pair(1,i, flv_born(k), model) &
                   .and. flv_real(l)%valid_pair(2,i, flv_born(k), model)) then
                 n = n + 1
                 call current_ftuple%set (0,i)
                 call ftuples(l)%append (current_ftuple)
                 emitter_tmp(n) = 0
                 flst_alr_tmp(n) = create_alr (flv_real(l),0,i)
                 exit
               else if (flv_real(l)%valid_pair(1,i, flv_born(k), model) &
                        .and. .not. &
                        flv_real(l)%valid_pair(2,i, flv_born(k), model)) then
                 n = n+1
                 call current_ftuple%set (1,i)
                 call ftuples(l)%append (current_ftuple)
                 emitter_tmp(n) = 1
                 flst_alr_tmp(n) = create_alr (flv_real(l),1,i)
                 exit
               else if (flv_real(l)%valid_pair(2,i, flv_born(k), model) &
                       .and. .not. &
                       flv_real(l)%valid_pair(1,i, flv_born(k), model)) then
                 n = n+1
                 call current_ftuple%set(2,i)
                 call ftuples(l)%append (current_ftuple)
                 emitter_tmp(n) = 2
                 flst_alr_tmp(n) = create_alr (flv_real(l),2,i)
                 exit
               end if
             end do
           end do
@ Creates singular regions according to table \ref{table:singular
regions}. It scans all regions in table \ref{table:ftuples and
flavors} and records the real flavor structures. If they are
equivalent, the flavor structure is not recorded, but the multiplicity
of the present one is increased.
<<fks regions: reg data: TBP>>=
  procedure :: init_regions => region_data_init_singular_regions
<<fks regions: procedures>>=
  subroutine region_data_init_singular_regions &
       (reg_data, ftuples, emitter, flst_alr)
    class(region_data_t), intent(inout) :: reg_data
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
    type(ftuple_list_t) :: current_region
    integer, intent(in), dimension(:), allocatable :: emitter
    type(flv_structure_t), intent(in), dimension(:), allocatable :: flst_alr
    type(flv_structure_t), dimension(:), allocatable :: flst_uborn, flst_alr2
    integer, dimension(:), allocatable :: mult
    integer, dimension(:), allocatable :: flst_emitter
    integer :: nregions, maxregions
    integer, dimension(:,:), allocatable :: perm_list
    integer, dimension(:), allocatable :: index
    integer :: i, j, k, l
    integer :: nlegs 
    logical :: equiv
    integer :: nreg, i1, i2
    integer :: i_first, j_first
    integer, dimension(:), allocatable :: &
         region_to_ftuple, ftuple_limits, k_index

    maxregions = size (emitter)
    nlegs = size(flst_alr(1)%flst)

    allocate (flst_uborn (maxregions))
    allocate (flst_alr2 (maxregions))
    allocate (mult (maxregions))
    allocate (flst_emitter (maxregions))
    allocate (index (maxregions))
    allocate (region_to_ftuple (maxregions))
    allocate (ftuple_limits (size (ftuples)))
    allocate (k_index (maxregions))

    mult = 0

    do i = 1, size(ftuples)
      ftuple_limits(i) = ftuples(i)%get_n_tuples ()
    end do
    if (.not. (sum (ftuple_limits) == maxregions)) &
         call msg_fatal ("Too many regions!")
    k = 1
    do j =1, size(ftuples)
      do i = 1, ftuple_limits(j)
        region_to_ftuple(k) = i
        k = k + 1
      end do
    end do
    i_first = 1
    j_first = 1
    j = 1
    SCAN_REGIONS: do l = 1, size(ftuples)
    SCAN_FTUPLES: do i = i_first, i_first + ftuple_limits (l) -1 
      equiv = .false.
      if (i==i_first) then
        flst_alr2(j)%flst = flst_alr(i)%flst
        mult(j) = mult(j) + 1
        flst_uborn(j) = flst_alr(i)%create_uborn (emitter(i))
        flst_emitter(j) = emitter(i)
        index (j) = region_to_index(ftuples, i)
        k_index (j) = region_to_ftuple(i)
        j = j+1
      else
        !!! Check for equivalent flavor structures
        do k =j_first ,j-1
           if (emitter(i) == emitter(k) .and. emitter(i) > 2) then
             if (flst_alr(i) == flst_alr2(k) .and. &
                 flst_alr(i)%flst(nlegs-1) == flst_alr2(k)%flst(nlegs-1) &
                 .and. flst_alr(i)%flst(nlegs) == flst_alr2(k)%flst(nlegs)) then
                   mult(k) = mult(k) + 1
                   equiv = .true.
                   call ftuples (region_to_index(ftuples, i))%set_equiv &
                        (k_index(k), region_to_ftuple(i))
                   exit
              end if
           else if (emitter(i) == emitter(k) .and. emitter(i) <= 2) then
             if (flst_alr(i) == flst_alr2(k)) then
               mult(k) = mult(k) + 1
               equiv = .true.
               call ftuples (region_to_index(ftuples,i))%set_equiv &
                    (k_index(k), region_to_ftuple(i))
               exit
             end if
          end if
        end do
        if (.not.equiv) then
          flst_alr2(j)%flst = flst_alr(i)%flst
          mult(j) = mult(j) + 1
          flst_uborn(j) = flst_alr(i)%create_uborn (emitter(i))
          flst_emitter(j) = emitter(i)
          index (j) = region_to_index (ftuples, i)
          k_index (j) = region_to_ftuple(i)
          j = j+1
        end if
      end if
    end do SCAN_FTUPLES
    i_first = i_first + ftuple_limits(l)
    j_first = j_first + j - 1
    end do SCAN_REGIONS
    nregions = j-1
    allocate (reg_data%regions (nregions))
    do j = 1, nregions
      do i = 1, reg_data%n_flv_born
        if (reg_data%flv_born (i) == flst_uborn (j)) then
          reg_data%regions(j)%uborn_index = i
          if (allocated (perm_list)) then
            deallocate (perm_list)
          end if
          call fks_permute_born &
               (reg_data%flv_born (i), flst_uborn (j), perm_list)
          call fks_apply_perm (flst_alr2(j), flst_emitter(j), perm_list)
        end if
      end do
    end do
    !!! Check if new emitters require a rearrangement of ftuples
    do i = 1, nregions
      reg_data%regions(i)%alr = i
      reg_data%regions(i)%flst_real = flst_alr2(i)
      reg_data%regions(i)%mult = mult(i)
      reg_data%regions(i)%flst_uborn = flst_uborn(i)
      reg_data%regions(i)%emitter = flst_emitter(i)
      nreg = ftuples (index(i))%get_n_tuples ()
      reg_data%regions(i)%nregions = nreg
      allocate (reg_data%regions(i)%flst_allreg (nreg))
      do j = 1, nreg
        current_region = ftuples (index(i))%get_entry (j)
        if (.not. associated (current_region%equiv)) then
          call current_region%ftuple%get (i1, i2)
          if (i2 /= nlegs) &
             call current_region%ftuple%set (i1, nlegs)
          ! if (i2 /= nlegs) then
          !   call current_region%ftuple%set (flst_emitter(i), nlegs)
          ! end if
        end if
        reg_data%regions(i)%flst_allreg (j) = current_region%ftuple
      end do
    end do
    !!! Find underlying Born index
    do j = 1, nregions
      do i = 1, reg_data%n_flv_born
        if (reg_data%flv_born (i) == reg_data%regions(j)%flst_uborn) then
          reg_data%regions(j)%uborn_index = i
          exit
        end if
      end do
    end do
  end subroutine region_data_init_singular_regions

@ %def region_data_init_singular_regions
@ Create an array containing all emitters of a singular region.
<<fks regions: reg data: TBP>>=
  procedure :: find_emitters => region_data_find_emitters
<<fks regions: procedures>>=
  subroutine region_data_find_emitters (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i, j, n
    integer :: em
    integer, dimension(10) :: em_count
    em_count = 0
    n = 0

@ %def region_data_find_emitters
@ Count the number of different emitters.
<<fks regions: procedures>>=
    do i = 1, size (reg_data%regions)
      em = reg_data%regions(i)%emitter
      if (.not. any (em_count == em)) then
        n = n+1
        em_count(i) = em
      end if
    end do

    if (n < 1) call msg_fatal ("region_data_find_emitters: No emitters found")
    reg_data%n_emitters = n
    allocate (reg_data%emitters (reg_data%n_emitters))
    reg_data%emitters = 0

    j = 1
    do i = 1, size(reg_data%regions)
      em = reg_data%regions(i)%emitter
      if (.not. any (reg_data%emitters == em)) then
        reg_data%emitters(j) = em
        j = j+1
      end if
    end do
  end subroutine region_data_find_emitters

@ %def region_data_find_emitters
@
<<fks regions: reg data: TBP>>=
  procedure :: get_nregions => region_data_get_nregions
<<fks regions: procedures>>=
  function region_data_get_nregions (reg_data) result (nregions)
    class(region_data_t), intent(in) :: reg_data
    integer :: nregions
    nregions = size(reg_data%regions) 
  end function region_data_get_nregions

@ %def region_data_get_nregions
@
<<fks regions: reg data: TBP>>=
  procedure :: write_regions => region_data_write_regions
<<fks regions: procedures>>=
  subroutine region_data_write_regions (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: n, i, j
    n = size(reg_data%regions)
    associate (regions => reg_data%regions)
      do i = 1, n
        print *, i, '//', regions(i)%flst_real%flst, '//', &
             regions(i)%mult ,'//', regions(i)%flst_uborn%flst , &
                    '//', regions(i)%emitter
        do j = 1, size (regions(i)%flst_allreg)
          call regions(i)%flst_allreg(j)%write
        end do
      end do
    end associate
  end subroutine region_data_write_regions

@ %def region_data_write_regions  
@ Creates a table with information about all singular regions and
writes it to a file. 
<<fks regions: reg data: TBP>>=
  procedure :: write_file => region_data_write_file
<<fks regions: procedures>>=
  subroutine region_data_write_file (reg_data, proc)
    class(region_data_t), intent(inout) :: reg_data
    type(string_t), intent(inout), optional :: proc
    integer :: u, i, j
    integer :: nreal, nborn
    integer :: i1, i2, nreg
    integer :: maxnregions, nreg_diff
    integer :: nleft, nright
    type(singular_region_t) :: region
    character(len=7) :: flst_format = "(I3,A1)"
    character(len=10) :: sep_format = "(1X,A2,1X)"
    character(len=16) :: ireg_format = "(A1,I3,A1,I3,A3)"
    character(len=7) :: ireg_space_format = "(7X,A1)"
    u = free_unit ()
    open (u, file="region_data.log", action = "write", status="replace")
    maxnregions = 1
    do j = 1, size (reg_data%regions)
      if (reg_data%regions(j)%nregions > maxnregions) &
           maxnregions = reg_data%regions(j)%nregions
    end do
    write (u,*) 'Total number of regions: ', size(reg_data%regions)
    write (u, '(A6)', advance = 'no') 'alr'
    write (u, sep_format, advance = 'no') '||'
    write (u, '(A12)', advance = 'no') 'flst_real'
    write (u, sep_format, advance = 'no') '||'
    write (u, '(A4)', advance = 'no') 'em'
    write (u, sep_format, advance = 'no') '||'
    write (u, '(A6)', advance = 'no') 'mult'
    write (u, sep_format, advance = 'no') '||'
    write (u, '(A12)') 'flst_born'
    do j = 1, size (reg_data%regions)
      region = reg_data%regions(j)
      nreal = size (region%flst_real%flst)
      nborn = size (region%flst_uborn%flst)
      write (u, '(I3)', advance = 'no') j
      write (u, sep_format, advance = 'no') '||'
      write (u, '(A1)', advance = 'no') '['
      do i = 1, nreal-1
        write (u, flst_format, advance = 'no') region%flst_real%flst(i), ','
      end do
      write (u, flst_format, advance = 'no') region%flst_real%flst(nreal), ']'
      write (u, sep_format, advance = 'no') '||'
      write (u, '(I3)', advance = 'no') region%emitter
      write (u, sep_format, advance = 'no') '||'
      write (u, '(I3)', advance = 'no') region%mult
      write (u, sep_format, advance = 'no') '||'
      write (u, '(I3)', advance = 'no') region%nregions
      write (u, sep_format, advance = 'no') '||'
      !!! write ftuples
      nreg = region%nregions
      if (nreg == maxnregions) then
        nleft = 0
        nright = 0
      else
        nreg_diff = maxnregions - nreg
        nleft = nreg_diff/2
        if (mod(nreg_diff,2) == 0) then
          nright = nleft
        else
          nright = nleft + 1
        end if
      end if
      if (nleft > 0) then
        do i=1,nleft
          write(u,ireg_space_format, advance='no') ' '
        end do
      end if
      write(u,'(A1)', advance = 'no') '{'
      if (nreg > 1) then
        do i=1,nreg-1
          call region%flst_allreg(i)%get (i1, i2)
          write(u,ireg_format,advance = 'no') '(', i1, ',', i2, '),'
        end do
      end if
      call region%flst_allreg(nreg)%get (i1, i2) 
      write(u,ireg_format,advance = 'no') '(', i1, ',', i2, ')}' 
      if (nright > 0) then
        do i=1,nright
          write(u,ireg_space_format, advance='no') ' '
        end do
      end if
      !!! end write ftuples
      write(u,sep_format,advance = 'no') '||'
      write(u,'(A1)',advance = 'no') '['
      do i=1,nborn-1
        write(u,flst_format,advance = 'no') region%flst_uborn%flst(i), ','
      end do
      write(u,flst_format, advance = 'no') region%flst_uborn%flst(nborn), ']'
      write(u,*) ''
    end do
    close (u)
  end subroutine region_data_write_file

@ %def region_data_write_file
@ Returns the index of the real flavor structure an ftuple belongs to.
<<fks regions: procedures>>=
  function region_to_index (list, i) result(index)
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: list
    integer, intent(in) :: i
    integer :: index
    integer :: nlist
    integer :: j
    integer, dimension(:), allocatable :: nreg
    nlist = size(list)
    allocate (nreg (nlist))
    do j = 1, nlist
      if (j == 1) then
        nreg(j) = list(j)%get_n_tuples ()
      else
        nreg(j) = nreg(j-1) + list(j)%get_n_tuples ()
      end if
    end do
    do j = 1, nlist
      if (j == 1) then
        if (i <= nreg(j)) then
          index = j
          exit
        end if
      else
        if (i > nreg(j-1) .and. i <= nreg(j)) then
          index = j
          exit
        end if
      end if
    end do
  end function region_to_index

@ %def region_to_index
@ Rearrange the flavor array in such a way that the emitted particle
is last and the emitter is second last. [[i1]] is the index of the
emitter, [[i2]] is the index of the emitted particle. Only works for
final-state emitters. 
<<fks regions: procedures>>=
  function create_alr (flv1,i1,i2) result(flv2)
    type(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: i1, i2
    type(flv_structure_t) :: flv2
    integer :: n, i, j
    n = size (flv1%flst)
    allocate (flv2%flst (n))
    if (i1 > 2) then
      flv2%flst(1:2) = flv1%flst(1:2)
      flv2%flst(n-1) = flv1%flst(i1)
      flv2%flst(n) = flv1%flst(i2)
@ Order remaining particles according to their original position
<<fks regions: procedures>>=
      j = 3
      do i = 3,n
        if (i /= i1 .and. i /= i2) then
          flv2%flst(j) = flv1%flst(i)
          j = j+1
        end if
      end do
    else
      call msg_fatal ("Create alr: Only works for final-state emissions!")
    end if
  end function create_alr

@ %def create_alr
@ Explain
<<fks regions: procedures>>=
  subroutine fks_permute_born (flv_in, flv_out, perm_list)
    type(flv_structure_t), intent(in) :: flv_in
    type(flv_structure_t), intent(inout) :: flv_out
    integer, intent(out), dimension(:,:), allocatable :: perm_list
    integer, dimension(:,:), allocatable :: perm_list_tmp
    integer :: n_perms, n_perms_max
    integer :: nlegs
    integer :: flv1, flv2, tmp
    integer :: i, j, j_min
    n_perms_max = 100 
    !!! actually (n-1)!, but there seems to be no intrinsic function 
    !!! of this type in fortran
    if (allocated (perm_list_tmp)) deallocate (perm_list_tmp)
    allocate (perm_list_tmp (n_perms_max,2))
    n_perms = 0
    j_min = 3
    nlegs = size (flv_in%flst)
      do i = 3, nlegs
        flv1 = flv_in%flst(i)
        do j = j_min, nlegs
          flv2 = flv_out%flst(j)
          if (flv1 == flv2 .and. i /= j) then
            n_perms = n_perms + 1
            tmp = flv_out%flst(i)
            flv_out%flst(i) = flv2
            flv_out%flst(j) = tmp
            perm_list_tmp (n_perms, 1) = j
            perm_list_tmp (n_perms, 2) = i
            j_min = j_min + 1
            exit
          end if
        end do
      end do
      allocate (perm_list (n_perms, 2))
      perm_list (1:n_perms, :) = perm_list_tmp (1:n_perms, :)
  end subroutine fks_permute_born

@ %def fks_permute_born
@ Explain
<<fks regions: procedures>>=
  subroutine fks_apply_perm (flv, emitter, perm_list)
    type(flv_structure_t), intent(inout) :: flv
    integer, intent(inout) :: emitter
    integer, intent(in), dimension(:,:), allocatable :: perm_list
    integer :: i
    integer :: i1, i2
    integer :: tmp
    do i = 1, size (perm_list (:,1))
      i1 = perm_list (i,1)
      i2 = perm_list (i,2)
      tmp = flv%flst (i1)
      flv%flst (i1) = flv%flst (i2)
      flv%flst (i2) = tmp
      if (i1 == emitter) emitter = i2
    end do
  end subroutine fks_apply_perm

@ %def fks_apply_perm
@ Translates the tree code of the emitter branch into the position of
the emitter in the flavor structure array. 
<<fks regions: public>>=
  public :: fks_tree_to_position
<<fks regions: procedures>>=
  function fks_tree_to_position (k, n_tot) result(pos)
    integer, intent(in) :: k, n_tot
    integer :: pos
    integer :: k_tot
    k_tot = 2**(n_tot - 1)
    !!! Inital-state particles
    if (k == k_tot) then
       pos = 1
    else if (k == k_tot/2) then
       pos = 2
       !!! Final-state particles
    else
       ! pos = 3 + nint(log(k)/log(2))
       pos = 3 + dual_log (k)
    end if
  contains
    recursive function dual_log (x) result (ld) 
      integer, intent(in) :: x
      integer :: ld
      if (x == 1) then
        ld = 0
      else
        ld = 1 + dual_log (x/2)
      end if
    end function dual_log 
  end function fks_tree_to_position
@ %def fks_tree_to_position
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij), deferred :: dij
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij (map, p, i, j) result (d)
      import
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      real(default) :: d
    end function fks_mapping_dij
  end interface

@ %def fks_mapping_dij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij), deferred :: compute_sumdij
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_compute_sumdij (map, sregion, p) result (d)
      import
      class(fks_mapping_t), intent(in) :: map
      type(singular_region_t), intent(inout) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p
      real(default) :: d
    end function fks_mapping_compute_sumdij
  end interface

@ %def fks_mapping_compute_sumdij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue), deferred :: svalue
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue (map, p, i, j) result (value)
      import
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      real(default) :: value
    end function fks_mapping_svalue
  end interface

@ %def fks_mapping_svalue
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij_soft), deferred :: dij_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij_soft (map, p_born, p_soft, em) result (d)
      import
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      real(default) :: d
    end function fks_mapping_dij_soft
  end interface

@ %def fks_mapping_dij_soft
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij_soft), deferred :: compute_sumdij_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_compute_sumdij_soft (map, sregion, p_born, p_soft) result (d)
      import
      class(fks_mapping_t), intent(in) :: map
      type(singular_region_t), intent(inout) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      real(default) :: d
    end function
  end interface
@ %def fks_mapping_compute_sumdij_soft
@ 
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue_soft), deferred :: svalue_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue_soft (map, p_born, p_soft, em) result (value)
      import
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      real(default) :: value
    end function fks_mapping_svalue_soft
  end interface

@ %def fks_mapping_svalue_soft
@
<<fks regions: fks mapping 1: TBP>>=
  procedure :: set_parameter => fks_mapping_default_set_parameter
<<fks regions: procedures>>=
  subroutine fks_mapping_default_set_parameter (map, dij_exp1, dij_exp2)
    class(fks_mapping_default_t), intent(inout) :: map
    real(default), intent(in) :: dij_exp1, dij_exp2
    map%exp_1 = dij_exp1
    map%exp_2 = dij_exp2
  end subroutine fks_mapping_default_set_parameter

@ %def fks_mapping_default_set_parameter
@
<<fks regions: fks mapping 1: TBP>>=
  procedure :: dij => fks_mapping_default_dij
<<fks regions: procedures>>=
  function fks_mapping_default_dij (map, p, i, j) result (d)
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    real(default) :: d
    real(default) :: sqrts
    real :: y
    real :: E1, E2

    if (i /= j .and. (i > 2 .or. j > 2)) then
      if (i == 0 .or. j == 0) then
        if (j == 0) then
          E1 = energy (p(i))
          y = polar_angle_ct (p(i))
        else
          E1 = energy (p(j))
          y = polar_angle_ct(p(j))
        end if
        d = (E1**2 * (1-y**2))**map%exp_2
      else
        E1 = energy(p(i))
        E2 = energy(p(j))
        y = enclosed_angle_ct (p(i), p(j))
        sqrts = (p(1)+p(2))**1
        d = (2*p(i)*p(j) * E1*E2 / (E1 + E2)**2)**map%exp_1
      end if  
    else if (i == j) then
      call msg_fatal ("Invalid FKS region: Emitter equals FKS parton!")
    else
      !!! case i,j <= 2 not yet implemented
      d = 0
    end if
  end function fks_mapping_default_dij

@  %def fks_mapping_default_dij
@ 
<<fks regions: fks mapping 1: TBP>>=
  procedure :: compute_sumdij => fks_mapping_default_compute_sumdij
<<fks regions: procedures>>=
  function fks_mapping_default_compute_sumdij (map, sregion, p) result (d)
    class(fks_mapping_default_t), intent(in) :: map
    type(singular_region_t), intent(inout) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: d
    integer :: i, k, l

    associate (ftuples => sregion%flst_allreg)
      d = 0
      do i = 1, sregion%nregions
        call ftuples(i)%get (k, l)
        d = d + 1.0/map%dij (p, k, l)
      end do
    end associate

  end function fks_mapping_default_compute_sumdij

@ %def fks_mapping_default_compute_sumdij
@ 
<<fks regions: fks mapping 1: TBP>>=
  procedure :: svalue => fks_mapping_default_svalue
<<fks regions: procedures>>=
  function fks_mapping_default_svalue (map, p, i, j) result (value)
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    real(default) :: value
    value = 1._default / (map%dij (p, i, j) * map%sumdij)
  end function fks_mapping_default_svalue

@ %def fks_mapping_default_svalue
@
<<fks regions: fks mapping 1: TBP>>=
  procedure :: dij_soft => fks_mapping_default_dij_soft
<<fks regions: procedures>>=
  function fks_mapping_default_dij_soft (map, p_born, p_soft, em) result (d)
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    real(default) :: d
    d = (2*p_born(em)*p_soft / energy(p_born(em)))**map%exp_1
  end function fks_mapping_default_dij_soft

@ %def fks_mapping_default_dij_soft
@
<<fks regions: fks mapping 1: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_default_compute_sumdij_soft
<<fks regions: procedures>>=
  function fks_mapping_default_compute_sumdij_soft (map, sregion, p_born, p_soft) result (d)
    class(fks_mapping_default_t), intent(in) :: map
    type(singular_region_t), intent(inout) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    integer :: i, k, l
    integer :: nlegs
    d = 0
    nlegs = size (sregion%flst_real%flst)
    associate (ftuples => sregion%flst_allreg)
      do i = 1, sregion%nregions
        call ftuples(i)%get (k,l)
        if (l == nlegs) then
          d = d + 1._default/map%dij_soft (p_born, p_soft, k)
        end if
      end do
    end associate
  end function fks_mapping_default_compute_sumdij_soft

@ %def fks_mapping_default_compute_sumdij_soft
@
<<fks regions: fks mapping 1: TBP>>=
  procedure :: svalue_soft => fks_mapping_default_svalue_soft
<<fks regions: procedures>>=
  function fks_mapping_default_svalue_soft (map, p_born, p_soft, em) result (value)
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    real(default) :: value
    value = 1._default/(map%sumdij_soft*map%dij_soft (p_born, p_soft, em))
  end function fks_mapping_default_svalue_soft

@ %def fks_mapping_default_svalue_soft
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The FKS phase space}
To handle the FKS phase space and adapt it to multi-channel
integration, some extensions have to be made for pre-existing types. 
The \texttt{phs\_tree}-type has an attribute containing the tree-code
of the emitting branch.  
<<PHS trees: phs tree: TBP>>=
  procedure :: get_emitter => phs_tree_get_emitter
<<PHS trees: procedures>>=
  function phs_tree_get_emitter (tree) result (emitter)
    class(phs_tree_t), intent(in) :: tree
    integer :: emitter
    emitter = tree%emitter
  end function phs_tree_get_emitter

@ %def phs_tree_get_emitter
@ 
<<[[phs_fks.f90]]>>=
<<File header>>

module phs_fks
  
<<Use kinds>>
<<Use strings>>
  use constants
  use diagnostics
  use lorentz
  use models
  use flavors
  use sf_mappings
  use sf_base
  use phs_base
  use phs_wood
  use process_constants

<<Standard module head>>

<<phs fks: public>>

<<phs fks: types>>

contains

<<phs fks: procedures>>

end module phs_fks

@ %def phs_fks
@
<<phs fks: public>>=
  public :: phs_fks_config_t
<<phs fks: types>>=
  type, extends (phs_wood_config_t) :: phs_fks_config_t
  contains
  <<phs fks: fks config: TBP>>
  end type phs_fks_config_t

@ %def phs_fks_config_t
<<phs fks: fks config: TBP>>=
  procedure :: final => phs_fks_config_final
<<phs fks: procedures>>=
  subroutine phs_fks_config_final (object)
    class(phs_fks_config_t), intent(inout) :: object
!    call object%phs_wood_config_t%final ()
  end subroutine phs_fks_config_final
 
@ %def phs_fks_config_final
@
<<phs fks: fks config: TBP>>=
  procedure :: write => phs_fks_config_write
<<phs fks: procedures>>=
  subroutine phs_fks_config_write (object, unit)
    class(phs_fks_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call object%phs_wood_config_t%write
  end subroutine phs_fks_config_write

@ %def phs_fks_config_write
@
<<phs fks: fks config: TBP>>=
  procedure :: configure => phs_fks_config_configure
<<phs fks: procedures>>=
  subroutine phs_fks_config_configure (phs_config, sqrts, &
        sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, &
        ignore_mismatch, nlo_type)
    class(phs_fks_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(string_t), intent(inout), optional :: nlo_type
    if (present (nlo_type)) then
      if (nlo_type /= 'Real') & 
        call msg_fatal ("FKS config has to be called with nlo_type = 'Real'")
    end if 
    phs_config%n_par = phs_config%n_par + 3
!!! Channel equivalences not accessible yet
    phs_config%provides_equivalences = .false.
  end subroutine phs_fks_config_configure

@ %def phs_fks_config_configure
@
<<phs fks: fks config: TBP>>=
  procedure :: startup_message => phs_fks_config_startup_message
<<phs fks: procedures>>=
  subroutine phs_fks_config_startup_message (phs_config, unit)
    class(phs_fks_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%phs_wood_config_t%startup_message
  end subroutine phs_fks_config_startup_message

@ %def phs_fks_config_startup_message
@
<<phs fks: fks config: TBP>>=
  procedure, nopass :: allocate_instance => phs_fks_config_allocate_instance
<<phs fks: procedures>>=
  subroutine phs_fks_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_fks_t :: phs)
  end subroutine phs_fks_config_allocate_instance

@ %def phs_fks_config_allocate_instance
@ 
<<phs fks: fks config: TBP>>=
  procedure :: set_born_config => phs_fks_config_set_born_config
<<phs fks: procedures>>=
  subroutine phs_fks_config_set_born_config (phs_config, phs_cfg_born)
    class(phs_fks_config_t), intent(inout) :: phs_config
    type(phs_wood_config_t), intent(in), target :: phs_cfg_born
    phs_config%forest = phs_cfg_born%forest
    phs_config%n_channel = phs_cfg_born%n_channel
    phs_config%n_par = phs_cfg_born%n_par
    phs_config%sqrts = phs_cfg_born%sqrts
    phs_config%par = phs_cfg_born%par
    phs_config%sqrts_fixed = phs_cfg_born%sqrts_fixed
    phs_config%azimuthal_dependence = phs_cfg_born%azimuthal_dependence
    phs_config%provides_chains = phs_cfg_born%provides_chains
    phs_config%chain = phs_cfg_born%chain
  end subroutine phs_fks_config_set_born_config

@ %def phs_fks_config_set_born_config
@ Keep score about the real kinematics.
<<phs fks: public>>=
  public :: kinematics_counter_t
<<phs fks: types>>=
  type :: kinematics_counter_t
     integer :: n_bins = 0
     integer, dimension(:), allocatable :: histo_xi
     integer, dimension(:), allocatable :: histo_xi_tilde
     integer, dimension(:), allocatable :: histo_xi_max 
     integer, dimension(:), allocatable :: histo_y
     integer, dimension(:), allocatable :: histo_phi
  contains
<<phs fks: kinematics counter: TBP>>
  end type kinematics_counter_t

@ %def kinematics_counter_t
@
<<phs fks: kinematics counter: TBP>>=
  procedure :: init => kinematics_counter_init
<<phs fks: procedures>>=
  subroutine kinematics_counter_init (counter, n_bins)
    class(kinematics_counter_t), intent(inout) :: counter
    integer, intent(in) :: n_bins
    counter%n_bins = n_bins
    allocate (counter%histo_xi (n_bins), counter%histo_xi_tilde (n_bins))
    allocate (counter%histo_y (n_bins), counter%histo_phi (n_bins))
    allocate (counter%histo_xi_max (n_bins))
    counter%histo_xi = 0
    counter%histo_xi_tilde = 0
    counter%histo_xi_max = 0
    counter%histo_y = 0
    counter%histo_phi = 0
  end subroutine kinematics_counter_init

@ %def kinematics_counter_init
@ 
<<phs fks: kinematics counter: TBP>>=
  procedure :: record => kinematics_counter_record
<<phs fks: procedures>>=
  subroutine kinematics_counter_record (counter, xi, xi_tilde, &
                                        xi_max, y, phi)
     class(kinematics_counter_t), intent(inout) :: counter
     real(default), intent(in), optional :: xi, xi_tilde, xi_max
     real(default), intent(in), optional :: y, phi
 
     if (counter%n_bins > 0) then
       if (present (xi)) then
          call fill_histogram (counter%histo_xi, xi, &
                               0.0_default, 1.0_default)
       end if
       if (present (xi_tilde)) then
          call fill_histogram (counter%histo_xi_tilde, xi_tilde, &
                               0.0_default, 1.0_default)
       end if
       if (present (xi_max)) then
          call fill_histogram (counter%histo_xi_max, xi_max, &
                               0.0_default, 1.0_default)
       end if
       if (present (y)) then
          call fill_histogram (counter%histo_y, y, -1.0_default, 1.0_default)
       end if
       if (present (phi)) then
          call fill_histogram (counter%histo_phi, phi, 0.0_default, twopi)
       end if
     end if
  contains
     subroutine fill_histogram (histo, value, val_min, val_max)
        integer, dimension(:), allocatable :: histo
        real(default), intent(in) :: value, val_min, val_max
        real(default) :: step, lo, hi
        integer :: bin
        step = (val_max-val_min) / counter%n_bins
        do bin = 1, counter%n_bins
           lo = (bin-1) * step
           hi = bin * step
           if (value >= lo .and. value < hi) then
               histo (bin) = histo (bin) + 1
               exit
           end if
        end do
     end subroutine fill_histogram
  end subroutine kinematics_counter_record

@ %def kinematics_counter_record
<<phs fks: kinematics counter: TBP>>=
  procedure :: display => kinematics_counter_display
<<phs fks: procedures>>=
  subroutine kinematics_counter_display (counter)
     class(kinematics_counter_t), intent(in) :: counter
     print *, 'xi: ', counter%histo_xi
     print *, 'xi_tilde: ', counter%histo_xi_tilde
     print *, 'xi_max: ', counter%histo_xi_max
     print *, 'y: ', counter%histo_y
     print *, 'phi: ', counter%histo_phi
  end subroutine kinematics_counter_display

@ %def kinematics_counter_display
@ The fks phase space type contains the wood phase space and
separately the in- and outcoming momenta for the real process and the
corresponding Born momenta. Additionally, there are the variables
$\xi$,$\xi_{max}$, $y$ and $\phi$ which are used to create the real
phase space, as well as the jacobian and its corresponding soft and
collinear limit. Lastly, the array \texttt{ch\_to\_em} connects each
channel with an emitter.
<<phs fks: public>>=
  public :: phs_fks_t
<<phs fks: types>>=
  type, extends (phs_wood_t) :: phs_fks_t
    type(vector4_t), dimension(:), allocatable :: p_born
    type(vector4_t), dimension(:), allocatable :: q_born
    type(vector4_t), dimension(:), allocatable :: p_real
    type(vector4_t), dimension(:), allocatable :: q_real
    real(default), dimension(3) :: r_real
    real(default) :: xi_tilde, y, phi
    real(default), dimension(:), allocatable :: xi_max
    real(default), dimension(3) :: jac
    real(default) :: jac_rand
    integer, dimension(:), allocatable :: emitters
    type(kinematics_counter_t) :: counter
  contains
<<phs fks: phs fks: TBP>>
  end type phs_fks_t

@ %def phs_fks_t
@ Initializer for the phase space. Calls the initialization of the
corresponding Born phase space, sets up the
channel-emitter-association and allocates space for the momenta.  
<<phs fks: phs fks: TBP>>=
  procedure :: init => phs_fks_init
<<phs fks: procedures>>=
  subroutine phs_fks_init (phs, phs_config)
    class(phs_fks_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config


    call phs%base_init (phs_config)
    select type (phs_config)
    type is (phs_fks_config_t)
       phs%config => phs_config
       phs%forest = phs_config%forest
    end select
!!!    allocate (phs%f (phs%config%n_channel)); phs%f = 0._default
    deallocate (phs%r)
    allocate (phs%r (phs%config%n_par-3, phs%config%n_channel)); phs%r = 0

    select type(phs)
    type is (phs_fks_t)
      call phs%init_momenta (phs_config)
      allocate (phs%xi_max (phs_config%n_tot))
      phs%xi_max = 0._default
      phs%jac_rand = 1._default
    end select
  end subroutine phs_fks_init

@ %def phs_fks_init
@
<<phs fks: phs fks: TBP>>=
  procedure :: final => phs_fks_final
<<phs fks: procedures>>=
  subroutine phs_fks_final (object)
    class(phs_fks_t), intent(inout) :: object
  end subroutine phs_fks_final

@ %def phs_fks_final
@
<<phs fks: phs fks: TBP>>=
  procedure :: init_momenta => phs_fks_init_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_init_momenta (phs, phs_config)
    class(phs_fks_t), intent(inout) :: phs
    class(phs_config_t), intent(in) :: phs_config
    allocate (phs%p_born (phs_config%n_in))
    allocate (phs%q_born (phs_config%n_out-1))
    allocate (phs%p_real (phs_config%n_in))
    allocate (phs%q_real (phs_config%n_out-1))
  end subroutine phs_fks_init_momenta

@ %def phs_fks_init_momenta
@ Evaluate selected channel. First, the subroutine calls the
evaluation procedure of the underlying Born phase space, using $n_r -
3$ random numbers. Then, the remaining three random numbers are used
to create $\xi$, $y$ and $\phi$, from which the real momenta are
calculated from the Born momenta. 
<<phs fks: phs fks: TBP>>=
  procedure :: evaluate_selected_channel => phs_fks_evaluate_selected_channel
<<phs fks: procedures>>=
  subroutine phs_fks_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    integer :: em 
    type(vector4_t), dimension(:), allocatable :: p_born_tot
    real(default), dimension(:), allocatable :: r_born
    integer :: n_r_born
    type (vector4_t), dimension(:), allocatable :: p_real_tot
    real(default) :: phi
    real(default) :: sqrts_beam
    integer :: n_in, n_out, n_tot
    real(default), parameter :: xi_min = 1d-5, y_max = 1.0
    real(default), parameter :: tiny_y = 1d-5
 
    n_r_born = size(r_in) - 3
    allocate (r_born (n_r_born))
    r_born = r_in(1:n_r_born)
    call phs%phs_wood_t%evaluate_selected_channel (c_in, r_born)
    phs%p_born = phs%phs_wood_t%p
    phs%q_born = phs%phs_wood_t%q
    n_in = size (phs%p_born)
    n_out = size(phs%q_born)
    n_tot = n_in + n_out
    allocate (p_born_tot (n_tot))
    p_born_tot (1:n_in) = phs%p_born
    p_born_tot (n_in+1:) = phs%q_born

    !!! Jacobian corresponding to the transformation rand -> (xi, y, phi)
    phs%jac_rand = 1.0
    !!! Produce real momentum
    phs%y = (1 -2*r_in (n_r_born+2))*y_max
    phs%jac_rand = phs%jac_rand * 3 * (1-phs%y**2)
    phs%y = 1.5_default * (phs%y - phs%y**3/3)
    phs%phi = r_in (n_r_born+3)*twopi
    phs%xi_tilde = xi_min + r_in (n_r_born+1)*(1-xi_min)
    phs%jac_rand = phs%jac_rand * (1-xi_min)       
    do em = 1, phs%config%n_tot
      if (any (phs%emitters == em)) then
         phs%xi_max (em) = fks_get_xi_max_fsr (p_born_tot, em)
      end if
    end do
    phs%f(c_in) = phs%f(c_in) * phs%jac_rand

    phs%volume = phs%volume * phs%config%sqrts**2 / (8*twopi2)
    phs%r(:,c_in) = r_in(1:n_r_born)
    phs%r_real = r_in (n_r_born+1:)
  end subroutine phs_fks_evaluate_selected_channel

@ %def phs_fks_evaluate_selected_channel
@
<<phs fks: phs fks: TBP>>=
  procedure :: evaluate_other_channels => phs_fks_evaluate_other_channels
<<phs fks: procedures>>=
  subroutine phs_fks_evaluate_other_channels (phs, c_in)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    integer :: c, em
    call phs%phs_wood_t%evaluate_other_channels (c_in)
    do c = 1, size (phs%f)
      if (c == c_in) cycle
      phs%f(c) = phs%f(c) * phs%jac_rand
    end do
    phs%r_defined = .true.
  end subroutine phs_fks_evaluate_other_channels

@ %def phs_fks_evaluate_other_channels
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_mcpar => phs_fks_get_mcpar
<<phs fks: procedures>>=
  subroutine phs_fks_get_mcpar (phs, c, r)
    class(phs_fks_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default), dimension(:), intent(out) :: r
    integer :: n_r_born 
    n_r_born = size (phs%r(:,c))
    r(1:n_r_born) = phs%r(:,c)
    r(n_r_born+1:) = phs%r_real
  end subroutine phs_fks_get_mcpar

@ %def phs_fks_get_mcpar
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_real_kinematics => phs_fks_get_real_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_get_real_kinematics (phs, xit, y, phi, xi_max, jac)
    class(phs_fks_t), intent(inout) :: phs
    real(default), intent(out), dimension(:), allocatable :: xi_max
    real(default), intent(out) :: xit
    real(default), intent(out) :: y, phi
    real(default), intent(out), dimension(3) :: jac
    xit = phs%xi_tilde
    y = phs%y
    phi = phs%phi
    xi_max = phs%xi_max
    jac = phs%jac
  end subroutine phs_fks_get_real_kinematics

@ %def phs_fks_get_real_kinematics
@
<<phs fks: phs fks: TBP>>=
  procedure :: set_emitters => phs_fks_set_emitters
<<phs fks: procedures>>=
  subroutine phs_fks_set_emitters (phs, emitters)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in), dimension(:), allocatable :: emitters
    phs%emitters = emitters
  end subroutine phs_fks_set_emitters

@ %def phs_fks_set_emitters
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_born_momenta => phs_fks_get_born_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_born_momenta (phs, p)
    class(phs_fks_t), intent(inout) :: phs
    type(vector4_t), intent(out), dimension(:) :: p
    p(1:phs%config%n_in) = phs%p_born
    p(phs%config%n_in+1:) = phs%q_born
  end subroutine phs_fks_get_born_momenta

@ %def phs_fks_get_born_momenta
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_outgoing_momenta => phs_fks_get_outgoing_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_outgoing_momenta (phs, q)
    class(phs_fks_t), intent(in) :: phs
    type(vector4_t), intent(out), dimension(:) :: q
    q = phs%q_real
  end subroutine phs_fks_get_outgoing_momenta

@ %def phs_fks_get_outgoing_momenta
@ 
<<phs fks: phs fks: TBP>>=
  procedure :: get_incoming_momenta => phs_fks_get_incoming_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_incoming_momenta (phs, p)
    class(phs_fks_t), intent(in) :: phs
    type(vector4_t), intent(inout), dimension(:), allocatable :: p
    p = phs%p_real
  end subroutine phs_fks_get_incoming_momenta

@ %def phs_fks_get_incoming_momenta0
@ 
<<phs fks: phs fks: TBP>>=
!!!  procedure :: get_ch_to_em => phs_fks_get_ch_to_em
<<phs fks: procedures>>=
!!!  function phs_fks_get_ch_to_em (phs) result (ch_to_em)
!!!    class(phs_fks_t), intent(inout) :: phs
!!!    integer, dimension(:), allocatable :: ch_to_em
!!!    ch_to_em = phs%ch_to_em
!!!  end function phs_fks_get_ch_to_em

@ %def phs_fks_get_ch_to_em
@
<<phs fks: phs fks: TBP>>=
  procedure :: display_kinematics => phs_fks_display_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_display_kinematics (phs)
     class(phs_fks_t), intent(in) :: phs
!     call phs%counter%display ()
  end subroutine phs_fks_display_kinematics

@ %def phs_fks_display_kinematics
@
\subsection{Creation of the real phase space - FSR}
At this point, the Born phase space has been generated, as well as the
three random variables $\xi$, $y$ and $\phi$. The question is how the
real phase space is generated for a final-state emission
configuration. We work with two different sets of momenta, the Born
configuration $\Bigl\{ \bar{k}_{\oplus}, \bar{k}_{\ominus}, \bar{k}_{1}, ...,
\bar{k}_{n} \Bigr\}$ and the real configuration $\Bigl\{ k_{\oplus},
k_{\ominus}, k_1,..., k_n, k_{n+1} \Bigr\}$. We define the momentum of
the emitter to be on the $n$-th position and the momentum of the
radiated particle to be at position $n+1$. The magnitude of the
spatial component of k is denoted by $\underline{k}$.

For final-state emissions, it is $\bar{k}_\oplus = k_\oplus$ and
$\bar{k}_\ominus = k_\ominus$. Thus, the center-of-mass systems
coincide and it is 
\begin{equation}
  q = \sum_{i=1}^n \bar{k}_i = \sum_{i=1}^{n+1} k_i,
\end{equation}
with $\vec{q} = 0$ and $q^2 = \left(q^0\right)^2$. 

We want to construct the real phase space from the Born phase space
using three random numbers. They are defined as follows: 
\begin{itemize}
\item $\xi = \frac{2k_{n+1}^0}{\sqrt{s}} \in [0, \xi_{max}]$, where
  $k_{n+1}$ denotes the four-momentum of the radiated particle. 
\item $y = \cos\theta = \frac{\vec{k}_n \cdot
    \vec{k}_{n+1}}{\underline{k}_n \underline{k}_{n+1}}$ is the
  splitting angle. 
\item The angle between tho two splitting particles in the transversal
  plane, $phi \in [0,2\pi]$.  
\end{itemize}
Further, $k_{rec} = \sum_{i=1}^{n-1} k_i$ denotes the sum of all
recoiling momenta. 
%\begin{dubious}
%  Note that this calculation only works for massless particles. 
%\end{dubious}
<<phs fks: public>>=
  public :: fks_born_to_real_fsr
<<phs fks: procedures>>=
  subroutine fks_born_to_real_fsr (emitter, xi, y, phi, p_born, p_real, jac)
    !!! Important: Momenta must be input in the center-of-mass frame
    integer, intent(in) :: emitter
    type(vector4_t), intent(inout), dimension(:), allocatable :: p_born 
    real(default), intent(in) :: xi, y, phi
    type(vector4_t), intent(out), dimension(:), allocatable :: p_real
    real(default), intent(out), dimension(3), optional :: jac
    integer nlegborn, nlegreal
    type(vector4_t) :: k_rec, q
    real(default) :: q0, q2, k0_np1, uk_np1, uk_n
    real(default) :: uk_rec, k_rec0
    type(vector3_t) :: k_n_born, k_real, k
    real(default) :: k_real0, uk_real
    real(default) :: uk_n_born
    real(default) :: mrec2
    real(default) :: uk, k2
    real(default) :: cpsi, beta
    type(vector3_t) :: vec, vec_orth
    type(lorentz_transformation_t) :: rot, lambda
    integer :: i
    real(default) :: pb
    nlegborn = size(p_born)
    if (emitter <= 2 .or. emitter > nlegborn) then
      call msg_fatal ("fks_born_to_real: emitter must be larger than 2.")
      return
    end if
    nlegreal = nlegborn + 1
    allocate (p_real (nlegreal))

    p_real(1) = p_born(1)
    p_real(2) = p_born(2)
    q = p_born(1) + p_born(2)
    q0 = vector4_get_component (q, 0)
    q2 = q**2

    k0_np1 = q0*xi/2
    uk_np1 = k0_np1
    k_n_born = space_part (p_born(emitter))
    uk_n_born = space_part_norm (p_born(emitter))

<<phs fks: compute momentum of radiated particle>>
<<phs fks: construct the recoiling momenta>>
<<phs fks: Jacobian>>
  end subroutine fks_born_to_real_fsr

@ %def fks_born_to_real_fsr
@ The momentum of the radiated particle is computed according to 
\begin{equation}
  \label{eq:phs fks:compute k_n}
  \underline{k}_n = \frac{q^2 - M_{\rm{rec}}^2 -
    2q^0\underline{k}_{n+1}}{2(q^0 - \underline{k}_{n+1}(1-y))}, 
\end{equation}
with $k = k_n + k_{n+1}$ and $M_{\rm{rec}}^2 = k_{\rm{rec}}^2 =
\left(q-k\right)^2$. Because of $\boldsymbol{\bar{k}}_n \parallel
\boldsymbol{k}_n + \boldsymbol{k}_{n+1}$ we find $M_{\rm{rec}}^2 =
\left(q-\bar{k}_n\right)^2$. 
Equation \ref{eq:phs fks: compute k_n} follows from the fact that
$\left(\boldsymbol{k} - \boldsymbol{k}_n\right)^2 =
\boldsymbol{k}_{n+1}^2$, which is equivalent to $\boldsymbol{k}_n
\cdot \boldsymbol{k} = \frac{1}{2} \left(\underline{k}_n^2 +
  \underline{k}^2 - \underline{k}_{n+1}^2\right)$.\\ 
$\boldsymbol{k}_n$ and $\boldsymbol{k}_{n+1}$ are obtained by first
setting up vectors parallel to $\boldsymbol{\bar{k}}_n$,  
\begin{equation*}
  \boldsymbol{k}_n' = \underline{k}_n
  \frac{\bar{\pmb{k}}_n}{\underline{\bar{k}}_n}, \quad \pmb{k}_{n+1}'
  = \underline{k}_{n+1}\frac{\bar{\pmb{k}}_n}{\underline{\bar{k}}_n}, 
\end{equation*}
and then rotating these vectors by an amount of $\cos\psi_n =
\frac{\boldsymbol{k}_n\cdot\pmb{k}}{\underline{k}_n \underline{k}}$. 
<<phs fks: compute momentum of radiated particle>>=
    mrec2 = (q-p_born(emitter))**2
    uk_n = (q2 - mrec2 - 2*q0*uk_np1) / (2*(q0 - uk_np1*(1-y)))
    uk = sqrt (uk_n**2 + uk_np1**2 + 2*uk_n*uk_np1*y)
    vec = uk_n / uk_n_born * k_n_born
    vec_orth = create_orthogonal (vec)
    call vector4_set_component (p_real(emitter), 0, uk_n)
    do i = 1, 3
       call vector4_set_component (p_real(emitter), i, &
            vector3_get_component (vec, i))
    end do
    cpsi = (uk_n**2 + uk**2 - uk_np1**2) / (2*(uk_n * uk))
    !!! This is to catch the case where cpsi = 1, but numerically 
    !!! turns out to be slightly larger than 1. 
    if (cpsi > 1._default) cpsi = 1._default
    rot = rotation (cpsi, -sqrt (1-cpsi**2), vec_orth)
    p_real(emitter) = rot*p_real(emitter)
    vec = uk_np1 / uk_n_born * k_n_born
    vec_orth = create_orthogonal (vec)
    call vector4_set_component (p_real(nlegreal), 0, uk_np1)
    do i = 1, 3
       call vector4_set_component (p_real(nlegreal), i, &
            vector3_get_component (vec,i))
    end do
    cpsi = (uk_np1**2 + uk**2 - uk_n**2) / (2*(uk_np1 * uk))
    rot = rotation (cpsi, sqrt (1-cpsi**2), vec_orth)
    p_real(nlegreal) = rot*p_real(nlegreal)
@ Construction of the recoiling momenta. The reshuffling of momenta
must not change the invariant mass of the recoiling system, which
means $k_{\rm{rec}}^2 = \bar{k_{\rm{rec}}}^2$. Therefore, the momenta
are related by a boost, $\bar{k}_i = \Lambda k_i$. The boost parameter
is 
\begin{equation*}
  \beta = \frac{q^2 - (k_{\rm{rec}}^0 +
    \underline{k}_{\rm{rec}})^2}{q^2 + (k_{\rm{rec}}^0 +
    \underline{k}_{\rm{rec}})^2} 
\end{equation*}
<<phs fks: construct the recoiling momenta>>=
    k_rec0 = q0 - vector4_get_component (p_real(emitter), 0) - &
                  vector4_get_component (p_real(nlegreal), 0)
    uk_rec = sqrt (k_rec0**2 - mrec2)
    beta = (q2 - (k_rec0 + uk_rec)**2) / (q2 + (k_rec0 + uk_rec)**2)
    k = space_part (p_real(emitter) + p_real(nlegreal))
    do i = 1, 3
      call vector3_set_component (vec, i, 1 / uk*vector3_get_component(k,i))
    end do
    lambda = boost (beta/sqrt(1-beta**2), vec)
    do i = 3, nlegborn
      if (i /= emitter) then
        p_real(i) = lambda * p_born(i)
      end if
    end do
    do i = 1, 3
      pb = vector4_get_component (p_born(emitter), i)
      call vector3_set_component (vec, i, pb/uk_n_born)
    end do
    rot = rotation (cos(phi), sin(phi), vec)
    p_real(nlegreal) = rot * p_real(nlegreal)
    p_real(emitter) = rot * p_real(emitter)
    k2 = 2*uk_n*uk_np1*(1-y)
@ The factor $\frac{q^2}{(4\pi)^3}$ is not included here since it is
supplied during phase space generation. Also, we already divide by
$\xi$. 
<<phs fks: Jacobian>>=
    if (present (jac)) then
      jac(1) = 1.0*uk_n**2/uk_n_born / (uk_n - k2/(2*q0))
      !!! Soft jacobian
      jac(2) = 1.0
      !!! Collinear jacobian
      jac(3) = 1.0*(1-xi/2*q0/uk_n_born)
    end if
@ The emitted particle cannot have more momentum than the emitter has
in the Born phase space. Thus, there is an upper bound for $\xi$,
determined by the condition $k_{n+1}^0 = \underline{\bar{k}}_n$, which
is equal to 
\begin{equation*}
\xi_{\rm{max}} = \frac{2}{\underline{\bar{k}}_n}{q^0}.
\end{equation*}
<<phs fks: public>>=
  public :: fks_get_xi_max_fsr
<<phs fks: procedures>>=
  function fks_get_xi_max_fsr (p_born, emitter) result (xi_max)
    type(vector4_t), intent(in), dimension(:), allocatable :: p_born
    integer, intent(in) :: emitter
    real(default) :: xi_max
    real(default) :: uk_n_born, q0
    q0 = vector4_get_component (p_born(1) + p_born(2), 0)
    uk_n_born = space_part_norm (p_born(emitter))
    xi_max = 2*uk_n_born / q0
  end function fks_get_xi_max_fsr
  
@ %def fks_get_xi_max_fsr
\subsection{Creation of the real phase space - ISR}
%\begin{dubious}
%  This part of the code has not been tested fully. It becomes
%  relevant for hadron collisions, where initial-state divergences are
%  an important source of corrections. We focus on QCD corrections for
%  lepton collisions, though, and are thus not concerned with ISR
%  corrections yet. 
%\end{dubious}
<<phs fks: public>>=
  public :: fks_born_to_real_isr
<<phs fks: procedures>>=
  subroutine fks_born_to_real_isr &
       (emitter, xi, y, phi, p_born, p_real, sqrts_beam, jac)
    !!! Important: Import momenta in the lab frame
    integer, intent(in) :: emitter
    type(vector4_t), intent(in) , dimension(:), allocatable :: p_born
    real(default), intent(in) :: xi, y, phi
    real(default), intent(in) :: sqrts_beam
    type(vector4_t), intent(out), dimension(:), allocatable :: p_real
    real(default), intent(out), dimension(3) :: jac
    integer :: nlegborn, nlegreal
    real(default) :: sqrts_born
    real(default) :: k0_np1
    type(vector3_t) :: beta_l, vec_t
    real(default) :: beta_t, beta_gamma_l, beta_gamma_t
    real(default) :: k_tmp, k_p, k_m, k_p0, k_m0
    real(default) :: pt_rad
    type(lorentz_transformation_t) :: lambda_t, lambda_l, lambda_l_inv
    real(default) :: x_plus, x_minus, barx_plus, barx_minus
    integer :: i
    nlegborn = size (p_born)
    nlegreal = nlegborn  + 1
    sqrts_born = sqrt ((p_born(1) + p_born(2))**2)
    allocate (p_real (nlegreal))
    !!! Create radiation momentum
    k0_np1 = sqrts_born*xi/2 
    !!! There must be the real cm-energy, not the Born one! 
    !!!    s_real = s_born / (1-xi)
    !!! Build radiation momentum in the rest frame of the real momenta
    call vector4_set_component &
         (p_real(nlegreal), 0, k0_np1)
    call vector4_set_component &
         (p_real(nlegreal), 1, k0_np1*sqrt(1-y**2)*sin(phi))
    call vector4_set_component &
         (p_real(nlegreal), 2, k0_np1*sqrt(1-y**2)*cos(phi))
    call vector4_set_component (p_real(nlegreal), 3, k0_np1*y)
    !!! Boost to lab frame missing
    pt_rad = transverse_part (p_real(nlegreal))
    beta_t = sqrt (1 + sqrts_born**2 * (1-xi) / pt_rad**2)
    beta_gamma_t = 1/sqrt(beta_t)
    k_p0 = vector4_get_component (p_born(1), 0)
    k_m0 = vector4_get_component (p_born(2), 0)
    do i = 1,3
	k_p = vector4_get_component (p_born(1), i)
        k_m = vector4_get_component (p_born(2), i)
        k_tmp = (k_p + k_m) / (k_p0 + k_m0)
        call vector3_set_component (beta_l, i, k_tmp)
    end do
    beta_gamma_l = beta_l**1
    beta_l = beta_l / beta_gamma_l
    beta_gamma_l = beta_gamma_l / sqrt (1 - beta_gamma_l**2)
    call vector3_set_component &
         (vec_t, 1, vector4_get_component (p_real(nlegreal), 1))
    call vector3_set_component &
         (vec_t, 2, vector4_get_component (p_real(nlegreal), 2))
    call vector3_set_component (vec_t, 3, 0._default)
    call normalize (vec_t)
    lambda_l = boost(beta_gamma_l, beta_l)
    lambda_t = boost(-beta_gamma_t, vec_t)
    lambda_l_inv = boost(-beta_gamma_l, beta_l)
    forall (i=3:nlegborn) &
         p_real(i) = lambda_l_inv * lambda_t * lambda_l * p_born(i)
    !!! Now need access to the x-variables of the IS-partons
    barx_plus = 2*vector4_get_component(p_born(1), 0)/sqrts_beam
    barx_minus = 2*vector4_get_component(p_born(2), 0)/sqrts_beam
    x_plus = barx_plus/sqrt(1-xi) * sqrt ((2-xi*(1-y)) / (2-xi*(1+y)))
    x_minus = barx_minus/sqrt(1-xi) * sqrt ((2-xi*(1+y)) / (2-xi*(1-y)))
    p_real(1) = x_plus/barx_plus * p_born(1)
    p_real(2) = x_minus/barx_minus * p_born(2)
    !!! Total nonsense
    jac(1) = 1
  end subroutine fks_born_to_real_isr
@ %def fks_born_to_real_isr
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation of the Calculation}
<<[[fks_calculation.f90]]>>=
<<File header>>

module fks_calculation

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: pi, twopi
  use unit_tests
  use diagnostics
  use physics_defs
  use process_constants !NODEP!
  use sm_physics
  use os_interface
  use variables
  use models
  use parser
  use eval_trees
  use pdg_arrays
  use particle_specifiers
  use phs_single
  use state_matrices
  use interactions
  use lorentz
  use prc_core
  use pdg_arrays
  use sf_base
  use colors
  use flavors
  use fks_regions
  use phs_fks

<<Standard module head>>

<<fks calc: public>>

<<fks calc: types>>

contains
 
<<fks calc: procedures>>

end module fks_calculation
@ %def fks_calculation
@ We need to associate singular regions with compatible color flows.
<<fks calc: public>>=
  public :: fks_template_t
<<fks calc: types>>=
  type :: fks_template_t
    integer :: mapping_type
    logical :: count_kinematics = .false.
    real(default) :: fks_dij_exp1
    real(default) :: fks_dij_exp2
  contains
  <<fks calc: fks template: TBP>>
  end type fks_template_t

@ %def fks_template_t
@
<<fks calc: fks template: TBP>>=
  procedure :: write => fks_template_write
<<fks calc: procedures>>=
  subroutine fks_template_write (object, unit)
    class(fks_template_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,'(1x,A)') 'FKS Template: '
    write (u,'(1x,A,I0)') 'Mapping Type: ', object%mapping_type
    write (u,'(1x,A,ES4.3,ES4.3)') 'd_ij exponentials: ', object%fks_dij_exp1, object%fks_dij_exp2
  end subroutine fks_template_write

@ %def fks_template_write
@
<<fks calc: fks template: TBP>>=
  procedure :: set_dij_exp => fks_template_set_dij_exp
<<fks calc: procedures>>=
  subroutine fks_template_set_dij_exp (object, exp1, exp2)
    class(fks_template_t), intent(inout) :: object
    real(default), intent(in) :: exp1, exp2
    object%fks_dij_exp1 = exp1
    object%fks_dij_exp2 = exp2
  end subroutine fks_template_set_dij_exp

@ %def fks_template_set_dij_exp
@
<<fks calc: fks template: TBP>>=
  procedure :: set_mapping_type => fks_template_set_mapping_type
<<fks calc: procedures>>=
  subroutine fks_template_set_mapping_type (object, val)
    class(fks_template_t), intent(inout) :: object
    integer, intent(in) :: val
    object%mapping_type = val
  end subroutine fks_template_set_mapping_type

@ %def fks_template_set_mapping_type
@
<<fks calc: fks template: TBP>>=
  procedure :: set_counter => fks_template_set_counter
<<fks calc: procedures>>=
  subroutine fks_template_set_counter (object)
    class(fks_template_t), intent(inout) :: object
    object%count_kinematics = .true.
  end subroutine fks_template_set_counter

@ %def fks_template_set_counter
@
<<fks calc: types>>=
  type :: ftuple_color_map_t
    integer :: index
    integer :: color_index
    type(ftuple_color_map_t), pointer :: next
    type(ftuple_color_map_t), pointer :: prev
  contains
  <<fks calc: color map: TBP>>  
  end type ftuple_color_map_t

@ %def ftuple_color_map_t
@
<<fks calc: color map: TBP>>=
  procedure :: init => ftuple_color_map_init
<<fks calc: procedures>>=   
  subroutine ftuple_color_map_init (icm)
    class(ftuple_color_map_t), intent(inout), target :: icm
    icm%index = 0
    icm%color_index = 0
    nullify (icm%next)
    nullify (icm%prev)
  end subroutine ftuple_color_map_init

@ %def ftuple_color_map_init
@ Explain
<<fks calc: color map: TBP>>=
  procedure :: present => ftuple_color_map_present  
<<fks calc: procedures>>=
  function ftuple_color_map_present (icm, color_index) result(pres)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: color_index
    logical :: pres
    type(ftuple_color_map_t), pointer :: current
    select type (icm)
    type is (ftuple_color_map_t)
    current => icm
    pres = .false.
    do
      if (current%color_index == color_index) then
        pres = .true.
        exit
      else
        if (associated (current%next)) then
          current => current%next
        else
          exit
        end if
      end if
    end do
    end select
  end function ftuple_color_map_present        

@ %def ftuple_color_map_present
@ Appends a color flow to the list
<<fks calc: color map: TBP>>=
  procedure :: append => ftuple_color_map_append  
<<fks calc: procedures>>=
  subroutine ftuple_color_map_append (icm, val)
    class(ftuple_color_map_t), intent(inout), target :: icm
    integer, intent(in) :: val
    type(ftuple_color_map_t), pointer :: current
    select type (icm)
    type is (ftuple_color_map_t)
    if (.not. icm%present (val)) then 
      if (icm%index == 0) then
        nullify(icm%next)
        icm%index = 1
        icm%color_index = val
      else
        current => icm
        do 
          if (associated (current%next)) then
            current => current%next
          else
            allocate (current%next)
            nullify (current%next%next)
            current%next%prev => current 
            current%next%index = current%index + 1
            current%next%color_index = val
            exit
          end if
        end do
      end if
    end if
    end select
  end subroutine ftuple_color_map_append

@ %def ftuple_color_map_append
@
<<fks calc: color map: TBP>>=
  procedure :: get_n_entries => ftuple_color_map_get_n_entries
<<fks calc: procedures>>=
  function ftuple_color_map_get_n_entries (icm) result(n_entries)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer :: n_entries
    type(ftuple_color_map_t), pointer :: current
    select type (icm)
    type is (ftuple_color_map_t)
    current => icm
    n_entries = 0
    do 
      if (associated (current%next)) then
        current => current%next
      else
        n_entries = current%index
        exit
      end if
    end do
    end select
  end function ftuple_color_map_get_n_entries

@ %def ftuple_color_map_get_n_entries
@ Explain
<<fks calc: color map: TBP>>=
  procedure :: get_index_array => ftuple_color_map_get_index_array  
<<fks calc: procedures>>=
  function ftuple_color_map_get_index_array (icm) result(iarr)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, dimension(:), allocatable :: iarr
    type(ftuple_color_map_t), pointer :: current
    integer :: n_entries, val
    integer :: i
    select type (icm)
    type is (ftuple_color_map_t)
    n_entries = icm%get_n_entries ()
    allocate (iarr(n_entries))
    do i = 1, n_entries
      if (i == 1) then
        current => icm
      else
        current => current%next
      end if
      iarr(i) = current%color_index
    end do
    end select
  end function ftuple_color_map_get_index_array

@ %def ftuple_color_map_get_index_array
@
<<fks calc: color map: TBP>>=
  procedure :: get_entry => ftuple_color_map_get_entry  
<<fks calc: procedures>>=
  function ftuple_color_map_get_entry (icm, index) result(entry)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: index
    integer :: entry
    type(ftuple_color_map_t), pointer :: current
    integer :: i
    select type (icm)
    type is (ftuple_color_map_t)
    if (index <= icm%get_n_entries ()) then
      do i = 1, icm%get_n_entries ()
        if (i == 1) then
          current => icm
        else
          current => current%next
        end if
        if (i == index) entry = current%color_index
      end do
    else
      entry = 0
    end if
    end select 
  end function ftuple_color_map_get_entry

@ %def ftuple_color_map_get_entry
@ Explain
<<fks calc: color map: TBP>>=
  procedure :: create_map => ftuple_color_map_create_map
<<fks calc: procedures>>=
  recursive subroutine ftuple_color_map_create_map (icm, flst, &
       emitter, allreg, color_states_born, color_states_real, p_rad_in)
    class(ftuple_color_map_t), intent(inout) :: icm
    type(flv_structure_t), intent(in) :: flst
    integer, intent(in) :: emitter
    type(ftuple_t), intent(in), dimension(:) :: allreg
    integer, intent(in), dimension(:,:,:) :: color_states_born
    integer, intent(in), dimension(:,:,:) :: color_states_real
    integer, intent(in), optional :: p_rad_in
    integer :: nreg, region
    integer :: p1, p2, p_rad
    integer :: flv_em, flv_rad
    integer :: n_col_real, n_col_born
    integer, dimension(2) :: col_em, col_rad
    integer :: i, j
    !!! splitting type: 1 - q -> qg
    !!!                 2 - g -> qq
    !!!                 3 - g -> gg
    integer :: splitting_type_flv, splitting_type_col
    nreg = size (allreg)
    n_col_real = size (color_states_real (1,1,:))
    n_col_born = size (color_states_born (1,1,:))
    do region = 1, nreg
      call allreg(region)%get (p1, p2)
      if (p1 == emitter .or. p2 == emitter .or. present (p_rad_in)) then
        if (.not. present (p_rad_in)) then
          if (p1 == emitter) then
            p_rad = p2
          else
            p_rad = p1
          end if
        else
          p_rad = p_rad_in
        end if
        if (emitter /= 0) then
          flv_em = flst%flst (emitter)
        else
          call icm%create_map &
               (flst, 1, allreg, color_states_born, color_states_real, p_rad)
          call icm%create_map &
               (flst, 2, allreg, color_states_born, color_states_real, p_rad)
        end if
        flv_rad = flst%flst (p_rad)
        if (is_quark (abs(flv_em)) .and. is_gluon (flv_rad)) then
           splitting_type_flv = 1
        else if (is_quark (abs(flv_em)) .and. flv_em + flv_rad == 0) then
           splitting_type_flv = 2
        else if (is_gluon (flv_em) .and. is_gluon (flv_rad)) then
           splitting_type_flv = 3
        else 
          splitting_type_flv = 0
        end if 
        do i = 1, n_col_real
           col_em = color_states_real(:,emitter,i)
           col_rad = color_states_real(:,p_rad,i)
          if (is_color_singlet (col_em(1), col_em(2)) &
              .and. (is_color_doublet (col_rad(1), col_rad(2)) &
              .or. is_color_ghost (col_rad(1), col_rad(2)))) then
            splitting_type_col = 1
          else if (is_color_singlet (col_em(1), col_em(2)) .and. &
                   is_color_singlet (col_rad(1), col_rad(2))) then
            splitting_type_col = 2
          else if (is_color_doublet (col_em(1), col_em(2)) .and. &
                   is_color_doublet (col_rad(1), col_rad(2))) then
            splitting_type_col = 3
          else
            splitting_type_col = 0
          end if
          if (splitting_type_flv == splitting_type_col .and. &
              splitting_type_flv /= 0) then
            call icm%append (i)
          end if
        end do    
      end if  
    end do
  contains
    function is_color_singlet (c1, c2) result (singlet)
      integer, intent(in) :: c1, c2
      logical :: singlet
      singlet = (c1 == 0 .and. c2 /= 0) .or. (c1 /= 0 .and. c2 == 0) 
    end function is_color_singlet
    function is_color_doublet (c1, c2) result (doublet)
      integer, intent(in) :: c1, c2
      logical :: doublet
      doublet = c1 /= 0 .and. c2 /= 0
    end function is_color_doublet
    function is_color_ghost (c1, c2) result (ghost)
      integer, intent(in) :: c1, c2
      logical :: ghost
      ghost = c1 == 0 .and. c2 == 0
    end function is_color_ghost
  end subroutine ftuple_color_map_create_map

@ %def ftuple_color_map_create_map
@ Just a container for the real kinematics variables.
<<fks calc: types>>=
  type :: real_kinematics_t
    real(default) :: xi_tilde
    real(default) :: y
    real(default) :: phi
    real(default), dimension(:), allocatable :: xi_max
    real(default), dimension(3) :: jac
    type(vector4_t), dimension(:), allocatable :: p_real
  end type real_kinematics_t

@ %def real_kinematics_t
@ This data type contains color information, necessary for both soft
and virtual counterterms. 
<<fks calc: types>>=
  type color_data_t
    type(ftuple_color_map_t), dimension(:), allocatable :: icm
    integer, dimension(:,:,:), allocatable :: col_state_born, col_state_real
    logical, dimension(:,:), allocatable :: ghost_flag_born, ghost_flag_real
    integer :: n_col_born, n_col_real
    type(color_t), dimension(:,:), allocatable :: color_real, color_born
    integer, dimension(:), allocatable :: col_born
    complex(default), dimension(:), allocatable :: color_factors_born
    integer, dimension(:,:), allocatable :: cf_index_real
    real(default), dimension(:,:,:), allocatable :: beta_ij
    logical :: color_is_conserved
  contains
  <<fks calc: color data: TBP>>
  end type color_data_t

@ %def color_data_t
@
<<fks calc: color data: TBP>>=
  procedure :: init => color_data_init
<<fks calc: procedures>>= 
  subroutine color_data_init (color_data, reg_data, prc_constants)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    type(process_constants_t), intent(inout), dimension(2) :: prc_constants
    integer :: nlegs_born, nlegs_real
    integer :: i
    nlegs_born = reg_data%nlegs_born
    nlegs_real = reg_data%nlegs_real
    call prc_constants(1)%get_col_state (color_data%col_state_born)
    call prc_constants(2)%get_col_state (color_data%col_state_real)
    call prc_constants(2)%get_cf_index (color_data%cf_index_real)
    call prc_constants(1)%get_color_factors (color_data%color_factors_born)
    color_data%n_col_born = size (color_data%col_state_born(1,1,:))
    color_data%n_col_real = size (color_data%col_state_real(1,1,:))
    color_data%ghost_flag_born = prc_constants(1)%get_ghost_flag ()
    color_data%ghost_flag_real = prc_constants(2)%get_ghost_flag ()
    allocate (color_data%color_real (nlegs_real, color_data%n_col_real))
    allocate (color_data%icm (size (reg_data%regions)))
    do i = 1, color_data%n_col_real
      call color_init_from_array (color_data%color_real (:,i), &
           color_data%col_state_real (:,:,i), &
           color_data%ghost_flag_real (:,i))
    end do
    do i = 1, size(reg_data%regions)
      call color_data%icm(i)%init
      associate (region => reg_data%regions(i))
        call color_data%icm(i)%create_map (region%flst_real, region%emitter, &
             region%flst_allreg, color_data%col_state_born, &
             color_data%col_state_real)
      end associate
    end do
    call color_data%init_betaij (reg_data)
  end subroutine color_data_init

@ %def color_data_init
@ Allocate and compute $\beta_{ij}$:
<<fks calc: color data: TBP>>=
  procedure :: init_betaij => color_data_init_betaij
<<fks calc: procedures>>=
  subroutine color_data_init_betaij (color_data, reg_data)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer :: i, j, k
    integer :: i_uborn
    allocate (color_data%beta_ij (reg_data%nlegs_born, &
         reg_data%nlegs_born, reg_data%n_flv_born))
    do i = 1, reg_data%n_flv_born
      call color_data%fill_betaij_matrix (reg_data%nlegs_born, i, &
           reg_data%regions(1)%flst_real, reg_data)
    end do
  end subroutine color_data_init_betaij

@ %def color_data_init_betaij
@ Actual computation of $\beta_{ij}$.
<<fks calc: color data: TBP>>=
  procedure :: fill_betaij_matrix => color_data_fill_betaij_matrix
<<fks calc: procedures>>=
  subroutine color_data_fill_betaij_matrix &
       (color_data, n_legs, uborn_index, flst_real, reg_data)
    class(color_data_t), intent(inout) :: color_data
    integer, intent(in) :: n_legs, uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    type(region_data_t), intent(inout) :: reg_data
    integer :: em1, em2
    associate (flv_born => reg_data%flv_born (uborn_index))
    do em1 = 1, n_legs
      do em2 = 1, n_legs
        if (is_qcd_particle (flv_born%flst(em1)) &
            .and. is_qcd_particle (flv_born%flst(em2))) then
          if (em1 < em2) then
             color_data%beta_ij (em1, em2, uborn_index) &
                = color_data%compute_bij &
                     (reg_data, uborn_index, flst_real, em1, em2)
          else if (em1 > em2) then
             !!! B_ij is symmetric
             color_data%beta_ij (em1, em2, uborn_index) = &
                  color_data%beta_ij (em2, em1, uborn_index)
          else
            if (is_quark (abs (flv_born%flst (em1)))) then
              color_data%beta_ij (em1, em2, uborn_index) = -cf
            else
              color_data%beta_ij (em1, em2, uborn_index) = -ca
            end if
          end if
        else
          color_data%beta_ij (em1, em2, uborn_index) = 0.0
        end if
      end do
    end do
    end associate
    call check_color_conservation (color_data%beta_ij (:,:,uborn_index), &
         n_legs, color_data%color_is_conserved)
  contains
    subroutine check_color_conservation (bij_matrix, n_legs, success)
      real(default), intent(in), dimension(:,:) :: bij_matrix
      integer, intent(in) :: n_legs
      logical, intent(out) :: success
      logical, dimension(:), allocatable :: check
      integer :: i, j
      real(default) :: bcheck
      real(default), parameter :: tol = 0.0001_default
      allocate (check (n_legs))
      do i = 1, n_legs
        bcheck = 0.0
        do j = 1, n_legs
          if (i /= j) bcheck = bcheck + bij_matrix (i, j)
        end do
        if (is_quark (abs(flst_real%flst (i))) .or. &
            is_gluon (flst_real%flst (i))) then
          if (is_quark (abs(flst_real%flst (i))) .and. &
               (bcheck - cf) < tol) then
             check (i) = .true.
          else if (is_gluon (flst_real%flst (i)) .and. &
               (bcheck - ca) < tol) then
            check (i) = .true.
          else
            check (i) = .false.
          end if
        else 
          if (bcheck < tol) then
            check (i) = .true.
          else
            check (i) = .false.
          end if
        end if
      end do
      if (.not. all (check)) then
        success = .false.
        ! call msg_fatal ("Color conservation violated!") 
      else
        success = .true.
      end if
    end subroutine check_color_conservation
  end subroutine color_data_fill_betaij_matrix

@ %def color_data_fill_betaij_matrix
@ Explain
<<fks calc: color data: TBP>>=
  procedure :: compute_bij => color_data_compute_bij
<<fks calc: procedures>>=
  function color_data_compute_bij &
       (color_data, reg_data, uborn_index, flst_real, em1, em2) result (bij)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    integer, intent(in) :: em1, em2
    real(default) :: bij
    integer :: pref
    logical, dimension(:,:), allocatable :: cf_present
    type(singular_region_t), dimension(2,100) :: reg
    integer ::  i, j, k, l
    type(ftuple_color_map_t) :: icm1, icm2
    integer :: i1, i2
    real(default) :: color_factor, color_factor_born
    real(default) :: sqme_born
    integer, dimension(2) :: i_reg
    logical , dimension(2) :: found
    integer, dimension(2,100) :: map_em_col_tmp
    integer, dimension(:), allocatable :: map_em_col1, map_em_col2
    integer, dimension(2) :: col1, col2
    integer, dimension(:), allocatable :: iarray1, iarray2
    integer, dimension(:), allocatable :: iisec1, iisec2
    integer :: sign
    color_factor = 0.0; color_factor_born = 0.0
    found = .false.
    !!! Include distinction between Born flavors
    do i = 1, size (color_data%color_factors_born)
      color_factor_born = color_factor_born + color_data%color_factors_born (i)
    end do
    i1 = 1
    i2 = 1
    !!! Catch case em = 0
    if (em1 == 0 .or. em2 == 0) then
       !!! What to do?
       bij = 0.0
    else
       do i = 1, color_data%n_col_real
          col1 = color_data%col_state_real (:, em1, i)
          col2 = color_data%col_state_real (:, reg_data%nlegs_real, i)
          if (share_line (col1, col2)) then
             map_em_col_tmp(1,i1) = i
             i1 = i1+1
          end if
          col1 = color_data%col_state_real (:, em2, i)
          if (share_line (col1, col2)) then 
             map_em_col_tmp(2,i2) = i
             i2 = i2 + 1
          end if
       end do
       allocate (map_em_col1 (i1), map_em_col2 (i2))
       map_em_col1 = map_em_col_tmp (1,1:i1-1)
       map_em_col2 = map_em_col_tmp (2,1:i2-1)

       i_reg = 1
    
       do i = 1, reg_data%get_nregions ()
           if (uborn_index == reg_data%regions(i)%uborn_index) then
             if (em1 == reg_data%regions(i)%emitter .or. &
                 (em1 <= 2 .and. reg_data%regions(i)%emitter == 0)) then
               reg(1,i_reg(1)) = reg_data%regions(i)
               i_reg(1) = i_reg(1)+1
               found(1) = .true.
             end if
             if (em2 == reg_data%regions(i)%emitter .or. &
                 (em2 <= 2 .and. reg_data%regions(i)%emitter == 0)) then
               reg(2,i_reg(2)) = reg_data%regions(i)
               i_reg(2) = i_reg(2)+1
               found(2) = .true.
             end if
           end if
       end do
       if (.not. (found(1).and.found(2))) then
         bij = 0
         return
       end if

       do i = 1, i_reg(1)-1
         do j = 1, i_reg(2)-1
           icm1 = color_data%icm (reg(1,i)%alr)
           icm2 = color_data%icm (reg(2,j)%alr)
       
           iarray1 = icm1%get_index_array ()
           iarray2 = icm2%get_index_array ()
       
           iisec1 = pack (iarray1, [ (any(iarray1(i) == map_em_col1), &
                i = 1, size(iarray1)) ])
           iisec2 = pack (iarray2, [ (any(iarray2(i) == map_em_col2), &
                i = 1, size(iarray2)) ])
       
           cf_present = color_index_present (color_data%cf_index_real)
       
           do k = 1, size (iisec1)
             do l = 1, size (iisec2)
               i1 = iisec1(k)
               i2 = iisec2(l)
               if (cf_present (i1, i2)) then
                 if (is_gluon (flst_real%flst (em1)) .or. &
                     is_gluon (flst_real%flst (em2))) then
                   sign = get_sign (color_data%col_state_real (:,:,i1)) * &
                        get_sign (color_data%col_state_real (:,:,i2))
                 else
                   sign = 1
                 end if
                   color_factor = color_factor + sign*compute_color_factor &
                         (color_data%color_real(:,i1), &
                          color_data%color_real(:,i2))
               end if
             end do
           end do       
         end do
       end do
       !!! The real color factor always differs from the Born one 
       !!! by one vertex factor. Thus, apply the factor 1/2  
       bij = color_factor / (2 * color_factor_born) 
    end if

  contains
    function share_line (col1, col2) result (share)
      integer, intent(in), dimension(2) :: col1, col2
      logical :: share
      logical :: id1, id2, id3
      id1 = (abs(col1(1)) == abs(col2(1)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(2)) .and. col1(2) /= 0)
      id2 = (abs(col1(1)) == abs(col2(2)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(1)) .and. col1(2) /= 0)
      id3 = col2(1) == 0 .and. col2(2) == 0
      if (id1 .or. id2 .or. id3) then
        share = .true.
      else
        share = .false.
      end if
    end function share_line

    function get_sign (col) result (sign)
      integer, intent(in), dimension(:,:) :: col
      integer :: sign
      integer, dimension(:), allocatable :: iref, iperm
      integer :: iref1, iperm1
      integer :: n, i, i_first, j
      integer :: i1, i2
      integer :: p1, p2
      p1 = 2; p2 = 2
      do i = 1, size(col(1,:))
        if (.not. all (col(:,i) == 0)) then 
          if (col(1,i) == 0) then
            i1 = col(2,i)
            iref1 = i; iperm1 = i
            i_first = i
          else
            i1 = col(1,i)
            iref1 = i; iperm1 = i
            i_first = i
          end if
          exit
        end if
      end do
      n = size(col(1,:)) - i_first + 1
      allocate (iref(n), iperm(n))
      iref(1) = iref1; iperm(1) = iperm1
      do i = i_first+1, size(col(1,:))
        if (all (col(:,i) == 0)) cycle
        if (i == size(col(1,:))) then
          iref(p1) = i_first + 1
        else
          iref(p1) = i + 1
          p1 = p1 + 1
        end if
        do j = i_first+1, size(col(1,:))
          if (col(1,j) == -i1) then
            i1 = col(2,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          else if (col(2,j) == -i1) then
            i1 = col(1,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          end if
        end do
      end do
      sign = 1
      do i = 1, n
        if (iperm(i) == iref(i)) then
          cycle
        else
          do j = i+1, n
            if (iperm(j) == iref(i)) then
              i1 = j
              exit
            end if
          end do
          i2 = iperm(i)
          iperm(i) = iperm(i1) 
          iperm(i1) = i2
          sign = -sign
        end if
      end do 
    end function get_sign
 
    function color_index_present (cf_index) result (cf_present) 
      integer, intent(in), dimension(:,:), allocatable :: cf_index
      logical, dimension(:,:), allocatable :: cf_present
      integer :: n_col
      integer :: c, i1, i2
      n_col = size (cf_index(1,:))
      allocate (cf_present (n_col, n_col))
      cf_present = .false.
      do c = 1, n_col
        i1 = cf_index (1, c)
        i2 = cf_index (2, c)
        cf_present (i1, i2) = .true.
        if (i1 /= i2) cf_present(i2, i1) = .true.
      end do
    end function color_index_present
  end function color_data_compute_bij

@ %def color_data_compute_bij
@
<<fks calc: color data: TBP>>=
  procedure :: write => color_data_write
<<fks calc: procedures>>=
  subroutine color_data_write (color_data, unit)
    class(color_data_t), intent(in) :: color_data
    integer, intent(in), optional :: unit
    integer :: u, i, i1, i2
    integer :: n_legs
    u = given_output_unit (unit); if (u < 0) return
    n_legs = size (color_data%beta_ij, dim=2)
    write (u, "(1x,A)") "Color information: "
    write (u, "(1x,A,1x,I1)") "Number of Born color states: ", &
         color_data%n_col_born
    write (u, "(1x,A,1x,I1)") "Number of real color states: ", &
         color_data%n_col_real
    write (u, "(1x,A)") "Color correlation: "
    do i = 1, size (color_data%beta_ij, dim=3)
      write (u, "(1x,A,1x,I1)") "State nr. ", i
      write (u, "(1x,A)") "-------------"
      write (u, "(1x,A,1x,A,1x,A)") "i1", "i2", "color factor"
      do i1 = 1, n_legs
        do i2 = 1, i1
          write (u, "(1x,I1,1x,I1,1x,F5.2)") &
               i1, i2, color_data%beta_ij (i1,i2,i)
        end do
      end do
      write (u, "(1x,A)") "========================================"
    end do
    if (color_data%color_is_conserved) then
      write (u, "(1x,A)") "Color is conserved."
    else
      write (u, "(1x,A)") "Fatal error: Color conversation is violated."
    end if
  end subroutine color_data_write

@ %def color_data_write
@
\subsection{The real contribution to the cross section}
In each singular region $\alpha$, the real contribution to $\sigma$ is
given by the second summand of eqn. \ref{fks: sub: complete}, 
\begin{equation}
  \sigma^\alpha_{\text{real}} = \int d\Phi_n \int_0^{2\pi} d\phi
  \int_{-1}^1 dy \int_0^{\xi_{\text{max}}} d\xi
  \left(\frac{1}{\xi}\right)_+ \left(\frac{1}{1-y}\right)_+
  \underbrace{\frac{J(\Phi_n, \xi, y, \phi)}{\xi}
    \left[(1-y)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]}_{g^\alpha(\xi,y)}. 
\end{equation}
Writing out the plus-distribution and introducing $\tilde{\xi} =
\xi/\xi_{\text{max}}$ to set the upper integration limit to 1,  this
turns out to be equal to 
\begin{equation}
  \begin{split}
    \sigma^\alpha_{\rm{real}} &= \int d\Phi_n \int_0^{2/pi}d\phi
    \int_{-1}^1 \frac{dy}{1-y} \Bigg\{\int_0^1
    d\tilde{\xi}\Bigg[\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},y)}{\tilde{\xi}}
    - \underbrace{\frac{g^\alpha(0,y)}{\tilde{\xi}}}_{\text{soft}} -
    \underbrace{\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},1)}{\tilde{\xi}}}_{\text{coll.}}
    +
    \underbrace{\frac{g^\alpha(0,1)}{\tilde{\xi}}}_{\text{coll.+soft}}\Bigg]
    \\ 
&+ \left[\log\xi_{\rm{max}}(y)g^\alpha(0,y) - \log\xi_{\rm{max}}(1)g^\alpha(0,1)\right]\Bigg\}.
  \end{split}
\end{equation}
This formula is implemented in the \texttt{nlo\_data}-type.
<<fks calc: nlo data: TBP>>=
  procedure :: compute_sqme_real_fin => nlo_data_compute_sqme_real_fin
<<fks calc: procedures>>=
  function nlo_data_compute_sqme_real_fin (nlo_data, weight, p_real, sqme0) result (sqme_fin)
    class(nlo_data_t), intent(inout) :: nlo_data
    real(default), intent(in) :: weight
    type(vector4_t), intent(inout), dimension(:), allocatable :: p_real
    real(default), intent(inout) :: sqme0
    real(default) :: sqme_fin
    integer :: em, alr
    integer :: iuborn
    real(default) :: xi, y, xi_max, phi
    real(default), dimension(3) :: jac
    real(default) :: xi_tilde
    real(default) :: s_alpha
    real(default) :: sqme_soft, sqme_coll, sqme_cs, sqme_remn
    sqme_fin = 0
    if (.not. nlo_data%alpha_s_born_set) &
      call msg_fatal ("Strong coupling not set for real calculation - abort")
    em = nlo_data%get_active_emitter ()
    call nlo_data%get_real_kinematics (em, xi_tilde, y, xi_max, jac = jac, phi = phi)
    call nlo_data%counter%record (xi_tilde = xi_tilde, xi_max = xi_max, &
                                  y = y, phi = phi)
    LOOP_OVER_ALPHA_REGIONS: do alr = 1, nlo_data%n_alr
      iuborn = nlo_data%reg_data%regions(alr)%uborn_index
      if (em == nlo_data%reg_data%regions(alr)%emitter .and. iuborn == 1) then
        xi = xi_tilde * xi_max
        call nlo_data%counter%record (xi = xi)
        sqme0 = sqme0 * xi**2/xi_tilde
        s_alpha = nlo_data%reg_data%get_svalue (p_real, alr, em)
        sqme0 = sqme0 * weight * s_alpha * jac(1)
        call nlo_data%compute_sub_soft (nlo_data%int_born, p_real, alr, em)
        call nlo_data%compute_sub_coll (nlo_data%int_born, alr)
        call nlo_data%compute_sub_coll_soft (nlo_data%int_born, alr)
        sqme_soft = nlo_data%sub_soft%value(alr)
        sqme_coll = nlo_data%sub_coll%value(alr)
        sqme_cs = nlo_data%sub_coll%value_soft(alr)
@ Supply the $\tilde{\xi}^{-1}(1-y)^{-1}$-factor; note that this is not done for the pure real matrix element because it directly cancels out with the numerator. Further, the jacobians are supplied in their appropriate limits.
<<fks calc: procedures>>=
        sqme_soft = sqme_soft/(1-y)/xi_tilde*jac(2)
        sqme_coll = sqme_coll/(1-y)/xi_tilde*jac(3)
        sqme_cs = sqme_cs/(1-y)/xi_tilde*jac(2)
        sqme_remn = (sqme_soft - sqme_cs)*log(xi_max)*xi_tilde
        sqme_fin = sqme_fin + sqme0 - sqme_soft - sqme_coll + sqme_cs + sqme_remn
        if (sqme_fin /= sqme_fin) then
                         print *, 'emitter: ', em
                         print *, 'xi_max: ', xi_max
                         print *, 'xi: ', xi, 'y: ', y
                         print *, 'sqme_born: ', nlo_data%sqme_born(iuborn), &
                        'sqme_real: ', sqme0, &
                        'sqme_soft: ', sqme_soft, &
                        'sqme_coll: ', sqme_coll, &
                        'sqme_coll-soft: ', sqme_cs, &
                        'sqme_remn: ', sqme_remn
        else
          sqme_fin = sqme_fin * nlo_data%reg_data%regions(alr)%mult
        end if
      end if
    end do LOOP_OVER_ALPHA_REGIONS
  end function nlo_data_compute_sqme_real_fin

@ %def nlo_data_compute_sqme_real_fin
\subsubsection{Soft counterterms}
The soft contribution to the counterterms is calculated by the
\texttt{soft\_subtraction}-type. 
<<fks calc: types>>=
  type :: soft_subtraction_t
    real(default), dimension(:), allocatable :: value
    type(region_data_t) :: reg_data
    integer :: nlegs_born, nlegs_real
    real(default), dimension(:,:), allocatable :: momentum_matrix
    logical :: use_internal_color_correlations = .true.
    logical :: use_internal_spin_correlations = .false.
  contains
  <<fks calc: soft sub: TBP>>
  end type soft_subtraction_t
  
@ %def soft_subtraction_t
@ Computation of $\mathcal{R}_{soft}$:
<<fks calc: soft sub: TBP>>=
  procedure :: compute => soft_subtraction_compute
<<fks calc: procedures>>=
  subroutine soft_subtraction_compute (sub_soft, int_born, p_real, &
       sqme_born, born_ij, y, phi, alpha_s_born, alr, emitter)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(interaction_t), intent(in) :: int_born
    type(vector4_t), intent(in), dimension(:), allocatable :: p_real
    real(default), intent(in) :: sqme_born
    real(default), intent(in), dimension(:,:) :: born_ij
    real(default), intent(in) :: y, phi
    real(default), intent(in) :: alpha_s_born
    integer, intent(in) :: alr, emitter
    type(vector4_t), dimension(:), allocatable :: p_born
    type(vector4_t) :: p_soft
    real(default) :: s_alpha_soft
    real(default) :: q02
    integer :: i, j
    allocate (p_born (sub_soft%nlegs_born))
    p_born = interaction_get_momenta (int_born)
    p_soft = sub_soft%create_softvec_fsr (p_born, y, phi, emitter)
    s_alpha_soft = sub_soft%reg_data%get_svalue_soft &
         (p_born, p_soft, alr, emitter)
    call sub_soft%compute_momentum_matrix (p_born, p_soft)
    if (sub_soft%use_internal_color_correlations) then
      sub_soft%value(alr) = 4*pi*alpha_s_born * sqme_born * s_alpha_soft
    else
      sub_soft%value(alr) = 4*pi*alpha_s_born * s_alpha_soft
    end if
    sub_soft%value(alr) = sub_soft%value(alr) * &
         fold_matrices(sub_soft%momentum_matrix, &
         born_ij, 1)
<<fks calc: soft subtraction computation>>    
  end subroutine soft_subtraction_compute

@ %def soft_subtraction_compute
@ We have to multiply this with $\xi^2(1-y)$. Further, when applying
the soft $\mathcal{S}$-function, the energy of the radiated particle
is factored out. Thus we have $\xi^2/E_{em}^2(1-y) = 4/q_0^2(1-y)$. 
<<fks calc: soft subtraction computation>>=
    q02 = 4* vector4_get_component (p_born(1), 0) * &
         vector4_get_component (p_born(2), 0)
    !!! Map emitter -> value_index    
    sub_soft%value(alr) = 4/q02 * (1-y) * sub_soft%value(alr) 
  contains
    subroutine exchange_color_particles (col_state, i1, i2)
      integer, intent(inout), dimension(:,:) :: col_state
      integer, intent(in) :: i1, i2
      integer, dimension(2) :: col_tmp
      col_tmp = col_state (:,i1)
      col_state (:,i1) = col_state (:,i2)
      col_state (:,i2) = col_tmp
    end subroutine exchange_color_particles
@ Computes the quantity $\mathcal{K}_{ij} = \frac{k_i \cdot
k_j}{(k_i\cdot k)(k_j\cdot k)}$. 
<<fks calc: soft sub: TBP>>=
  procedure :: compute_momentum_matrix => &
       soft_subtraction_compute_momentum_matrix
<<fks calc: procedures>>=
  subroutine soft_subtraction_compute_momentum_matrix &
       (sub_soft, p_born, p_soft)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), dimension(:), allocatable :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: num, deno1, deno2
    integer :: i, j
    do i = 1, sub_soft%nlegs_born
      do j = 1, sub_soft%nlegs_born
        if (i <= j) then
          num = p_born(i) * p_born(j)
          deno1 = p_born(i)*p_soft
          deno2 = p_born(j)*p_soft
          sub_soft%momentum_matrix(i,j) = num/(deno1*deno2)
        else
           !!! momentum matrix is symmetric.
          sub_soft%momentum_matrix(i,j) = sub_soft%momentum_matrix(j,i)
        end if
      end do
    end do
  end subroutine soft_subtraction_compute_momentum_matrix
  
@ %def soft_subtraction_compute_momentum_matrx
@ Explain how soft vector is constructed.
<<fks calc: soft sub: TBP>>=
  procedure :: create_softvec_fsr => soft_subtraction_create_softvec_fsr
<<fks calc: procedures>>=
  function soft_subtraction_create_softvec_fsr &
       (sub_soft, p_born, y, phi, emitter) result (p_soft)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(inout), dimension(:), allocatable :: p_born
    real(default), intent(in) :: y, phi
    integer, intent(in) :: emitter
    type(vector4_t) :: p_soft
    type(vector3_t) :: dir
    type(lorentz_transformation_t) :: rot
    p_soft = p_born(emitter) / vector4_get_component (p_born(emitter), 0)
    dir = create_orthogonal (space_part (p_born(emitter)))
    rot = rotation (y, sqrt(1-y**2), dir)
    p_soft = rot*p_soft
    if (phi /= 0) then
      dir = space_part (p_born(emitter)) / &
           vector4_get_component (p_born(emitter), 0)
      rot = rotation (cos(phi), sin(phi), dir)
      p_soft = rot*p_soft
    end if
  end function soft_subtraction_create_softvec_fsr
  
@ %def soft_subtraction_create_softvec_fsr
@ Perform the sum $\sum_{ij} \mathcal{K}_{ij}\beta_{ij}$
<<fks calc: procedures>>=
  function fold_matrices (m1, m2, i_i, i_final) result (res)
    real(default), intent(in), dimension(:,:) :: m1, m2
    integer, intent(in) :: i_i
    integer, intent(in), optional :: i_final
    real(default) :: res
    integer :: n1, n2
    integer :: i_f
    integer :: i, j
    res = 0
    n1 = size (m1,1)
    n2 = size (m2,1)
    if (n1 /= n2) then
      call msg_fatal ("Fold matrices: Matrices need to have identical shape!")
    else
      if (present (i_final)) then
        i_f = i_final
      else
        i_f = n1
      end if
    end if

    do i = i_i, i_f
      do j = i_i, i_f
        res = res + m1(i,j) * m2(i,j)
      end do
    end do
    !!! Matrices are symmetric
    ! res = 2*res
  end function fold_matrices
  
@ %def fold_matrices
@
\subsection{Collinear counterterms}
@ This data type deals with the calculation of the collinear and
soft-collinear contribution to the cross section. 
<<fks calc: types>>=
  type :: coll_subtraction_t
    real(default), dimension(:), allocatable :: value
    real(default), dimension(:), allocatable :: value_soft
    integer :: n_alr
    real(default), dimension(0:3,0:3) :: b_munu
    real(default) , dimension(0:3,0:3) :: k_perp_matrix
  contains
  <<fks calc: coll sub: TBP>>
  end type coll_subtraction_t
  
@ %def coll_subtraction_t
@
<<fks calc: coll sub: TBP>>=
  procedure :: init => coll_subtraction_init
<<fks calc: procedures>>=
  subroutine coll_subtraction_init (coll_sub, n_alr)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    integer, intent(in) :: n_alr
    coll_sub%n_alr = n_alr
    allocate (coll_sub%value (n_alr))
    allocate (coll_sub%value_soft (n_alr))
  end subroutine coll_subtraction_init

@ %def coll_subtraction_init
<<fks calc: coll sub: TBP>>=
  procedure :: set_k_perp => coll_subtraction_set_k_perp
<<fks calc: procedures>>=
  subroutine coll_subtraction_set_k_perp (coll_sub, p, em, phi)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: em
    real(default), intent(in) :: phi
    type(vector4_t) :: k_perp
    real(default) :: p1, p2, p3
    type(vector3_t) :: vec
    type(lorentz_transformation_t) :: rot
    integer :: i, j

    p1 = vector4_get_component (p(em), 1)
    p2 = vector4_get_component (p(em), 2)
    p3 = vector4_get_component (p(em), 3)

    call vector4_set_component (k_perp, 0, 0._default)
    call vector4_set_component (k_perp, 1, p1)
    call vector4_set_component (k_perp, 2, p2)
    call vector4_set_component (k_perp, 3, -(p1**2+p2**2)/p3)

    vec = create_unit_vector (p(em))
    rot = rotation (cos(phi), sin(phi), vec)
    k_perp = rot * k_perp

    do i = 0, 3
      do j = 0, i
        coll_sub%k_perp_matrix(i,j) = vector4_get_component (k_perp, i) * &
                                      vector4_get_component (k_perp, j)
        coll_sub%k_perp_matrix(j,i) = coll_sub%k_perp_matrix(i,j)
      end do
    end do

  end subroutine coll_subtraction_set_k_perp

@ %def coll_subtraction_set_k_perp
@ Explain computation
<<fks calc: coll sub: TBP>>=
  procedure :: compute => coll_subtraction_compute
<<fks calc: procedures>>=
  subroutine coll_subtraction_compute &
       (coll_sub, sregion, p_born, sqme_born, sqme_born_sc, &
        xi, alpha_s, alr, soft_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:), allocatable :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in), dimension(0:3,0:3) :: sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr
    logical, intent(in), optional :: soft_in
    real(default) :: res
    real(default) :: q0, z, p0
    real(default) :: zoxi
    real(default) :: trB, BK
    real(default) :: pggz
    integer :: nlegs, emitter
    integer :: flv_em, flv_rad
    logical :: soft
    if (present (soft_in)) then
      soft = soft_in
    else
      soft = .false.
    end if
    nlegs = size (sregion%flst_real%flst)
    emitter = sregion%emitter
    flv_rad = sregion%flst_real%flst(nlegs)
    flv_em = sregion%flst_real%flst(emitter)
    p0 = vector4_get_component (p_born(emitter),0)
    if (sregion%emitter <= 2) then
      coll_sub%value(alr) = 0   
    else
      q0 = vector4_get_component (p_born(1), 0) + &
           vector4_get_component (p_born(2), 0)
      !!! Here, z corresponds to 1-z in the formulas of arXiv:1002.2581; 
      !!! the integrand is symmetric under this variable change
      zoxi = q0/(2*p0)
      z = xi*zoxi
      if (is_gluon(flv_em) .and. is_gluon(flv_rad)) then
         pggz = CA*(z**2*(1-z) - z**2/(1-z) + z-1)
         trB = compute_trB (); BK = compute_BK ()
         res = (trB*pggz + 4*BK*CA*z**2*(1-z))/zoxi
      else if (is_gluon(flv_em) .and. is_quark (abs(flv_rad))) then
         trB = compute_trB (); BK = compute_BK ()
         res = -TR*(trB*z + z**2*(1-z)*BK)/zoxi
      else if (is_quark (abs(flv_em)) .and. is_gluon (flv_rad)) then
         res = sqme_born*CF*(1+(1-z)**2)/zoxi
      else
        stop 'Error: Impossible flavor structure in collinear counterterm!' 
      end if
    end if
    res = res /(p0**2*(1-z)**zoxi)
@ Actually it's 8 but we divide by the factor 2 in the denominator
<<fks calc: procedures>>=
    res = res * 4*pi*alpha_s * sregion%mult

    if (soft) then
      coll_sub%value_soft (alr) = res
    else
      coll_sub%value (alr) = res
    end if
  contains
    function compute_trB () result (value)
      real(default) :: value
      value = sqme_born_sc(0,0) - sqme_born_sc(1,1) - sqme_born_sc(2,2) - sqme_born_sc(3,3)
    end function compute_trB
    
    function compute_BK () result (value)
      real(default) :: value
      BK = fold_matrices (sqme_born_sc, coll_sub%k_perp_matrix, 0, 3)
    end function compute_BK
  end subroutine coll_subtraction_compute
  
@ %def coll_subtraction_compute
@ Explain soft limit
<<fks calc: coll sub: TBP>>=
  procedure :: compute_soft_limit => coll_subtraction_compute_soft_limit
<<fks calc: procedures>>=
  subroutine coll_subtraction_compute_soft_limit &
       (coll_sub, sregion, p_born, sqme_born, &
        sqme_born_sc, xi, alpha_s, alr)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:), allocatable :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in), dimension(0:3,0:3) :: sqme_born_sc
    real(default) :: xi, alpha_s
    integer, intent(in) :: alr
    real(default) :: coll_soft_sub
    call coll_sub%compute (sregion, p_born, sqme_born, &
                           sqme_born_sc, xi, alpha_s, alr, .true.)
  end subroutine coll_subtraction_compute_soft_limit
  
@ %def coll_subtraction_compute_soft_limit
\subsection{Virtual contribution to the cross section}
<<fks calc: types>>=
  type :: virtual_t
    real(default) :: Q
    real(default), dimension(:,:), allocatable :: I
    real(default) :: vfin
    real(default) :: sqme_cc
    real(default) :: sqme_virt
    real(default), dimension(:), allocatable :: gamma_0, gamma_p, c_flv
    real(default) :: ren_scale2
    integer :: n_is_neutrinos = 0
    logical :: bad_point
    logical :: use_internal_color_correlations
  contains
  <<fks calc: virtual: TBP>>
  end type virtual_t
  
@ %def virtual_t 
<<fks calc: virtual: TBP>>=
  procedure :: init => virtual_init
<<fks calc: procedures>>=
 subroutine virtual_init (object, flv_born)
    class(virtual_t), intent(inout) :: object
    integer, intent(in), dimension(:) :: flv_born
    integer :: nlegs
    nlegs = size (flv_born)
    allocate (object%I (nlegs, nlegs))
    allocate (object%gamma_0 (nlegs), object%gamma_p (nlegs), &
         object%c_flv (nlegs))
    call object%init_constants (flv_born)
    if (is_neutrino (flv_born(1))) &
       object%n_is_neutrinos = object%n_is_neutrinos + 1
    if (is_neutrino (flv_born(2))) &
       object%n_is_neutrinos = object%n_is_neutrinos + 1 
  contains
    function is_neutrino (flv) result (neutrino)
      integer, intent(in) :: flv
      logical :: neutrino
      neutrino = (abs(flv)==12 .or. abs(flv)==14 .or. abs(flv)==16)
    end function is_neutrino
  end subroutine virtual_init

@ %def virtual_init
@ Write down constant definition somewhere
<<fks calc: virtual: TBP>>=
  procedure :: init_constants => virtual_init_constants
<<fks calc: procedures>>=
  subroutine virtual_init_constants (object, flv_born)
    class(virtual_t), intent(inout) :: object
    integer, intent(in), dimension(:) :: flv_born
    integer :: i
    integer, parameter :: nf = 1 !What is the proper choice of nf?
    do i = 1, size (flv_born)
      if (is_gluon (flv_born(i))) then
        object%gamma_0(i) = (11*ca - 2*nf)/6
        object%gamma_p(i) = (67.0/9 - 2*pi**2/3)*ca - 23.0/18*nf
        object%c_flv(i) = ca
      else if (is_quark (abs(flv_born(i)))) then
        object%gamma_0(i) = 1.5*cf
        object%gamma_p(i) = (6.5 - 2*pi**2/3)*cf
        object%c_flv(i) = cf
      else
        object%gamma_0(i) = 0
        object%gamma_p(i) = 0
        object%c_flv(i) = 0
      end if
    end do
  end subroutine virtual_init_constants
  
@ %def virtual_init_constants
@ Set the renormalization scale. If the input is zero, use the
center-of-mass energy. 
<<fks calc: virtual: TBP>>=
  procedure :: set_ren_scale => virtual_set_ren_scale
<<fks calc: procedures>>=
  subroutine virtual_set_ren_scale (object, int_born, ren_scale)
    class(virtual_t), intent(inout) :: object
    type(interaction_t), intent(in) :: int_born
    real(default), intent(in) :: ren_scale
    type(vector4_t), dimension(:), allocatable :: p_born
    if (ren_scale > 0) then
      object%ren_scale2 = ren_scale**2
    else
      p_born = interaction_get_momenta (int_born)
      object%ren_scale2 = (p_born(1)+p_born(2))**2
    end if
  end subroutine virtual_set_ren_scale
  
@ %def virtual_set_ren_scale
@ Draw formula for $\mathcal{Q}$
<<fks calc: virtual: TBP>>=
  procedure :: compute_Q => virtual_compute_Q
<<fks calc: procedures>>=
  subroutine virtual_compute_Q (object, p_born)
    class(virtual_t), intent(inout) :: object
    type(vector4_t), intent(in), dimension(:), allocatable :: p_born
    real(default) :: Q
    real(default) :: sqrts, E
    real(default) :: s1, s2, s3, s4
    integer :: i
    sqrts = sqrt ((p_born(1)+p_born(2))**2)
    !!! ---- NOTE: Implementation only works for lepton collisions. 
    !!!            This implies that both the summand containing log(s/q**2) 
    !!!            and (_fp + vfm) vanish. 
    !!!            Also, s = (p_born(1)+p_born(2))**2
    object%Q = 0
    do i = 1, size(p_born)
      s1 = object%gamma_p(i)
      s2 = 0; s3 = 0; s4 = 0
      E = vector4_get_component (p_born(i), 0)
      s2 = log(sqrts**2/object%ren_scale2)*&
           (object%gamma_0(i)-2 * object%c_flv(i) * log(2*E/sqrts))
      s3 = 2*log(2*E/sqrts)**2*object%c_flv(i)
      s4 = 2*log(2*E/sqrts)*object%gamma_0(i)
      object%Q = object%Q + s1 - s2 + s3 - s4
    end do
  end subroutine virtual_compute_Q
  
@ %def virtual_compute_Q
@ Draw formula for $\mathcal{I}$
<<fks calc: virtual: TBP>>=
  procedure :: compute_I => virtual_compute_I
<<fks calc: procedures>>=
  subroutine virtual_compute_I (object, p_born, i, j)
    class(virtual_t), intent(inout) :: object
    type(vector4_t), intent(in), dimension(:), allocatable :: p_born
    integer, intent(in) :: i, j
    type(vector4_t) :: pi, pj
    real(default) :: Ei, Ej
    real(default) :: pij, Eij
    real(default) :: s
    real(default) :: s1, s2, s3, s4, s5
    real(default) :: arglog
    real(default), parameter :: tiny_value = epsilon(1.0)
    !!! ----NOTE: As above, only lepton collisions. Therefore, the 
    !!!           first and second summand are not taken into account.
    s1 = 0; s2 = 0; s3 = 0; s4 = 0; s5 = 0
    s = (p_born(1)+p_born(2))**2
    pi = p_born(i); pj = p_born(j)
    Ei = vector4_get_component (pi, 0)
    Ej = vector4_get_component (pj, 0)
    pij = pi*pj; Eij = Ei*Ej
    s1 = 0.5*log(s/object%ren_scale2)**2
    s2 = log(s/object%ren_scale2)*log(pij/(2*Eij))
    s3 = Li2 (pij / (2*Eij))
    s4 = 0.5*log (pij / (2*Eij))**2
    arglog = 1 - pij/(2*Eij)
    if (arglog > tiny_value) then
      s5 = log(arglog) * log(pij / (2*Eij))
    else
      s5 = 0
    end if
    object%I(i,j) = s1 + s2 -s3 + s4 - s5
  end subroutine virtual_compute_I
  
@ %def virtual_compute_I
@ Explain $\mathcal{V}_{fin}$.
<<fks calc: virtual: TBP>>=
  procedure :: compute_vfin_test => virtual_compute_vfin_test
<<fks calc: procedures>>=
  subroutine virtual_compute_vfin_test (object, p_born, sqme_born)
    class(virtual_t), intent(inout) :: object
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default) :: s, mu2
    s = (p_born(1)+p_born(2))**2
    !!! ----NOTE: Test implementation for e+ e- -> u ubar
    object%vfin = sqme_born * cf * &
         (pi**2 - 8 + 3*log(s/object%ren_scale2) - log(s/object%ren_scale2)**2)
    object%bad_point = .false.
  end subroutine virtual_compute_vfin_test

@ %def virtual_compute_vfin
@ $\mathcal{V} = \frac{\alpha_s}{2\pi}\left(\mathcal{Q}\mathcal{B} +
  \sum \mathcal{I}_{ij}\mathcal{B}_{ij} + \mathcal{V}_{fin}\right)$ 
<<fks calc: virtual: TBP>>=
  procedure :: evaluate => virtual_evaluate
<<fks calc: procedures>>=
  subroutine virtual_evaluate &
       (object, reg_data, i_proc, alpha_s, p_born, born, b_ij)
    class(virtual_t), intent(inout) :: object
    type(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_proc
    real(default), intent(in) :: alpha_s
    type(vector4_t), intent(inout), dimension(:), allocatable :: p_born
    real(default), intent(in) :: born
    real(default), intent(in), dimension(:,:,:), allocatable :: b_ij
    integer :: i, j, alr
    integer :: nlegs
    real(default) :: BI
    if (object%bad_point) then
       object%sqme_virt = 0
    else
       BI = 0
       nlegs = size (p_born)
       call object%compute_Q (p_born)
       alr = find_first_alr (reg_data, i_proc)
       associate (flst_born => reg_data%regions(alr)%flst_uborn%flst)
         do i = 1, nlegs
           do j = 1, nlegs
             if (i /= j) then
               if (abs(flst_born(i)) <= 6 .and. abs(flst_born(j)) <= 6) then
                  call object%compute_I (p_born, i, j)
                  BI = BI + b_ij (i,j,reg_data%regions(alr)%uborn_index) * &
                                  object%I(i,j)
               end if
             end if
           end do
         end do
       end associate
       if (object%use_internal_color_correlations) BI = BI*born
       object%sqme_virt = alpha_s/twopi * (object%Q*born + BI + object%vfin)
       if (object%n_is_neutrinos > 0) &
          object%sqme_virt = object%sqme_virt * object%n_is_neutrinos*2
    end if
  contains
    function find_first_alr (reg_data, i_proc) result (alr_out)
       type(region_data_t), intent(in) :: reg_data
       integer, intent(in) :: i_proc
       integer :: alr_out
       integer :: k
       alr_out = 0
       do k = 1, reg_data%get_nregions ()
          alr_out = alr_out+1
          if (reg_data%regions(k)%uborn_index == i_proc+1) exit
       end do
    end function find_first_alr
  end subroutine virtual_evaluate

@ %def virtual_evaluate
@
<<fks calc: virtual: TBP>>=
  procedure :: set_vfin => virtual_set_vfin
<<fks calc: procedures>>=
  subroutine virtual_set_vfin (object, vfin)
    class(virtual_t), intent(inout) :: object
    real(default) :: vfin
    object%vfin = vfin
  end subroutine virtual_set_vfin

@ %def virtual_set_vfin
@  
<<fks calc: virtual: TBP>>=
  procedure :: set_bad_point => virtual_set_bad_point
<<fks calc: procedures>>=
  subroutine virtual_set_bad_point (object, value)
     class(virtual_t), intent(inout) :: object
     logical, intent(in) :: value
     object%bad_point = value
  end subroutine virtual_set_bad_point

@  %def virtual_set_bad_point
@
\subsection{Putting it together}
This data type governs the whole calculation. It contains information
about color, spin and flavor as well as the information about the Born
process. 
<<fks calc: public>>=
  public :: nlo_data_t
<<fks calc: types>>=
  type :: nlo_data_t
    type(string_t) :: nlo_type
    type(region_data_t) :: reg_data
    integer :: n_alr
    integer :: n_in
    integer :: n_out_born
    integer :: n_out_real
    integer :: n_allowed_born
    integer :: n_flv_born 
    integer :: n_flv_real
    integer :: active_emitter
    complex(default), dimension(:), allocatable :: amp_born
    type(color_data_t) :: color_data
    type(real_kinematics_t) :: real_kinematics
    type(soft_subtraction_t) :: sub_soft
    type(coll_subtraction_t) :: sub_coll
    type(virtual_t) :: virtual_terms
    integer, dimension(:,:), allocatable :: flv_state_born
    integer, dimension(:,:), allocatable :: hel_state_born
    integer, dimension(:,:), allocatable :: flv_state_real
    integer, dimension(:,:), allocatable :: hel_state_real
    integer, dimension(:), allocatable :: flv_born
    integer, dimension(:), allocatable :: hel_born
    integer, dimension(:), allocatable :: col_born
    real(default) :: alpha_s_born
    logical :: alpha_s_born_set
    real(default), dimension(:), allocatable :: sqme_born
    real(default), dimension(:,:,:), allocatable :: sqme_born_cc
    real(default), dimension(:,:,:), allocatable :: sqme_born_sc
    real(default), public :: sqme_real
    real(default), public :: sqme_virt
    type(interaction_t), public :: int_born
    real(default), public :: jac_real
    type(kinematics_counter_t), public :: counter
    logical, public :: counter_exists = .false.
    logical, dimension(:), allocatable :: sc_required
    logical :: use_internal_color_correlations = .true.
    logical :: use_internal_spin_correlations = .false.
  contains
  <<fks calc: nlo data: TBP>>
  end type nlo_data_t

@ %def nlo_data_t 
@
<<fks calc: public>>=
  public :: nlo_pointer_t
<<fks calc: types>>=
  type :: nlo_pointer_t
    type(nlo_data_t), public, pointer :: nlo_data => null ()
  end type nlo_pointer_t

@ %def nlo_pointer_t
@
<<fks calc: nlo data: TBP>>=
  procedure :: init => nlo_data_init
<<fks calc: procedures>>=  
  subroutine nlo_data_init (nlo_data, nlo_type, prc_constants, template, model)
     class(nlo_data_t), intent(inout) :: nlo_data
     type(string_t), intent(in) :: nlo_type
     type(process_constants_t), intent(inout), dimension(2) :: prc_constants
     type(fks_template_t), intent(in) :: template
     type(model_t), intent(in) :: model
     integer :: i
     nlo_data%nlo_type = nlo_type
     select case (char (nlo_type))
     case ('Real')
       nlo_data%flv_state_born = prc_constants(1)%get_flv_state ()
       nlo_data%flv_state_real = prc_constants(2)%get_flv_state ()
       allocate (nlo_data%sc_required (size (nlo_data%flv_state_born, dim=2)))
       do i = 1, size (nlo_data%sc_required)
         if (any (nlo_data%flv_state_born (:,i) == GLUON)) then
            nlo_data%sc_required(i) = .true.
         else
            nlo_data%sc_required(i) = .false.
         end if
       end do
       ! call prc_constants(1)%get_hel_state (nlo_data%hel_state_born)
       ! call prc_constants(2)%get_hel_state (nlo_data%hel_state_real)
       call nlo_data%reg_data%init &
            (model, nlo_data%flv_state_born, nlo_data%flv_state_real, &
             template%mapping_type)
       select type (mapping => nlo_data%reg_data%fks_mapping)
       type is (fks_mapping_default_t)
         call mapping%set_parameter (template%fks_dij_exp1, template%fks_dij_exp2)
       end select
       nlo_data%n_flv_born = nlo_data%reg_data%n_flv_born
       nlo_data%n_flv_real = nlo_data%reg_data%n_flv_real
       allocate (nlo_data%sqme_born (nlo_data%n_flv_born))
       nlo_data%sqme_born = 0.0
       nlo_data%n_alr = size(nlo_data%reg_data%regions)
       nlo_data%n_in = prc_constants(2)%n_in
       nlo_data%n_out_born = prc_constants(1)%n_out
       nlo_data%n_out_real = prc_constants(2)%n_out
       nlo_data%alpha_s_born = 0._default
       nlo_data%alpha_s_born_set = .false.
       nlo_data%sqme_real = 0._default
       allocate (nlo_data%sqme_born_cc (nlo_data%n_in + nlo_data%n_out_born, &
                                        nlo_data%n_in + nlo_data%n_out_born, &
                                        nlo_data%n_flv_born))
       allocate (nlo_data%sqme_born_sc (0:3,0:3,nlo_data%n_flv_born))
       call nlo_data%color_data%init (nlo_data%reg_data, prc_constants)
       call nlo_data%init_real_kinematics
       call nlo_data%init_soft (prc_constants)
       call nlo_data%init_coll 
       nlo_data%counter_exists = template%count_kinematics
       if (nlo_data%counter_exists) call nlo_data%counter%init(20)
     end select
   end subroutine nlo_data_init

@ %def nlo_data_init
@
<<fks calc: nlo data: TBP>>=
  procedure :: write => nlo_data_write
<<fks calc: procedures>>=
  subroutine nlo_data_write (nlo_data, unit)
    class(nlo_data_t), intent(in) :: nlo_data
    integer, intent(in), optional :: unit
    integer :: i, j, u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(1x,A,I0)") "n_alr          = ", nlo_data%n_alr
    write (u, "(1x,A,I0)") "n_in           = ", nlo_data%n_in
    write (u, "(1x,A,I0)") "n_out_born     = ", nlo_data%n_out_born
    write (u, "(1x,A,I0)") "n_out_real     = ", nlo_data%n_out_real
    write (u, "(1x,A,I0)") "n_allowed_born = ", nlo_data%n_allowed_born
    write (u, "(1x,A,I0)") "n_flv_born     = ", nlo_data%n_flv_born
    write (u, "(1x,A,I0)") "n_flv_real     = ", nlo_data%n_flv_real
    do i = 1, size (nlo_data%flv_born)
      write (u, "(3x,I0)") nlo_data%flv_born(i)
    end do
    do i = 1, size (nlo_data%col_born)
      write (u, "(3x,I0)") nlo_data%col_born(i)
    end do
  end subroutine nlo_data_write

@ %def nlo_data_write
@
<<fks calc: nlo data: TBP>>=
  procedure :: init_born_amps => nlo_data_init_born_amps
<<fks calc: procedures>>=
  subroutine nlo_data_init_born_amps (nlo_data, n, internal_correlations)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in) :: n
    logical, intent(in) :: internal_correlations
    nlo_data%n_allowed_born = n
    allocate (nlo_data%amp_born (n))
    nlo_data%use_internal_color_correlations = internal_correlations
    nlo_data%sub_soft%use_internal_color_correlations = internal_correlations
    nlo_data%virtual_terms%use_internal_color_correlations = internal_correlations
    nlo_data%use_internal_spin_correlations = internal_correlations
  end subroutine nlo_data_init_born_amps

@ %def nlo_data_init_born_amps
<<fks calc: nlo data: TBP>>=
  procedure :: init_soft => nlo_data_init_soft
<<fks calc: procedures>>=
  subroutine nlo_data_init_soft (nlo_data, prc_constants)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(process_constants_t), intent(inout), dimension(2) :: prc_constants
    nlo_data%sub_soft%reg_data = nlo_data%reg_data
    nlo_data%sub_soft%nlegs_born = nlo_data%n_in + nlo_data%n_out_born
    nlo_data%sub_soft%nlegs_real = nlo_data%n_in + nlo_data%n_out_real
    allocate (nlo_data%sub_soft%value (nlo_data%reg_data%n_emitters))
    allocate (nlo_data%sub_soft%momentum_matrix &
             (nlo_data%sub_soft%nlegs_born, nlo_data%sub_soft%nlegs_born))
  end subroutine nlo_data_init_soft

@
@ %def nlo_data_init_soft
<<fks calc: nlo data: TBP>>=
  procedure :: init_coll => nlo_data_init_coll
<<fks calc: procedures>>=
  subroutine nlo_data_init_coll (nlo_data)
    class(nlo_data_t), intent(inout) :: nlo_data
    call nlo_data%sub_coll%init (nlo_data%n_alr)
  end subroutine nlo_data_init_coll

@
@ %def nlo_data_init_coll
<<fks calc: nlo data: TBP>>=
  procedure :: init_virtual => nlo_data_init_virtual
<<fks calc: procedures>>=
  subroutine nlo_data_init_virtual (nlo_data)
    class(nlo_data_t), intent(inout) :: nlo_data
    call nlo_data%virtual_terms%init (nlo_data%flv_state_born (:,1))
  end subroutine nlo_data_init_virtual

@ %def nlo_data_init_virtual
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_nlo_type => nlo_data_set_nlo_type
<<fks calc: procedures>>=
  subroutine nlo_data_set_nlo_type (nlo_data, nlo_type)
   class(nlo_data_t), intent(inout) :: nlo_data
   ! integer, intent(in) :: nlo_type
   type(string_t), intent(in) :: nlo_type
   nlo_data%nlo_type = nlo_type
  end subroutine nlo_data_set_nlo_type

@ %def nlo_data_set_nlo_type
@
<<fks calc: nlo data: TBP>>=
  procedure :: get_nlo_type => nlo_data_get_nlo_type 
<<fks calc: procedures>>=
  function nlo_data_get_nlo_type (nlo_data) result(nlo_type)
    class(nlo_data_t), intent(inout) :: nlo_data
    ! integer :: nlo_type
    type(string_t) :: nlo_type
    nlo_type = nlo_data%nlo_type
  end function nlo_data_get_nlo_type

@ %def nlo_data_get_nlo_type
@
<<fks calc: nlo data: TBP>>=
  procedure :: get_emitters => nlo_data_get_emitters
<<fks calc: procedures>>=
  function nlo_data_get_emitters (nlo_data) result(emitters)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, dimension(:), allocatable :: emitters
    emitters = nlo_data%reg_data%get_emitters ()
  end function nlo_data_get_emitters

@ %def nlo_data_get_emmiters
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_active_emitter => nlo_data_set_active_emitter
<<fks calc: procedures>>=
  subroutine nlo_data_set_active_emitter (nlo_data, emitter)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in) :: emitter
    nlo_data%active_emitter = emitter
  end subroutine nlo_data_set_active_emitter

@ %def nlo_data_set_active_emitter
@
<<fks calc: nlo data: TBP>>=
  procedure :: get_active_emitter => nlo_data_get_active_emitter
<<fks calc: procedures>>=
  function nlo_data_get_active_emitter (nlo_data) result(emitter)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer :: emitter
    emitter = nlo_data%active_emitter
  end function nlo_data_get_active_emitter

@ %def nlo_data_get_active_emitter
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_flv_born => nlo_data_set_flv_born
<<fks calc: procedures>>=
  subroutine nlo_data_set_flv_born (nlo_data, flv_in)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in), dimension(:), allocatable :: flv_in
    allocate (nlo_data%flv_born (size (flv_in)))
    nlo_data%flv_born = flv_in
  end subroutine nlo_data_set_flv_born 

@ %def nlo_data_set_flv_born
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_hel_born => nlo_data_set_hel_born
<<fks calc: procedures>>=
  subroutine nlo_data_set_hel_born (nlo_data, hel_in)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in), dimension(:), allocatable :: hel_in
    allocate (nlo_data%hel_born (size (hel_in)))
    nlo_data%hel_born = hel_in
  end subroutine nlo_data_set_hel_born 

@ %def nlo_data_set_hel_born
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_col_born => nlo_data_set_col_born
<<fks calc: procedures>>=
  subroutine nlo_data_set_col_born (nlo_data, col_in)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in), dimension(:), allocatable :: col_in
    allocate (nlo_data%col_born (size (col_in)))
    nlo_data%col_born = col_in
  end subroutine nlo_data_set_col_born

@ %def nlo_data_set_col_born
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_alpha_s_born => nlo_data_set_alpha_s_born
<<fks calc: procedures>>=
  subroutine nlo_data_set_alpha_s_born (nlo_data, as_born)
    class (nlo_data_t), intent(inout) :: nlo_data
    real(default), intent(in) :: as_born
    nlo_data%alpha_s_born = as_born
    nlo_data%alpha_s_born_set = .true.
  end subroutine nlo_data_set_alpha_s_born

@ %def nlo_data_set_alpha_s_born
@
<<fks calc: nlo data: TBP>>=
  procedure :: init_real_kinematics => nlo_data_init_real_kinematics
<<fks calc: procedures>>=
  subroutine nlo_data_init_real_kinematics (nlo_data)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer :: n_tot
    n_tot = nlo_data%n_in + nlo_data%n_out_born
    allocate (nlo_data%real_kinematics%xi_max (n_tot))
    nlo_data%real_kinematics%xi_tilde = 0
    nlo_data%real_kinematics%y = 0
    nlo_data%real_kinematics%xi_max = 0
    nlo_data%real_kinematics%phi = 0
  end subroutine nlo_data_init_real_kinematics

@ %def nlo_data_init_real_kinematics
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_real_kinematics => nlo_data_set_real_kinematics 
<<fks calc: procedures>>=
  subroutine nlo_data_set_real_kinematics (nlo_data, xi_tilde, y, phi, xi_max, jac)
    class(nlo_data_t), intent(inout) :: nlo_data
    real(default), dimension(:), allocatable :: xi_max
    real(default), intent(in) :: xi_tilde
    real(default), intent(in) :: y, phi
    real(default), intent(in), dimension(3) :: jac
    nlo_data%real_kinematics%xi_tilde = xi_tilde
    nlo_data%real_kinematics%y = y
    nlo_data%real_kinematics%phi = phi
    nlo_data%real_kinematics%xi_max = xi_max
    nlo_data%real_kinematics%jac = jac
  end subroutine nlo_data_set_real_kinematics

@ %def nlo_data_set_real_kinematics
@
<<fks calc: nlo data: TBP>>=
  procedure :: get_real_kinematics => nlo_data_get_real_kinematics
<<fks calc: procedures>>=
  subroutine nlo_data_get_real_kinematics &
       (nlo_data, em, xi_tilde, y, xi_max, jac, phi)
    class(nlo_data_t), intent(in) :: nlo_data
    integer, intent(in) :: em
    real(default), intent(out) :: xi_tilde, y, xi_max
    real(default), intent(out), dimension(3), optional :: jac
    !!! For most applications, phi is not relevant. Thus, it is not 
    !!! always transferred as a dummy-variable
    real(default), intent(out), optional :: phi
    xi_tilde = nlo_data%real_kinematics%xi_tilde
    y = nlo_data%real_kinematics%y
    xi_max = nlo_data%real_kinematics%xi_max (em)
    if (present (jac)) jac = nlo_data%real_kinematics%jac
    if (present (phi)) phi = nlo_data%real_kinematics%phi
  end subroutine nlo_data_get_real_kinematics

@ %def nlo_data_get_real_kinematics
@
<<fks calc: nlo data: TBP>>=
  procedure :: set_real_momenta => nlo_data_set_real_momenta 
<<fks calc: procedures>>=
  subroutine nlo_data_set_real_momenta (nlo_data, p)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(vector4_t), intent(in), dimension(:), allocatable :: p
    nlo_data%real_kinematics%p_real = p
  end subroutine nlo_data_set_real_momenta

@ %def nlo_data_set_real_momenta
<<fks calc: nlo data: TBP>>=
  procedure :: get_real_momenta => nlo_data_get_real_momenta
<<fks calc: procedures>>=
  function nlo_data_get_real_momenta (nlo_data) result (p)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(vector4_t), dimension(:), allocatable :: p
    p = nlo_data%real_kinematics%p_real
  end function nlo_data_get_real_momenta

@ %def nlo_data_get_real_kinematics
<<fks calc: nlo data: TBP>>=
  procedure :: set_jacobian => nlo_data_set_jacobian
<<fks calc: procedures>>=
  subroutine nlo_data_set_jacobian (nlo_data, jac)
    class(nlo_data_t), intent(inout) :: nlo_data
    real(default), intent(in), dimension(3) :: jac
    nlo_data%real_kinematics%jac = jac
  end subroutine nlo_data_set_jacobian

@ %def nlo_data_set_jacobian
<<fks calc: nlo data: TBP>>=
  procedure :: compute_sub_soft => nlo_data_compute_sub_soft
<<fks calc: procedures>>=
  subroutine nlo_data_compute_sub_soft &
       (nlo_data, int_born, p_real, alr, emitter)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(interaction_t), intent(in) :: int_born
    type(vector4_t), intent(in), dimension(:), allocatable :: p_real
    integer, intent(in) :: alr, emitter
    associate (sregion => nlo_data%reg_data%regions(alr))
      if (nlo_data%use_internal_color_correlations) then
        call nlo_data%sub_soft%compute (int_born, p_real, &
                                    nlo_data%sqme_born(sregion%uborn_index), &
                                    nlo_data%color_data%beta_ij (:,:,sregion%uborn_index), &
                                    nlo_data%real_kinematics%y, &
                                    nlo_data%real_kinematics%phi, &
                                    nlo_data%alpha_s_born, &
                                    alr, emitter)
      else
        call nlo_data%sub_soft%compute (int_born, p_real, &
                                    nlo_data%sqme_born(sregion%uborn_index), &
                                    nlo_data%sqme_born_cc (:,:,sregion%uborn_index), &
                                    nlo_data%real_kinematics%y, &
                                    nlo_data%real_kinematics%phi, &
                                    nlo_data%alpha_s_born, &
                                    alr, emitter)
      end if
    end associate
  end subroutine nlo_data_compute_sub_soft

@ %def nlo_data_compute_sub_soft
@ 
<<fks calc: nlo data: TBP>>=
  procedure :: compute_sub_coll => nlo_data_compute_sub_coll
<<fks calc: procedures>>=
  subroutine nlo_data_compute_sub_coll (nlo_data, int_born, alr)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(interaction_t), intent(in) :: int_born
    integer, intent(in) :: alr
    type(vector4_t), dimension(:), allocatable :: p_born
    integer :: em
    real(default) :: xi
    p_born = interaction_get_momenta (int_born)
    em = nlo_data%get_active_emitter ()
    xi = nlo_data%real_kinematics%xi_tilde * nlo_data%real_kinematics%xi_max (em)
    associate (sregion => nlo_data%reg_data%regions(alr))
    call nlo_data%sub_coll%compute (sregion, p_born, &
                                      nlo_data%sqme_born(sregion%uborn_index), &
                                      nlo_data%sqme_born_sc (:,:,sregion%uborn_index), &
                                      xi, &
                                      nlo_data%alpha_s_born, alr)
    end associate
  end subroutine nlo_data_compute_sub_coll

@ %def nlo_data_compute_sub_coll
@
<<fks calc: nlo data: TBP>>=
  procedure :: compute_sub_coll_soft => nlo_data_compute_sub_coll_soft
<<fks calc: procedures>>=
  subroutine nlo_data_compute_sub_coll_soft (nlo_data, int_born, alr)
    class(nlo_data_t), intent(inout) :: nlo_data
    type(interaction_t), intent(in) :: int_born
    integer, intent(in) :: alr
    type(vector4_t), dimension(:), allocatable :: p_born
    real(default), parameter :: xi = 0
    p_born = interaction_get_momenta (int_born)
    associate (sregion => nlo_data%reg_data%regions(alr))
    call nlo_data%sub_coll%compute_soft_limit (sregion, p_born, &
         nlo_data%sqme_born(sregion%uborn_index), &
         nlo_data%sqme_born_sc (:,:,sregion%uborn_index), &
         xi, nlo_data%alpha_s_born, alr)
    end associate
  end subroutine nlo_data_compute_sub_coll_soft

@ %def nlo_data_compute_sub_coll_soft
@
<<fks calc: nlo data: TBP>>=
  procedure :: compute_virt => nlo_data_compute_virt
<<fks calc: procedures>>=
  function nlo_data_compute_virt (nlo_data, i_proc, int_born) result(sqme_virt)
    class(nlo_data_t), intent(inout) :: nlo_data
    integer, intent(in) :: i_proc
    type(interaction_t), intent(in) :: int_born
    real(default) :: sqme_virt
    type(vector4_t), dimension(:), allocatable :: p_born
    p_born = interaction_get_momenta (int_born)
    if (nlo_data%use_internal_color_correlations) then
      call nlo_data%virtual_terms%evaluate (nlo_data%reg_data, &
                                            i_proc, &
                                            nlo_data%alpha_s_born, &
                                            p_born, &
                                            nlo_data%sqme_born(1), &
                                            nlo_data%color_data%beta_ij)
    else
      call nlo_data%virtual_terms%evaluate (nlo_data%reg_data, &
                                            i_proc, &
                                            nlo_data%alpha_s_born, &
                                            p_born, &
                                            nlo_data%sqme_born(1), &
                                            nlo_data%sqme_born_cc)
    end if
    sqme_virt = nlo_data%virtual_terms%sqme_virt
  end function nlo_data_compute_virt

@ %def nlo_data_compute_virt
@
<<fks calc: public>>=
  public :: fks_calculation_test
<<fks calc: procedures>>=
  subroutine fks_calculation_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test (fks_calculation_1, "fks_calculation_1", &
               "Check the creation of color-correlated matrix elements", &
                u, results)
  end subroutine fks_calculation_test

@ %def fks_calculation_test
@
<<fks calc: procedures>>=
  subroutine fks_calculation_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(nlo_data_t) :: nlo_data
    type(process_constants_t), dimension(2) :: prc_const
    integer, dimension(:,:), allocatable :: flavor_born, flavor_real
    integer, dimension(:,:), allocatable :: cf_index
    complex(default), dimension(:), allocatable :: color_factors
    integer, dimension(:,:,:), allocatable :: col_state_born, col_state_real
    logical, dimension(:,:), allocatable :: ghost_flag_born, ghost_flag_real
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(fks_template_t) :: template

    call os_data_init (os_data)

    allocate (flavor_born (5,1))
    allocate (flavor_real (6,2))
    flavor_born (:,1) = [11, -11, 2, -2, 21]
    flavor_real (:,1) = [11, -11, 2, -2, 21, 21]
    flavor_real (:,2) = [11, -11, 2, -2, 2, -2]

    allocate (col_state_born (2,5,2))
    allocate (col_state_real (2,6,7))
    col_state_born(1,:,1) = [0,0,0,1,2]
    col_state_born(2,:,1) = [0,0,-2,0,-1]
    col_state_born(1,:,2) = [0,0,0,1,0]
    col_state_born(2,:,2) = [0,0,-1,0,0]
    col_state_real(1,:,1) = [0,0,0,1,0,3]
    col_state_real(2,:,1) = [0,0,-3,0,0,-1]
    col_state_real(1,:,2) = [0,0,0,1,2,3]
    col_state_real(2,:,2) = [0,0,-3,0,-1,-2]
    col_state_real(1,:,3) = [0,0,0,1,0,2]
    col_state_real(2,:,3) = [0,0,-2,0,-1,0]
    col_state_real(1,:,4) = [0,0,0,1,2,3]
    col_state_real(2,:,4) = [0,0,-2,0,-3,-1]
    col_state_real(1,:,5) = [0,0,0,1,2,0]
    col_state_real(2,:,5) = [0,0,-2,0,-1,0]
    col_state_real(1,:,6) = [0,0,0,1,0,0]
    col_state_real(2,:,6) = [0,0,-1,0,0,0]
    col_state_real(1,:,7) = [0,0,0,1,0,2]
    col_state_real(2,:,7) = [0,0,-1,0,-2,0]

    allocate (cf_index (2,11))
    cf_index (:,1) = [1,1]
    cf_index (:,2) = [2,2]
    cf_index (:,3) = [2,4]
    cf_index (:,4) = [3,3]
    cf_index (:,5) = [3,7]
    cf_index (:,6) = [4,2]
    cf_index (:,7) = [4,4]
    cf_index (:,8) = [5,5]
    cf_index (:,9) = [6,6]
    cf_index (:,10) = [7,3]
    cf_index (:,11) = [7,7]

    allocate (color_factors (2))
    color_factors(1) = (9,0)
    color_factors(2) = (-1,0)

    allocate (ghost_flag_born (5,2))
    ghost_flag_born = .false.
    
    allocate (ghost_flag_real (6,7))
    ghost_flag_real = .false.
    ghost_flag_real (5,1) = .true.
    ghost_flag_real (6,5) = .true.
    ghost_flag_real (5:6,6) = .true.

    call prc_const(1)%set_flv_state (flavor_born)
    call prc_const(2)%set_flv_state (flavor_real)
    call prc_const(1)%set_col_state (col_state_born)
    call prc_const(2)%set_col_state (col_state_real)
    call prc_const(2)%set_cf_index (cf_index)
    call prc_const(1)%set_color_factors (color_factors)
    call prc_const(1)%set_ghost_flag (ghost_flag_born)
    call prc_const(2)%set_ghost_flag (ghost_flag_real)
    
    call model_list%read_model (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)

    call nlo_data%init (var_str ('Real'), prc_const, template, model)

    call nlo_data%color_data%write (u)

  end subroutine fks_calculation_1

@ %def fks_calculation_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Multi-Channel Integration}

In this chapter we provide the implementations of the MCI abstract type:
handling multi-channel phase space and concrete implementations.
\begin{description}
\item[Module [[mci_midpoint]]:]
  A simple integrator that uses the midpoint rule to sample the
  integrand uniformly over the unit hypercube.  There is only one
  integration channel, so this can be matched only to single-channel
  phase space.
\item[Module [[mci_vamp]]:]
  Interface for the VAMP package.
\end{description}


@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simple midpoint integration}
This is a most simple implementation of an integrator.  The algorithm
is the straightforward multi-dimensional midpoint rule, i.e., the
integration hypercube is binned uniformly, the integrand is evaluated
at the midpoints of each bin, and the result is the average.  The
binning is equivalent for all integration dimensions.

This rule is accurate to the order $h^2$, where $h$ is the bin width.
Given that $h=N^{-1/d}$, where $d$ is the integration dimension and
$N$ is the total number of sampling points, we get a relative error
of order $N^{-2/d}$.  This is superior to MC integration if $d<4$, and
equivalent if $d=4$.  It is not worse than higher-order formulas
(such as Gauss integration) if the integrand is not smooth, e.g., if
it contains cuts.

The integrator is specifically single-channel.  However, we do not
limit the dimension.
<<[[mci_midpoint.f90]]>>=
<<File header>>

module mci_midpoint

  use kinds
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics

  use phs_base
  use rng_base
  use mci_base
  
<<Standard module head>>

<<MCI midpoint: public>>

<<MCI midpoint: types>>

<<MCI midpoint: test types>>

contains
  
<<MCI midpoint: procedures>>

<<MCI midpoint: tests>>

end module mci_midpoint
@ %def mci_midpoint
@
\subsection{Integrator}
The object contains the methods for integration and event generation.
For the actual work and data storage, it spawns an instance object.

After an integration pass, we update the [[max]] parameter to indicate
the maximum absolute value of the integrand that the integrator
encountered.  This is required for event generation.
<<MCI midpoint: public>>=
  public :: mci_midpoint_t
<<MCI midpoint: types>>=
  type, extends (mci_t) :: mci_midpoint_t
     integer :: n_dim_binned = 0
     logical, dimension(:), allocatable :: dim_is_binned
     logical :: calls_known = .false.
     integer :: n_calls = 0
     integer :: n_calls_pos = 0
     integer :: n_calls_nul = 0
     integer :: n_calls_neg = 0
     real(default) :: integral_pos = 0
     real(default) :: integral_neg = 0
     integer, dimension(:), allocatable :: n_bin
     logical :: max_known = .false.
     real(default) :: max = 0
     real(default) :: min = 0
     real(default) :: max_abs = 0
     real(default) :: min_abs = 0
   contains
   <<MCI midpoint: mci midpoint: TBP>>
end type mci_midpoint_t
  
@ %def mci_t
@ Finalizer: base version is sufficient
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: final => mci_midpoint_final
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_final (object)
    class(mci_midpoint_t), intent(inout) :: object
    call object%base_final ()
  end subroutine mci_midpoint_final
  
@ %def mci_midpoint_final
@ Output.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: write => mci_midpoint_write
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_write (object, unit, pacify, md5sum_version)
    class(mci_midpoint_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    logical, intent(in), optional :: md5sum_version
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Single-channel midpoint rule integrator:"
    call object%base_write (u, pacify, md5sum_version)
    if (object%n_dim_binned < object%n_dim) then
       write (u, "(3x,A,99(1x,I0))")  "Flat dimensions      =", &
            pack ([(i, i = 1, object%n_dim)], mask = .not. object%dim_is_binned)
       write (u, "(3x,A,I0)")  "Number of binned dim = ", object%n_dim_binned
    end if
    if (object%calls_known) then
       write (u, "(3x,A,99(1x,I0))")  "Number of bins       =", object%n_bin
       write (u, "(3x,A,I0)")  "Number of calls      = ", object%n_calls
       if (object%n_calls_pos /= object%n_calls) then
          write (u, "(3x,A,I0)")  "  positive value     = ", object%n_calls_pos
          write (u, "(3x,A,I0)")  "  zero value         = ", object%n_calls_nul
          write (u, "(3x,A,I0)")  "  negative value     = ", object%n_calls_neg
          write (u, "(3x,A,ES17.10)") &
               "Integral (pos. part) = ", object%integral_pos
          write (u, "(3x,A,ES17.10)") &
               "Integral (neg. part) = ", object%integral_neg
       end if
    end if
    if (object%max_known) then
       write (u, "(3x,A,ES17.10)")  "Maximum of integrand = ", object%max
       write (u, "(3x,A,ES17.10)")  "Minimum of integrand = ", object%min
       if (object%min /= object%min_abs) then
          write (u, "(3x,A,ES17.10)")  "Maximum (abs. value) = ", object%max_abs
          write (u, "(3x,A,ES17.10)")  "Minimum (abs. value) = ", object%min_abs
       end if
    end if
    if (allocated (object%rng))  call object%rng%write (u)
  end subroutine mci_midpoint_write
    
@ %def mci_midpoint_write
@ Startup message: short version.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: startup_message => mci_midpoint_startup_message
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_startup_message (mci, unit, n_calls)
    class(mci_midpoint_t), intent(in) :: mci
    integer, intent(in), optional :: unit, n_calls
    call mci%base_startup_message (unit = unit, n_calls = n_calls)
    if (mci%n_dim_binned < mci%n_dim) then
       write (msg_buffer, "(A,2(1x,I0,1x,A))") &
            "Integrator: Midpoint rule:", &
            mci%n_dim_binned, "binned dimensions"
    else
       write (msg_buffer, "(A,2(1x,I0,1x,A))") &
            "Integrator: Midpoint rule"
    end if
    call msg_message (unit = unit)
  end subroutine mci_midpoint_startup_message
    
@ %def mci_midpoint_startup_message
@ The number of channels must be one.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: set_dimensions => mci_midpoint_set_dimensions
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_set_dimensions (mci, n_dim, n_channel)
    class(mci_midpoint_t), intent(inout) :: mci
    integer, intent(in) :: n_dim
    integer, intent(in) :: n_channel
    if (n_channel == 1) then
       mci%n_channel = n_channel
       mci%n_dim = n_dim
       allocate (mci%dim_is_binned (mci%n_dim))
       mci%dim_is_binned = .true.
       mci%n_dim_binned = count (mci%dim_is_binned)
       allocate (mci%n_bin (mci%n_dim))
       mci%n_bin = 0
    else
       call msg_fatal ("Attempt to initialize single-channel integrator &
            &for multiple channels")
    end if
  end subroutine mci_midpoint_set_dimensions
  
@ %def mci_midpoint_set_dimensions
@ Declare particular dimensions as flat.  These dimensions will not be binned.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: declare_flat_dimensions => mci_midpoint_declare_flat_dimensions
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_declare_flat_dimensions (mci, dim_flat)
    class(mci_midpoint_t), intent(inout) :: mci
    integer, dimension(:), intent(in) :: dim_flat
    integer :: d
    mci%n_dim_binned = mci%n_dim - size (dim_flat)
    do d = 1, size (dim_flat)
       mci%dim_is_binned(dim_flat(d)) = .false.
    end do
    mci%n_dim_binned = count (mci%dim_is_binned)
  end subroutine mci_midpoint_declare_flat_dimensions
  
@ %def mci_midpoint_declare_flat_dimensions
@ Declare particular channels as equivalent.  This has no effect.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: declare_equivalences => mci_midpoint_ignore_equivalences
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_ignore_equivalences (mci, channel, dim_offset)
    class(mci_midpoint_t), intent(inout) :: mci
    type(phs_channel_t), dimension(:), intent(in) :: channel
    integer, intent(in) :: dim_offset
  end subroutine mci_midpoint_ignore_equivalences
  
@ %def mci_midpoint_ignore_equivalences
@ Allocate instance with matching type.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: allocate_instance => mci_midpoint_allocate_instance
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_allocate_instance (mci, mci_instance)
    class(mci_midpoint_t), intent(in) :: mci
    class(mci_instance_t), intent(out), pointer :: mci_instance
    allocate (mci_midpoint_instance_t :: mci_instance)
  end subroutine mci_midpoint_allocate_instance
  
@ %def mci_midpoint_allocate_instance
@ Integrate.  The number of dimensions is arbitrary.  We make sure
that the number of calls is evenly distributed among the dimensions.
The actual number of calls will typically be smaller than the
requested number, but never smaller than 1.

The sampling over a variable number of dimensions implies a variable
number of nested loops.  We implement this by a recursive subroutine,
one loop in each recursion level.

The number of iterations [[n_it]] is ignored.  Also, the error is set
to zero in the current implementation.

With this integrator, we allow the calculation to abort immediately when
forced by a signal.  There is no state that we can save, hence we do not catch
an interrupt.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: integrate => mci_midpoint_integrate
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_integrate (mci, instance, sampler, n_it, n_calls, &
       results, pacify)
    class(mci_midpoint_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout) :: instance
    class(mci_sampler_t), intent(inout) :: sampler
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    logical, intent(in), optional :: pacify
    class(mci_results_t), intent(inout), optional :: results
    real(default), dimension(:), allocatable :: x
    real(default) :: integral, integral_pos, integral_neg
    integer :: n_bin
    select type (instance)
    type is (mci_midpoint_instance_t)
       allocate (x (mci%n_dim))
       integral = 0
       integral_pos = 0
       integral_neg = 0
       select case (mci%n_dim_binned)
       case (1)
          n_bin = n_calls
       case (2:)
          n_bin = max (int (n_calls ** (1. / mci%n_dim_binned)), 1)
       end select
       where (mci%dim_is_binned)
          mci%n_bin = n_bin
       elsewhere
          mci%n_bin = 1
       end where
       mci%n_calls = product (mci%n_bin)
       mci%n_calls_pos = 0
       mci%n_calls_nul = 0
       mci%n_calls_neg = 0
       mci%calls_known = .true.
       call sample_dim (mci%n_dim)
       mci%integral = integral / mci%n_calls
       mci%integral_pos = integral_pos / mci%n_calls
       mci%integral_neg = integral_neg / mci%n_calls
       mci%integral_known = .true.
       call instance%set_max ()
       if (present (results)) then
          call results%record (1, mci%n_calls, &
               mci%integral, mci%error, mci%efficiency)
       end if
    end select
  contains
    recursive subroutine sample_dim (d)
      integer, intent(in) :: d
      integer :: i
      real(default) :: value
      do i = 1, mci%n_bin(d)
         x(d) = (i - 0.5_default) / mci%n_bin(d)
         if (d > 1) then
            call sample_dim (d - 1)
         else
            if (signal_is_pending ())  return
            call instance%evaluate (sampler, 1, x)
            value = instance%get_value ()
            if (value > 0) then
               mci%n_calls_pos = mci%n_calls_pos + 1
               integral = integral + value
               integral_pos = integral_pos + value
            else if (value == 0) then
               mci%n_calls_nul = mci%n_calls_nul + 1
            else
               mci%n_calls_neg = mci%n_calls_neg + 1
               integral = integral + value
               integral_neg = integral_neg + value
            end if
         end if
      end do
    end subroutine sample_dim
  end subroutine mci_midpoint_integrate

@ %def mci_midpoint_integrate
@ Simulation initializer and finalizer: nothing to do here.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: prepare_simulation => mci_midpoint_ignore_prepare_simulation
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_ignore_prepare_simulation (mci)
    class(mci_midpoint_t), intent(inout) :: mci
  end subroutine mci_midpoint_ignore_prepare_simulation
  
@ %def mci_midpoint_ignore_prepare_simulation
@ Generate weighted event.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: generate_weighted_event => mci_midpoint_generate_weighted_event
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_generate_weighted_event (mci, instance, sampler)
    class(mci_midpoint_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout), target :: instance
    class(mci_sampler_t), intent(inout), target :: sampler
    real(default), dimension(mci%n_dim) :: x
    select type (instance)
    type is (mci_midpoint_instance_t)
       call mci%rng%generate (x)
       call instance%evaluate (sampler, 1, x)
       instance%excess_weight = 0
    end select
  end subroutine mci_midpoint_generate_weighted_event
       
@ %def mci_midpoint_generate_weighted_event
@ For unweighted events, we generate weighted events and apply a
simple rejection step to the relative event weight, until an event
passes.  

Note that we use the [[max_abs]] value stored in the configuration
record, not the one stored in the instance.  The latter may change
during event generation.  After an event generation pass is over, we
may update the value for a subsequent pass.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: generate_unweighted_event => &
       mci_midpoint_generate_unweighted_event
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_generate_unweighted_event (mci, instance, sampler)
    class(mci_midpoint_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout), target :: instance
    class(mci_sampler_t), intent(inout), target :: sampler
    real(default) :: x, norm, int
    select type (instance)
    type is (mci_midpoint_instance_t)
       if (mci%max_known .and. mci%max_abs > 0) then
          norm = abs (mci%max_abs * instance%safety_factor)
          REJECTION: do
             call mci%generate_weighted_event (instance, sampler)
             if (sampler%is_valid ()) then
                call mci%rng%generate (x)
                int = abs (instance%integrand)
                if (x * norm <= int) then
                   if (norm > 0 .and. norm < int) then
                      instance%excess_weight = int / norm - 1
                   end if
                   exit REJECTION
                end if
             end if
             if (signal_is_pending ())  return
          end do REJECTION
       else
          call msg_fatal ("Unweighted event generation: &
               &maximum of integrand is zero or unknown")
       end if
    end select
  end subroutine mci_midpoint_generate_unweighted_event
    
@ %def mci_midpoint_generate_unweighted_event
@ Rebuild an event, using the [[state]] input.
<<MCI midpoint: mci midpoint: TBP>>=
  procedure :: rebuild_event => mci_midpoint_rebuild_event
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_rebuild_event (mci, instance, sampler, state)
    class(mci_midpoint_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout) :: instance
    class(mci_sampler_t), intent(inout) :: sampler
    class(mci_state_t), intent(in) :: state
    select type (instance)
    type is (mci_midpoint_instance_t)
       call instance%recall (sampler, state)
    end select
  end subroutine mci_midpoint_rebuild_event
       
@ %def mci_midpoint_rebuild_event
@
\subsection{Integrator instance}
Covering the case of flat dimensions, we store a complete [[x]] array.  This
is filled when generating events.
<<MCI midpoint: public>>=
  public :: mci_midpoint_instance_t
<<MCI midpoint: types>>=
  type, extends (mci_instance_t) :: mci_midpoint_instance_t
     type(mci_midpoint_t), pointer :: mci => null ()
     logical :: max_known = .false.
     real(default) :: max = 0
     real(default) :: min = 0
     real(default) :: max_abs = 0
     real(default) :: min_abs = 0
     real(default) :: safety_factor = 1
     real(default) :: excess_weight = 0
   contains
   <<MCI midpoint: mci midpoint instance: TBP>>
  end type mci_midpoint_instance_t
  
@ %def mci_midpoint_instance_t
@ Output.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: write => mci_midpoint_instance_write
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_write (object, unit, pacify)
    class(mci_midpoint_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,9(1x,F12.10))")  "x =", object%x(:,1)
    write (u, "(1x,A,ES19.12)") "Integrand = ", object%integrand
    write (u, "(1x,A,ES19.12)") "Weight    = ", object%mci_weight
    if (object%safety_factor /= 1) then
       write (u, "(1x,A,ES19.12)") "Safety f  = ", object%safety_factor
    end if
    if (object%excess_weight /= 0) then
       write (u, "(1x,A,ES19.12)") "Excess    = ", object%excess_weight
    end if
    if (object%max_known) then
       write (u, "(1x,A,ES19.12)") "Maximum   = ", object%max
       write (u, "(1x,A,ES19.12)") "Minimum   = ", object%min
       if (object%min /= object%min_abs) then
          write (u, "(1x,A,ES19.12)") "Max.(abs) = ", object%max_abs
          write (u, "(1x,A,ES19.12)") "Min.(abs) = ", object%min_abs
       end if
    end if
  end subroutine mci_midpoint_instance_write
  
@ %def mci_midpoint_instance_write
@ The finalizer is empty.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: final => mci_midpoint_instance_final
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_instance_final (object)
    class(mci_midpoint_instance_t), intent(inout) :: object
  end subroutine mci_midpoint_instance_final
  
@ %def mci_midpoint_instance_final
@ Initializer.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: init => mci_midpoint_instance_init
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_init (mci_instance, mci)
    class(mci_midpoint_instance_t), intent(out) :: mci_instance
    class(mci_t), intent(in), target :: mci
    call mci_instance%base_init (mci)
    select type (mci)
    type is (mci_midpoint_t)
       mci_instance%mci => mci
       call mci_instance%get_max ()
       mci_instance%selected_channel = 1
    end select
  end subroutine mci_midpoint_instance_init
    
@ %def mci_midpoint_instance_init
@ Copy the stored extrema of the integrand in the instance record.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: get_max => mci_midpoint_instance_get_max
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_get_max (instance)
    class(mci_midpoint_instance_t), intent(inout) :: instance
    associate (mci => instance%mci)
      if (mci%max_known) then
         instance%max_known = .true.
         instance%max = mci%max
         instance%min = mci%min
         instance%max_abs = mci%max_abs
         instance%min_abs = mci%min_abs
      end if
    end associate
  end subroutine mci_midpoint_instance_get_max
  
@ %def mci_midpoint_instance_get_max
@ Reverse operations: recall the extrema, but only if they are wider
than the extrema already stored in the configuration.  Also recalculate the
efficiency value.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: set_max => mci_midpoint_instance_set_max
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_set_max (instance)
    class(mci_midpoint_instance_t), intent(inout) :: instance
    associate (mci => instance%mci)
      if (instance%max_known) then
         if (mci%max_known) then
            mci%max = max (mci%max, instance%max)
            mci%min = min (mci%min, instance%min)
            mci%max_abs = max (mci%max_abs, instance%max_abs)
            mci%min_abs = min (mci%min_abs, instance%min_abs)
         else
            mci%max = instance%max
            mci%min = instance%min
            mci%max_abs = instance%max_abs
            mci%min_abs = instance%min_abs
            mci%max_known = .true.
         end if
         if (mci%max_abs /= 0) then
            if (mci%integral == mci%integral_pos) then
               mci%efficiency = mci%integral / mci%max_abs
               mci%efficiency_known = .true.
            else if (mci%n_calls /= 0) then
               mci%efficiency = &
                    (mci%n_calls_pos * mci%integral_pos &
                    - mci%n_calls_neg * mci%integral_neg) &
                    / mci%n_calls / mci%max_abs
               mci%efficiency_known = .true.
            end if
         end if
      end if
    end associate
  end subroutine mci_midpoint_instance_set_max
  
@ %def mci_midpoint_instance_set_max
@ The weight is the Jacobian of the mapping for the only channel.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: compute_weight => mci_midpoint_instance_compute_weight
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_compute_weight (mci, c)
    class(mci_midpoint_instance_t), intent(inout) :: mci
    integer, intent(in) :: c
    select case (c)
    case (1)
       mci%mci_weight = mci%f(1)
    case default
       call msg_fatal ("MCI midpoint integrator: only single channel supported")
    end select
  end subroutine mci_midpoint_instance_compute_weight
    
@ %def mci_midpoint_instance_compute_weight
@ Record the integrand.  Update stored values for maximum and minimum.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: record_integrand => mci_midpoint_instance_record_integrand
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_record_integrand (mci, integrand)
    class(mci_midpoint_instance_t), intent(inout) :: mci
    real(default), intent(in) :: integrand
    mci%integrand = integrand
    if (mci%max_known) then
       mci%max = max (mci%max, integrand)
       mci%min = min (mci%min, integrand)
       mci%max_abs = max (mci%max_abs, abs (integrand))
       mci%min_abs = min (mci%min_abs, abs (integrand))
    else
       mci%max = integrand
       mci%min = integrand
       mci%max_abs = abs (integrand)
       mci%min_abs = abs (integrand)
       mci%max_known = .true.
    end if
  end subroutine mci_midpoint_instance_record_integrand
  
@ %def mci_midpoint_instance_record_integrand
@ We store the safety factor, otherwise nothing to do here.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: init_simulation => mci_midpoint_instance_init_simulation
  procedure :: final_simulation => mci_midpoint_instance_final_simulation
<<MCI midpoint: procedures>>=
  subroutine mci_midpoint_instance_init_simulation (instance, safety_factor)
    class(mci_midpoint_instance_t), intent(inout) :: instance
    real(default), intent(in), optional :: safety_factor
    if (present (safety_factor))  instance%safety_factor = safety_factor
  end subroutine mci_midpoint_instance_init_simulation
  
  subroutine mci_midpoint_instance_final_simulation (instance)
    class(mci_midpoint_instance_t), intent(inout) :: instance
  end subroutine mci_midpoint_instance_final_simulation
  
@ %def mci_midpoint_instance_init_simulation
@ %def mci_midpoint_instance_final_simulation
@ Return excess weight for the current event.
<<MCI midpoint: mci midpoint instance: TBP>>=
  procedure :: get_event_excess => mci_midpoint_instance_get_event_excess
<<MCI midpoint: procedures>>=
  function mci_midpoint_instance_get_event_excess (mci) result (excess)
    class(mci_midpoint_instance_t), intent(in) :: mci
    real(default) :: excess
    excess = mci%excess_weight
  end function mci_midpoint_instance_get_event_excess
  
@ %def mci_midpoint_instance_get_event_excess
@
\subsection{Unit tests}
<<MCI midpoint: public>>=
  public :: mci_midpoint_test
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<MCI midpoint: execute tests>>
  end subroutine mci_midpoint_test
  
@ %def mci_midpoint_test
@
\subsubsection{Test sampler}
A test sampler object should implement a function with known integral that
we can use to check the integrator.

This is the function $f(x) = 3 x^2$ with integral $\int_0^1
f(x)\,dx=1$ and maximum $f(1)=3$.  If the integration dimension is
greater than one, the function is extended as a constant in the other
dimension(s).

Mimicking the behavior of a process object, we store the argument
and result inside the sampler, so we can [[fetch]] results.
<<MCI midpoint: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_1_t
     real(default), dimension(:), allocatable :: x
     real(default) :: val
   contains
   <<MCI midpoint: test sampler 1: TBP>>
  end type test_sampler_1_t

@ %def test_sampler_1_t
@ Output: There is nothing stored inside, so just print an informative line.
<<MCI midpoint: test sampler 1: TBP>>=
  procedure :: write => test_sampler_1_write
<<MCI midpoint: procedures>>=
  subroutine test_sampler_1_write (object, unit, testflag)
    class(test_sampler_1_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Test sampler: f(x) = 3 x^2"
  end subroutine test_sampler_1_write
  
@ %def test_sampler_1_write
@ Evaluation: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI midpoint: test sampler 1: TBP>>=
  procedure :: evaluate => test_sampler_1_evaluate
<<MCI midpoint: procedures>>=
  subroutine test_sampler_1_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_1_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    if (allocated (sampler%x))  deallocate (sampler%x)
    allocate (sampler%x (size (x_in)))
    sampler%x = x_in
    sampler%val = 3 * x_in(1) ** 2
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_1_evaluate

@ %def test_sampler_1_evaluate
@ The point is always valid.
<<MCI midpoint: test sampler 1: TBP>>=
  procedure :: is_valid => test_sampler_1_is_valid
<<MCI midpoint: tests>>=
  function test_sampler_1_is_valid (sampler) result (valid)
    class(test_sampler_1_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_1_is_valid
  
@ %def test_sampler_1_is_valid
@ Rebuild: compute all but the function value.
<<MCI midpoint: test sampler 1: TBP>>=
  procedure :: rebuild => test_sampler_1_rebuild
<<MCI midpoint: procedures>>=
  subroutine test_sampler_1_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_1_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    if (allocated (sampler%x))  deallocate (sampler%x)
    allocate (sampler%x (size (x_in)))
    sampler%x = x_in
    sampler%val = val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_1_rebuild

@ %def test_sampler_1_rebuild
@ Extract the results.
<<MCI midpoint: test sampler 1: TBP>>=
  procedure :: fetch => test_sampler_1_fetch
<<MCI midpoint: procedures>>=
  subroutine test_sampler_1_fetch (sampler, val, x, f)
    class(test_sampler_1_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_1_fetch
    
@ %def test_sampler_1_fetch
@
This is the function $f(x) = 3 x^2 + 2 y$ with integral $\int_0^1
f(x,y)\,dx\,dy=2$ and maximum $f(1)=5$.
<<MCI midpoint: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_2_t
     real(default) :: val
     real(default), dimension(2) :: x
   contains
   <<MCI midpoint: test sampler 2: TBP>>
  end type test_sampler_2_t

@ %def test_sampler_2_t
@ Output: There is nothing stored inside, so just print an informative line.
<<MCI midpoint: test sampler 2: TBP>>=
  procedure :: write => test_sampler_2_write
<<MCI midpoint: procedures>>=
  subroutine test_sampler_2_write (object, unit, testflag)
    class(test_sampler_2_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Test sampler: f(x) = 3 x^2 + 2 y"
  end subroutine test_sampler_2_write
  
@ %def test_sampler_2_write
@ Evaluate: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI midpoint: test sampler 2: TBP>>=
  procedure :: evaluate => test_sampler_2_evaluate
<<MCI midpoint: procedures>>=
  subroutine test_sampler_2_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_2_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    sampler%x = x_in
    sampler%val = 3 * x_in(1) ** 2 + 2 * x_in(2)
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_2_evaluate

@ %def test_sampler_2_evaluate
@ The point is always valid.
<<MCI midpoint: test sampler 2: TBP>>=
  procedure :: is_valid => test_sampler_2_is_valid
<<MCI midpoint: tests>>=
  function test_sampler_2_is_valid (sampler) result (valid)
    class(test_sampler_2_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_2_is_valid
  
@ %def test_sampler_2_is_valid
@ Rebuild: compute all but the function value.
<<MCI midpoint: test sampler 2: TBP>>=
  procedure :: rebuild => test_sampler_2_rebuild
<<MCI midpoint: procedures>>=
  subroutine test_sampler_2_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_2_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    sampler%x = x_in
    sampler%val = val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_2_rebuild

@ %def test_sampler_2_rebuild
<<MCI midpoint: test sampler 2: TBP>>=
  procedure :: fetch => test_sampler_2_fetch
<<MCI midpoint: procedures>>=
  subroutine test_sampler_2_fetch (sampler, val, x, f)
    class(test_sampler_2_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_2_fetch
  
@ %def test_sampler_2_fetch
@
This is the function $f(x) = (1 - 3 x^2)\,\theta(x-1/2)$ with integral
$\int_0^1 f(x)\,dx=-3/8$, minimum $f(1)=-2$ and maximum $f(1/2)=1/4$.
If the integration dimension is greater than one, the function is
extended as a constant in the other dimension(s).
<<MCI midpoint: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_4_t
     real(default) :: val
     real(default), dimension(:), allocatable :: x
   contains
   <<MCI midpoint: test sampler 4: TBP>>
  end type test_sampler_4_t

@ %def test_sampler_4_t
@ Output: There is nothing stored inside, so just print an informative line.
<<MCI midpoint: test sampler 4: TBP>>=
  procedure :: write => test_sampler_4_write
<<MCI midpoint: procedures>>=
  subroutine test_sampler_4_write (object, unit, testflag)
    class(test_sampler_4_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Test sampler: f(x) = 1 - 3 x^2"
  end subroutine test_sampler_4_write
  
@ %def test_sampler_4_write
@ Evaluation: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI midpoint: test sampler 4: TBP>>=
  procedure :: evaluate => test_sampler_4_evaluate
<<MCI midpoint: procedures>>=
  subroutine test_sampler_4_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_4_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    if (x_in(1) >= .5_default) then
       sampler%val = 1 - 3 * x_in(1) ** 2
    else
       sampler%val = 0
    end if
    if (.not. allocated (sampler%x))  allocate (sampler%x (size (x_in)))
    sampler%x = x_in
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_4_evaluate

@ %def test_sampler_4_evaluate
@ The point is always valid.
<<MCI midpoint: test sampler 4: TBP>>=
  procedure :: is_valid => test_sampler_4_is_valid
<<MCI midpoint: tests>>=
  function test_sampler_4_is_valid (sampler) result (valid)
    class(test_sampler_4_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_4_is_valid
  
@ %def test_sampler_4_is_valid
@ Rebuild: compute all but the function value.
<<MCI midpoint: test sampler 4: TBP>>=
  procedure :: rebuild => test_sampler_4_rebuild
<<MCI midpoint: procedures>>=
  subroutine test_sampler_4_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_4_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    sampler%x = x_in
    sampler%val = val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_4_rebuild

@ %def test_sampler_4_rebuild
<<MCI midpoint: test sampler 4: TBP>>=
  procedure :: fetch => test_sampler_4_fetch
<<MCI midpoint: procedures>>=
  subroutine test_sampler_4_fetch (sampler, val, x, f)
    class(test_sampler_4_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_4_fetch
    
@ %def test_sampler_4_fetch
@
\subsubsection{One-dimensional integration}
Construct an integrator and use it for a one-dimensional sampler.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_1, "mci_midpoint_1", &
       "one-dimensional integral", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_1 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    
    write (u, "(A)")  "* Test output: mci_midpoint_1"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (1, 1)
    
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_1_t :: sampler)
    call sampler%write (u)
     
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.8"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.8_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.7"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.7_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.9"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.9_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_calls = 1000"
    write (u, "(A)")
    
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_1"

  end subroutine mci_midpoint_1

@ %def mci_midpoint_1
@
\subsubsection{Two-dimensional integration}
Construct an integrator and use it for a two-dimensional sampler.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_2, "mci_midpoint_2", &
       "two-dimensional integral", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_2 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    
    write (u, "(A)")  "* Test output: mci_midpoint_2"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (2, 1)
    
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_2_t :: sampler)
    call sampler%write (u)
     
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.8, y = 0.2"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.8_default, 0.2_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_calls = 1000"
    write (u, "(A)")
    
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_2"

  end subroutine mci_midpoint_2

@ %def mci_midpoint_2
@
\subsubsection{Two-dimensional integration with flat dimension}
Construct an integrator and use it for a two-dimensional sampler,
where the function is constant in the second dimension.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_3, "mci_midpoint_3", &
       "two-dimensional integral with flat dimension", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_3 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    
    write (u, "(A)")  "* Test output: mci_midpoint_3"
    write (u, "(A)")  "*   Purpose: integrate function with one flat dimension"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    select type (mci)
    type is (mci_midpoint_t)
       call mci%set_dimensions (2, 1)
       call mci%declare_flat_dimensions ([2])
    end select
    
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_1_t :: sampler)
    call sampler%write (u)
     
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.8, y = 0.2"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.8_default, 0.2_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_calls = 1000"
    write (u, "(A)")
    
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_3"

  end subroutine mci_midpoint_3

@ %def mci_midpoint_3
@
\subsubsection{Integrand with sign flip}
Construct an integrator and use it for a one-dimensional sampler.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_4, "mci_midpoint_4", &
       "integrand with sign flip", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_4 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    
    write (u, "(A)")  "* Test output: mci_midpoint_4"
    write (u, "(A)")  "*   Purpose: integrate function with sign flip &
         &in one dimension"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (1, 1)
    
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_4_t :: sampler)
    call sampler%write (u)
     
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for x = 0.8"
    write (u, "(A)")
    
    call mci_instance%evaluate (sampler, 1, [0.8_default])
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_calls = 1000"
    write (u, "(A)")
    
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_4"

  end subroutine mci_midpoint_4

@ %def mci_midpoint_4
@
\subsubsection{Weighted events}
Generate weighted events.  Without rejection, we do not need to know maxima
and minima, so we can start generating events immediately.  We have two
dimensions.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_5, "mci_midpoint_5", &
       "weighted events", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_5 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    class(mci_state_t), allocatable :: state

    write (u, "(A)")  "* Test output: mci_midpoint_5"
    write (u, "(A)")  "*   Purpose: generate weighted events"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (2, 1)
    
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_2_t :: sampler)

    write (u, "(A)")  "* Initialize random-number generator"
    write (u, "(A)")
    
    allocate (rng_test_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)
    
    write (u, "(A)")  "* Generate weighted event"
    write (u, "(A)")
    
    call mci%generate_weighted_event (mci_instance, sampler)
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate weighted event"
    write (u, "(A)")
    
    call mci%generate_weighted_event (mci_instance, sampler)
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Store data"
    write (u, "(A)")
    
    allocate (state)
    call mci_instance%store (state)
    call mci_instance%final ()
    deallocate (mci_instance)
    
    call state%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Recall data and rebuild event"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    call mci%rebuild_event (mci_instance, sampler, state)

    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    deallocate (mci_instance)
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_5"

  end subroutine mci_midpoint_5
    
@ %def mci_midpoint_5
@
\subsubsection{Unweighted events}
Generate unweighted events.  The integrand has a sign flip in it.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_6, "mci_midpoint_6", &
       "unweighted events", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_6 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng

    write (u, "(A)")  "* Test output: mci_midpoint_6"
    write (u, "(A)")  "*   Purpose: generate unweighted events"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (1, 1)
    
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_4_t :: sampler)

    write (u, "(A)")  "* Initialize random-number generator"
    write (u, "(A)")
    
    allocate (rng_test_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)
    
    write (u, "(A)")  "* Integrate (determine maximum of integrand"
    write (u, "(A)")
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate unweighted event"
    write (u, "(A)")
    
    call mci%generate_unweighted_event (mci_instance, sampler)
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    deallocate (mci_instance)
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_6"

  end subroutine mci_midpoint_6
    
@ %def mci_midpoint_6
@
\subsubsection{Excess weight}
Generate unweighted events.  With only 2 points for integration, the
maximum of the integrand is too low, and we produce excess weight.
<<MCI midpoint: execute tests>>=
  call test (mci_midpoint_7, "mci_midpoint_7", &
       "excess weight", &
       u, results)
<<MCI midpoint: tests>>=
  subroutine mci_midpoint_7 (u)
    integer, intent(in) :: u
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng

    write (u, "(A)")  "* Test output: mci_midpoint_7"
    write (u, "(A)")  "*   Purpose: generate unweighted event &
         &with excess weight"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_midpoint_t :: mci)
    call mci%set_dimensions (1, 1)
    
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_4_t :: sampler)

    write (u, "(A)")  "* Initialize random-number generator"
    write (u, "(A)")
    
    allocate (rng_test_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)
    
    write (u, "(A)")  "* Integrate (determine maximum of integrand"
    write (u, "(A)")
    call mci%integrate (mci_instance, sampler, 1, 2)
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate unweighted event"
    write (u, "(A)")
    
    call mci_instance%init_simulation ()
    call mci%generate_unweighted_event (mci_instance, sampler)
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Use getter methods"
    write (u, "(A)")
    
    write (u, "(1x,A,1x,ES19.12)")  "weight =", mci_instance%get_event_weight ()
    write (u, "(1x,A,1x,ES19.12)")  "excess =", mci_instance%get_event_excess ()

    write (u, "(A)")
    write (u, "(A)")  "* Apply safety factor"
    write (u, "(A)")

    call mci_instance%init_simulation (safety_factor = 2.1_default)

    write (u, "(A)")  "* Generate unweighted event"
    write (u, "(A)")
    
    call mci%generate_unweighted_event (mci_instance, sampler)
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Use getter methods"
    write (u, "(A)")
    
    write (u, "(1x,A,1x,ES19.12)")  "weight =", mci_instance%get_event_weight ()
    write (u, "(1x,A,1x,ES19.12)")  "excess =", mci_instance%get_event_excess ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    deallocate (mci_instance)
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_midpoint_7"

  end subroutine mci_midpoint_7
    
@ %def mci_midpoint_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\vamp\ interface}
The standard method for integration is \vamp: the multi-channel
version of the VEGAS algorithm.  Each parameterization (channel) of
the hypercube is binned in each dimension.  The binning is equally
equidistant, but an iteration of the integration procedure,
the binning is updated for each dimension, according to the variance
distribution of the integrand, summed over all other dimension.  In
the next iteration, the binning approximates (hopefully) follows the
integrand more closely, and the accuracy of the result is increased.
Furthermore, the relative weight of the individual channels is also updated
after an iteration.

The bin distribution is denoted as the grid for a channel, which we
can write to file and reuse later.

In our implementation we specify the generic \vamp\ algorithm more
tightly: the number of bins is equal for all dimensions, the initial
weights are all equal.  The user controls whether to update bins
and/or weights after each iteration.  The integration is organized in
passes, each one consisting of several iterations with a common number
of calls to the integrand.  The first passes are intended as warmup,
so the results are displayed but otherwise discarded.  In the final
pass, the integration estimates for the individual iterations are
averaged for the final result.
<<[[mci_vamp.f90]]>>=
<<File header>>

module mci_vamp

  use kinds
<<Use strings>>
  use io_units
  use constants
  use format_utils, only: pac_fmt
  use format_defs, only: FMT_12, FMT_14, FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use md5

  use phs_base
  use rng_base
  use rng_tao
  use mci_base
  
  use vamp !NODEP!
  use exceptions !NODEP!
  
<<Standard module head>>

<<MCI vamp: public>>

<<MCI vamp: types>>

<<MCI vamp: interfaces>>

<<MCI vamp: test types>>

contains
  
<<MCI vamp: procedures>>

<<MCI vamp: tests>>

end module mci_vamp
@ %def mci_vamp
@
\subsection{Grid parameters}
This is a transparent container.  It holds the parameters that are
stored in grid files, and are checked when grid files are read.
<<MCI vamp: public>>=
  public :: grid_parameters_t
<<MCI vamp: types>>=
  type :: grid_parameters_t
     integer :: threshold_calls = 0
     integer :: min_calls_per_channel = 10
     integer :: min_calls_per_bin = 10
     integer :: min_bins = 3
     integer :: max_bins = 20
     logical :: stratified = .true.
     logical :: use_vamp_equivalences = .true.
     real(default) :: channel_weights_power = 0.25_default
     real(default) :: accuracy_goal = 0
     real(default) :: error_goal = 0
     real(default) :: rel_error_goal = 0
   contains
   <<MCI vamp: grid parameters: TBP>>
  end type grid_parameters_t

@ %def grid_parameters_t
@ I/O:
<<MCI vamp: grid parameters: TBP>>=
  procedure :: write => grid_parameters_write
<<MCI vamp: procedures>>=
  subroutine grid_parameters_write (object, unit)
    class(grid_parameters_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,I0)") "threshold_calls       = ", &
         object%threshold_calls 
    write (u, "(3x,A,I0)") "min_calls_per_channel = ", &
         object%min_calls_per_channel
    write (u, "(3x,A,I0)") "min_calls_per_bin     = ", &
         object%min_calls_per_bin
    write (u, "(3x,A,I0)") "min_bins              = ", &
         object%min_bins
    write (u, "(3x,A,I0)") "max_bins              = ", &
         object%max_bins
    write (u, "(3x,A,L1)") "stratified            = ", &
         object%stratified
    write (u, "(3x,A,L1)") "use_vamp_equivalences = ", &
         object%use_vamp_equivalences
    write (u, "(3x,A,F10.7)") "channel_weights_power = ", &
         object%channel_weights_power
    if (object%accuracy_goal > 0) then
       write (u, "(3x,A,F10.7)") "accuracy_goal         = ", &
            object%accuracy_goal
    end if
    if (object%error_goal > 0) then
       write (u, "(3x,A,F10.7)") "error_goal            = ", &
            object%error_goal
    end if
    if (object%rel_error_goal > 0) then
       write (u, "(3x,A,F10.7)") "rel_error_goal        = ", &
            object%rel_error_goal
    end if
  end subroutine grid_parameters_write

@ %def grid_parameters_write
@
\subsection{History parameters}
The history parameters are also stored in a transparent container.
This is not a part of the grid definition, and should not be included
in the MD5 sum.
<<MCI vamp: public>>=
  public :: history_parameters_t
<<MCI vamp: types>>=
  type :: history_parameters_t
     logical :: global = .true.
     logical :: global_verbose = .false.
     logical :: channel = .false.
     logical :: channel_verbose = .false.
   contains
   <<MCI vamp: history parameters: TBP>>
  end type history_parameters_t

@ %def history_parameters_t
@ I/O:
<<MCI vamp: history parameters: TBP>>=
  procedure :: write => history_parameters_write
<<MCI vamp: procedures>>=
  subroutine history_parameters_write (object, unit)
    class(history_parameters_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)") "history(global)       = ", object%global
    write (u, "(3x,A,L1)") "history(global) verb. = ", object%global_verbose
    write (u, "(3x,A,L1)") "history(channels)     = ", object%channel
    write (u, "(3x,A,L1)") "history(chann.) verb. = ", object%channel_verbose
  end subroutine history_parameters_write

@ %def history_parameters_write
@
\subsection{Integration pass}
We store the parameters for each integration pass in a linked list.
<<MCI vamp: types>>=
  type :: pass_t
     integer :: i_pass = 0
     integer :: i_first_it = 0
     integer :: n_it = 0
     integer :: n_calls = 0
     integer :: n_bins = 0
     logical :: adapt_grids = .false.
     logical :: adapt_weights = .false.
     logical :: is_final_pass = .false.
     logical :: integral_defined = .false.
     integer, dimension(:), allocatable :: calls
     real(default), dimension(:), allocatable :: integral
     real(default), dimension(:), allocatable :: error
     real(default), dimension(:), allocatable :: efficiency
     type(vamp_history), dimension(:), allocatable :: v_history
     type(vamp_history), dimension(:,:), allocatable :: v_histories
     type(pass_t), pointer :: next => null ()
   contains
   <<MCI vamp: pass: TBP>>
  end type pass_t
     
@ %def pass_t
@ Finalizer.  The VAMP histories contain a pointer array.
<<MCI vamp: pass: TBP>>=
  procedure :: final => pass_final
<<MCI vamp: procedures>>=
  subroutine pass_final (object)
    class(pass_t), intent(inout) :: object
    if (allocated (object%v_history)) then
       call vamp_delete_history (object%v_history)
    end if
    if (allocated (object%v_histories)) then
       call vamp_delete_history (object%v_histories)
    end if
  end subroutine pass_final
  
@ %def pass_final
@ Output.  Note that the precision of the numerical values should match the
precision for comparing output from file with data.
<<MCI vamp: pass: TBP>>=
  procedure :: write => pass_write
<<MCI vamp: procedures>>=
  subroutine pass_write (object, unit, pacify)
    class(pass_t), intent(in) :: object
    integer, intent(in) :: unit
    logical, intent(in), optional :: pacify
    integer :: u, i
    character(len=7) :: fmt
    call pac_fmt (fmt, FMT_17, FMT_14, pacify)
    u = given_output_unit (unit)
    write (u, "(3x,A,I0)")  "n_it          = ", object%n_it
    write (u, "(3x,A,I0)")  "n_calls       = ", object%n_calls
    write (u, "(3x,A,I0)")  "n_bins        = ", object%n_bins
    write (u, "(3x,A,L1)")  "adapt grids   = ", object%adapt_grids
    write (u, "(3x,A,L1)")  "adapt weights = ", object%adapt_weights
    if (object%integral_defined) then
       write (u, "(3x,A)")  "Results:  [it, calls, integral, error, efficiency]"
       do i = 1, object%n_it
          write (u, "(5x,I0,1x,I0,3(1x," // fmt // "))") &
               i, object%calls(i), object%integral(i), object%error(i), &
               object%efficiency(i)
       end do
    else
       write (u, "(3x,A)")  "Results: [undefined]"
    end if
  end subroutine pass_write
  
@ %def pass_write
@ Read and reconstruct the pass.
<<MCI vamp: pass: TBP>>=
  procedure :: read => pass_read
<<MCI vamp: procedures>>=
  subroutine pass_read (object, u, n_pass, n_it)
    class(pass_t), intent(out) :: object
    integer, intent(in) :: u, n_pass, n_it
    integer :: i, j
    character(80) :: buffer
    object%i_pass = n_pass + 1
    object%i_first_it = n_it + 1
    call read_ival (u, object%n_it)
    call read_ival (u, object%n_calls)
    call read_ival (u, object%n_bins)
    call read_lval (u, object%adapt_grids)
    call read_lval (u, object%adapt_weights)
    allocate (object%calls (object%n_it), source = 0)
    allocate (object%integral (object%n_it), source = 0._default)
    allocate (object%error (object%n_it), source = 0._default)
    allocate (object%efficiency (object%n_it), source = 0._default)
    read (u, "(A)")  buffer
    select case (trim (adjustl (buffer)))
    case ("Results:  [it, calls, integral, error, efficiency]")
       do i = 1, object%n_it
          read (u, *) &
               j, object%calls(i), object%integral(i), object%error(i), &
               object%efficiency(i)
       end do
       object%integral_defined = .true.
    case ("Results: [undefined]")
       object%integral_defined = .false.
    case default
       call msg_fatal ("Reading integration pass: corrupted file")
    end select
  end subroutine pass_read
  
@ %def pass_read
@ Write the VAMP history for this pass.  (The subroutine writes the
whole array at once.)
<<MCI vamp: pass: TBP>>=
  procedure :: write_history => pass_write_history
<<MCI vamp: procedures>>=
  subroutine pass_write_history (pass, unit)
    class(pass_t), intent(in) :: pass
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (allocated (pass%v_history)) then
       call vamp_write_history (u, pass%v_history)
    else
       write (u, "(1x,A)")  "Global history: [undefined]"
    end if
    if (allocated (pass%v_histories)) then
       write (u, "(1x,A)")  "Channel histories:"
       call vamp_write_history (u, pass%v_histories)
    else
       write (u, "(1x,A)")  "Channel histories: [undefined]"
    end if
  end subroutine pass_write_history
    
@ %def pass_write_history
@ Given a number of calls and iterations, compute remaining data.
<<MCI vamp: pass: TBP>>=
  procedure :: configure => pass_configure
<<MCI vamp: procedures>>=
  subroutine pass_configure (pass, n_it, n_calls, min_calls, &
       min_bins, max_bins, min_channel_calls)
    class(pass_t), intent(inout) :: pass
    integer, intent(in) :: n_it, n_calls, min_channel_calls
    integer, intent(in) :: min_calls, min_bins, max_bins
    pass%n_it = n_it    
    if (min_calls /= 0) then
       pass%n_bins =  max (min_bins, &
            min (n_calls / min_calls, max_bins))
    else
       pass%n_bins = max_bins
    end if
    pass%n_calls = max (n_calls, max (min_calls, min_channel_calls))
    if (pass%n_calls /= n_calls) then
       write (msg_buffer, "(A,I0)")  "VAMP: too few calls, resetting " &
            // "n_calls to ", pass%n_calls
       call msg_warning ()
    end if
    allocate (pass%calls (n_it), source = 0)
    allocate (pass%integral (n_it), source = 0._default)
    allocate (pass%error (n_it), source = 0._default)
    allocate (pass%efficiency (n_it), source = 0._default)
  end subroutine pass_configure
  
@ %def pass_configure
@ Allocate the VAMP history and give options.  We assume that the
[[configure]] routine above has been executed, so the number of
iterations is known.
<<MCI vamp: pass: TBP>>=
  procedure :: configure_history => pass_configure_history
<<MCI vamp: procedures>>=
  subroutine pass_configure_history (pass, n_channels, par)
    class(pass_t), intent(inout) :: pass
    integer, intent(in) :: n_channels
    type(history_parameters_t), intent(in) :: par
    if (par%global) then
       allocate (pass%v_history (pass%n_it))
       call vamp_create_history (pass%v_history, &
            verbose = par%global_verbose)
    end if
    if (par%channel) then
       allocate (pass%v_histories (pass%n_it, n_channels))
       call vamp_create_history (pass%v_histories, &
            verbose = par%channel_verbose)
    end if
  end subroutine pass_configure_history
  
@ %def pass_configure_history
@ Given two pass objects, compare them.  All parameters must match.  Where
integrations are done in both (number of calls nonzero), the results must be
equal (up to numerical noise).

The allocated array sizes might be different, but should match up to the
common [[n_it]] value.
<<MCI vamp: interfaces>>=
  interface operator (.matches.)
     module procedure pass_matches
  end interface operator (.matches.)
<<MCI vamp: procedures>>=
  function pass_matches (pass, ref) result (ok)
    type(pass_t), intent(in) :: pass, ref
    integer :: n
    logical :: ok
    ok = .true.
    if (ok)  ok = pass%i_pass == ref%i_pass
    if (ok)  ok = pass%i_first_it == ref%i_first_it
    if (ok)  ok = pass%n_it == ref%n_it
    if (ok)  ok = pass%n_calls == ref%n_calls
    if (ok)  ok = pass%n_bins == ref%n_bins
    if (ok)  ok = pass%adapt_grids .eqv. ref%adapt_grids
    if (ok)  ok = pass%adapt_weights .eqv. ref%adapt_weights
    if (ok)  ok = pass%integral_defined .eqv. ref%integral_defined
    if (pass%integral_defined) then
       n = pass%n_it
       if (ok)  ok = all (pass%calls(:n) == ref%calls(:n))
       if (ok)  ok = all (pass%integral(:n) .matches. ref%integral(:n))
       if (ok)  ok = all (pass%error(:n) .matches. ref%error(:n))
       if (ok)  ok = all (pass%efficiency(:n) .matches. ref%efficiency(:n))
    end if
  end function pass_matches
    
@ %def pass_matches
@ Update a pass object, given a reference.  The parameters must match, except
for the [[n_it]] entry.  The number of complete iterations must be less or
equal to the reference, and the number of complete iterations in the reference
must be no larger than [[n_it]].  Where results are present in both passes,
they must match.  Where results are present in the reference only, the pass is
updated accordingly.
<<MCI vamp: pass: TBP>>=
  procedure :: update => pass_update
<<MCI vamp: procedures>>=
  subroutine pass_update (pass, ref, ok)
    class(pass_t), intent(inout) :: pass
    type(pass_t), intent(in) :: ref
    logical, intent(out) :: ok
    integer :: n, n_ref
    ok = .true.
    if (ok)  ok = pass%i_pass == ref%i_pass
    if (ok)  ok = pass%i_first_it == ref%i_first_it
    if (ok)  ok = pass%n_calls == ref%n_calls
    if (ok)  ok = pass%n_bins == ref%n_bins
    if (ok)  ok = pass%adapt_grids .eqv. ref%adapt_grids
    if (ok)  ok = pass%adapt_weights .eqv. ref%adapt_weights
    if (ok) then
       if (ref%integral_defined) then
          if (.not. allocated (pass%calls)) then
             allocate (pass%calls (pass%n_it), source = 0)
             allocate (pass%integral (pass%n_it), source = 0._default)
             allocate (pass%error (pass%n_it), source = 0._default)
             allocate (pass%efficiency (pass%n_it), source = 0._default)
          end if
          n = count (pass%calls /= 0)
          n_ref = count (ref%calls /= 0)
          ok = n <= n_ref .and. n_ref <= pass%n_it
          if (ok)  ok = all (pass%calls(:n) == ref%calls(:n))
          if (ok)  ok = all (pass%integral(:n) .matches. ref%integral(:n))
          if (ok)  ok = all (pass%error(:n) .matches. ref%error(:n))
          if (ok)  ok = all (pass%efficiency(:n) .matches. ref%efficiency(:n))
          if (ok) then
             pass%calls(n+1:n_ref) = ref%calls(n+1:n_ref)
             pass%integral(n+1:n_ref) = ref%integral(n+1:n_ref)
             pass%error(n+1:n_ref) = ref%error(n+1:n_ref)
             pass%efficiency(n+1:n_ref) = ref%efficiency(n+1:n_ref)
             pass%integral_defined = any (pass%calls /= 0)
          end if
       end if
    end if
  end subroutine pass_update

@ %def pass_update
@ Match two real numbers: they are equal up to a tolerance, which is
$10^{-8}$, matching the number of digits that are output by [[pass_write]].
In particular, if one number is exactly zero, the other one must also be zero.
<<MCI vamp: interfaces>>=
  interface operator (.matches.)
     module procedure real_matches
  end interface operator (.matches.)
<<MCI vamp: procedures>>=
  elemental function real_matches (x, y) result (ok)
    real(default), intent(in) :: x, y
    logical :: ok
    real(default), parameter :: tolerance = 1.e-8_default
    ok = abs (x - y) <= tolerance * max (abs (x), abs (y))
  end function real_matches
  
@ %def real_matches
@ Return the index of the most recent complete integration.  If there is none,
return zero.
<<MCI vamp: pass: TBP>>=
  procedure :: get_integration_index => pass_get_integration_index
<<MCI vamp: procedures>>=
  function pass_get_integration_index (pass) result (n)
    class (pass_t), intent(in) :: pass
    integer :: n
    integer :: i
    n = 0
    if (allocated (pass%calls)) then
       do i = 1, pass%n_it
          if (pass%calls(i) == 0)  exit
          n = i
       end do
    end if
  end function pass_get_integration_index

@ %def pass_get_integration_index
@ Return the most recent integral and error, if available.
<<MCI vamp: pass: TBP>>=
  procedure :: get_calls => pass_get_calls
  procedure :: get_integral => pass_get_integral
  procedure :: get_error => pass_get_error
  procedure :: get_efficiency => pass_get_efficiency
<<MCI vamp: procedures>>=
  function pass_get_calls (pass) result (calls)
    class(pass_t), intent(in) :: pass
    integer :: calls
    integer :: n
    n = pass%get_integration_index ()
    if (n /= 0) then
       calls = pass%calls(n)
    else
       calls = 0
    end if
  end function pass_get_calls

  function pass_get_integral (pass) result (integral)
    class(pass_t), intent(in) :: pass
    real(default) :: integral
    integer :: n
    n = pass%get_integration_index ()
    if (n /= 0) then
       integral = pass%integral(n)
    else
       integral = 0
    end if
  end function pass_get_integral

  function pass_get_error (pass) result (error)
    class(pass_t), intent(in) :: pass
    real(default) :: error
    integer :: n
    n = pass%get_integration_index ()
    if (n /= 0) then
       error = pass%error(n)
    else
       error = 0
    end if
  end function pass_get_error

  function pass_get_efficiency (pass) result (efficiency)
    class(pass_t), intent(in) :: pass
    real(default) :: efficiency
    integer :: n
    n = pass%get_integration_index ()
    if (n /= 0) then
       efficiency = pass%efficiency(n)
    else
       efficiency = 0
    end if
  end function pass_get_efficiency

@ %def pass_get_integral
@ %def pass_get_error
@ %def pass_get_efficiency
@
\subsection{Integrator}
<<MCI vamp: public>>=
  public :: mci_vamp_t
<<MCI vamp: types>>=
  type, extends (mci_t) :: mci_vamp_t
     logical, dimension(:), allocatable :: dim_is_flat
     type(grid_parameters_t) :: grid_par
     type(history_parameters_t) :: history_par
     integer :: min_calls = 0
     type(pass_t), pointer :: first_pass => null ()
     type(pass_t), pointer :: current_pass => null ()
     type(vamp_equivalences_t) :: equivalences
     logical :: rebuild = .true.
     logical :: check_grid_file = .true.
     logical :: grid_filename_set = .false.
     logical :: negative_weights = .false.
     logical :: verbose = .false.
     type(string_t) :: grid_filename
     character(32) :: md5sum_adapted = ""
   contains
   <<MCI vamp: mci vamp: TBP>>
  end type mci_vamp_t
  
@ %def mci_vamp_t
@ Reset: delete integration-pass entries.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: reset => mci_vamp_reset
<<MCI vamp: procedures>>=
  subroutine mci_vamp_reset (object)
    class(mci_vamp_t), intent(inout) :: object
    type(pass_t), pointer :: current_pass
    do while (associated (object%first_pass))
       current_pass => object%first_pass
       object%first_pass => current_pass%next
       call current_pass%final ()
       deallocate (current_pass)
    end do
    object%current_pass => null ()
  end subroutine mci_vamp_reset
  
@ %def mci_vamp_reset
@ Finalizer: reset and finalize the equivalences list.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: final => mci_vamp_final
<<MCI vamp: procedures>>=
  subroutine mci_vamp_final (object)
    class(mci_vamp_t), intent(inout) :: object
    call object%reset ()
    call vamp_equivalences_final (object%equivalences)
    call object%base_final ()
  end subroutine mci_vamp_final
  
@ %def mci_vamp_final
@ Output.  Do not output the grids themselves, this may result in tons
of data.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: write => mci_vamp_write
<<MCI vamp: procedures>>=
  subroutine mci_vamp_write (object, unit, pacify, md5sum_version)
    class(mci_vamp_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    logical, intent(in), optional :: md5sum_version
    type(pass_t), pointer :: current_pass
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "VAMP integrator:"
    call object%base_write (u, pacify, md5sum_version)
    if (allocated (object%dim_is_flat)) then
       write (u, "(3x,A,999(1x,I0))")  "Flat dimensions    =", &
            pack ([(i, i = 1, object%n_dim)], object%dim_is_flat)
    end if
    write (u, "(1x,A)")  "Grid parameters:"
    call object%grid_par%write (u)
    write (u, "(3x,A,I0)") "min_calls             = ", object%min_calls
    write (u, "(3x,A,L1)") "negative weights      = ", &
         object%negative_weights
    write (u, "(3x,A,L1)") "verbose               = ", &
         object%verbose  
    if (object%grid_par%use_vamp_equivalences) then
       call vamp_equivalences_write (object%equivalences, u)
    end if
    current_pass => object%first_pass
    do while (associated (current_pass))
       write (u, "(1x,A,I0,A)")  "Integration pass:"
       call current_pass%write (u, pacify)
       current_pass => current_pass%next
    end do
    if (object%md5sum_adapted /= "") then
       write (u, "(1x,A,A,A)")  "MD5 sum (including results) = '", &
            object%md5sum_adapted, "'"
    end if
  end subroutine mci_vamp_write
  
@ %def mci_vamp_write
@ Write the history parameters.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: write_history_parameters => mci_vamp_write_history_parameters
<<MCI vamp: procedures>>=
  subroutine mci_vamp_write_history_parameters (mci, unit)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "VAMP history parameters:"
    call mci%history_par%write (unit)
  end subroutine mci_vamp_write_history_parameters

@ %def mci_vamp_write_history_parameters
@ Write the history, iterating over passes.  We keep this separate
from the generic [[write]] routine.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: write_history => mci_vamp_write_history
<<MCI vamp: procedures>>=
  subroutine mci_vamp_write_history (mci, unit)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in), optional :: unit
    type(pass_t), pointer :: current_pass
    integer :: i_pass
    integer :: u
    u = given_output_unit (unit)
    if (associated (mci%first_pass)) then
       write (u, "(1x,A)")  "VAMP history (global):"
       i_pass = 0
       current_pass => mci%first_pass
       do while (associated (current_pass))
          i_pass = i_pass + 1
          write (u, "(1x,A,I0,':')")  "Pass #", i_pass
          call current_pass%write_history (u)
          current_pass => current_pass%next
       end do
    end if
  end subroutine mci_vamp_write_history
  
@ %def mci_vamp_write_history
@ Compute the MD5 sum, including the configuration MD5 sum and the
printout, which incorporates the current results.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: compute_md5sum => mci_vamp_compute_md5sum
<<MCI vamp: procedures>>=
  subroutine mci_vamp_compute_md5sum (mci, pacify)
    class(mci_vamp_t), intent(inout) :: mci
    logical, intent(in), optional :: pacify
    integer :: u
    mci%md5sum_adapted = ""
    u = free_unit ()
    open (u, status = "scratch", action = "readwrite")
    write (u, "(A)")  mci%md5sum
    call mci%write (u, pacify, md5sum_version = .true.)
    rewind (u)
    mci%md5sum_adapted = md5sum (u)
    close (u)
  end subroutine mci_vamp_compute_md5sum
    
@ %def mci_vamp_compute_md5sum
@ Return the MD5 sum: If available, return the adapted one.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: get_md5sum => mci_vamp_get_md5sum
<<MCI vamp: procedures>>=
  function mci_vamp_get_md5sum (mci) result (md5sum)
    class(mci_vamp_t), intent(in) :: mci
    character(32) :: md5sum
    if (mci%md5sum_adapted /= "") then
       md5sum = mci%md5sum_adapted
    else
       md5sum = mci%md5sum
    end if
  end function mci_vamp_get_md5sum
  
@ %def mci_vamp_get_md5sum
@ Startup message: short version.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: startup_message => mci_vamp_startup_message
<<MCI vamp: procedures>>=
  subroutine mci_vamp_startup_message (mci, unit, n_calls)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in), optional :: unit, n_calls
    integer :: num_calls, n_bins
    if (present (n_calls)) then
       num_calls = n_calls 
    else
       num_calls = 0
    end if
    if (mci%min_calls /= 0) then
       n_bins =  max (mci%grid_par%min_bins, &
            min (num_calls / mci%min_calls, &
            mci%grid_par%max_bins))
    else
       n_bins = mci%grid_par%max_bins  
    end if    
    call mci%base_startup_message (unit = unit, n_calls = n_calls)
    if (mci%grid_par%use_vamp_equivalences) then
       write (msg_buffer, "(A,2(1x,I0,1x,A))") &
            "Integrator: Using VAMP channel equivalences"    
       call msg_message (unit = unit)
    end if
    write (msg_buffer, "(A,2(1x,I0,1x,A),L1)") &
         "Integrator:", num_calls, &
         "initial calls,", n_bins, & 
         "bins, stratified = ", &
         mci%grid_par%stratified
    call msg_message (unit = unit)
    write (msg_buffer, "(A,2(1x,I0,1x,A))") &
         "Integrator: VAMP"
    call msg_message (unit = unit)
  end subroutine mci_vamp_startup_message
    
@ %def mci_vamp_startup_message
@ Set the MCI index (necessary for processes with multiple components).
We append the index to the grid filename, just before the final dotted
suffix.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: record_index => mci_vamp_record_index
<<MCI vamp: procedures>>=
  subroutine mci_vamp_record_index (mci, i_mci)
    class(mci_vamp_t), intent(inout) :: mci
    integer, intent(in) :: i_mci
    type(string_t) :: basename, suffix
    character(32) :: buffer
    if (mci%grid_filename_set) then
       basename = mci%grid_filename
       call split (basename, suffix, ".", back=.true.)
       write (buffer, "(I0)")  i_mci
       if (basename /= "") then
          mci%grid_filename = basename // "_m" // trim (buffer) // "." // suffix
       else
          mci%grid_filename = suffix // "_m" // trim (buffer) // ".vg"
       end if
    end if
  end subroutine mci_vamp_record_index

@ %def mci_vamp_record_index
@ Set the grid parameters.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: set_grid_parameters => mci_vamp_set_grid_parameters
<<MCI vamp: procedures>>=
  subroutine mci_vamp_set_grid_parameters (mci, grid_par)
    class(mci_vamp_t), intent(inout) :: mci
    type(grid_parameters_t), intent(in) :: grid_par
    mci%grid_par = grid_par
    mci%min_calls = grid_par%min_calls_per_bin * mci%n_channel
  end subroutine mci_vamp_set_grid_parameters
  
@ %def mci_vamp_set_grid_parameters
@ Set the history parameters.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: set_history_parameters => mci_vamp_set_history_parameters
<<MCI vamp: procedures>>=
  subroutine mci_vamp_set_history_parameters (mci, history_par)
    class(mci_vamp_t), intent(inout) :: mci
    type(history_parameters_t), intent(in) :: history_par
    mci%history_par = history_par
  end subroutine mci_vamp_set_history_parameters
  
@ %def mci_vamp_set_history_parameters
@ Set the rebuild flag, also the flag for checking the grid file.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: set_rebuild_flag => mci_vamp_set_rebuild_flag
<<MCI vamp: procedures>>=
  subroutine mci_vamp_set_rebuild_flag (mci, rebuild, check_grid_file)
    class(mci_vamp_t), intent(inout) :: mci
    logical, intent(in) :: rebuild
    logical, intent(in) :: check_grid_file
    mci%rebuild = rebuild
    mci%check_grid_file = check_grid_file
  end subroutine mci_vamp_set_rebuild_flag
  
@ %def mci_vamp_set_rebuild_flag
@ Set the filename.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: set_grid_filename => mci_vamp_set_grid_filename
<<MCI vamp: procedures>>=
  subroutine mci_vamp_set_grid_filename (mci, name, run_id)
    class(mci_vamp_t), intent(inout) :: mci
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: run_id
    if (present (run_id)) then
       mci%grid_filename = name // "." // run_id // ".vg"
    else
       mci%grid_filename = name // ".vg"
    end if
    mci%grid_filename_set = .true.
  end subroutine mci_vamp_set_grid_filename
  
@ %def mci_vamp_set_grid_filename
@ Declare particular dimensions as flat.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: declare_flat_dimensions => mci_vamp_declare_flat_dimensions
<<MCI vamp: procedures>>=
  subroutine mci_vamp_declare_flat_dimensions (mci, dim_flat)
    class(mci_vamp_t), intent(inout) :: mci
    integer, dimension(:), intent(in) :: dim_flat
    integer :: d
    allocate (mci%dim_is_flat (mci%n_dim), source = .false.)
    do d = 1, size (dim_flat)
       mci%dim_is_flat(dim_flat(d)) = .true.
    end do
  end subroutine mci_vamp_declare_flat_dimensions
  
@ %def mci_vamp_declare_flat_dimensions
@ Declare equivalences.  We have an array of channel equivalences,
provided by the phase-space module.  Here, we translate this into the
[[vamp_equivalences]] array.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: declare_equivalences => mci_vamp_declare_equivalences
<<MCI vamp: procedures>>=
  subroutine mci_vamp_declare_equivalences (mci, channel, dim_offset)
    class(mci_vamp_t), intent(inout) :: mci
    type(phs_channel_t), dimension(:), intent(in) :: channel
    integer, intent(in) :: dim_offset
    integer, dimension(:), allocatable :: perm, mode
    integer :: n_channels, n_dim, n_equivalences
    integer :: c, i, j, left, right
    n_channels = mci%n_channel
    n_dim = mci%n_dim
    n_equivalences = 0
    do c = 1, n_channels
       n_equivalences = n_equivalences + size (channel(c)%eq)
    end do
    call vamp_equivalences_init (mci%equivalences, &
         n_equivalences, n_channels, n_dim)
    allocate (perm (n_dim))
    allocate (mode (n_dim))
    perm(1:dim_offset) = [(i, i = 1, dim_offset)]
    mode(1:dim_offset) = VEQ_IDENTITY
    c = 1
    j = 0
    do i = 1, n_equivalences
       if (j < size (channel(c)%eq)) then
          j = j + 1
       else
          c = c + 1
          j = 1
       end if
       associate (eq => channel(c)%eq(j))
         left = c
         right = eq%c
         perm(dim_offset+1:) = eq%perm + dim_offset
         mode(dim_offset+1:) = eq%mode
         call vamp_equivalence_set (mci%equivalences, &
              i, left, right, perm, mode)
       end associate
    end do
    call vamp_equivalences_complete (mci%equivalences)
  end subroutine mci_vamp_declare_equivalences

@ %def mci_vamp_declare_equivalences
@ Allocate instance with matching type.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: allocate_instance => mci_vamp_allocate_instance
<<MCI vamp: procedures>>=
  subroutine mci_vamp_allocate_instance (mci, mci_instance)
    class(mci_vamp_t), intent(in) :: mci
    class(mci_instance_t), intent(out), pointer :: mci_instance
    allocate (mci_vamp_instance_t :: mci_instance)
  end subroutine mci_vamp_allocate_instance
  
@ %def mci_vamp_allocate_instance
@ Allocate a new integration pass.  We can preset everything that does not
depend on the number of iterations and calls.  This is postponed to
the [[integrate]] method.

In the final pass, we do not check accuracy goal etc., since we can assume
that the user wants to perform and average all iterations in this pass.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: add_pass => mci_vamp_add_pass
<<MCI vamp: procedures>>=
  subroutine mci_vamp_add_pass (mci, adapt_grids, adapt_weights, final)
    class(mci_vamp_t), intent(inout) :: mci
    logical, intent(in), optional :: adapt_grids, adapt_weights, final
    integer :: i_pass, i_it
    type(pass_t), pointer :: new
    allocate (new)
    if (associated (mci%current_pass)) then
       i_pass = mci%current_pass%i_pass + 1
       i_it   = mci%current_pass%i_first_it + mci%current_pass%n_it
       mci%current_pass%next => new
    else
       i_pass = 1
       i_it = 1
       mci%first_pass => new
    end if
    mci%current_pass => new
    new%i_pass = i_pass
    new%i_first_it = i_it
    if (present (adapt_grids)) then
       new%adapt_grids = adapt_grids
    else
       new%adapt_grids = .false.
    end if
    if (present (adapt_weights)) then
       new%adapt_weights = adapt_weights
    else
       new%adapt_weights = .false.
    end if
    if (present (final)) then
       new%is_final_pass = final
    else
       new%is_final_pass = .false.
    end if
  end subroutine mci_vamp_add_pass
  
@ %def mci_vamp_add_pass
@ Update the list of integration passes.  All passes except for the last one
must match exactly.  For the last one, integration results are updated.  The
reference output may contain extra passes, these are ignored.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: update_from_ref => mci_vamp_update_from_ref
<<MCI vamp: procedures>>=
  subroutine mci_vamp_update_from_ref (mci, mci_ref, success)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_t), intent(in) :: mci_ref
    logical, intent(out) :: success
    type(pass_t), pointer :: current_pass, ref_pass
    select type (mci_ref)
    type is (mci_vamp_t)
       current_pass => mci%first_pass
       ref_pass => mci_ref%first_pass
       success = .true.
       do while (success .and. associated (current_pass))
          if (associated (ref_pass)) then
             if (associated (current_pass%next)) then
                success = current_pass .matches. ref_pass
             else
                call current_pass%update (ref_pass, success)
                if (current_pass%integral_defined) then
                   mci%integral = current_pass%get_integral ()
                   mci%error = current_pass%get_error ()
                   mci%efficiency = current_pass%get_efficiency ()
                   mci%integral_known = .true.
                   mci%error_known = .true.
                   mci%efficiency_known = .true.
                end if
             end if
             current_pass => current_pass%next
             ref_pass => ref_pass%next
          else
             success = .false.
          end if
       end do
    end select
  end subroutine mci_vamp_update_from_ref
  
@ %def mci_vamp_update
@ Update the MCI record (i.e., the integration passes) by reading from input
stream.  The stream should contain a [[write]] output from a previous run.  We
first check the MD5 sum of the configuration parameters.  If that matches, we
proceed directly to the stored integration passes.  If successful, we may
continue to read the file; the position will be after a blank line that
must follow the MCI record.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: update => mci_vamp_update
<<MCI vamp: procedures>>=
  subroutine mci_vamp_update (mci, u, success)
    class(mci_vamp_t), intent(inout) :: mci
    integer, intent(in) :: u
    logical, intent(out) :: success
    character(80) :: buffer
    character(32) :: md5sum_file
    type(mci_vamp_t) :: mci_file
    integer :: n_pass, n_it
    call read_sval (u, md5sum_file)
    if (mci%check_grid_file) then
       success = md5sum_file == mci%md5sum
    else
       success = .true.
    end if
    if (success) then
       read (u, *)
       read (u, "(A)")  buffer
       if (trim (adjustl (buffer)) == "VAMP integrator:") then
          n_pass = 0
          n_it = 0
          do
             read (u, "(A)")  buffer
             select case (trim (adjustl (buffer)))
             case ("")
                exit
             case ("Integration pass:")
                call mci_file%add_pass ()
                call mci_file%current_pass%read (u, n_pass, n_it)
                n_pass = n_pass + 1
                n_it = n_it + mci_file%current_pass%n_it
             end select
          end do
          call mci%update_from_ref (mci_file, success)
          call mci_file%final ()
       else
          call msg_fatal ("VAMP: reading grid file: corrupted data")
       end if
    end if
  end subroutine mci_vamp_update
  
@ %def mci_vamp_update
@ Read / write grids from / to file.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: write_grids => mci_vamp_write_grids
  procedure :: read_grids_header => mci_vamp_read_grids_header
  procedure :: read_grids_data => mci_vamp_read_grids_data
  procedure :: read_grids => mci_vamp_read_grids
<<MCI vamp: procedures>>=
  subroutine mci_vamp_write_grids (mci, instance)
    class(mci_vamp_t), intent(in) :: mci
    class(mci_instance_t), intent(inout) :: instance
    integer :: u
    select type (instance)
    type is (mci_vamp_instance_t)
       if (mci%grid_filename_set) then
          if (instance%grids_defined) then
             u = free_unit ()
             open (u, file = char (mci%grid_filename), &
                  action = "write", status = "replace")
             write (u, "(1x,A,A,A)")  "MD5sum = '", mci%md5sum, "'"
             write (u, *)
             call mci%write (u)
             write (u, *)
             write (u, "(1x,A)")  "VAMP grids:"
             call vamp_write_grids (instance%grids, u, &
                  write_integrals = .true.)
             close (u)
          else
             call msg_bug ("VAMP: write grids: grids undefined")
          end if
       else
          call msg_bug ("VAMP: write grids: filename undefined")
       end if
    end select
  end subroutine mci_vamp_write_grids

  subroutine mci_vamp_read_grids_header (mci, success)
    class(mci_vamp_t), intent(inout) :: mci
    logical, intent(out) :: success
    logical :: exist
    integer :: u
    success = .false.
    if (mci%grid_filename_set) then
       inquire (file = char (mci%grid_filename), exist = exist)
       if (exist) then
          u = free_unit ()
          open (u, file = char (mci%grid_filename), &
               action = "read", status = "old")
          call mci%update (u, success)
          close (u)
          if (.not. success) then
             write (msg_buffer, "(A,A,A)") &
                  "VAMP: parameter mismatch, discarding grid file '", &
                  char (mci%grid_filename), "'"
             call msg_message ()
          end if
       end if
    else
       call msg_bug ("VAMP: read grids: filename undefined")
    end if
  end subroutine mci_vamp_read_grids_header
  
  subroutine mci_vamp_read_grids_data (mci, instance, read_integrals)
    class(mci_vamp_t), intent(in) :: mci
    class(mci_instance_t), intent(inout) :: instance
    logical, intent(in), optional :: read_integrals
    integer :: u
    character(80) :: buffer
    select type (instance)
    type is (mci_vamp_instance_t)
       if (.not. instance%grids_defined) then
          u = free_unit ()
          open (u, file = char (mci%grid_filename), &
               action = "read", status = "old") 
          do
             read (u, "(A)")  buffer
             if (trim (adjustl (buffer)) == "VAMP grids:")  exit
          end do
          call vamp_read_grids (instance%grids, u, read_integrals)
          close (u)
          instance%grids_defined = .true.
       else
          call msg_bug ("VAMP: read grids: grids already defined")
       end if
    end select
  end subroutine mci_vamp_read_grids_data
  
  subroutine mci_vamp_read_grids (mci, instance, success)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout) :: instance
    logical, intent(out) :: success
    logical :: exist
    integer :: u
    character(80) :: buffer
    select type (instance)
    type is (mci_vamp_instance_t)
       success = .false.
       if (mci%grid_filename_set) then
          if (.not. instance%grids_defined) then
             inquire (file = char (mci%grid_filename), exist = exist)
             if (exist) then
                u = free_unit ()
                open (u, file = char (mci%grid_filename), &
                     action = "read", status = "old")
                call mci%update (u, success)
                if (success) then
                   read (u, "(A)")  buffer
                   if (trim (adjustl (buffer)) == "VAMP grids:") then
                      call vamp_read_grids (instance%grids, u)
                   else
                      call msg_fatal ("VAMP: reading grid file: &
                           &corrupted grid data")
                   end if
                else
                   write (msg_buffer, "(A,A,A)") &
                        "VAMP: parameter mismatch, discarding grid file '", &
                        char (mci%grid_filename), "'"
                   call msg_message ()
                end if
                close (u)
                instance%grids_defined = success
             end if
          else
             call msg_bug ("VAMP: read grids: grids already defined")
          end if
       else
          call msg_bug ("VAMP: read grids: filename undefined")
       end if
    end select
  end subroutine mci_vamp_read_grids
  
@ %def mci_vamp_write_grids
@ %def mci_vamp_read_grids_header
@ %def mci_vamp_read_grids_data
@ %def mci_vamp_read_grids
@ Auxiliary: Read real, integer, string value.  We search for an equals sign,
the value must follow.
<<MCI vamp: procedures>>=
  subroutine read_rval (u, rval)
    integer, intent(in) :: u
    real(default), intent(out) :: rval
    character(80) :: buffer
    read (u, "(A)")  buffer
    buffer = adjustl (buffer(scan (buffer, "=") + 1:))
    read (buffer, *)  rval
  end subroutine read_rval
    
  subroutine read_ival (u, ival)
    integer, intent(in) :: u
    integer, intent(out) :: ival
    character(80) :: buffer
    read (u, "(A)")  buffer
    buffer = adjustl (buffer(scan (buffer, "=") + 1:))
    read (buffer, *)  ival
  end subroutine read_ival
    
  subroutine read_sval (u, sval)
    integer, intent(in) :: u
    character(*), intent(out) :: sval
    character(80) :: buffer
    read (u, "(A)")  buffer
    buffer = adjustl (buffer(scan (buffer, "=") + 1:))
    read (buffer, *)  sval
  end subroutine read_sval
    
  subroutine read_lval (u, lval)
    integer, intent(in) :: u
    logical, intent(out) :: lval
    character(80) :: buffer
    read (u, "(A)")  buffer
    buffer = adjustl (buffer(scan (buffer, "=") + 1:))
    read (buffer, *)  lval
  end subroutine read_lval
    
@ %def read_rval read_ival read_sval read_lval
@ Integrate.  Perform a new integration pass (possibly reusing
previous results), which may consist of several iterations.

Note: we record the integral once per iteration.  The integral stored
in the [[mci]] record itself is the last integral of the current
iteration, no averaging done.  The [[results]] record may average results.

Note: recording the efficiency is not supported yet.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: integrate => mci_vamp_integrate
<<MCI vamp: procedures>>=
  subroutine mci_vamp_integrate (mci, instance, sampler, &
       n_it, n_calls, results, pacify)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout) :: instance
    class(mci_sampler_t), intent(inout) :: sampler
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    class(mci_results_t), intent(inout), optional :: results
    logical, intent(in), optional :: pacify
    integer :: it
    logical :: reshape, from_file, success
    select type (instance)
    type is (mci_vamp_instance_t)
       if (associated (mci%current_pass)) then
          mci%current_pass%integral_defined = .false.
          call mci%current_pass%configure (n_it, n_calls, &
               mci%min_calls, mci%grid_par%min_bins, &
               mci%grid_par%max_bins, &
               mci%grid_par%min_calls_per_channel * mci%n_channel)
          call mci%current_pass%configure_history &
               (mci%n_channel, mci%history_par)
          instance%pass_complete = .false.
          instance%it_complete = .false.
          call instance%new_pass (reshape)
          if (.not. instance%grids_defined .or. instance%grids_from_file) then
             if (mci%grid_filename_set .and. .not. mci%rebuild) then
                call mci%read_grids_header (success)
                from_file = success
                if (.not. instance%grids_defined .and. success) then
                   call mci%read_grids_data (instance)
                end if
             else
                from_file = .false.
             end if
          else
             from_file = .false.
          end if
          if (from_file) then
             if (.not. mci%check_grid_file) &
                  call msg_warning ("Reading grid file: MD5 sum check disabled")
             call msg_message ("VAMP: " &
                  // "using grids and results from file '" &
                  // char (mci%grid_filename) // "'")
          else if (.not. instance%grids_defined) then
             call instance%create_grids ()
          end if
          do it = 1, instance%n_it
             if (signal_is_pending ())  return
             instance%grids_from_file = from_file .and. &
                  it <= mci%current_pass%get_integration_index ()
             if (.not. instance%grids_from_file) then
                instance%it_complete = .false.
                call instance%adapt_grids ()
                if (signal_is_pending ())  return
                call instance%adapt_weights ()
                if (signal_is_pending ())  return
                call instance%discard_integrals (reshape)
                if (mci%grid_par%use_vamp_equivalences) then
                   call instance%sample_grids (mci%rng, sampler, &
                        mci%equivalences)
                else
                   call instance%sample_grids (mci%rng, sampler)
                end if
                if (signal_is_pending ())  return
                instance%it_complete = .true.
                if (instance%integral /= 0) then
                   mci%current_pass%calls(it) = instance%calls
                   mci%current_pass%integral(it) = instance%integral
                   if (abs (instance%error / instance%integral) &
                        > epsilon (1._default)) then
                      mci%current_pass%error(it) = instance%error
                   end if
                   mci%current_pass%efficiency(it) = instance%efficiency
                end if
                mci%current_pass%integral_defined = .true.
             end if
             if (present (results)) then
                if (mci%has_chains ()) then
                   call mci%collect_chain_weights (instance%w)
                   call results%record (1, &
                        n_calls    = mci%current_pass%calls(it), &
                        integral   = mci%current_pass%integral(it), &
                        error      = mci%current_pass%error(it), &
                        efficiency = mci%current_pass%efficiency(it), &
                        chain_weights = mci%chain_weights, &
                        suppress = pacify)
                else
                   call results%record (1, &
                        n_calls    = mci%current_pass%calls(it), &
                        integral   = mci%current_pass%integral(it), &
                        error      = mci%current_pass%error(it), &
                        efficiency = mci%current_pass%efficiency(it), &
                        suppress = pacify)
                end if
             end if
             if (.not. instance%grids_from_file &
                  .and. mci%grid_filename_set) then
                call mci%write_grids (instance)
             end if
             call instance%allow_adaptation ()
             reshape = .false.
             if (.not. mci%current_pass%is_final_pass) then
                call mci%check_goals (it, success)
                if (success)  exit
             end if
          end do
          if (signal_is_pending ())  return
          instance%pass_complete = .true.
          mci%integral = mci%current_pass%get_integral()
          mci%error = mci%current_pass%get_error()
          mci%efficiency = mci%current_pass%get_efficiency()
          mci%integral_known = .true.
          mci%error_known = .true.
          mci%efficiency_known = .true.
          call mci%compute_md5sum (pacify)
       else
          call msg_bug ("MCI integrate: current_pass object not allocated")
       end if
    end select
  end subroutine mci_vamp_integrate

@ %def mci_vamp_integrate
@ Check whether we are already finished with this pass.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: check_goals => mci_vamp_check_goals
<<MCI vamp: procedures>>=
  subroutine mci_vamp_check_goals (mci, it, success)
    class(mci_vamp_t), intent(inout) :: mci
    integer, intent(in) :: it
    logical, intent(out) :: success
    success = .false.
    if (mci%error_reached (it)) then
       mci%current_pass%n_it = it
       call msg_message ("VAMP: error goal reached; &
            &skipping iterations")
       success = .true.
       return
    end if
    if (mci%rel_error_reached (it)) then
       mci%current_pass%n_it = it
       call msg_message ("VAMP: relative error goal reached; &
            &skipping iterations")
       success = .true.
       return
    end if
    if (mci%accuracy_reached (it)) then
       mci%current_pass%n_it = it
       call msg_message ("VAMP: accuracy goal reached; &
            &skipping iterations")
       success = .true.
       return
    end if
  end subroutine mci_vamp_check_goals
    
@ %def mci_vamp_check_goals
@ Return true if the error, relative error, or accuracy goal has been reached,
if any.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: error_reached => mci_vamp_error_reached
  procedure :: rel_error_reached => mci_vamp_rel_error_reached
  procedure :: accuracy_reached => mci_vamp_accuracy_reached
<<MCI vamp: procedures>>=
  function mci_vamp_error_reached (mci, it) result (flag)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in) :: it
    logical :: flag
    real(default) :: error_goal, error
    error_goal = mci%grid_par%error_goal
    if (error_goal > 0) then
       associate (pass => mci%current_pass)
         if (pass%integral_defined) then
            error = abs (pass%error(it))
            flag = error < error_goal
         else
            flag = .false.
         end if
       end associate
    else
       flag = .false.
    end if
  end function mci_vamp_error_reached
  
  function mci_vamp_rel_error_reached (mci, it) result (flag)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in) :: it
    logical :: flag
    real(default) :: rel_error_goal, rel_error
    rel_error_goal = mci%grid_par%rel_error_goal
    if (rel_error_goal > 0) then
       associate (pass => mci%current_pass)
         if (pass%integral_defined) then
            if (pass%integral(it) /= 0) then
               rel_error = abs (pass%error(it) / pass%integral(it))
               flag = rel_error < rel_error_goal
            else
               flag = .true.
            end if
         else
            flag = .false.
         end if
       end associate
    else
       flag = .false.
    end if
  end function mci_vamp_rel_error_reached
  
  function mci_vamp_accuracy_reached (mci, it) result (flag)
    class(mci_vamp_t), intent(in) :: mci
    integer, intent(in) :: it
    logical :: flag
    real(default) :: accuracy_goal, accuracy
    accuracy_goal = mci%grid_par%accuracy_goal
    if (accuracy_goal > 0) then
       associate (pass => mci%current_pass)
         if (pass%integral_defined) then
            if (pass%integral(it) /= 0) then
               accuracy = abs (pass%error(it) / pass%integral(it)) &
                    * sqrt (real (pass%calls(it), default))
               flag = accuracy < accuracy_goal
            else
               flag = .true.
            end if
         else
            flag = .false.
         end if
       end associate
    else
       flag = .false.
    end if
  end function mci_vamp_accuracy_reached
  
@ %def mci_vamp_error_reached
@ %def mci_vamp_rel_error_reached
@ %def mci_vamp_accuracy_reached
@ Prepare an event generation pass.  Should be called before a sequence of
events is generated, then we should call the corresponding finalizer.

The pass-specific data of the previous integration pass are retained,
but we reset the number of iterations and calls to zero.  The latter
now counts the number of events (calls to the sampling function, actually).
<<MCI vamp: mci vamp: TBP>>=
  procedure :: prepare_simulation => mci_vamp_prepare_simulation
<<MCI vamp: procedures>>=
  subroutine mci_vamp_prepare_simulation (mci)
    class(mci_vamp_t), intent(inout) :: mci
    logical :: success
    if (mci%grid_filename_set) then
       call mci%read_grids_header (success)
       call mci%compute_md5sum ()
       if (.not. success) then
          call msg_fatal ("Simulate: " &
               // "reading integration grids from file '" &
               // char (mci%grid_filename) // "' failed")
       end if
    else
       call msg_bug ("VAMP: simulation: no grids, no grid filename")
    end if
  end subroutine mci_vamp_prepare_simulation
  
@ %def mci_vamp_prepare_simulation
@ Generate weighted event.  Note that the event weight
([[vamp_weight]]) is not just the MCI weight.  [[vamp_next_event]]
selects a channel based on the channel weights multiplied by the
(previously recorded) maximum integrand value of the channel.  The
MCI weight is renormalized accordingly, to cancel this effect on the
result.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: generate_weighted_event => mci_vamp_generate_weighted_event
<<MCI vamp: procedures>>=
  subroutine mci_vamp_generate_weighted_event (mci, instance, sampler)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout), target :: instance
    class(mci_sampler_t), intent(inout), target :: sampler
    class(vamp_data_t), allocatable :: data
    type(exception) :: vamp_exception
    select type (instance)
    type is (mci_vamp_instance_t)
       instance%vamp_weight_set = .false.
       allocate (mci_workspace_t :: data)
       select type (data)
       type is (mci_workspace_t)
          data%sampler => sampler
          data%instance => instance
       end select
       select type (rng => mci%rng)
       type is (rng_tao_t)
          if (instance%grids_defined) then
             call vamp_next_event ( &
                  instance%vamp_x, &
                  rng%state, &
                  instance%grids, &
                  vamp_sampling_function, &
                  data, &
                  phi = phi_trivial, &
                  weight = instance%vamp_weight, &
                  exc = vamp_exception)
             call handle_vamp_exception (vamp_exception, mci%verbose)
             instance%vamp_excess = 0
             instance%vamp_weight_set = .true.
          else
             call msg_bug ("VAMP: generate event: grids undefined")
          end if
       class default
         call msg_fatal ("VAMP event generation: &
               &random-number generator must be TAO")
       end select
    end select
  end subroutine mci_vamp_generate_weighted_event
       
@ %def mci_vamp_generate_weighted_event
@ Generate unweighted event.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: generate_unweighted_event => &
       mci_vamp_generate_unweighted_event
<<MCI vamp: procedures>>=
  subroutine mci_vamp_generate_unweighted_event (mci, instance, sampler)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout), target :: instance
    class(mci_sampler_t), intent(inout), target :: sampler
    class(vamp_data_t), allocatable :: data
    type(exception) :: vamp_exception
    select type (instance)
    type is (mci_vamp_instance_t)
       instance%vamp_weight_set = .false.
       allocate (mci_workspace_t :: data)
       select type (data)
       type is (mci_workspace_t)
          data%sampler => sampler
          data%instance => instance
       end select
       select type (rng => mci%rng)
       type is (rng_tao_t)
          if (instance%grids_defined) then
             REJECTION: do
                call vamp_next_event ( &
                     instance%vamp_x, &
                     rng%state, &
                     instance%grids, &
                     vamp_sampling_function, &
                     data, &
                     phi = phi_trivial, &
                     excess = instance%vamp_excess, &
                     exc = vamp_exception)
                if (signal_is_pending ())  return
                if (sampler%is_valid ())  exit REJECTION
             end do REJECTION
             call handle_vamp_exception (vamp_exception, mci%verbose)
             instance%vamp_weight = 1
             instance%vamp_weight_set = .true.
          else
             call msg_bug ("VAMP: generate event: grids undefined")
          end if
       class default
         call msg_fatal ("VAMP event generation: &
               &random-number generator must be TAO")
       end select
    end select
  end subroutine mci_vamp_generate_unweighted_event
    
@ %def mci_vamp_generate_unweighted_event
@ Rebuild an event, using the [[state]] input.

Note: This feature is currently unused.
<<MCI vamp: mci vamp: TBP>>=
  procedure :: rebuild_event => mci_vamp_rebuild_event
<<MCI vamp: procedures>>=
  subroutine mci_vamp_rebuild_event (mci, instance, sampler, state)
    class(mci_vamp_t), intent(inout) :: mci
    class(mci_instance_t), intent(inout) :: instance
    class(mci_sampler_t), intent(inout) :: sampler
    class(mci_state_t), intent(in) :: state
    call msg_bug ("MCI vamp rebuild event not implemented yet")
  end subroutine mci_vamp_rebuild_event
       
@ %def mci_vamp_rebuild_event
@
<<MCI vamp: mci vamp: TBP>>=
  procedure :: pacify => mci_vamp_pacify
<<MCI vamp: procedures>>=
  subroutine mci_vamp_pacify (object, efficiency_reset, error_reset)
    class(mci_vamp_t), intent(inout) :: object
    logical, intent(in), optional :: efficiency_reset, error_reset
    logical :: err_reset
    type(pass_t), pointer :: current_pass
    err_reset = .false.
    if (present (error_reset))  err_reset = error_reset
    current_pass => object%first_pass    
    do while (associated (current_pass))
       if (allocated (current_pass%error) .and. err_reset) then
          current_pass%error = 0
       end if
       if (allocated (current_pass%efficiency) .and. err_reset) then
          current_pass%efficiency = 1
       end if
       current_pass => current_pass%next
    end do
  end subroutine mci_vamp_pacify
    
@  %def mci_vamp_pacify
@
\subsection{Sampler as Workspace}
In the full setup, the sampling function requires the process instance
object as workspace.  We implement this by (i) implementing the
process instance as a type extension of the abstract [[sampler_t]]
object used by the MCI implementation and (ii) providing such an
object as an extra argument to the sampling function that VAMP can
call.  To minimize cross-package dependencies, we use an abstract type
[[vamp_workspace]] that VAMP declares and extend this by including a
pointer to the [[sampler]] and [[instance]] objects.  In the body of
the sampling function, we dereference this pointer and can then work
with the contents.
<<MCI vamp: types>>=
  type, extends (vamp_data_t) :: mci_workspace_t
     class(mci_sampler_t), pointer :: sampler => null ()
     class(mci_vamp_instance_t), pointer :: instance => null ()
  end type mci_workspace_t
  
@ %def mci_workspace_t
@
\subsection{Integrator instance}
The history entries should point to the corresponding history entry in
the [[pass_t]] object.  If there is none, we may allocate a local
history, which is then just transient.
<<MCI vamp: public>>=
  public :: mci_vamp_instance_t
<<MCI vamp: types>>=
  type, extends (mci_instance_t) :: mci_vamp_instance_t
     type(mci_vamp_t), pointer :: mci => null ()
     logical :: grids_defined = .false.
     logical :: grids_from_file = .false.
     integer :: n_it = 0
     integer :: it = 0
     logical :: pass_complete = .false.
     integer :: n_calls = 0
     integer :: calls = 0
     logical :: it_complete = .false.
     logical :: enable_adapt_grids = .false.
     logical :: enable_adapt_weights = .false.
     logical :: allow_adapt_grids = .false.
     logical :: allow_adapt_weights = .false.
     logical :: negative_weights = .false.
     integer :: n_adapt_grids = 0
     integer :: n_adapt_weights = 0
     logical :: generating_events = .false.
     real(default) :: safety_factor = 1
     type(vamp_grids) :: grids
     real(default) :: g = 0
     real(default), dimension(:), allocatable :: gi
     real(default) :: integral = 0
     real(default) :: error = 0
     real(default) :: efficiency = 0
     real(default), dimension(:), allocatable :: vamp_x
     logical :: vamp_weight_set = .false.
     real(default) :: vamp_weight = 0
     real(default) :: vamp_excess = 0
     logical :: allocate_global_history = .false.
     type(vamp_history), dimension(:), pointer :: v_history => null ()
     logical :: allocate_channel_history = .false.
     type(vamp_history), dimension(:,:), pointer :: v_histories => null ()
   contains
   <<MCI vamp: mci vamp instance: TBP>>
  end type mci_vamp_instance_t
  
@ %def mci_vamp_instance_t
@ Output.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: write => mci_vamp_instance_write
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_write (object, unit, pacify)
    class(mci_vamp_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify    
    integer :: u, i
    character(len=7) :: fmt 
    call pac_fmt (fmt, FMT_17, FMT_14, pacify)
    u = given_output_unit (unit)
    write (u, "(3x,A," // FMT_19 // ")") "Integrand = ", object%integrand
    write (u, "(3x,A," // FMT_19 // ")") "Weight    = ", object%mci_weight
    if (object%vamp_weight_set) then
       write (u, "(3x,A," // FMT_19 // ")") "VAMP wgt  = ", object%vamp_weight
       if (object%vamp_excess /= 0) then
          write (u, "(3x,A," // FMT_19 // ")") "VAMP exc  = ", &
               object%vamp_excess
       end if
    end if
    write (u, "(3x,A,L1)")  "adapt grids   = ", object%enable_adapt_grids
    write (u, "(3x,A,L1)")  "adapt weights = ", object%enable_adapt_weights
    if (object%grids_defined) then
       if (object%grids_from_file) then
          write (u, "(3x,A)")  "VAMP grids: read from file"
       else
          write (u, "(3x,A)")  "VAMP grids: defined"
       end if
    else
       write (u, "(3x,A)")  "VAMP grids: [undefined]"
    end if
    write (u, "(3x,A,I0)")  "n_it          = ", object%n_it
    write (u, "(3x,A,I0)")  "it            = ", object%it
    write (u, "(3x,A,L1)")  "pass complete = ", object%it_complete
    write (u, "(3x,A,I0)")  "n_calls       = ", object%n_calls
    write (u, "(3x,A,I0)")  "calls         = ", object%calls
    write (u, "(3x,A,L1)")  "it complete   = ", object%it_complete
    write (u, "(3x,A,I0)")  "n adapt.(g)   = ", object%n_adapt_grids
    write (u, "(3x,A,I0)")  "n adapt.(w)   = ", object%n_adapt_weights
    write (u, "(3x,A,L1)")  "gen. events   = ", object%generating_events
    write (u, "(3x,A,L1)")  "neg. weights  = ", object%negative_weights
    if (object%safety_factor /= 1)  write &
          (u, "(3x,A," // fmt // ")")  "safety f = ", object%safety_factor
    write (u, "(3x,A," // fmt // ")")  "integral = ", object%integral
    write (u, "(3x,A," // fmt // ")")  "error    = ", object%error
    write (u, "(3x,A," // fmt // ")")  "eff.     = ", object%efficiency
    write (u, "(3x,A)")  "weights:"
    do i = 1, size (object%w)
       write (u, "(5x,I0,1x," // FMT_12 // ")")  i, object%w(i)
    end do
  end subroutine mci_vamp_instance_write
  
@ %def mci_vamp_instance_write
@ Write the grids to the specified unit.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: write_grids => mci_vamp_instance_write_grids
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_write_grids (object, unit)
    class(mci_vamp_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%grids_defined) then
       call vamp_write_grids (object%grids, u, write_integrals = .true.)
    end if
  end subroutine mci_vamp_instance_write_grids
  
@ %def mci_vamp_instance_write_grids
@ Finalizer: the history arrays are pointer arrays and need finalization.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: final => mci_vamp_instance_final
<<MCI vamp: tests>>=
  subroutine mci_vamp_instance_final (object)
    class(mci_vamp_instance_t), intent(inout) :: object
    if (object%allocate_global_history) then
       if (associated (object%v_history)) then
          call vamp_delete_history (object%v_history)
          deallocate (object%v_history)
       end if
    end if
    if (object%allocate_channel_history) then
       if (associated (object%v_histories)) then
          call vamp_delete_history (object%v_histories)
          deallocate (object%v_histories)
       end if
    end if
    if (object%grids_defined) then
       call vamp_delete_grids (object%grids)
       object%grids_defined = .false.       
    end if
  end subroutine mci_vamp_instance_final
  
@ %def mci_vamp_instance_final
@ Initializer.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: init => mci_vamp_instance_init
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_init (mci_instance, mci)
    class(mci_vamp_instance_t), intent(out) :: mci_instance
    class(mci_t), intent(in), target :: mci
    call mci_instance%base_init (mci)
    select type (mci)
    type is (mci_vamp_t)
       mci_instance%mci => mci
       allocate (mci_instance%gi (mci%n_channel))
       mci_instance%allocate_global_history = .not. mci%history_par%global
       mci_instance%allocate_channel_history = .not. mci%history_par%channel
       mci_instance%negative_weights = mci%negative_weights
    end select
  end subroutine mci_vamp_instance_init
    
@ %def mci_vamp_instance_init
@ Prepare a new integration pass: write the pass-specific settings to
the [[instance]] object.  This should be called initially, together
with the [[create_grids]] procedure, and whenever we start a new
integration pass.

Set [[reshape]] if the number of calls is different than previously (unless it
was zero, indicating the first pass).

We link VAMP histories to the allocated histories in the current pass
object, so the recorded results are persistent.  However, if there are
no histories present there, we allocate them locally.  In that case,
the histories will disappear together with the MCI instance object.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: new_pass => mci_vamp_instance_new_pass
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_new_pass (instance, reshape)
    class(mci_vamp_instance_t), intent(inout) :: instance
    logical, intent(out) :: reshape
    type(pass_t), pointer :: current
    associate (mci => instance%mci)
      current => mci%current_pass
      instance%n_it = current%n_it
      if (instance%n_calls == 0) then
         reshape = .false.
         instance%n_calls = current%n_calls
      else if (instance%n_calls == current%n_calls) then
         reshape = .false.
      else
         reshape = .true.
         instance%n_calls = current%n_calls
      end if
      instance%it = 0
      instance%calls = 0
      instance%enable_adapt_grids = current%adapt_grids
      instance%enable_adapt_weights = current%adapt_weights
      instance%generating_events = .false.
      if (instance%allocate_global_history) then
         if (associated (instance%v_history)) then
            call vamp_delete_history (instance%v_history)
            deallocate (instance%v_history)
         end if
         allocate (instance%v_history (instance%n_it))
         call vamp_create_history (instance%v_history, verbose = .false.)
      else
         instance%v_history => current%v_history
      end if
      if (instance%allocate_channel_history) then
         if (associated (instance%v_histories)) then
            call vamp_delete_history (instance%v_histories)
            deallocate (instance%v_histories)
         end if
         allocate (instance%v_histories (instance%n_it, mci%n_channel))
         call vamp_create_history (instance%v_histories, verbose = .false.)
      else
         instance%v_histories => current%v_histories
      end if
    end associate
  end subroutine mci_vamp_instance_new_pass
  
@ %def mci_vamp_instance_new_pass
@
Create a grid set within the [[instance]] object, using the data of
the current integration pass.  Also reset counters that track this
grid set.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: create_grids => mci_vamp_instance_create_grids
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_create_grids (instance)
    class(mci_vamp_instance_t), intent(inout) :: instance
    type (pass_t), pointer :: current
    integer, dimension(:), allocatable :: num_div
    real(default), dimension(:,:), allocatable :: region
    associate (mci => instance%mci)
      current => mci%current_pass
      allocate (num_div (mci%n_dim))
      allocate (region (2, mci%n_dim))
      region(1,:) = 0
      region(2,:) = 1
      num_div = current%n_bins
      instance%n_adapt_grids = 0
      instance%n_adapt_weights = 0
      if (.not. instance%grids_defined) then
         call vamp_create_grids (instance%grids, &
              region, &
              current%n_calls, &
              weights = instance%w, &
              num_div = num_div, &
              stratified = mci%grid_par%stratified)
         instance%grids_defined = .true.
      else
         call msg_bug ("VAMP: create grids: grids already defined")
      end if
    end associate
  end subroutine mci_vamp_instance_create_grids

@ %def mci_vamp_instance_create_grids
@ Reset a grid set, so we can start a fresh integration pass.  In
effect, we delete results of previous integrations, but keep the grid
shapes, weights, and variance arrays, so adaptation is still possible.
The grids are prepared for a specific number of calls (per iteration)
and sampling mode (stratified/importance).

The [[vamp_discard_integrals]] implementation will reshape the grids
only if the argument [[num_calls]] is present.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: discard_integrals => mci_vamp_instance_discard_integrals
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_discard_integrals (instance, reshape)
    class(mci_vamp_instance_t), intent(inout) :: instance
    logical, intent(in) :: reshape
    instance%calls = 0
    instance%integral = 0
    instance%error = 0
    instance%efficiency = 0
    associate (mci => instance%mci)
      if (instance%grids_defined) then
         if (mci%grid_par%use_vamp_equivalences) then
            if (reshape) then
               call vamp_discard_integrals (instance%grids, &
                    num_calls = instance%n_calls, &
                    stratified = mci%grid_par%stratified, &
                    eq = mci%equivalences)
            else
               call vamp_discard_integrals (instance%grids, &
                    stratified = mci%grid_par%stratified, &
                    eq = mci%equivalences)
            end if
         else
            if (reshape) then
               call vamp_discard_integrals (instance%grids, &
                    num_calls = instance%n_calls, &
                    stratified = mci%grid_par%stratified)
            else
               call vamp_discard_integrals (instance%grids, &
                    stratified = mci%grid_par%stratified)
            end if
         end if
      else
         call msg_bug ("VAMP: discard integrals: grids undefined")
      end if
    end associate
  end subroutine mci_vamp_instance_discard_integrals
    
@ %def mci_vamp_instance_discard_integrals
@ After grids are created (with equidistant binning and equal weight),
adaptation is redundant.  Therefore, we should allow it only after a
complete integration step has been performed, calling this.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: allow_adaptation => mci_vamp_instance_allow_adaptation
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_allow_adaptation (instance)
    class(mci_vamp_instance_t), intent(inout) :: instance
    instance%allow_adapt_grids = .true.
    instance%allow_adapt_weights = .true.
  end subroutine mci_vamp_instance_allow_adaptation

@ %def mci_vamp_instance_allow_adaptation
@ Adapt grids.  
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: adapt_grids => mci_vamp_instance_adapt_grids
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_adapt_grids (instance)
    class(mci_vamp_instance_t), intent(inout) :: instance
    if (instance%enable_adapt_grids .and. instance%allow_adapt_grids) then
       if (instance%grids_defined) then
          call vamp_refine_grids (instance%grids)
          instance%n_adapt_grids = instance%n_adapt_grids + 1
      else
         call msg_bug ("VAMP: adapt grids: grids undefined")
      end if
    end if
  end subroutine mci_vamp_instance_adapt_grids
  
@ %def mci_vamp_instance_adapt_grids
@ Adapt weights.  Use the variance array returned by \vamp\ for
recalculating the weight array.  The parameter
[[channel_weights_power]] dampens fluctuations.

If the number of calls in a given channel falls below a user-defined threshold,
the weight is not lowered further but kept at this threshold.  The other
channel weights are reduced accordingly.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: adapt_weights => mci_vamp_instance_adapt_weights
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_adapt_weights (instance)
    class(mci_vamp_instance_t), intent(inout) :: instance
    real(default) :: w_sum, w_avg_ch, sum_w_underflow, w_min
    integer :: n_ch, ch, n_underflow
    logical, dimension(:), allocatable :: mask, underflow
    type(exception) :: vamp_exception
    if (instance%enable_adapt_weights .and. instance%allow_adapt_weights) then
       associate (mci => instance%mci)
         if (instance%grids_defined) then
            instance%w = instance%grids%weights &
                 * vamp_get_variance (instance%grids%grids) &
                 ** mci%grid_par%channel_weights_power
            w_sum = sum (instance%w)
            if (w_sum /= 0) then
               instance%w = instance%w / w_sum
               if (mci%n_chain /= 0) then
                  allocate (mask (mci%n_channel))
                  do ch = 1, mci%n_chain
                     mask = mci%chain == ch
                     n_ch = count (mask)
                     if (n_ch /= 0) then
                        w_avg_ch = sum (instance%w, mask) / n_ch
                        where (mask)  instance%w = w_avg_ch
                     end if
                  end do
               end if
               if (mci%grid_par%threshold_calls /= 0) then
                  w_min = &
                       real (mci%grid_par%threshold_calls, default) &
                       / instance%n_calls
                  allocate (underflow (mci%n_channel))
                  underflow = instance%w /= 0 .and. abs (instance%w) < w_min
                  n_underflow = count (underflow)
                  sum_w_underflow = sum (instance%w, mask=underflow)
                  if (sum_w_underflow /= 1) then
                     where (underflow)
                        instance%w = w_min
                     elsewhere
                        instance%w = instance%w &
                             * (1 - n_underflow * w_min) / (1 - sum_w_underflow)
                     end where
                  end if
               end if
            end if
            call vamp_update_weights (instance%grids, instance%w, &
                 exc = vamp_exception)
            call handle_vamp_exception (vamp_exception, mci%verbose)
         else
            call msg_bug ("VAMP: adapt weights: grids undefined")
         end if
       end associate
       instance%n_adapt_weights = instance%n_adapt_weights + 1
    end if
  end subroutine mci_vamp_instance_adapt_weights
  
@ %def mci_vamp_instance_adapt_weights
@ Integration: sample the VAMP grids.  The number of calls etc. are
already stored inside the grids.  We provide the random-number
generator, the sampling function, and a link to the workspace object,
which happens to contain a pointer to the sampler object.  The sampler
object thus becomes the workspace of the sampling function.

Note: in the current implementation, the random-number generator must
be the TAO generator.  This explicit dependence should be removed from
the VAMP implementation.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: sample_grids => mci_vamp_instance_sample_grids
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_sample_grids (instance, rng, sampler, eq)
    class(mci_vamp_instance_t), intent(inout), target :: instance
    class(rng_t), intent(inout) :: rng
    class(mci_sampler_t), intent(inout), target :: sampler
    type(vamp_equivalences_t), intent(in), optional :: eq
    class(vamp_data_t), allocatable :: data
    type(exception) :: vamp_exception
    allocate (mci_workspace_t :: data)
    select type (data)
    type is (mci_workspace_t)
       data%sampler => sampler
       data%instance => instance
    end select
    select type (rng)
    type is (rng_tao_t)
       instance%it = instance%it + 1
       instance%calls = 0
       if (instance%grids_defined) then
          call vamp_sample_grids ( &
               rng%state, &
               instance%grids, &
               vamp_sampling_function, &
               data, &
               1, &
               eq = eq, &
               history = instance%v_history(instance%it:), &
               histories = instance%v_histories(instance%it:,:), &
               integral = instance%integral, &
               std_dev = instance%error, &
               exc = vamp_exception, &
               negative_weights = instance%negative_weights)
          call handle_vamp_exception (vamp_exception, instance%mci%verbose)
          instance%efficiency = instance%get_efficiency ()
       else
          call msg_bug ("VAMP: sample grids: grids undefined")
       end if
    class default
       call msg_fatal ("VAMP integration: random-number generator must be TAO")
    end select
  end subroutine mci_vamp_instance_sample_grids

@ %def mci_vamp_instance_sample_grids
@ 
Compute the reweighting efficiency for the current grids, suitable
averaged over all active channels.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: get_efficiency_array => mci_vamp_instance_get_efficiency_array
  procedure :: get_efficiency => mci_vamp_instance_get_efficiency
<<MCI vamp: procedures>>=
  function mci_vamp_instance_get_efficiency_array (mci) result (efficiency)
    class(mci_vamp_instance_t), intent(in) :: mci
    real(default), dimension(:), allocatable :: efficiency
    allocate (efficiency (mci%mci%n_channel))
    where (mci%grids%grids%f_max /= 0)
       efficiency = mci%grids%grids%mu(1) / abs (mci%grids%grids%f_max)
    elsewhere
       efficiency = 0
    end where
  end function mci_vamp_instance_get_efficiency_array

  function mci_vamp_instance_get_efficiency (mci) result (efficiency)
    class(mci_vamp_instance_t), intent(in) :: mci
    real(default) :: efficiency
    real(default), dimension(:), allocatable :: weight
    real(default) :: norm
    allocate (weight (mci%mci%n_channel))
    weight = mci%grids%weights * abs (mci%grids%grids%f_max)
    norm = sum (weight)
    if (norm /= 0) then
       efficiency = dot_product (mci%get_efficiency_array (), weight) / norm
    else
       efficiency = 1
    end if
  end function mci_vamp_instance_get_efficiency

@ %def mci_vamp_instance_get_efficiency_array
@ %def mci_vamp_instance_get_efficiency
@ Prepare an event generation pass.  Should be called before a sequence of
events is generated, then we should call the corresponding finalizer.

The pass-specific data of the previous integration pass are retained,
but we reset the number of iterations and calls to zero.  The latter
now counts the number of events (calls to the sampling function, actually).
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: init_simulation => mci_vamp_instance_init_simulation
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_init_simulation (instance, safety_factor)
    class(mci_vamp_instance_t), intent(inout) :: instance
    real(default), intent(in), optional :: safety_factor
    associate (mci => instance%mci)
      allocate (instance%vamp_x (mci%n_dim))
      instance%it = 0
      instance%calls = 0
      instance%generating_events = .true.
      if (present (safety_factor))  instance%safety_factor = safety_factor
      if (.not. instance%grids_defined) then
         if (mci%grid_filename_set) then
            if (.not. mci%check_grid_file) &
                 call msg_warning ("Reading grid file: MD5 sum check disabled")
            call msg_message ("Simulate: " &
                 // "using integration grids from file '" &
                 // char (mci%grid_filename) // "'")
            call mci%read_grids_data (instance)
            if (instance%safety_factor /= 1) then
               write (msg_buffer, "(A,ES10.3,A)")  "Simulate: &
                    &applying safety factor", instance%safety_factor, &
                    " to event rejection"
               call msg_message ()
               instance%grids%grids%f_max = &
                    instance%grids%grids%f_max * instance%safety_factor
            end if
         else
            call msg_bug ("VAMP: simulation: no grids, no grid filename")
         end if
      end if
    end associate
  end subroutine mci_vamp_instance_init_simulation
  
@ %def mci_vamp_init_simulation
@ Finalize an event generation pass.  Should be called before a sequence of
events is generated, then we should call the corresponding finalizer.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: final_simulation => mci_vamp_instance_final_simulation
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_final_simulation (instance)
    class(mci_vamp_instance_t), intent(inout) :: instance
    if (allocated (instance%vamp_x))  deallocate (instance%vamp_x)
  end subroutine mci_vamp_instance_final_simulation
  
@ %def mci_vamp_instance_final_simulation
@
\subsection{Sampling function}
The VAMP sampling function has a well-defined interface which we have
to implement.  The [[data]] argument allows us to pass pointers to the
[[sampler]] and [[instance]] objects, so we can access configuration
data and fill point-dependent contents within these objects.

The [[weights]] and [[channel]] argument must be present in the call.

Note: we would normally declare the [[instance]] pointer with the
concrete type, or just use the [[data]] component directly.
Unfortunately, gfortran 4.6 forgets the inherited base-type methods in
that case.

Note: this is the place where we must look for external signals, i.e.,
interrupt from the OS.  We would like to raise a VAMP exception which is then
caught by [[vamp_sample_grids]] as the caller, so it dumps its current state
and returns (with the signal still pending).  WHIZARD will then terminate
gracefully.  Of course, VAMP should be able to resume from the dump.  

In the current implementation, we handle the exception in place and terminate
immediately.  The incomplete current integration pass is lost.
<<MCI vamp: procedures>>=
  function vamp_sampling_function &
       (xi, data, weights, channel, grids) result (f)
    real(default) :: f
    real(default), dimension(:), intent(in) :: xi
    class(vamp_data_t), intent(in) :: data
    real(default), dimension(:), intent(in), optional :: weights
    integer, intent(in), optional :: channel
    type(vamp_grid), dimension(:), intent(in), optional :: grids
    type(exception) :: exc
    class(mci_instance_t), pointer :: instance
    logical :: verbose
    character(*), parameter :: FN = "WHIZARD sampling function"
    select type (data)
    type is (mci_workspace_t)
       instance => data%instance
       select type (instance)
       class is (mci_vamp_instance_t)
          instance%calls = instance%calls + 1
          verbose = instance%mci%verbose
       end select
       call instance%evaluate (data%sampler, channel, xi)
       if (signal_is_pending ()) then
          call raise_exception (exc, EXC_FATAL, FN, "signal received")
          call handle_vamp_exception (exc, verbose)
          call terminate_now_if_signal ()
       end if
       f = instance%get_value ()
    end select
  end function vamp_sampling_function

@ %def vamp_sampling_function
@ This is supposed to be the mapping between integration channels.
The VAMP event generating procedures technically require it, but it is
meaningless in our setup where all transformations happen inside the
sampler object.  So, this implementation is trivial:
<<MCI vamp: procedures>>=
  pure function phi_trivial (xi, channel_dummy) result (x)
    real(default), dimension(:), intent(in) :: xi
    integer, intent(in) :: channel_dummy
    real(default), dimension(size(xi)) :: x
    x = xi
  end function phi_trivial

@ %def phi_trivial
@
\subsection{Integrator instance: evaluation}
Here, we compute the multi-channel reweighting factor for the current
channel, that accounts for the Jacobians of the transformations
from/to all other channels.

The computation of the VAMP probabilities may consume considerable
time, therefore we enable parallel evaluation. (Collecting the
contributions to [[mci%g]] is a reduction, which we should also
implement via OpenMP.)
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: compute_weight => mci_vamp_instance_compute_weight
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_compute_weight (mci, c)
    class(mci_vamp_instance_t), intent(inout) :: mci
    integer, intent(in) :: c
    integer :: i
    mci%selected_channel = c
    !$OMP PARALLEL PRIVATE(i) SHARED(mci)
    !$OMP DO
    do i = 1, mci%mci%n_channel
       if (mci%w(i) /= 0) then
          mci%gi(i) = vamp_probability (mci%grids%grids(i), mci%x(:,i))
       else
          mci%gi(i) = 0
       end if
    end do
    !$OMP END DO
    !$OMP END PARALLEL
    mci%g = 0
    if (mci%gi(c) /= 0) then
       do i = 1, mci%mci%n_channel
          if (mci%w(i) /= 0 .and. mci%f(i) /= 0) then
             mci%g = mci%g + mci%w(i) * mci%gi(i) / mci%f(i)
          end if
       end do
    end if
    if (mci%g /= 0) then
       mci%mci_weight = mci%gi(c) / mci%g
    else
       mci%mci_weight = 0
    end if
  end subroutine mci_vamp_instance_compute_weight
    
@ %def mci_vamp_instance_compute_weight
@ Record the integrand.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: record_integrand => mci_vamp_instance_record_integrand
<<MCI vamp: procedures>>=
  subroutine mci_vamp_instance_record_integrand (mci, integrand)
    class(mci_vamp_instance_t), intent(inout) :: mci
    real(default), intent(in) :: integrand
    mci%integrand = integrand
  end subroutine mci_vamp_instance_record_integrand
  
@ %def mci_vamp_instance_record_integrand
@ Get the event weight.  The default routine returns the same value that
we would use for integration.  This is correct if we select the integration
channel according to the channel weight.  [[vamp_next_event]] does
differently, so we should rather rely on the weight that VAMP
returns.  This is the value stored in [[vamp_weight]].  We override
the default TBP accordingly.
<<MCI vamp: mci vamp instance: TBP>>=
  procedure :: get_event_weight => mci_vamp_instance_get_event_weight
  procedure :: get_event_excess => mci_vamp_instance_get_event_excess
<<MCI vamp: procedures>>=
  function mci_vamp_instance_get_event_weight (mci) result (value)
    class(mci_vamp_instance_t), intent(in) :: mci
    real(default) :: value
    if (mci%vamp_weight_set) then
       value = mci%vamp_weight
    else
       call msg_bug ("VAMP: attempt to read undefined event weight")
    end if
  end function mci_vamp_instance_get_event_weight
   
  function mci_vamp_instance_get_event_excess (mci) result (value)
    class(mci_vamp_instance_t), intent(in) :: mci
    real(default) :: value
    if (mci%vamp_weight_set) then
       value = mci%vamp_excess
    else
       call msg_bug ("VAMP: attempt to read undefined event excess weight")
    end if
  end function mci_vamp_instance_get_event_excess
   
@ %def mci_vamp_instance_get_event_excess
@
\subsection{VAMP exceptions}
A VAMP routine may have raised an exception.  Turn this into a WHIZARD
error message.

An external signal could raise a fatal exception, but this should be delayed and
handled by the correct termination routine.
<<MCI vamp: procedures>>=
  subroutine handle_vamp_exception (exc, verbose)
    type(exception), intent(in) :: exc
    logical, intent(in) :: verbose
    integer :: exc_level
    if (verbose) then
       exc_level = EXC_INFO
    else
       exc_level = EXC_ERROR
    end if
    if (exc%level >= exc_level) then
       write (msg_buffer, "(A,':',1x,A)")  trim (exc%origin), trim (exc%message)
       select case (exc%level)
       case (EXC_INFO);  call msg_message ()
       case (EXC_WARN);  call msg_warning ()
       case (EXC_ERROR); call msg_error ()
       case (EXC_FATAL)
          if (signal_is_pending ()) then
             call msg_message ()
          else
             call msg_fatal ()
          end if
       end select
    end if
  end subroutine handle_vamp_exception
  
@ %def handle_vamp_exception
@
\subsection{Unit tests}
<<MCI vamp: public>>=
  public :: mci_vamp_test
<<MCI vamp: tests>>=
  subroutine mci_vamp_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<MCI vamp: execute tests>>
  end subroutine mci_vamp_test
  
@ %def mci_vamp_test
@
\subsubsection{Test sampler}
A test sampler object should implement a function with known integral that
we can use to check the integrator.

In mode [[1]], the function is $f(x) = 3 x^2$ with integral $\int_0^1
f(x)\,dx=1$ and maximum $f(1)=3$.  If the integration dimension is
greater than one, the function is extended as a constant in the other
dimension(s).

In mode [[2]], the function is $11 x^{10}$, also with integral $1$.
<<MCI vamp: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_1_t
     real(default), dimension(:), allocatable :: x
     real(default) :: val
     integer :: mode = 1
   contains
   <<MCI vamp: test sampler 1: TBP>>
  end type test_sampler_1_t

@ %def test_sampler_1_t
@ Output: There is nothing stored inside, so just print an informative line.
<<MCI vamp: test sampler 1: TBP>>=
  procedure :: write => test_sampler_1_write
<<MCI vamp: tests>>=
  subroutine test_sampler_1_write (object, unit, testflag)
    class(test_sampler_1_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    select case (object%mode)
    case (1)
       write (u, "(1x,A)") "Test sampler: f(x) = 3 x^2"
    case (2)
       write (u, "(1x,A)") "Test sampler: f(x) = 11 x^10"
    case (3)
       write (u, "(1x,A)") "Test sampler: f(x) = 11 x^10 * 2 * cos^2 (2 pi y)"
    end select
  end subroutine test_sampler_1_write
  
@ %def test_sampler_1_write
@ Evaluation: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI vamp: test sampler 1: TBP>>=
  procedure :: evaluate => test_sampler_1_evaluate
<<MCI vamp: tests>>=
  subroutine test_sampler_1_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_1_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    if (allocated (sampler%x))  deallocate (sampler%x)
    allocate (sampler%x (size (x_in)))
    sampler%x = x_in
    select case (sampler%mode)
    case (1)
       sampler%val = 3 * x_in(1) ** 2
    case (2)
       sampler%val = 11 * x_in(1) ** 10
    case (3)
       sampler%val = 11 * x_in(1) ** 10 * 2 * cos (twopi * x_in(2)) ** 2
    end select
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_1_evaluate

@ %def test_sampler_1_evaluate
@ The point is always valid.
<<MCI vamp: test sampler 1: TBP>>=
  procedure :: is_valid => test_sampler_1_is_valid
<<MCI vamp: tests>>=
  function test_sampler_1_is_valid (sampler) result (valid)
    class(test_sampler_1_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_1_is_valid
  
@ %def test_sampler_1_is_valid
@ Rebuild: compute all but the function value.
<<MCI vamp: test sampler 1: TBP>>=
  procedure :: rebuild => test_sampler_1_rebuild
<<MCI vamp: tests>>=
  subroutine test_sampler_1_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_1_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    if (allocated (sampler%x))  deallocate (sampler%x)
    allocate (sampler%x (size (x_in)))
    sampler%x = x_in
    sampler%val = val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_1_rebuild

@ %def test_sampler_1_rebuild
@ Extract the results.
<<MCI vamp: test sampler 1: TBP>>=
  procedure :: fetch => test_sampler_1_fetch
<<MCI vamp: tests>>=
  subroutine test_sampler_1_fetch (sampler, val, x, f)
    class(test_sampler_1_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x(:,1) = sampler%x
    f = 1
  end subroutine test_sampler_1_fetch
    
@ %def test_sampler_1_fetch
@
\subsubsection{Two-channel, two dimension test sampler}
This sampler implements the function
\begin{equation}
  f(x, y) = 4\sin^2(\pi x)\sin^2(\pi y) + 2\sin^2(\pi v)
\end{equation}
where
\begin{align}
  x &= u^v        &u &= xy
\\
  y &= u^{(1-v)}  &v &= \frac12\left(1 + \frac{\log(x/y)}{\log xy}\right)
\end{align}
Each term contributes $1$ to the integral.  The first term in the function is
peaked along a cross aligned to the coordinates $x$ and $y$, while the second
term is peaked along the diagonal $x=y$.

The Jacobian is
\begin{equation}
  \frac{\partial(x,y)}{\partial(u,v)} = |\log u|
\end{equation}
<<MCI vamp: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_2_t
     real(default), dimension(:,:), allocatable :: x
     real(default), dimension(:), allocatable :: f
     real(default) :: val
   contains
   <<MCI vamp: test sampler 2: TBP>>
  end type test_sampler_2_t

@ %def test_sampler_2_t
@ Output: There is nothing stored inside, so just print an informative line.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: write => test_sampler_2_write
<<MCI vamp: tests>>=
  subroutine test_sampler_2_write (object, unit, testflag)
    class(test_sampler_2_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Two-channel test sampler 2"
  end subroutine test_sampler_2_write
  
@ %def test_sampler_2_write
@ Kinematics: compute $x$ and Jacobians, given the input parameter array.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: compute => test_sampler_2_compute
<<MCI vamp: tests>>=
  subroutine test_sampler_2_compute (sampler, c, x_in)
    class(test_sampler_2_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default) :: xx, yy, uu, vv
    if (.not. allocated (sampler%x)) &
         allocate (sampler%x (size (x_in), 2))
    if (.not. allocated (sampler%f)) &
         allocate (sampler%f (2))
    select case (c)
    case (1)
       xx = x_in(1)
       yy = x_in(2)
       uu = xx * yy
       vv = (1 + log (xx/yy) / log (xx*yy)) / 2
    case (2)
       uu = x_in(1)
       vv = x_in(2)
       xx = uu ** vv
       yy = uu ** (1 - vv)
    end select
    sampler%val = (2 * sin (pi * xx) * sin (pi * yy)) ** 2 &
         + 2 * sin (pi * vv) ** 2
    sampler%f(1) = 1
    sampler%f(2) = abs (log (uu))
    sampler%x(:,1) = [xx, yy]
    sampler%x(:,2) = [uu, vv]
  end subroutine test_sampler_2_compute

@ %def test_sampler_kineamtics
@ Evaluation: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: evaluate => test_sampler_2_evaluate
<<MCI vamp: tests>>=
  subroutine test_sampler_2_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_2_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%compute (c, x_in)
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_2_evaluate

@ %def test_sampler_2_evaluate
@ The point is always valid.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: is_valid => test_sampler_2_is_valid
<<MCI vamp: tests>>=
  function test_sampler_2_is_valid (sampler) result (valid)
    class(test_sampler_2_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_2_is_valid
  
@ %def test_sampler_2_is_valid
@ Rebuild: compute all but the function value.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: rebuild => test_sampler_2_rebuild
<<MCI vamp: tests>>=
  subroutine test_sampler_2_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_2_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%compute (c, x_in)
    x = sampler%x
    f = sampler%f
  end subroutine test_sampler_2_rebuild

@ %def test_sampler_2_rebuild
@ Extract the results.
<<MCI vamp: test sampler 2: TBP>>=
  procedure :: fetch => test_sampler_2_fetch
<<MCI vamp: tests>>=
  subroutine test_sampler_2_fetch (sampler, val, x, f)
    class(test_sampler_2_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x = sampler%x
    f = sampler%f
  end subroutine test_sampler_2_fetch
    
@ %def test_sampler_2_fetch
@
\subsubsection{Two-channel, one dimension test sampler}
This sampler implements the function
\begin{equation}
  f(x, y) = a * 5 x^4 + b * 5 (1-x)^4
\end{equation}
Each term contributes $1$ to the integral, multiplied by $a$ or $b$,
respectively.  The first term is peaked at $x=1$, the second one at $x=0$..

We implement the two mappings
\begin{equation}
  x = u^{1/5} \quad\text{and}\quad x = 1 - v^{1/5},
\end{equation}
with Jacobians
\begin{equation}
  \frac{\partial(x)}{\partial(u)} = u^{-4/5}/5 \quad\text{and}\quad v^{-4/5}/5,
\end{equation}
respectively.  The first mapping concentrates points near $x=1$, the
second one near $x=0$.
<<MCI vamp: test types>>=
  type, extends (mci_sampler_t) :: test_sampler_3_t
     real(default), dimension(:,:), allocatable :: x
     real(default), dimension(:), allocatable :: f
     real(default) :: val
     real(default) :: a = 1
     real(default) :: b = 1
   contains
   <<MCI vamp: test sampler 3: TBP>>
  end type test_sampler_3_t

@ %def test_sampler_3_t
@ Output: display $a$ and $b$
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: write => test_sampler_3_write
<<MCI vamp: tests>>=
  subroutine test_sampler_3_write (object, unit, testflag)
    class(test_sampler_3_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") "Two-channel test sampler 3"
    write (u, "(3x,A,F5.2)")  "a = ", object%a
    write (u, "(3x,A,F5.2)")  "b = ", object%b
  end subroutine test_sampler_3_write
  
@ %def test_sampler_3_write
@ Kinematics: compute $x$ and Jacobians, given the input parameter array.
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: compute => test_sampler_3_compute
<<MCI vamp: tests>>=
  subroutine test_sampler_3_compute (sampler, c, x_in)
    class(test_sampler_3_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default) :: u, v, xx
    if (.not. allocated (sampler%x)) &
         allocate (sampler%x (size (x_in), 2))
    if (.not. allocated (sampler%f)) &
         allocate (sampler%f (2))
    select case (c)
    case (1)
       u = x_in(1)
       xx = u ** 0.2_default
       v = (1 - xx) ** 5._default
    case (2)
       v = x_in(1)
       xx = 1 - v ** 0.2_default
       u = xx ** 5._default
    end select
    sampler%val = sampler%a * 5 * xx ** 4 + sampler%b * 5 * (1 - xx) ** 4
    sampler%f(1) = 0.2_default * u ** (-0.8_default)
    sampler%f(2) = 0.2_default * v ** (-0.8_default)
    sampler%x(:,1) = [u]
    sampler%x(:,2) = [v]
  end subroutine test_sampler_3_compute

@ %def test_sampler_kineamtics
@ Evaluation: compute the function value.  The output $x$ parameter
(only one channel) is identical to the input $x$, and the Jacobian is 1.
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: evaluate => test_sampler_3_evaluate
<<MCI vamp: tests>>=
  subroutine test_sampler_3_evaluate (sampler, c, x_in, val, x, f)
    class(test_sampler_3_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%compute (c, x_in)
    call sampler%fetch (val, x, f)
  end subroutine test_sampler_3_evaluate

@ %def test_sampler_3_evaluate
@ The point is always valid.
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: is_valid => test_sampler_3_is_valid
<<MCI vamp: tests>>=
  function test_sampler_3_is_valid (sampler) result (valid)
    class(test_sampler_3_t), intent(in) :: sampler
    logical :: valid
    valid = .true.
  end function test_sampler_3_is_valid
  
@ %def test_sampler_3_is_valid
@ Rebuild: compute all but the function value.
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: rebuild => test_sampler_3_rebuild
<<MCI vamp: tests>>=
  subroutine test_sampler_3_rebuild (sampler, c, x_in, val, x, f)
    class(test_sampler_3_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%compute (c, x_in)
    x = sampler%x
    f = sampler%f
  end subroutine test_sampler_3_rebuild

@ %def test_sampler_3_rebuild
@ Extract the results.
<<MCI vamp: test sampler 3: TBP>>=
  procedure :: fetch => test_sampler_3_fetch
<<MCI vamp: tests>>=
  subroutine test_sampler_3_fetch (sampler, val, x, f)
    class(test_sampler_3_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    val = sampler%val
    x = sampler%x
    f = sampler%f
  end subroutine test_sampler_3_fetch
    
@ %def test_sampler_3_fetch
@
\subsubsection{One-dimensional integration}
Construct an integrator and use it for a one-dimensional sampler.

Note: We would like to check the precise contents of the grid
allocated during integration, but the output format for reals is very
long (for good reasons), so the last digits in the grid content
display are numerical noise.  So, we just check the integration
results.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_1, "mci_vamp_1", &
       "one-dimensional integral", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_1 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_1"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(single channel)"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 1)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize instance"
    write (u, "(A)")
    
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Initialize test sampler"
    write (u, "(A)")
    
    allocate (test_sampler_1_t :: sampler)
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_calls = 1000"
    write (u, "(A)")  "   (lower precision to avoid"
    write (u, "(A)")  "      numerical noise)"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass ()
    end select
    call mci%integrate (mci_instance, sampler, 1, 1000, pacify = .true.)
    call mci%write (u, .true.)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u, .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_1"

  end subroutine mci_vamp_1

@ %def mci_vamp_1
@
\subsubsection{Multiple iterations}
Construct an integrator and use it for a one-dimensional sampler.
Integrate with five iterations without grid adaptation.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_2, "mci_vamp_2", &
       "multiple iterations", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_2 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_2"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(single channel)" 
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 1)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_1_t :: sampler)
    select type (sampler)
    type is (test_sampler_1_t)
       sampler%mode = 2
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 100"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .false.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 100)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_2"

  end subroutine mci_vamp_2

@ %def mci_vamp_2
@
\subsubsection{Grid adaptation}
Construct an integrator and use it for a one-dimensional sampler.
Integrate with three iterations and in-between grid adaptations.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_3, "mci_vamp_3", &
       "grid adaptation", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_3 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_3"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(single channel)" 
    write (u, "(A)")  "*            and adapt grid"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 1)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_1_t :: sampler)
    select type (sampler)
    type is (test_sampler_1_t)
       sampler%mode = 2
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 100"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 100)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_3"

  end subroutine mci_vamp_3

@ %def mci_vamp_3
@
\subsubsection{Two-dimensional integral}
Construct an integrator and use it for a two-dimensional sampler.
Integrate with three iterations and in-between grid adaptations.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_4, "mci_vamp_4", &
       "two-dimensional integration", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_4 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_4"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions &
         &(single channel)" 
    write (u, "(A)")  "*            and adapt grid"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 1)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_1_t :: sampler)
    select type (sampler)
    type is (test_sampler_1_t)
       sampler%mode = 3
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_4"

  end subroutine mci_vamp_4

@ %def mci_vamp_4
@
\subsubsection{Two-channel integral}
Construct an integrator and use it for a two-dimensional sampler with two
channels.

Integrate with three iterations and in-between grid adaptations.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_5, "mci_vamp_5", &
       "two-dimensional integration", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_5 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_5"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions &
         &(two channels)" 
    write (u, "(A)")  "*            and adapt grid"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_2_t :: sampler)
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_5"

  end subroutine mci_vamp_5

@ %def mci_vamp_5
@
\subsubsection{Weight adaptation}
Construct an integrator and use it for a one-dimensional sampler with two
channels.

Integrate with three iterations and in-between weight adaptations.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_6, "mci_vamp_6", &
       "weight adaptation", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_6 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_6"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(two channels)" 
    write (u, "(A)")  "*            and adapt weights"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_3_t :: sampler)
    select type (sampler)
    type is (test_sampler_3_t)
       sampler%a = 0.9_default
       sampler%b = 0.1_default
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_weights = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()
    deallocate (mci_instance)
    deallocate (mci)

    write (u, "(A)")
    write (u, "(A)")  "* Re-initialize with chained channels"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    call mci%declare_chains ([1,1])
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_weights = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_6"

  end subroutine mci_vamp_6

@ %def mci_vamp_6
@
\subsubsection{Equivalences}
Construct an integrator and use it for a one-dimensional sampler with two
channels.

Integrate with three iterations and in-between grid adaptations.
Apply an equivalence between the two channels, so the binning of the
two channels is forced to coincide.  Compare this with the behavior
without equivalences.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_7, "mci_vamp_7", &
       "use channel equivalences", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_7 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    type(phs_channel_t), dimension(:), allocatable :: channel
    class(rng_t), allocatable :: rng
    real(default), dimension(:,:), allocatable :: x
    integer :: u_grid, iostat, i, div, ch
    character(16) :: buffer
    
    write (u, "(A)")  "* Test output: mci_vamp_7"
    write (u, "(A)")  "*   Purpose: check effect of channel equivalences"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_3_t :: sampler)
    select type (sampler)
    type is (test_sampler_3_t)
       sampler%a = 0.7_default
       sampler%b = 0.3_default
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 2 and n_calls = 1000, &
         &adapt grids"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 2, 1000)

    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)") "* Write grids and extract binning"
    write (u, "(A)")

    u_grid = free_unit ()
    open (u_grid, status = "scratch", action = "readwrite")
    select type (mci_instance)
    type is (mci_vamp_instance_t)
       call vamp_write_grids (mci_instance%grids, u_grid)
    end select
    rewind (u_grid)
    allocate (x (0:20, 2))
    do div = 1, 2
       FIND_BINS1: do
          read (u_grid, "(A)")  buffer
          if (trim (adjustl (buffer)) == "begin d%x") then
             do
                read (u_grid, *, iostat = iostat)  i, x(i,div)
                if (iostat /= 0)  exit FIND_BINS1
             end do
          end if
       end do FIND_BINS1
    end do
    close (u_grid)

    write (u, "(1x,A,L1)")  "Equal binning in both channels = ", &
         all (x(:,1) == x(:,2))
    deallocate (x)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()
    deallocate (mci_instance)
    deallocate (mci)

    write (u, "(A)")
    write (u, "(A)")  "* Re-initialize integrator, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .true.
       call mci%set_grid_parameters (grid_par)
    end select
    
    write (u, "(A)")  "* Define equivalences"
    write (u, "(A)")

    allocate (channel (2))
    do ch = 1, 2
       allocate (channel(ch)%eq (2))
       do i = 1, 2
          associate (eq => channel(ch)%eq(i))
            call eq%init (1)
            eq%c = i
            eq%perm = [1]
            eq%mode = [0]
          end associate
       end do
       write (u, "(1x,I0,':')", advance = "no")  ch
       call channel(ch)%write (u)
    end do
    call mci%declare_equivalences (channel, dim_offset = 0)

    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 2 and n_calls = 1000, &
         &adapt grids"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 2, 1000)
 
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)") "* Write grids and extract binning"
    write (u, "(A)")

    u_grid = free_unit ()
    open (u_grid, status = "scratch", action = "readwrite")
    select type (mci_instance)
    type is (mci_vamp_instance_t)
       call vamp_write_grids (mci_instance%grids, u_grid)
    end select
    rewind (u_grid)
    allocate (x (0:20, 2))
    do div = 1, 2
       FIND_BINS2: do
          read (u_grid, "(A)")  buffer
          if (trim (adjustl (buffer)) == "begin d%x") then
             do
                read (u_grid, *, iostat = iostat)  i, x(i,div)
                if (iostat /= 0)  exit FIND_BINS2
             end do
          end if
       end do FIND_BINS2
    end do
    close (u_grid)

    write (u, "(1x,A,L1)")  "Equal binning in both channels = ", &
         all (x(:,1) == x(:,2))
    deallocate (x)
    

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_7"

  end subroutine mci_vamp_7

@ %def mci_vamp_7
@
\subsubsection{Multiple passes}
Integrate with three passes and different settings for weight and grid
adaptation.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_8, "mci_vamp_8", &
       "integration passes", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_8 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_8"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(two channels)" 
    write (u, "(A)")  "*            in three passes"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_3_t :: sampler)
    select type (sampler)
    type is (test_sampler_3_t)
       sampler%a = 0.9_default
       sampler%b = 0.1_default
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with grid and weight adaptation"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true., adapt_weights = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate with grid adaptation"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Integrate without adaptation"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass ()
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Contents of mci_instance:"
    write (u, "(A)")
    
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_8"

  end subroutine mci_vamp_8

@ %def mci_vamp_8
@
\subsubsection{Weighted events}
Construct an integrator and use it for a two-dimensional sampler with two
channels.  Integrate and generate a weighted event.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_9, "mci_vamp_9", &
       "weighted event", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_9 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_9"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions &
         &(two channels)" 
    write (u, "(A)")  "*            and generate a weighted event"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_2_t :: sampler)
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    call mci%add_pass ()
    call mci%integrate (mci_instance, sampler, 1, 1000)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Generate a weighted event"
    write (u, "(A)")

    call mci_instance%init_simulation ()
    call mci%generate_weighted_event (mci_instance, sampler)

    write (u, "(1x,A)")  "MCI instance:"
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final_simulation ()
    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_9"

  end subroutine mci_vamp_9

@ %def mci_vamp_9
@
\subsubsection{Grids I/O}
Construct an integrator and allocate grids.  Write grids to file, read
them in again and compare.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_10, "mci_vamp_10", &
       "grids I/O", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_10 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    type(string_t) :: file1, file2
    character(80) :: buffer1, buffer2
    integer :: u1, u2, iostat1, iostat2
    logical :: equal, success
   
    write (u, "(A)")  "* Test output: mci_vamp_10"
    write (u, "(A)")  "*   Purpose: write and read VAMP grids"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    mci%md5sum = "1234567890abcdef1234567890abcdef"

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_2_t :: sampler)
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    call mci%add_pass ()
    call mci%integrate (mci_instance, sampler, 1, 1000)
 
    write (u, "(A)")  "* Write grids to file"
    write (u, "(A)")
 
    file1 = "mci_vamp_10.1"
    select type (mci)
    type is (mci_vamp_t)
       call mci%set_grid_filename (file1)
       call mci%write_grids (mci_instance)
    end select

    call mci_instance%final ()
    call mci%final ()
    deallocate (mci)
    
    write (u, "(A)")  "* Read grids from file"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    mci%md5sum = "1234567890abcdef1234567890abcdef"

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)

    select type (mci)
    type is (mci_vamp_t)
       call mci%set_grid_filename (file1)
       call mci%add_pass ()
       call mci%current_pass%configure (1, 1000, &
            mci%min_calls, &
            mci%grid_par%min_bins, mci%grid_par%max_bins, &
            mci%grid_par%min_calls_per_channel * mci%n_channel)
       call mci%read_grids_header (success)
       call mci%compute_md5sum ()
       call mci%read_grids_data (mci_instance, read_integrals = .true.)
    end select
    write (u, "(1x,A,L1)")  "success = ", success
    
    write (u, "(A)")
    write (u, "(A)")  "* Write grids again"
    write (u, "(A)")

    file2 = "mci_vamp_10.2"
    select type (mci)
    type is (mci_vamp_t)
       call mci%set_grid_filename (file2)
       call mci%write_grids (mci_instance)
    end select

    u1 = free_unit ()
    open (u1, file = char (file1) // ".vg", action = "read", status = "old")
    u2 = free_unit ()
    open (u2, file = char (file2) // ".vg", action = "read", status = "old")

    equal = .true.
    iostat1 = 0
    iostat2 = 0
    do while (equal .and. iostat1 == 0 .and. iostat2 == 0)
       read (u1, "(A)", iostat = iostat1)  buffer1
       read (u2, "(A)", iostat = iostat2)  buffer2
       equal = buffer1 == buffer2 .and. iostat1 == iostat2
    end do
    close (u1)
    close (u2)
    
    if (equal) then
       write (u, "(1x,A)")  "Success: grid files are identical"
    else
       write (u, "(1x,A)")  "Failure: grid files differ"
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_10"

  end subroutine mci_vamp_10

@ %def mci_vamp_10
@
\subsubsection{Weighted events}
Construct an integrator and use it for a two-dimensional sampler with two
channels.  Integrate, write grids, and generate a weighted event using
the grids from file.
<<MCI vamp: execute tests>>=
 call test (mci_vamp_11, "mci_vamp_11", &
      "weighted events with grid I/O", &
      u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_11 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_11"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions &
         &(two channels)" 
    write (u, "(A)")  "*            and generate a weighted event"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
       call mci%set_grid_filename (var_str ("mci_vamp_11"))
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_2_t :: sampler)

    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    call mci%add_pass ()
    call mci%integrate (mci_instance, sampler, 1, 1000)
 
    write (u, "(A)")  "* Reset instance"
    write (u, "(A)")

    call mci_instance%final ()
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)

    write (u, "(A)")  "* Generate a weighted event"
    write (u, "(A)")

    call mci_instance%init_simulation ()
    call mci%generate_weighted_event (mci_instance, sampler)

    write (u, "(A)")  "* Cleanup"

    call mci_instance%final_simulation ()
    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_11"

  end subroutine mci_vamp_11

@ %def mci_vamp_11
@
\subsubsection{Weighted events}
Construct an integrator and use it for a two-dimensional sampler with two
channels.  Integrate, write grids, and generate a weighted event using
the grids from file.
<<MCI vamp: execute tests>>=
 call test (mci_vamp_12, "mci_vamp_12", &
      "unweighted events with grid I/O", &
      u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_12 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_12"
    write (u, "(A)")  "*   Purpose: integrate function in two dimensions &
         &(two channels)" 
    write (u, "(A)")  "*            and generate an unweighted event"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
       call mci%set_grid_filename (var_str ("mci_vamp_12"))
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_2_t :: sampler)

    write (u, "(A)")  "* Integrate with n_it = 3 and n_calls = 1000"
    write (u, "(A)")
    
    call mci%add_pass ()
    call mci%integrate (mci_instance, sampler, 1, 1000)
 
    write (u, "(A)")  "* Reset instance"
    write (u, "(A)")

    call mci_instance%final ()
    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)

    write (u, "(A)")  "* Generate an unweighted event"
    write (u, "(A)")

    call mci_instance%init_simulation ()
    call mci%generate_unweighted_event (mci_instance, sampler)

    write (u, "(1x,A)")  "MCI instance:"
    call mci_instance%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final_simulation ()
    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_12"

  end subroutine mci_vamp_12

@ %def mci_vamp_12
@
\subsubsection{Update integration results}
Compare two [[mci]] objects; match the two and update the first if
successful.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_13, "mci_vamp_13", &
       "updating integration results", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_13 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci, mci_ref
    logical :: success
    
    write (u, "(A)")  "* Test output: mci_vamp_13"
    write (u, "(A)")  "*   Purpose: match and update integrators"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator with no passes"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (2, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
    end select
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize reference"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci_ref)
    call mci_ref%set_dimensions (2, 2)
    select type (mci_ref)
    type is (mci_vamp_t)
       call mci_ref%set_grid_parameters (grid_par)
    end select
    
    select type (mci_ref)
    type is (mci_vamp_t)
       call mci_ref%add_pass (adapt_grids = .true.)
       call mci_ref%current_pass%configure (2, 1000, 0, 1, 5, 0)
       mci_ref%current_pass%calls = [77, 77]
       mci_ref%current_pass%integral = [1.23_default, 3.45_default]
       mci_ref%current_pass%error = [0.23_default, 0.45_default]
       mci_ref%current_pass%efficiency = [0.1_default, 0.6_default]
       mci_ref%current_pass%integral_defined = .true.

       call mci_ref%add_pass ()
       call mci_ref%current_pass%configure (2, 2000, 0, 1, 7, 0)
       mci_ref%current_pass%calls = [99, 0]
       mci_ref%current_pass%integral = [7.89_default, 0._default]
       mci_ref%current_pass%error = [0.89_default, 0._default]
       mci_ref%current_pass%efficiency = [0.86_default, 0._default]
       mci_ref%current_pass%integral_defined = .true.
    end select

    call mci_ref%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Update integrator (no-op, should succeed)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Add pass to integrator"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
       call mci%current_pass%configure (2, 1000, 0, 1, 5, 0)
       mci%current_pass%calls = [77, 77]
       mci%current_pass%integral = [1.23_default, 3.45_default]
       mci%current_pass%error = [0.23_default, 0.45_default]
       mci%current_pass%efficiency = [0.1_default, 0.6_default]
       mci%current_pass%integral_defined = .true.
    end select

    write (u, "(A)")  "* Update integrator (no-op, should succeed)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Add pass to integrator, wrong parameters"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass ()
       call mci%current_pass%configure (2, 1000, 0, 1, 7, 0)
    end select

    write (u, "(A)")  "* Update integrator (should fail)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset and add passes to integrator"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%reset ()
       call mci%add_pass (adapt_grids = .true.)
       call mci%current_pass%configure (2, 1000, 0, 1, 5, 0)
       mci%current_pass%calls = [77, 77]
       mci%current_pass%integral = [1.23_default, 3.45_default]
       mci%current_pass%error = [0.23_default, 0.45_default]
       mci%current_pass%efficiency = [0.1_default, 0.6_default]
       mci%current_pass%integral_defined = .true.
       
       call mci%add_pass ()
       call mci%current_pass%configure (2, 2000, 0, 1, 7, 0)
    end select

    write (u, "(A)")  "* Update integrator (should succeed)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Update again (no-op, should succeed)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Add extra result to integrator"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       mci%current_pass%calls(2) = 1234
    end select

    write (u, "(A)")  "* Update integrator (should fail)"
    write (u, "(A)")

    select type (mci)
    type is (mci_vamp_t)
       call mci%update_from_ref (mci_ref, success)
    end select

    write (u, "(1x,A,L1)")  "success = ", success
    write (u, "(A)")
    call mci%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci%final ()
    call mci_ref%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_13"

  end subroutine mci_vamp_13

@ %def mci_vamp_13
@
\subsubsection{Accuracy Goal}
Integrate with multiple iterations.  Skip iterations once an accuracy goal has
been reached.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_14, "mci_vamp_14", &
       "accuracy goal", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_14 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_14"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(single channel)" 
    write (u, "(A)")  "*            and check accuracy goal"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 1)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%use_vamp_equivalences = .false.
       grid_par%accuracy_goal = 5E-2_default
       call mci%set_grid_parameters (grid_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_1_t :: sampler)
    select type (sampler)
    type is (test_sampler_1_t)
       sampler%mode = 2
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integrate with n_it = 5 and n_calls = 100"
    write (u, "(A)")
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 5, 100)
    call mci%write (u)
 
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_14"

  end subroutine mci_vamp_14

@ %def mci_vamp_14
@
\subsubsection{VAMP history}
Integrate with three passes and different settings for weight and grid
adaptation.  Then show the VAMP history.
<<MCI vamp: execute tests>>=
  call test (mci_vamp_15, "mci_vamp_15", &
       "VAMP history", &
       u, results)
<<MCI vamp: tests>>=
  subroutine mci_vamp_15 (u)
    integer, intent(in) :: u
    type(grid_parameters_t) :: grid_par
    type(history_parameters_t) :: history_par
    class(mci_t), allocatable, target :: mci
    class(mci_instance_t), pointer :: mci_instance => null ()
    class(mci_sampler_t), allocatable :: sampler
    class(rng_t), allocatable :: rng
    
    write (u, "(A)")  "* Test output: mci_vamp_15"
    write (u, "(A)")  "*   Purpose: integrate function in one dimension &
         &(two channels)" 
    write (u, "(A)")  "*            in three passes, show history"
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize integrator, sampler, instance"
    write (u, "(A)")

    history_par%channel = .true.

    allocate (mci_vamp_t :: mci)
    call mci%set_dimensions (1, 2)
    select type (mci)
    type is (mci_vamp_t)
       grid_par%stratified = .false.
       grid_par%use_vamp_equivalences = .false.
       call mci%set_grid_parameters (grid_par)
       call mci%set_history_parameters (history_par)
    end select
    
    allocate (rng_tao_t :: rng)
    call rng%init ()
    call mci%import_rng (rng)

    call mci%allocate_instance (mci_instance)
    call mci_instance%init (mci)
    
    allocate (test_sampler_3_t :: sampler)
    select type (sampler)
    type is (test_sampler_3_t)
       sampler%a = 0.9_default
       sampler%b = 0.1_default
    end select
    call sampler%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Pass 1: grid and weight adaptation"
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true., adapt_weights = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
 
    write (u, "(A)")
    write (u, "(A)")  "* Pass 2: grid adaptation"
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass (adapt_grids = .true.)
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)
 
    write (u, "(A)")
    write (u, "(A)")  "* Pass 3: without adaptation"
    
    select type (mci)
    type is (mci_vamp_t)
       call mci%add_pass ()
    end select
    call mci%integrate (mci_instance, sampler, 3, 1000)

    write (u, "(A)")
    write (u, "(A)")  "* Contents of MCI record, with history"
    write (u, "(A)")
    
    call mci%write (u)
    select type (mci)
    type is (mci_vamp_t)
       call mci%write_history (u)
    end select
 
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call mci_instance%final ()
    call mci%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: mci_vamp_15"

  end subroutine mci_vamp_15

@ %def mci_vamp_15
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Process Libraries}

This chapter consists of two modules which organize and interface the
interaction matrix elements for a variety of elementary processes.

\begin{description}
\item[prclib\_interfaces]
  This module deals with matrix-element code which is accessible via
  external libraries (Fortran libraries or generic C-compatible
  libraries) and must either be generated by the program or provided
  by the user explicitly.

  The module defines and uses an abstract type [[prc_writer_t]] and two
  abstract extensions, one for a Fortran module and one for a C-compatible
  library.   The implementation provides the specific methods for writing the  
  appropriate parts in external matrix element code.
\item[prc\_core\_def]
  This module defines the abstract types [[prc_core_def_t]] and
  [[prc_driver_t]].  The implementation of the former provides the
  configuration for processes of a certain class, while the latter accesses
  the corresponding matrix element, in particular those generated by the
  appropriate [[prc_writer_t]] object.
\item[process\_libraries] This module combines the functionality of
  the previous module with the means for holding processes definitions
  (the internal counterpart of appropriate declarations in the user
  interface), for handling matrix elements which do not need external
  code, and for accessing the matrix elements by the procedures for
  matrix-element evaluation, integration and event generation.
\item[test\_me] This module provides a test implementation for the abstract
  types in the [[prc_core_def]] module.  The implementation is intended for
  self-tests of several later modules.  The implementation is internal, i.e.,
  no external code has is generated.
\end{description}


@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integration and Process Objects}

This is the central part of the \whizard\ package.  It provides the
functionality for evaluating structure functions, kinematics and matrix
elements, integration and event generation.  It combines the various
parts that deal with those tasks individually and organizes the data transfer
between them.
\begin{description}
\item[prc\_core]
  Here, we define the abstract [[prc_core_t]] type which handles all specific
  features of kinematics matrix-element evaluation that depend on a particular
  class of processes.
\item[parton\_states]
  A [[parton_state_t]] object represents an elementary partonic
  interaction.  There are two versions: one for the isolated
  elementary process, one for the elementary process convoluted with
  the structure-function chain.  The parton state is an effective
  state.  It needs not coincide with the seed-kinematics state which is
  used in evaluating phase space.
\item[processes]
  Here, all pieces are combined for the purpose of evaluating the
  elementary processes.  The whole algorithm is coded in terms of
  abstract data types as defined in the appropriate modules: [[prc_core]]
  for matrix-element evaluation, [[prc_core_def]] for the associated
  configuration and driver, [[sf_base]] for beams and structure-functions,
  [[phs_base]] for phase space, and [[mci_base]] for integration and event
  generation.
\item[process\_stacks]
  Process stacks collect process objects.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract process core}
In this module we provide abstract data types for process classes.  Each
process class represents a set of processes which are handled by a common
``method'', e.g., by the \oMega\ matrix-element generator.  The process class
is also able to select a particular implementation for the phase-space and
integration modules.

For a complete implementation of a process class, we have to
provide extensions of the following abstract types:
\begin{description}
\item[prc\_core\_def\_t] process and matrix-element configuration
\item[prc\_writer\_t] (optional) writing external matrix-element code
\item[prc\_driver\_t] accessing the matrix element (internal or external)
\item[prc\_core\_t] evaluating kinematics and matrix element.  The process
  core also selects phase-space and integrator implementations as appropriate
  for the process class and configuration.
\end{description}

In the actual process-handling data structures, each process component
contains an instance of such a process class as its core.  This allows us to
keep the [[processes]] module below, which supervises matrix-element
evaluation, integration, and event generation, free of any reference to
concrete implementations (for the process class, phase space, and
integrator).

There are no unit tests, these are deferred to the [[processes]] module.
<<[[prc_core.f90]]>>=
<<File header>>
module prc_core
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use diagnostics
  use lorentz
  use interactions

  use sf_base
  use process_constants
  use mci_base

  use prc_core_def
  use process_libraries

<<Standard module head>>

<<Prc core: public>>

<<Prc core: types>>

<<Prc core: interfaces>>

contains

<<Prc core: procedures>>

end module prc_core
@ %def prc_core
@
\subsection{The process core}
The process core is of abstract data type.  Different types of matrix
element will be represented by different implementations.
<<Prc core: public>>=
  public :: prc_core_t
<<Prc core: types>>=
  type, abstract :: prc_core_t
     class(prc_core_def_t), pointer :: def => null ()
     logical :: data_known = .false.
     type(process_constants_t) :: data
     class(prc_core_driver_t), allocatable :: driver
     logical :: use_color_factors = .false.
     integer :: nc = 3
   contains
   <<Prc core: process core: TBP>>
  end type prc_core_t
  
@ %def prc_core_t
@ In any case there must be an output routine.
<<Prc core: process core: TBP>>=
  procedure(prc_core_write), deferred :: write
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_write (object, unit)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine prc_core_write
  end interface
  
@ %def prc_core_write
@ For initialization, we assign a pointer to the process entry in the
relevant library.  This allows us to access all process functions via
the implementation of [[prc_core_t]].

We declare the [[object]] as [[intent(inout)]], since just after
allocation it may be useful to store some extra data in the object,
which we can then use in the actual initialization.  This applies to
extensions of [[prc_core]] which override the [[init]] method.
<<Prc core: process core: TBP>>=
  procedure :: init => prc_core_init
  procedure :: base_init => prc_core_init
<<Prc core: procedures>>=
  subroutine prc_core_init (object, def, lib, id, i_component)
    class(prc_core_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    object%def => def
    call lib%connect_process (id, i_component, object%data, object%driver)    
    object%data_known = .true.
  end subroutine prc_core_init
  
@ %def prc_core_init
@ Return true if the matrix element generation was successful.  This can be
tested by looking at the number of generated flavor states, which should be
nonzero.
<<Prc core: process core: TBP>>=
  procedure :: has_matrix_element => prc_core_has_matrix_element
<<Prc core: procedures>>=
  function prc_core_has_matrix_element (object) result (flag)
    class(prc_core_t), intent(in) :: object
    logical :: flag
    flag = object%data%n_flv /= 0
  end function prc_core_has_matrix_element

@ %def prc_core_has_matrix_element
@ Return true if a MC dataset should be attached to this process
component.  False if it shares the dataset with another component.
<<Prc core: process core: TBP>>=
  procedure(prc_core_get_flag), deferred :: needs_mcset
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_get_flag (object) result (flag)
       import
       class(prc_core_t), intent(in) :: object
       logical :: flag
     end function prc_core_get_flag
  end interface
  
@ %def prc_core_needs_mcset
@ Return an integer number
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_get_integer (object) result (i)
       import
       class(prc_core_t), intent(in) :: object
       integer :: i
     end function prc_core_get_integer
  end interface

@ %def prc_core_get_integer
@ Return the number of distinct terms requested by
this process component.
<<Prc core: process core: TBP>>=
  procedure(prc_core_get_integer), deferred :: get_n_terms
@
Tell whether a particular combination of flavor/helicity/color state
is allowed for the matrix element.
<<Prc core: process core: TBP>>=
  procedure(prc_core_is_allowed), deferred :: is_allowed
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_is_allowed (object, i_term, f, h, c) result (flag)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: i_term, f, h, c
       logical :: flag
     end function prc_core_is_allowed
  end interface

@ %def prc_core_is_allowed
@ Set the constant process data for a specific term.  By default,
these are the constants stored inside the object, ignoring the term
index.  Type extensions may override this and provide term-specific data.
<<Prc core: process core: TBP>>=
  procedure :: get_constants => prc_core_get_constants
<<Prc core: procedures>>=
  subroutine prc_core_get_constants (object, data, i_term)
    class(prc_core_t), intent(in) :: object
    type(process_constants_t), intent(out) :: data
    integer, intent(in) :: i_term
    data = object%data
  end subroutine prc_core_get_constants
  
@ %def prc_core_get_constants
@ The strong coupling is not among the process constants.  The default
implementation is to return a negative number, which indicates that $\alpha_s$
is not available.  This may be overridden by an implementation that provides
an (event-specific) value.  The value can be stored in the [[tmp]] workspace.
<<Prc core: process core: TBP>>=
  procedure :: get_alpha_s => prc_core_get_alpha_s
<<Prc core: procedures>>=
  function prc_core_get_alpha_s (object, tmp) result (alpha)
    class(prc_core_t), intent(in) :: object
    class(workspace_t), intent(in), allocatable :: tmp
    real(default) :: alpha
    alpha = -1
  end function prc_core_get_alpha_s
  
@ %def prc_core_get_alpha_s
@ Allocate the workspace associated to a process component.  The default is
that there is no workspace, so we do nothing.  A type extension may override
this and allocate a workspace object of appropriate type, which can be used in
further calculations.

In any case, the [[intent(out)]] attribute deletes any previously allocated
workspace.
<<Prc core: process core: TBP>>=
  procedure :: allocate_workspace => prc_core_ignore_workspace
<<Prc core: procedures>>=
  subroutine prc_core_ignore_workspace (object, tmp)
    class(prc_core_t), intent(in) :: object
    class(workspace_t), intent(inout), allocatable :: tmp
  end subroutine prc_core_ignore_workspace

@ %def prc_core_ignore_workspace
@ Initialize the structure-function instance that corresponds to a process
component.  In ordinary cases, this amounts to a straightforward copy of the
given template, but the process core may also choose to modify the setup,
and it may access its own workspace.

The [[sf_chain_instance]] is the object that we want to prepare.  The
[[sf_chain]] argument is a template for its structure.  For the
initialization, we also need the number of channels [[n_channel]].

Note: crash with nagfor 5.3.1 if [[sf_chain_instance]] is declared
[[intent(out)]], as would be more appropriate.
<<Prc core: process core: TBP>>=
  procedure :: init_sf_chain => prc_core_init_sf_chain
<<Prc core: procedures>>=
  subroutine prc_core_init_sf_chain &
       (object, sf_chain_instance, sf_chain, n_channel, tmp)
    class(prc_core_t), intent(in) :: object
    type(sf_chain_instance_t), intent(inout), target :: sf_chain_instance
    type(sf_chain_t), intent(in), target :: sf_chain
    integer, intent(in) :: n_channel
    class(workspace_t), intent(inout), allocatable :: tmp
    call sf_chain_instance%init (sf_chain, n_channel)
  end subroutine prc_core_init_sf_chain
  
@ %def prc_core_init_sf_chain
@ Compute the momenta in the hard interaction, taking the seed
kinematics as input.  The [[i_term]] index tells us which term we want
to compute.  (The standard method is to just transfer the momenta to the hard
interaction.)  
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_hard_kinematics), deferred :: &
       compute_hard_kinematics
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_compute_hard_kinematics &
          (object, p_seed, i_term, int_hard, tmp)
       import
       class(prc_core_t), intent(in) :: object
       type(vector4_t), dimension(:), intent(in) :: p_seed
       integer, intent(in) :: i_term
       type(interaction_t), intent(inout) :: int_hard
       class(workspace_t), intent(inout), allocatable :: tmp
     end subroutine prc_core_compute_hard_kinematics
  end interface

@ %def prc_core_compute_hard_kinematics
@ Compute the momenta in the effective interaction, taking the hard
kinematics as input.  (This is called only if parton recombination is to be
applied for the process variant.)
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_eff_kinematics), deferred :: &
       compute_eff_kinematics
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_compute_eff_kinematics &
          (object, i_term, int_hard, int_eff, tmp)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: i_term
       type(interaction_t), intent(in) :: int_hard
       type(interaction_t), intent(inout) :: int_eff
       class(workspace_t), intent(inout), allocatable :: tmp
     end subroutine prc_core_compute_eff_kinematics
  end interface

@ %def prc_core_compute_eff_kinematics
@ Recover the missing pieces.  We know the incoming momenta of the
[[p_seed]] array and the outgoing momenta of the [[int_eff]]
interaction.  We have to recover the outgoing momenta of [[p_seed]]
and the incoming momenta of [[int_eff]].

(The trivial case is that these are identical.)

Furthermore, if [[int_hard]] and [[int_eff]] are not aliased, we have
to set the momenta there.  In the trivial case, [[int_eff]] is a
pointer to [[int_hard]], so [[int_hard]] should not be touched at all.
<<Prc core: process core: TBP>>=
  procedure(prc_core_recover_kinematics), deferred :: &
       recover_kinematics
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_recover_kinematics &
          (object, p_seed, int_hard, int_eff, tmp)
       import
       class(prc_core_t), intent(in) :: object
       type(vector4_t), dimension(:), intent(inout) :: p_seed
       type(interaction_t), intent(inout) :: int_hard
       type(interaction_t), intent(inout) :: int_eff
       class(workspace_t), intent(inout), allocatable :: tmp
     end subroutine prc_core_recover_kinematics
  end interface

@ %def prc_core_recover_kinematics
@ The process core must implement this function.  Here, [[j]] is the index
of the particular term we want to compute.  The amplitude may depend on the
factorization and renormalization scales.

The [[tmp]] (workspace) argument may be used if it is provided by the caller.
Otherwise, the routine should compute the result directly.
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_amplitude), deferred :: compute_amplitude
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_compute_amplitude &
          (object, j, p, f, h, c, fac_scale, ren_scale, tmp) result (amp)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: j
       type(vector4_t), dimension(:), intent(in) :: p
       integer, intent(in) :: f, h, c
       real(default), intent(in) :: fac_scale, ren_scale
       class(workspace_t), intent(inout), allocatable, optional :: tmp
       complex(default) :: amp
     end function prc_core_compute_amplitude
  end interface
  
@ %def prc_core_compute_amplitude
@
\subsection{Storage for intermediate results}

The abstract [[workspace_t]] type allows process cores to set up temporary
workspace.  The object is an extra argument for each of the individual
calculations between kinematics setup and matrix-element evaluation.
<<Prc core: public>>=
  public :: workspace_t
<<Prc core: types>>=
  type, abstract :: workspace_t
   contains
     procedure(workspace_write), deferred :: write     
     procedure(workspace_reset_new_kinematics), deferred :: reset_new_kinematics
  end type workspace_t
  
@ %def workspace_t
@ For debugging, we should at least have an output routine.
<<Prc core: interfaces>>=
  abstract interface
     subroutine workspace_write (object, unit)
       import
       class(workspace_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine workspace_write
  end interface

@ %def workspace_write
@ This is used during the NLO calculation, see there for more information.
<<Prc core: interfaces>>=
  abstract interface
    subroutine workspace_reset_new_kinematics (object)
      import
      class(workspace_t), intent(inout) :: object
    end subroutine workspace_reset_new_kinematics
  end interface

@ %def workspace_reset_new_kinematics
@
\subsection{Helicity selection data}
This is intended for use with \oMega, but may also be made available to other
process methods.  We set thresholds for counting the times a specific
helicity amplitude is zero.  When the threshold is reached, we skip this
amplitude in subsequent calls.

For initializing the helicity counters, we need an object that holds the two
parameters, the threshold (large real number) and the cutoff (integer).

A helicity value suppressed by more than [[threshold]] (a value which
multiplies [[epsilon]], to be compared with the average of the current
amplitude, default is $10^{10}$) is treated as zero.  A matrix element is
assumed to be zero and not called again if it has been zero [[cutoff]] times.
<<Prc core: public>>=
  public :: helicity_selection_t
<<Prc core: types>>=
  type :: helicity_selection_t
     logical :: active = .false.
     real(default) :: threshold = 0
     integer :: cutoff = 0
   contains
   <<Prc core: helicity selection: TBP>>
  end type helicity_selection_t
     
@ %def helicity_selection_t
@ Output.  If the selection is inactive, print nothing.
<<Prc core: helicity selection: TBP>>=
  procedure :: write => helicity_selection_write
<<Prc core: procedures>>=
  subroutine helicity_selection_write (object, unit)
    class(helicity_selection_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%active) then
       write (u, "(3x,A)")  "Helicity selection data:"
       write (u, "(5x,A,ES17.10)") &
            "threshold =", object%threshold
       write (u, "(5x,A,I0)") &
            "cutoff    = ", object%cutoff
    end if
  end subroutine helicity_selection_write
    
@ %def helicity_selection_write
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process observables}
We define an abstract [[subevt_expr_t]] object as an extension of the
[[subevt_t]] type.  The object contains a local variable list, variable
instances (as targets for pointers in the variable list), and evaluation
trees.  The evaluation trees reference both the variables and the [[subevt]].

There are two instances of the abstract type: one for process instances, one
for physical events.  Both have a common logical expression [[selection]]
which determines whether the object passes user-defined cuts.

The intention is that we fill the [[subevt_t]] base object and compute the
variables once we have evaluated a kinematical phase space point (or a
complete event).  We then evaluate the expressions and can use the results in
further calculations.

The [[process_expr_t]] extension contains furthermore scale and weight
expressions.  The [[event_expr_t]] extension contains a reweighting-factor
expression and a logical expression for event analysis.  In practice, we will
link the variable list of the [[event_obs]] object to the variable list of the
currently active [[process_obs]] object, such that the process variables are
available to both objects.  Event variables are meaningful only for physical
events.

Note that there are unit tests, but they are deferred to the
[[expr_tests]] module.
<<[[subevt_expr.f90]]>>=
<<File header>>
module subevt_expr

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use lorentz
  use subevents
  use variables
  use flavors
  use quantum_numbers
  use interactions
  use particles
  use expr_base

<<Standard module head>>

<<Subevt expr: public>>

<<Subevt expr: types>>

<<Subevt expr: interfaces>>

contains
  
<<Subevt expr: procedures>>

end module subevt_expr
@ %def subevt_expr
@
\subsection{Abstract base type}
<<Subevt expr: types>>=
  type, extends (subevt_t), abstract :: subevt_expr_t
     logical :: subevt_filled = .false.
     type(var_list_t) :: var_list
     real(default) :: sqrts_hat = 0
     integer :: n_in = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     logical :: has_selection = .false.
     class(expr_t), allocatable :: selection
   contains
   <<Subevt expr: subevt expr: TBP>>
  end type subevt_expr_t
  
@ %def subevt_expr_t
@ Output: Base and extended version.  We already have a [[write]] routine for
the [[subevt_t]] parent type.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: base_write => subevt_expr_write
<<Subevt expr: procedures>>=
  subroutine subevt_expr_write (object, unit)
    class(subevt_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Local variables:"
    call write_separator (u)
    call var_list_write (object%var_list, u, follow_link=.false.)
    call write_separator (u)
    if (object%subevt_filled) then
       call object%subevt_t%write (u)
       if (object%has_selection) then
          call write_separator (u)
          write (u, "(1x,A)")  "Selection expression:"
          call write_separator (u)
          call object%selection%write (u)
       end if
    else
       write (u, "(1x,A)")  "subevt: [undefined]"
    end if
  end subroutine subevt_expr_write
    
@ %def subevt_expr_write   
@ Finalizer.
<<Subevt expr: subevt expr: TBP>>=
  procedure (subevt_expr_final), deferred :: final
  procedure :: base_final => subevt_expr_final
<<Subevt expr: procedures>>=
  subroutine subevt_expr_final (object)
    class(subevt_expr_t), intent(inout) :: object
    call var_list_final (object%var_list)
    if (object%has_selection) then
       call object%selection%final ()
    end if
  end subroutine subevt_expr_final
  
@ %def subevt_expr_final
@
\subsection{Initialization}
Initialization: define local variables and establish pointers.

The common variables are [[sqrts]] (the nominal beam energy, fixed),
[[sqrts_hat]] (the actual energy), [[n_in]], [[n_out]], and [[n_tot]] for
the [[subevt]].  With the exception of [[sqrts]], all are implemented as
pointers to subobjects.
<<Subevt expr: subevt expr: TBP>>=
  procedure (subevt_expr_setup_vars), deferred :: setup_vars
  procedure :: base_setup_vars => subevt_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine subevt_expr_setup_vars (expr, sqrts)
    class(subevt_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call var_list_final (expr%var_list)
    call var_list_append_real (expr%var_list, &
         var_str ("sqrts"), sqrts, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqrts_hat"), expr%sqrts_hat, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_in"), expr%n_in, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_out"), expr%n_out, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_tot"), expr%n_tot, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
  end subroutine subevt_expr_setup_vars
    
@ %def subevt_expr_setup_vars
@ Link a variable list to the local one.  This could be done event by event,
but before evaluating expressions.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: link_var_list => subevt_expr_link_var_list
<<Subevt expr: procedures>>=
  subroutine subevt_expr_link_var_list (expr, var_list)
    class(subevt_expr_t), intent(inout) :: expr
    type(var_list_t), intent(in), target :: var_list
    call var_list_link (expr%var_list, var_list)
  end subroutine subevt_expr_link_var_list

@ %def subevt_expr_link_var_list
@ Compile the selection expression.  If there is no expression, the build
method won't allocate the expression object.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: setup_selection => subevt_expr_setup_selection
<<Subevt expr: procedures>>=
  subroutine subevt_expr_setup_selection (expr, ef_cuts)
    class(subevt_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_cuts
    call ef_cuts%build (expr%selection)
    if (allocated (expr%selection)) then
       call expr%selection%setup_lexpr (expr%var_list, expr%subevt_t)
       expr%has_selection = .true.
    end if
  end subroutine subevt_expr_setup_selection

@ %def subevt_expr_setup_selection
@
\subsection{Evaluation}
Reset to initial state, i.e., mark the [[subevt]] as invalid.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: reset => subevt_expr_reset
  procedure :: base_reset => subevt_expr_reset
<<Subevt expr: procedures>>=
  subroutine subevt_expr_reset (expr)
    class(subevt_expr_t), intent(inout) :: expr
    expr%subevt_filled = .false.
  end subroutine subevt_expr_reset
  
@ %def subevt_expr_reset
@ Evaluate the selection expression and return the result.  There is also a
deferred version: this should evaluate the remaining expressions if the event
has passed.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: base_evaluate => subevt_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine subevt_expr_evaluate (expr, passed)
    class(subevt_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed 
    if (expr%has_selection) then
       call expr%selection%evaluate ()
       if (expr%selection%is_known ()) then
          passed = expr%selection%get_log ()
       else
          call msg_error ("Evaluate selection expression: result undefined")
          passed = .false.
       end if
    else
       passed = .true.
    end if
  end subroutine subevt_expr_evaluate
  
@ %def subevt_expr_evaluate
@
\subsection{Implementation for partonic events}
This implementation contains the expressions that we can evaluate for the
partonic process during integration.
<<Subevt expr: public>>=
  public :: parton_expr_t
<<Subevt expr: types>>=
  type, extends (subevt_expr_t) :: parton_expr_t
     integer, dimension(:), allocatable :: i_beam
     integer, dimension(:), allocatable :: i_in
     integer, dimension(:), allocatable :: i_out
     logical :: has_scale = .false.
     logical :: has_fac_scale = .false.
     logical :: has_ren_scale = .false.
     logical :: has_weight = .false.
     class(expr_t), allocatable :: scale
     class(expr_t), allocatable :: fac_scale
     class(expr_t), allocatable :: ren_scale
     class(expr_t), allocatable :: weight
   contains
   <<Subevt expr: parton expr: TBP>>
  end type parton_expr_t
     
@ %def parton_expr_t
@ Finalizer.
<<Subevt expr: parton expr: TBP>>=
  procedure :: final => parton_expr_final
<<Subevt expr: procedures>>=
  subroutine parton_expr_final (object)
    class(parton_expr_t), intent(inout) :: object
    call object%base_final ()
    if (object%has_scale) then
       call object%scale%final ()
    end if
    if (object%has_fac_scale) then
       call object%fac_scale%final ()
    end if
    if (object%has_ren_scale) then
       call object%ren_scale%final ()
    end if
    if (object%has_weight) then
       call object%weight%final ()
    end if
  end subroutine parton_expr_final

@ %def parton_expr_final
@ Output: continue writing the active expressions, after the common selection
expression.

Note: the [[prefix]] argument is declared in the [[write]] method of the
[[subevt_t]] base type.  Here, it is unused.
<<Subevt expr: parton expr: TBP>>=
  procedure :: write => parton_expr_write
<<Subevt expr: procedures>>=
  subroutine parton_expr_write (object, unit, prefix)
    class(parton_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    character(*), intent(in), optional :: prefix
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
    if (object%subevt_filled) then
       if (object%has_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Scale expression:"
          call write_separator (u)
          call object%scale%write (u)
       end if
       if (object%has_fac_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Factorization scale expression:"
          call write_separator (u)
          call object%fac_scale%write (u)
       end if
       if (object%has_ren_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Renormalization scale expression:"
          call write_separator (u)
          call object%ren_scale%write (u)
       end if
       if (object%has_weight) then
          call write_separator (u)
          write (u, "(1x,A)")  "Weight expression:"
          call write_separator (u)
          call object%weight%write (u)
       end if
    end if
  end subroutine parton_expr_write
    
@ %def parton_expr_write
@ Define variables.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_vars => parton_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_vars (expr, sqrts)
    class(parton_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call expr%base_setup_vars (sqrts)
  end subroutine parton_expr_setup_vars

@ %def parton_expr_setup_vars
@ Compile the scale expressions.  If a pointer is disassociated, there is
no expression.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_scale => parton_expr_setup_scale
  procedure :: setup_fac_scale => parton_expr_setup_fac_scale
  procedure :: setup_ren_scale => parton_expr_setup_ren_scale
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_scale (expr, ef_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_scale
    call ef_scale%build (expr%scale)
    if (allocated (expr%scale)) then
       call expr%scale%setup_expr (expr%var_list, expr%subevt_t)
       expr%has_scale = .true.
    end if
  end subroutine parton_expr_setup_scale

  subroutine parton_expr_setup_fac_scale (expr, ef_fac_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_fac_scale
    call ef_fac_scale%build (expr%fac_scale)
    if (allocated (expr%fac_scale)) then
       call expr%fac_scale%setup_expr (expr%var_list, expr%subevt_t)
       expr%has_fac_scale = .true.
    end if
  end subroutine parton_expr_setup_fac_scale

  subroutine parton_expr_setup_ren_scale (expr, ef_ren_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_ren_scale
    call ef_ren_scale%build (expr%ren_scale)
    if (allocated (expr%ren_scale)) then
       call expr%ren_scale%setup_expr (expr%var_list, expr%subevt_t)
       expr%has_ren_scale = .true.
    end if
  end subroutine parton_expr_setup_ren_scale

@ %def parton_expr_setup_scale
@ %def parton_expr_setup_fac_scale
@ %def parton_expr_setup_ren_scale
@ Compile the weight expression.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_weight => parton_expr_setup_weight
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_weight (expr, ef_weight)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_weight
    call ef_weight%build (expr%weight)
    if (allocated (expr%weight)) then
       call expr%weight%setup_expr (expr%var_list, expr%subevt_t)
       expr%has_weight = .true.
    end if
  end subroutine parton_expr_setup_weight

@ %def parton_expr_setup_weight
@ Filling the partonic state consists of two parts.  The first routine
prepares the subevt without assigning momenta.  It takes the particles from an
[[interaction_t]].  It needs the indices and flavors for the beam,
incoming, and outgoing particles.

We can assume that the particle content of the subevt does not change.
Therefore, we set the event variables [[n_in]], [[n_out]], [[n_tot]] already
in this initialization step.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_subevt => parton_expr_setup_subevt
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_subevt (expr, int, &
       i_beam, i_in, i_out, f_beam, f_in, f_out)
    class(parton_expr_t), intent(inout) :: expr
    type(interaction_t), intent(in), target :: int
    integer, dimension(:), intent(in) :: i_beam, i_in, i_out
    type(flavor_t), dimension(:), intent(in) :: f_beam, f_in, f_out
    allocate (expr%i_beam (size (i_beam)))
    allocate (expr%i_in (size (i_in)))
    allocate (expr%i_out (size (i_out)))
    expr%i_beam = i_beam
    expr%i_in = i_in
    expr%i_out = i_out
    call interaction_to_subevt (int, &
         expr%i_beam, expr%i_in, expr%i_out, expr%subevt_t)
    call subevt_set_pdg_beam     (expr%subevt_t, flavor_get_pdg (f_beam))
    call subevt_set_pdg_incoming (expr%subevt_t, flavor_get_pdg (f_in))
    call subevt_set_pdg_outgoing (expr%subevt_t, flavor_get_pdg (f_out))
    call subevt_set_p2_beam     (expr%subevt_t, flavor_get_mass (f_beam) ** 2)
    call subevt_set_p2_incoming (expr%subevt_t, flavor_get_mass (f_in)   ** 2)
    call subevt_set_p2_outgoing (expr%subevt_t, flavor_get_mass (f_out)  ** 2)
    expr%n_in  = size (i_in)
    expr%n_out = size (i_out)
    expr%n_tot = expr%n_in + expr%n_out
  end subroutine parton_expr_setup_subevt

@ %def parton_expr_setup_subevt
@ Transfer PDG codes, masses (initalization) and momenta to a
predefined subevent.  We use the flavor assignment of the first
branch in the interaction state matrix.  Only incoming and outgoing
particles are transferred.  Switch momentum sign for incoming
particles.
<<Subevt expr: public>>=
!  public :: interaction_to_subevt
!  public :: interaction_momenta_to_subevt
<<Subevt expr: interfaces>>=
  interface interaction_momenta_to_subevt
     module procedure interaction_momenta_to_subevt_id
     module procedure interaction_momenta_to_subevt_tr
  end interface

<<Subevt expr: procedures>>=
  subroutine interaction_to_subevt (int, j_beam, j_in, j_out, subevt)
    type(interaction_t), intent(in), target :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(out) :: subevt
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: n_beam, n_in, n_out, i, j
    allocate (flv (interaction_get_n_tot (int)))
    flv = quantum_numbers_get_flavor (interaction_get_quantum_numbers (int, 1))
    n_beam = size (j_beam)
    n_in = size (j_in)
    n_out = size (j_out)
    call subevt_init (subevt, n_beam + n_in + n_out)
    do i = 1, n_beam
       j = j_beam(i)
       call subevt_set_beam (subevt, i, &
            flavor_get_pdg (flv(j)), &
            vector4_null, &
            flavor_get_mass (flv(j)) ** 2)
    end do
    do i = 1, n_in
       j = j_in(i)
       call subevt_set_incoming (subevt, n_beam + i, &
            flavor_get_pdg (flv(j)), &
            vector4_null, &
            flavor_get_mass (flv(j)) ** 2)
    end do
    do i = 1, n_out
       j = j_out(i)
       call subevt_set_outgoing (subevt, n_beam + n_in + i, &
            flavor_get_pdg (flv(j)), &
            vector4_null, &
            flavor_get_mass (flv(j)) ** 2)
    end do
  end subroutine interaction_to_subevt

  subroutine interaction_momenta_to_subevt_id (int, j_beam, j_in, j_out, subevt)
    type(interaction_t), intent(in) :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(inout) :: subevt
    call subevt_set_p_beam &
         (subevt, - interaction_get_momenta (int, j_beam))
    call subevt_set_p_incoming &
         (subevt, - interaction_get_momenta (int, j_in))
    call subevt_set_p_outgoing &
         (subevt, interaction_get_momenta (int, j_out))
  end subroutine interaction_momenta_to_subevt_id

  subroutine interaction_momenta_to_subevt_tr &
       (int, j_beam, j_in, j_out, lt, subevt)
    type(interaction_t), intent(in) :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(inout) :: subevt
    type(lorentz_transformation_t), intent(in) :: lt
    call subevt_set_p_beam &
         (subevt, - lt * interaction_get_momenta (int, j_beam))
    call subevt_set_p_incoming &
         (subevt, - lt * interaction_get_momenta (int, j_in))
    call subevt_set_p_outgoing &
         (subevt, lt * interaction_get_momenta (int, j_out))
  end subroutine interaction_momenta_to_subevt_tr

@ %def interaction_momenta_to_subevt
@ The second part takes the momenta from the interaction object and thus
completes the subevt.  The partonic energy can then be computed.
<<Subevt expr: parton expr: TBP>>=
  procedure :: fill_subevt => parton_expr_fill_subevt
<<Subevt expr: procedures>>=
  subroutine parton_expr_fill_subevt (expr, int)
    class(parton_expr_t), intent(inout) :: expr
    type(interaction_t), intent(in), target :: int
    call interaction_momenta_to_subevt (int, &
         expr%i_beam, expr%i_in, expr%i_out, expr%subevt_t)
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%subevt_filled = .true.
  end subroutine parton_expr_fill_subevt
    
@ %def parton_expr_fill_subevt
@ Evaluate, if the event passes the selection.  For absent expressions we take
default values.
<<Subevt expr: parton expr: TBP>>=
  procedure :: evaluate => parton_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine parton_expr_evaluate &
       (expr, passed, scale, fac_scale, ren_scale, weight)
    class(parton_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed
    real(default), intent(out) :: scale
    real(default), intent(out) :: fac_scale
    real(default), intent(out) :: ren_scale
    real(default), intent(out) :: weight
    call expr%base_evaluate (passed)
    if (passed) then
       if (expr%has_scale) then
          call expr%scale%evaluate ()
          if (expr%scale%is_known ()) then
             scale = expr%scale%get_real ()
          else
             call msg_error ("Evaluate scale expression: result undefined")
             scale = 0
          end if
       else
          scale = expr%sqrts_hat
       end if
       if (expr%has_fac_scale) then
          call expr%fac_scale%evaluate ()
          if (expr%fac_scale%is_known ()) then
             fac_scale = expr%fac_scale%get_real ()
          else
             call msg_error ("Evaluate factorization scale expression: &
                  &result undefined")
             fac_scale = 0
          end if
       else
          fac_scale = scale
       end if
       if (expr%has_ren_scale) then
          call expr%ren_scale%evaluate ()
          if (expr%ren_scale%is_known ()) then
             ren_scale = expr%ren_scale%get_real ()
          else
             call msg_error ("Evaluate renormalization scale expression: &
                  &result undefined")
             ren_scale = 0
          end if
       else
          ren_scale = scale
       end if
       if (expr%has_weight) then
          call expr%weight%evaluate ()
          if (expr%weight%is_known ()) then
             weight = expr%weight%get_real ()
          else
             call msg_error ("Evaluate weight expression: result undefined")
             weight = 0
          end if
       else
          weight = 1
       end if
    end if
  end subroutine parton_expr_evaluate
  
@ %def parton_expr_evaluate
@ Return the beam/incoming parton indices.
<<Subevt expr: parton expr: TBP>>=
  procedure :: get_beam_index => parton_expr_get_beam_index
  procedure :: get_in_index => parton_expr_get_in_index
<<Subevt expr: procedures>>=
  subroutine parton_expr_get_beam_index (expr, i_beam)
    class(parton_expr_t), intent(in) :: expr
    integer, dimension(:), intent(out) :: i_beam
    i_beam = expr%i_beam
  end subroutine parton_expr_get_beam_index
  
  subroutine parton_expr_get_in_index (expr, i_in)
    class(parton_expr_t), intent(in) :: expr
    integer, dimension(:), intent(out) :: i_in
    i_in = expr%i_in
  end subroutine parton_expr_get_in_index
  
@ %def parton_expr_get_beam_index
@ %def parton_expr_get_in_index
@
\subsection{Implementation for full events}
This implementation contains the expressions that we can evaluate for the
full event.  It also contains data that pertain to the event, suitable
for communication with external event formats.  These data
simultaneously serve as pointer targets for the variable lists hidden
in the expressions (eval trees).

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.
<<Subevt expr: public>>=
  public :: event_expr_t
<<Subevt expr: types>>=
  type, extends (subevt_expr_t) :: event_expr_t
     logical :: has_reweight = .false.
     logical :: has_analysis = .false.
     class(expr_t), allocatable :: reweight
     class(expr_t), allocatable :: analysis
     logical :: has_id = .false.
     type(string_t) :: id
     logical :: has_num_id = .false.
     integer :: num_id = 0
     logical :: has_index = .false.
     integer :: index = 0
     logical :: has_sqme_ref = .false.
     real(default) :: sqme_ref = 0
     logical :: has_sqme_prc = .false.
     real(default) :: sqme_prc = 0
     logical :: has_weight_ref = .false.
     real(default) :: weight_ref = 0
     logical :: has_weight_prc = .false.
     real(default) :: weight_prc = 0
     logical :: has_excess_prc = .false.
     real(default) :: excess_prc = 0
     integer :: n_alt = 0
     logical :: has_sqme_alt = .false.
     real(default), dimension(:), allocatable :: sqme_alt
     logical :: has_weight_alt = .false.
     real(default), dimension(:), allocatable :: weight_alt
   contains
   <<Subevt expr: event expr: TBP>>
  end type event_expr_t
     
@ %def event_expr_t
@ Finalizer for the expressions.
<<Subevt expr: event expr: TBP>>=
  procedure :: final => event_expr_final
<<Subevt expr: procedures>>=
  subroutine event_expr_final (object)
    class(event_expr_t), intent(inout) :: object
    call object%base_final ()
    if (object%has_reweight) then
       call object%reweight%final ()
    end if
    if (object%has_analysis) then
       call object%analysis%final ()
    end if
  end subroutine event_expr_final

@ %def event_expr_final
@ Output: continue writing the active expressions, after the common selection
expression.

Note: the [[prefix]] argument is declared in the [[write]] method of the
[[subevt_t]] base type.  Here, it is unused.
<<Subevt expr: event expr: TBP>>=
  procedure :: write => event_expr_write
<<Subevt expr: procedures>>=
  subroutine event_expr_write (object, unit, prefix)
    class(event_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    character(*), intent(in), optional :: prefix
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
    if (object%subevt_filled) then
       if (object%has_reweight) then
          call write_separator (u)
          write (u, "(1x,A)")  "Reweighting expression:"
          call write_separator (u)
          call object%reweight%write (u)
       end if
       if (object%has_analysis) then
          call write_separator (u)
          write (u, "(1x,A)")  "Analysis expression:"
          call write_separator (u)
          call object%analysis%write (u)
       end if
    end if
  end subroutine event_expr_write
    
@ %def event_expr_write
@ Initializer.  This is required only for the [[sqme_alt]] and
[[weight_alt]] arrays.
<<Subevt expr: event expr: TBP>>=
  procedure :: init => event_expr_init
<<Subevt expr: procedures>>=
  subroutine event_expr_init (expr, n_alt)
    class(event_expr_t), intent(out) :: expr
    integer, intent(in), optional :: n_alt
    if (present (n_alt)) then
       expr%n_alt = n_alt
       allocate (expr%sqme_alt (n_alt), source = 0._default)
       allocate (expr%weight_alt (n_alt), source = 0._default)
    end if
  end subroutine event_expr_init
  
@ %def event_expr_init
@ Define variables.  We have the variables of the base type plus
specific variables for full events.  There is the event index.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_vars => event_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_vars (expr, sqrts)
    class(event_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call expr%base_setup_vars (sqrts)
    call var_list_append_string_ptr (expr%var_list, &
         var_str ("$process_id"), expr%id, &
         is_known = expr%has_id, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("process_num_id"), expr%num_id, &
         is_known = expr%has_num_id, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqme"), expr%sqme_prc, &
         is_known = expr%has_sqme_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqme_ref"), expr%sqme_ref, &
         is_known = expr%has_sqme_ref, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("event_index"), expr%index, &
         is_known = expr%has_index, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_weight"), expr%weight_prc, &
         is_known = expr%has_weight_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_weight_ref"), expr%weight_ref, &
         is_known = expr%has_weight_ref, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_excess"), expr%excess_prc, &
         is_known = expr%has_excess_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
  end subroutine event_expr_setup_vars

@ %def event_expr_setup_vars
@ Compile the analysis expression.  If the pointer is disassociated, there is
no expression.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_analysis => event_expr_setup_analysis
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_analysis (expr, ef_analysis)
    class(event_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_analysis
    call ef_analysis%build (expr%analysis)
    if (allocated (expr%analysis)) then
       call expr%analysis%setup_lexpr (expr%var_list, expr%subevt_t)
       expr%has_analysis = .true.
    end if
  end subroutine event_expr_setup_analysis

@ %def event_expr_setup_analysis
@ Compile the reweight expression.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_reweight => event_expr_setup_reweight
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_reweight (expr, ef_reweight)
    class(event_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_reweight
    call ef_reweight%build (expr%reweight)
    if (allocated (expr%reweight)) then
       call expr%reweight%setup_expr (expr%var_list, expr%subevt_t)
       expr%has_reweight = .true.
    end if
  end subroutine event_expr_setup_reweight

@ %def event_expr_setup_reweight
@ Store the string or numeric process ID.  This should be done during
initialization.
<<Subevt expr: event expr: TBP>>=
  procedure :: set_process_id => event_expr_set_process_id
  procedure :: set_process_num_id => event_expr_set_process_num_id
<<Subevt expr: procedures>>=
  subroutine event_expr_set_process_id (expr, id)
    class(event_expr_t), intent(inout) :: expr
    type(string_t), intent(in) :: id
    expr%id = id
    expr%has_id = .true.
  end subroutine event_expr_set_process_id
    
  subroutine event_expr_set_process_num_id (expr, num_id)
    class(event_expr_t), intent(inout) :: expr
    integer, intent(in) :: num_id
    expr%num_id = num_id
    expr%has_num_id = .true.
  end subroutine event_expr_set_process_num_id
    
@ %def event_expr_set_process_id
@ %def event_expr_set_process_num_id
@ Reset / set the data that pertain to a particular event.
<<Subevt expr: event expr: TBP>>=
  procedure :: reset => event_expr_reset
  procedure :: set => event_expr_set
<<Subevt expr: procedures>>=
  subroutine event_expr_reset (expr)
    class(event_expr_t), intent(inout) :: expr
    call expr%base_reset ()
    expr%has_sqme_ref = .false.
    expr%has_sqme_prc = .false.
    expr%has_sqme_alt = .false.
    expr%has_weight_ref = .false.
    expr%has_weight_prc = .false.
    expr%has_weight_alt = .false.
    expr%has_excess_prc = .false.
  end subroutine event_expr_reset
  
  subroutine event_expr_set (expr, &
       weight_ref, weight_prc, weight_alt, &
       excess_prc, &
       sqme_ref, sqme_prc, sqme_alt)
    class(event_expr_t), intent(inout) :: expr
    real(default), intent(in), optional :: weight_ref, weight_prc
    real(default), intent(in), optional :: excess_prc
    real(default), intent(in), optional :: sqme_ref, sqme_prc
    real(default), dimension(:), intent(in), optional :: sqme_alt, weight_alt
    if (present (sqme_ref)) then
       expr%has_sqme_ref = .true.
       expr%sqme_ref = sqme_ref
    end if
    if (present (sqme_prc)) then
       expr%has_sqme_prc = .true.
       expr%sqme_prc = sqme_prc
    end if 
    if (present (sqme_alt)) then
       expr%has_sqme_alt = .true.
       expr%sqme_alt = sqme_alt
    end if
    if (present (weight_ref)) then
       expr%has_weight_ref = .true.
       expr%weight_ref = weight_ref
    end if
    if (present (weight_prc)) then
       expr%has_weight_prc = .true.
       expr%weight_prc = weight_prc
    end if
    if (present (weight_alt)) then
       expr%has_weight_alt = .true.
       expr%weight_alt = weight_alt
    end if
    if (present (excess_prc)) then
       expr%has_excess_prc = .true.
       expr%excess_prc = excess_prc
    end if
  end subroutine event_expr_set
  
@ %def event_expr_reset event_expr_set
@ Fill the event expression: take the particle data and kinematics
from a [[particle_set]] object.

We allow the particle content to change for each event.  Therefore, we set the
event variables each time.

Also increment the event index; initialize it if necessary.
<<Subevt expr: event expr: TBP>>=
  procedure :: fill_subevt => event_expr_fill_subevt
<<Subevt expr: procedures>>=
  subroutine event_expr_fill_subevt (expr, particle_set)
    class(event_expr_t), intent(inout) :: expr
    type(particle_set_t), intent(in) :: particle_set
    call particle_set_to_subevt (particle_set, expr%subevt_t)
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in  = particle_set_get_n_in  (particle_set)
    expr%n_out = particle_set_get_n_out (particle_set)
    expr%n_tot = expr%n_in + expr%n_out
    expr%subevt_filled = .true.
    if (expr%has_index) then
       expr%index = expr%index + 1
    else
       expr%index = 1
       expr%has_index = .true.
    end if
  end subroutine event_expr_fill_subevt
  
@ %def event_expr_fill_subevt
@ Evaluate, if the event passes the selection.  For absent expressions we take
default values.
<<Subevt expr: event expr: TBP>>=
  procedure :: evaluate => event_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine event_expr_evaluate (expr, passed, reweight, analysis_flag)
    class(event_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed
    real(default), intent(out) :: reweight
    logical, intent(out) :: analysis_flag
    call expr%base_evaluate (passed)
    if (passed) then
       if (expr%has_reweight) then
          call expr%reweight%evaluate ()
          if (expr%reweight%is_known ()) then
             reweight = expr%reweight%get_real ()
          else
             call msg_error ("Evaluate reweight expression: &
                  &result undefined")
             reweight = 0
          end if
       else
          reweight = 1
       end if
       if (expr%has_analysis) then
          call expr%analysis%evaluate ()
          if (expr%analysis%is_known ()) then
             analysis_flag = expr%analysis%get_log ()
          else
             call msg_error ("Evaluate analysis expression: &
                  &result undefined")
             analysis_flag = .false.
          end if
       else
          analysis_flag = .true.
       end if
    end if
  end subroutine event_expr_evaluate
  
@ %def event_expr_evaluate
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parton states}
A [[parton_state_t]] object contains the effective kinematics and
dynamics of an elementary partonic interaction, with or without the
beam/structure function state included.  The type is abstract and has
two distinct extensions.  The [[isolated_state_t]] extension describes
the isolated elementary interaction where the [[int_eff]] subobject
contains the complex transition amplitude, exclusive in all quantum
numbers.  The particle content and kinematics describe the effective
partonic state.  The [[connected_state_t]] extension contains the
partonic [[subevt]] and the expressions for cuts and scales which use
it.

In the isolated state, the effective partonic interaction may either
be identical to the hard interaction, in which case it is just a
pointer to the latter.  Or it may involve a rearrangement of partons,
in which case we allocate it explicitly and flag this by
[[int_is_allocated]].

The [[trace]] evaluator contains the absolute square of the effective
transition amplitude matrix, summed over final states.  It is also summed over
initial states, depending on the the beam setup allows.  The result is used for
integration.

The [[matrix]] evaluator is the counterpart of [[trace]] which is kept
exclusive in all observable quantum numbers.  The [[flows]] evaluator is
furthermore exclusive in colors, but neglecting all color interference.  The
[[matrix]] and [[flows]] evaluators are filled only for sampling points that
become part of physical events.

Note: It would be natural to make the evaluators allocatable.
However, this causes memory corruption in gfortran 4.6.3.  The extra
[[has_XXX]] flags indicate whether evaluators are active, instead.

This module contains no unit tests.  The tests are covered by the
[[processes]] module below.
<<[[parton_states.f90]]>>=
<<File header>>
module parton_states

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use lorentz
  use subevents
  use variables
  use expr_base
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use evaluators

  use beams
  use sf_base
  use process_constants
  use prc_core
  use subevt_expr

<<Standard module head>>

<<Parton states: public>>

<<Parton states: types>>

contains
  
<<Parton states: procedures>>

end module parton_states
@ %def parton_states
@
\subsection{Abstract base type}
The common part are the evaluators, one for the trace (summed over all
quantum numbers), one for the transition matrix (summed only over
unobservable quantum numbers), and one for the flow distribution
(transition matrix without interferences, exclusive in color flow).
<<Parton states: types>>=
  type, abstract :: parton_state_t
     logical :: has_trace = .false.
     logical :: has_matrix = .false.
     logical :: has_flows = .false.
     type(evaluator_t) :: trace
     type(evaluator_t) :: matrix
     type(evaluator_t) :: flows
   contains
   <<Parton states: parton state: TBP>>
  end type parton_state_t

@ %def parton_state_t
@ The [[isolated_state_t]] extension contains the [[sf_chain_eff]] object
and the (hard) effective interaction [[int_eff]], separately, both
implemented as a pointer.  The evaluators (trace, matrix, flows) apply
to the hard interaction only.

If the effective interaction differs from the hard interaction, the
pointer is allocated explicitly.  Analogously for [[sf_chain_eff]].
<<Parton states: public>>=
  public :: isolated_state_t
<<Parton states: types>>=
  type, extends (parton_state_t) :: isolated_state_t
     logical :: sf_chain_is_allocated = .false.
     type(sf_chain_instance_t), pointer :: sf_chain_eff => null ()
     logical :: int_is_allocated = .false.
     type(interaction_t), pointer :: int_eff => null ()
   contains
   <<Parton states: isolated state: TBP>>
  end type isolated_state_t

@ %def isolated_state_t
@ The [[connected_state_t]] extension contains all data that enable
the evaluation of observables for the effective connected state.  The
evaluators connect the (effective) structure-function chain and hard
interaction that were kept separate in the [[isolated_state_t]].

The [[flows_sf]] evaluator is an extended copy of the
structure-function 

The [[expr]] subobject consists of the [[subevt]], a simple event record,
expressions for cuts etc.\ which refer to this record, and a [[var_list]]
which contains event-specific variables, linked to the process variable
list.  Variables used within the expressions are looked up in [[var_list]].
<<Parton states: types>>=
  public :: connected_state_t
<<Parton states: types>>=
  type, extends (parton_state_t) :: connected_state_t
     logical :: has_flows_sf = .false.
     type(evaluator_t) :: flows_sf
     logical :: has_expr = .false.
     type(parton_expr_t) :: expr
   contains
   <<Parton states: connected state: TBP>>
  end type connected_state_t
     
@ %def connected_state_t
@ Output: each evaluator is written only when it is active.  The
[[sf_chain]] is only written if it is explicitly allocated.
<<Parton states: parton state: TBP>>=
  procedure :: write => parton_state_write
<<Parton states: procedures>>=
  subroutine parton_state_write (state, unit, testflag)
    class(parton_state_t), intent(in) :: state
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    select type (state)
    class is (isolated_state_t)
       if (state%sf_chain_is_allocated) then
          call write_separator (u)
          call state%sf_chain_eff%write (u)
       end if
       if (state%int_is_allocated) then
          call write_separator (u)
          write (u, "(1x,A)") &
               "Effective interaction:"
          call write_separator (u)
          call interaction_write (state%int_eff, u, testflag = testflag)
       end if
    class is (connected_state_t)
       if (state%has_flows_sf) then
          call write_separator (u)
          write (u, "(1x,A)") &
               "Evaluator (extension of the beam evaluator &
               &with color contractions):"
          call write_separator (u)
          call state%flows_sf%write (u, testflag = testflag)
       end if
    end select
    if (state%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (trace of the squared transition matrix):"
       call write_separator (u)
       call state%trace%write (u, testflag = testflag)
    end if
    if (state%has_matrix) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (squared transition matrix):"
       call write_separator (u)
       call state%matrix%write (u, testflag = testflag)
    end if
    if (state%has_flows) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (squared color-flow matrix):"
       call write_separator (u)
       call state%flows%write (u, testflag = testflag)
    end if
    select type (state)
    class is (connected_state_t)
       if (state%has_expr) then
          call write_separator (u)
          call state%expr%write (u)
       end if
    end select
  end subroutine parton_state_write
    
@ %def parton_state_write
@ Finalize interaction and evaluators, but only if allocated.
<<Parton states: parton state: TBP>>=
  procedure :: final => parton_state_final
<<Parton states: procedures>>=
  subroutine parton_state_final (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_flows) then
       call evaluator_final (state%flows)
       state%has_flows = .false.
    end if
    if (state%has_matrix) then
       call evaluator_final (state%matrix)
       state%has_matrix = .false.
    end if
    if (state%has_trace) then
       call evaluator_final (state%trace)
       state%has_trace = .false.
    end if
    select type (state)
    class is (connected_state_t)
       if (state%has_flows_sf) then
          call evaluator_final (state%flows_sf)
          state%has_flows_sf = .false.
       end if
       call state%expr%final ()
    class is (isolated_state_t)
       if (state%int_is_allocated) then
          call interaction_final (state%int_eff)
          deallocate (state%int_eff)
          state%int_is_allocated = .false.
       end if
       if (state%sf_chain_is_allocated) then
          call state%sf_chain_eff%final ()
       end if
    end select
  end subroutine parton_state_final
    
@ %def parton_state_final
@
\subsection{Common Initialization}
Initialize the isolated parton state.  In this version, the
effective structure-function chain [[sf_chain_eff]] and the effective
interaction [[int_eff]] both are trivial pointers to the seed
structure-function chain and to the hard interaction, respectively.
<<Parton states: isolated state: TBP>>=
  procedure :: init => isolated_state_init_pointers
<<Parton states: procedures>>=
  subroutine isolated_state_init_pointers (state, sf_chain, int)
    class(isolated_state_t), intent(out) :: state
    type(sf_chain_instance_t), intent(in), target :: sf_chain
    type(interaction_t), intent(in), target :: int
    state%sf_chain_eff => sf_chain
    state%int_eff => int
  end subroutine isolated_state_init_pointers
    
@ %def isolated_state_init_pointers
@ 
\subsection{Evaluator initialization: isolated state}
Create an evaluator for the trace of the squared transition matrix.
The trace goes over all outgoing quantum numbers.  Whether we trace
over incoming quantum numbers other than color, depends on the given
[[qn_mask_in]].

There are two options: explicitly computing the color factor table
([[use_cf]] false; [[nc]] defined), or taking the color factor
table from the hard matrix element data.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_trace => isolated_state_setup_square_trace
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_trace (state, core, qn_mask_in, &
       col)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    integer, dimension(:), intent(in) :: col
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask    
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      qn_mask(:data%n_in) = &
              new_quantum_numbers_mask (.false., .true., .false.) &
              .or. qn_mask_in
      qn_mask(data%n_in+1:) = &
           new_quantum_numbers_mask (.true., .true., .true.)
    if (core%use_color_factors) then
       call evaluator_init_square (state%trace, &
            state%int_eff, qn_mask, &
            data%cf_index, data%color_factors, col, nc=core%nc)
    else
       call evaluator_init_square (state%trace, &
            state%int_eff, qn_mask, nc=core%nc)
    end if
    end associate
    state%has_trace = .true.
  end subroutine isolated_state_setup_square_trace
    
@ %def isolated_state_setup_square_trace
@ Setup the evaluator for the transition matrix, exclusive in
helicities where this is requested.  

For all unstable final-state particles we keep polarization according to the
applicable decay options.  If the process is a decay itself, this applies also
to the initial state.

For all polarized final-state particles, we keep polarization including
off-diagonal entries.  We drop helicity completely for unpolarized final-state
particles.

For the initial state, if the particle has not been handled yet, we
apply the provided [[qn_mask_in]] which communicates the beam properties.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_matrix => isolated_state_setup_square_matrix
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_matrix &
       (state, core, model, qn_mask_in, col)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    integer, dimension(:), intent(in) :: col
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    logical :: helmask, helmask_hd
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      allocate (flv (data%n_flv))
      do i = 1, data%n_in + data%n_out      
         call flavor_init (flv, data%flv_state(i,:), model)
         if ((data%n_in == 1 .or. i > data%n_in) &
              .and. any (.not. flavor_is_stable (flv))) then
            helmask = all (flavor_decays_isotropically (flv))
            helmask_hd = all (flavor_decays_diagonal (flv))
            qn_mask(i) = new_quantum_numbers_mask (.false., .true., helmask, &
                 mask_hd = helmask_hd)
         else if (i > data%n_in) then
            helmask = all (.not. flavor_is_polarized (flv))
            qn_mask(i) = new_quantum_numbers_mask (.false., .true., helmask)
         else
            qn_mask(i) = new_quantum_numbers_mask (.false., .true., .false.) &
              .or. qn_mask_in(i)
         end if
      end do
    if (core%use_color_factors) then
       call evaluator_init_square (state%matrix, &
            state%int_eff, qn_mask, &
            data%cf_index, data%color_factors, col, nc=core%nc)
    else
       call evaluator_init_square (state%matrix, state%int_eff, &
            qn_mask, nc=core%nc)
    end if
    end associate
    state%has_matrix = .true.
  end subroutine isolated_state_setup_square_matrix

@ %def isolated_state_setup_square_matrix
@ This procedure initializes the evaluator that computes the
contributions to color flows, neglecting color interference.
The incoming-particle mask can be used to sum over incoming flavor.

Helicity handling: see above.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_flows => isolated_state_setup_square_flows
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_flows (state, core, model, qn_mask_in)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    logical :: helmask, helmask_hd
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      allocate (flv (data%n_flv))
      do i = 1, data%n_in + data%n_out
         call flavor_init (flv, data%flv_state(i,:), model)
         if ((data%n_in == 1 .or. i > data%n_in) &
              .and. any (.not. flavor_is_stable (flv))) then
            helmask = all (flavor_decays_isotropically (flv))
            helmask_hd = all (flavor_decays_diagonal (flv))
            qn_mask(i) = new_quantum_numbers_mask (.false., .false., helmask, &
                 mask_hd = helmask_hd)
         else if (i > data%n_in) then
            helmask = all (.not. flavor_is_polarized (flv))
            qn_mask(i) = new_quantum_numbers_mask (.false., .false., helmask)
         else
            qn_mask(i) = new_quantum_numbers_mask (.false., .false., .false.) &
              .or. qn_mask_in(i)
         end if
      end do
      call evaluator_init_square (state%flows, state%int_eff, qn_mask, &
           expand_color_flows = .true.)
    end associate
    state%has_flows = .true.
  end subroutine isolated_state_setup_square_flows

@ %def isolated_state_setup_square_flows
@ 
\subsection{Evaluator initialization: connected state}
Setup a trace evaluator as a product of two evaluators (incoming state,
effective interaction).  In the result, all quantum numbers are summed over.

If the optional [[int]] interaction is provided, use this for the
first factor in the convolution.  Otherwise, use the final interaction
of the stored [[sf_chain]].

The [[resonant]] flag applies if we want to construct
a decay chain.  The resonance property can propagate to the final
event output.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_trace => connected_state_setup_connected_trace
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_trace &
       (state, isolated, int, resonant)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = new_quantum_numbers_mask (.true., .true., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
    end if
    call evaluator_init_product &
         (state%trace, src_int, isolated%trace, mask, mask, &
          connections_are_resonant = resonant)
    state%has_trace = .true.
  end subroutine connected_state_setup_connected_trace
    
@ %def connected_state_setup_connected_trace
@ Setup a matrix evaluator as a product of two evaluators (incoming
state, effective interation).  In the intermediate state, color and
helicity is summed over.  In the final state, we keep the quantum
numbers which are present in the original evaluators.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_matrix => connected_state_setup_connected_matrix
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_matrix &
       (state, isolated, int, resonant)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = new_quantum_numbers_mask (.false., .true., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
    end if
    call evaluator_init_product &
         (state%matrix, src_int, isolated%matrix, mask, &
          connections_are_resonant = resonant)
    state%has_matrix = .true.
  end subroutine connected_state_setup_connected_matrix
  
@ %def connected_state_setup_connected_matrix
@ Setup a matrix evaluator as a product of two evaluators (incoming
state, effective interation).  In the intermediate state, only
helicity is summed over.  In the final state, we keep the quantum
numbers which are present in the original evaluators.


If the optional [[int]] interaction is provided, use this for the
first factor in the convolution.  Otherwise, use the final interaction
of the stored [[sf_chain]], after creating an intermediate interaction
that includes a correlated color state.  We assume that for a
caller-provided [[int]], this is not necessary.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_flows => connected_state_setup_connected_flows
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_flows &
       (state, isolated, int, resonant)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = new_quantum_numbers_mask (.false., .false., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
       call evaluator_init_color_contractions (state%flows_sf, src_int)
       state%has_flows_sf = .true.
       src_int => evaluator_get_int_ptr (state%flows_sf)
    end if
    call evaluator_init_product &
         (state%flows, src_int, isolated%flows, mask, &
          connections_are_resonant = resonant)
    state%has_flows = .true.
  end subroutine connected_state_setup_connected_flows
  
@ %def connected_state_setup_connected_flows
@ 
\subsection{Cuts and expressions}
Set up the [[subevt]] that corresponds to the connected interaction.
The index arrays refer to the interaction.

We assign the particles as follows: the beam particles are the first
two (decay process: one) entries in the trace evaluator.  The incoming
partons are identified by their link to the outgoing partons of the
structure-function chain.  The outgoing partons are those of the trace
evaluator, which include radiated partons during the
structure-function chain.
<<Parton states: connected state: TBP>>=
  procedure :: setup_subevt => connected_state_setup_subevt
<<Parton states: procedures>>=
  subroutine connected_state_setup_subevt (state, sf_chain, f_beam, f_in, f_out)
    class(connected_state_t), intent(inout), target :: state
    type(sf_chain_instance_t), intent(in), target :: sf_chain
    type(flavor_t), dimension(:), intent(in) :: f_beam, f_in, f_out
    integer :: n_beam, n_in, n_out, n_vir, n_tot, i, j
    integer, dimension(:), allocatable :: i_beam, i_in, i_out
    integer :: sf_out_i
    type(interaction_t), pointer :: int, sf_int
    int => evaluator_get_int_ptr (state%trace)
    sf_int => sf_chain%get_out_int_ptr ()
    n_beam = size (f_beam)
    n_in = size (f_in)
    n_out = size (f_out)
    n_vir = interaction_get_n_vir (int)
    n_tot = interaction_get_n_tot (int)
    allocate (i_beam (n_beam), i_in (n_in), i_out (n_out))
    i_beam = [(i, i = 1, n_beam)]
    do j = 1, n_in
       sf_out_i = sf_chain%get_out_i (j)
       i_in(j) = interaction_find_link (int, sf_int, sf_out_i)
    end do
    i_out = [(i, i = n_vir + 1, n_tot)]
    call state%expr%setup_subevt (int, &
         i_beam, i_in, i_out, f_beam, f_in, f_out)
    state%has_expr = .true.
  end subroutine connected_state_setup_subevt

@ %def connected_state_setup_subevt
@ Initialize the variable list specific for this state/term.  We insert event
variables ([[sqrts_hat]]) and link the process variable list.  The variable
list acquires pointers to subobjects of [[state]], which must therefore have a
[[target]] attribute.
<<Parton states: connected state: TBP>>=
  procedure :: setup_var_list => connected_state_setup_var_list
<<Parton states: procedures>>=
  subroutine connected_state_setup_var_list (state, process_var_list, beam_data)
    class(connected_state_t), intent(inout), target :: state
    type(var_list_t), intent(in), target :: process_var_list
    type(beam_data_t), intent(in) :: beam_data
    call state%expr%setup_vars (beam_data_get_sqrts (beam_data))
    call state%expr%link_var_list (process_var_list)
  end subroutine connected_state_setup_var_list
  
@ %def connected_state_setup_var_list
@ Allocate the cut expression etc.
<<Parton states: connected state: TBP>>=
  procedure :: setup_cuts => connected_state_setup_cuts
  procedure :: setup_scale => connected_state_setup_scale
  procedure :: setup_fac_scale => connected_state_setup_fac_scale
  procedure :: setup_ren_scale => connected_state_setup_ren_scale
  procedure :: setup_weight => connected_state_setup_weight
<<Parton states: procedures>>=
  subroutine connected_state_setup_cuts (state, ef_cuts)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_cuts
    call state%expr%setup_selection (ef_cuts)
  end subroutine connected_state_setup_cuts
    
  subroutine connected_state_setup_scale (state, ef_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_scale
    call state%expr%setup_scale (ef_scale)
  end subroutine connected_state_setup_scale
    
  subroutine connected_state_setup_fac_scale (state, ef_fac_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_fac_scale
    call state%expr%setup_fac_scale (ef_fac_scale)
  end subroutine connected_state_setup_fac_scale
    
  subroutine connected_state_setup_ren_scale (state, ef_ren_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_ren_scale
    call state%expr%setup_ren_scale (ef_ren_scale)
  end subroutine connected_state_setup_ren_scale
    
  subroutine connected_state_setup_weight (state, ef_weight)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_weight
    call state%expr%setup_weight (ef_weight)
  end subroutine connected_state_setup_weight
    
@ %def connected_state_setup_expressions
@ Reset the expression object: invalidate the subevt.
<<Parton states: connected state: TBP>>=
  procedure :: reset_expressions => connected_state_reset_expressions
<<Parton states: procedures>>=
  subroutine connected_state_reset_expressions (state)
    class(connected_state_t), intent(inout) :: state
    if (state%has_expr)  call state%expr%reset ()
  end subroutine connected_state_reset_expressions
  
@ %def connected_state_reset_expressions
@ 
\subsection{Evaluation}
Transfer momenta to the trace evaluator and fill the [[subevt]] with
this effective kinematics, if applicable.

Note: we may want to apply a boost for the [[subevt]].
<<Parton states: parton state: TBP>>=
  procedure :: receive_kinematics => parton_state_receive_kinematics
<<Parton states: procedures>>=
  subroutine parton_state_receive_kinematics (state)
    class(parton_state_t), intent(inout), target :: state
    type(interaction_t), pointer :: int
    if (state%has_trace) then
       call evaluator_receive_momenta (state%trace)
       select type (state)
       class is (connected_state_t)
          if (state%has_expr) then
             int => evaluator_get_int_ptr (state%trace)
             call state%expr%fill_subevt (int)
          end if
       end select
    end if
  end subroutine parton_state_receive_kinematics

@ %def parton_state_receive_kinematics
@ Recover kinematics: We assume that the trace evaluator is filled
with momenta.  Send those momenta back to the sources, then fill the
variables and subevent as above.

The incoming momenta of the connected state are not connected to the
isolated state but to the beam interaction.  Therefore, the incoming
momenta within the isolated state do not become defined, yet.
Instead, we reconstruct the beam (and ISR) momentum configuration.
<<Parton states: parton state: TBP>>=
  procedure :: send_kinematics => parton_state_send_kinematics
<<Parton states: procedures>>=
  subroutine parton_state_send_kinematics (state)
    class(parton_state_t), intent(inout), target :: state
    type(interaction_t), pointer :: int
    if (state%has_trace) then
       call evaluator_send_momenta (state%trace)
       select type (state)
       class is (connected_state_t)
          int => evaluator_get_int_ptr (state%trace)
          call state%expr%fill_subevt (int)
       end select
    end if
  end subroutine parton_state_send_kinematics

@ %def parton_state_send_kinematics
@ Evaluate the expressions.  The routine evaluates first the cut expression.
If the event passes, it evaluates the other expressions.  Where no expressions
are defined, default values are inserted.
<<Parton states: connected state: TBP>>=
  procedure :: evaluate_expressions => connected_state_evaluate_expressions
<<Parton states: procedures>>=
  subroutine connected_state_evaluate_expressions (state, passed, &
       scale, fac_scale, ren_scale, weight)
    class(connected_state_t), intent(inout) :: state
    logical, intent(out) :: passed
    real(default), intent(out) :: scale, fac_scale, ren_scale, weight
    if (state%has_expr) then
       call state%expr%evaluate (passed, scale, fac_scale, ren_scale, weight)
    end if
  end subroutine connected_state_evaluate_expressions
    
@ %def connected_state_evaluate_expressions
@ Evaluate the structure-function chain, if it is allocated
explicitly.  The argument is the factorization scale.

If the chain is merely a pointer, the chain should already be
evaluated at this point.
<<Parton states: isolated state: TBP>>=
  procedure :: evaluate_sf_chain => isolated_state_evaluate_sf_chain
<<Parton states: procedures>>=
  subroutine isolated_state_evaluate_sf_chain (state, fac_scale)
    class(isolated_state_t), intent(inout) :: state
    real(default), intent(in) :: fac_scale
    if (state%sf_chain_is_allocated) then
       call state%sf_chain_eff%evaluate (fac_scale)
    end if
  end subroutine isolated_state_evaluate_sf_chain
  
@ %def isolated_state_evaluate_sf_chain
@ Evaluate the trace. 
<<Parton states: parton state: TBP>>=
  procedure :: evaluate_trace => parton_state_evaluate_trace
<<Parton states: procedures>>=
  subroutine parton_state_evaluate_trace (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_trace) then
       call state%trace%evaluate ()
    end if
  end subroutine parton_state_evaluate_trace

@ %def parton_state_evaluate_trace
@ Evaluate the extra evaluators that we need for physical events. 
<<Parton states: parton state: TBP>>=
  procedure :: evaluate_event_data => parton_state_evaluate_event_data
<<Parton states: procedures>>=
  subroutine parton_state_evaluate_event_data (state)
    class(parton_state_t), intent(inout) :: state
    select type (state)
    type is (connected_state_t)
       if (state%has_flows_sf) then
          call evaluator_receive_momenta (state%flows_sf)
          call state%flows_sf%evaluate ()
       end if
    end select
    if (state%has_matrix) then
       call evaluator_receive_momenta (state%matrix)
       call state%matrix%evaluate ()
    end if
    if (state%has_flows) then
       call evaluator_receive_momenta (state%flows)
       call state%flows%evaluate ()
    end if
  end subroutine parton_state_evaluate_event_data

@ %def parton_state_evaluate_event_data
@ Normalize the helicity density matrix by its trace, i.e., factor out
the trace and put it into an overall normalization factor.  The trace
and flow evaluators are unchanged.
<<Parton states: parton state: TBP>>=
  procedure :: normalize_matrix_by_trace => &
       parton_state_normalize_matrix_by_trace
<<Parton states: procedures>>=
  subroutine parton_state_normalize_matrix_by_trace (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_matrix) then
       call evaluator_normalize_by_trace (state%matrix)
    end if
  end subroutine parton_state_normalize_matrix_by_trace
  
@ %def parton_state_normalize_matrix_by_trace
@
\subsection{Accessing the state}
Three functions return a pointer to the event-relevant interactions.
<<Parton states: parton state: TBP>>=
  procedure :: get_trace_int_ptr => parton_state_get_trace_int_ptr
  procedure :: get_matrix_int_ptr => parton_state_get_matrix_int_ptr
  procedure :: get_flows_int_ptr => parton_state_get_flows_int_ptr
<<Parton states: procedures>>=
  function parton_state_get_trace_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_trace) then
       ptr => evaluator_get_int_ptr (state%trace)
    else
       ptr => null ()
    end if
  end function parton_state_get_trace_int_ptr
  
  function parton_state_get_matrix_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_matrix) then
       ptr => evaluator_get_int_ptr (state%matrix)
    else
       ptr => null ()
    end if
  end function parton_state_get_matrix_int_ptr
  
  function parton_state_get_flows_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_flows) then
       ptr => evaluator_get_int_ptr (state%flows)
    else
       ptr => null ()
    end if
  end function parton_state_get_flows_int_ptr
  
@ %def parton_state_get_trace_int_ptr
@ %def parton_state_get_matrix_int_ptr
@ %def parton_state_get_flows_int_ptr
@ Return the indices of the beam particles and the outgoing particles within
the trace (and thus, matrix and flows) evaluator, respectively.
<<Parton states: connected state: TBP>>=
  procedure :: get_beam_index => connected_state_get_beam_index
  procedure :: get_in_index => connected_state_get_in_index
<<Parton states: procedures>>=
  subroutine connected_state_get_beam_index (state, i_beam)
    class(connected_state_t), intent(in) :: state
    integer, dimension(:), intent(out) :: i_beam
    call state%expr%get_beam_index (i_beam)
  end subroutine connected_state_get_beam_index
  
  subroutine connected_state_get_in_index (state, i_in)
    class(connected_state_t), intent(in) :: state
    integer, dimension(:), intent(out) :: i_in
    call state%expr%get_in_index (i_in)
  end subroutine connected_state_get_in_index
  
@ %def connected_state_get_beam_index
@ %def connected_state_get_in_index
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Elementary Processes}
This module combines hard interactions, phase space, and (for
scatterings) structure functions and interfaces them to the
integration module.

The process object implements the combination of a fixed beam and
structure-function setup with a number of elementary processes.  The
latter are called process components.  The process object
represents an entity which is supposedly observable.  It should
be meaningful to talk about the cross section of a process.  

The individual components of a process are, technically, processes
themselves, but they may have unphysical cross sections which have to
be added for a physical result.  Process components may be exclusive
tree-level elementary processes, dipole subtraction term, loop
corrections, etc.

The beam and structure function setup is common to all process
components.  Thus, there is only one instance of this part.

The process may be a scattering process or a decay process.  In the
latter case, there are no structure functions, and the beam setup
consists of a single particle.  Otherwise, the two classes are treated
on the same footing.

Once a sampling point has been chosen, a process determines a set of
partons with a correlated density matrix of quantum numbers.  In general, each
sampling point will generate, for each process component, one or more
distinct parton configurations.  This is the [[computed]] state.  The
computed state is the subject of the multi-channel integration
algorithm.

For NLO computations, it is necessary to project the computed states
onto another set of parton configurations (e.g., by recombining
certain pairs).  This is the [[observed]] state.  When computing
partonic observables, the information is taken from the observed
state.

For the purpose of event generation, we will later select one parton
configuration from the observed state and collapse the correlated
quantum state.  This configuration is then dressed by applying parton
shower, decays and hadronization.  The decay chain, in particular,
combines a scattering process with possible subsequent decay processes
on the parton level, which are full-fledged process objects themselves.
<<[[processes.f90]]>>=
<<File header>>

module processes

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: twopi4
  use format_utils, only: write_separator
  use unit_tests
  use system_dependencies
  use diagnostics
  use md5
  use cputime
  use os_interface
  use physics_defs, only: conv
  use lorentz
  use sm_qcd
  use pdg_arrays
  use subevents
  use variables
  use expr_base
  use models
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use evaluators
  use particles
  use beam_structures
  use beams
  use sf_mappings
  use sf_base
  use process_constants
  use phs_base
  use phs_single
  use rng_base
  use mci_base
  use mci_midpoint
  use mci_vamp
  
  use vamp !NODEP!  

  use process_constants
  use prclib_interfaces
  use prc_core_def
  use process_libraries
  use prc_test

  use integration_results
  use prc_core
  use parton_states

  use fks_calculation
  use phs_wood
  use phs_fks
  use prc_gosam
  use prc_omega
  use blha_config
  
<<Standard module head>>

<<Processes: public>>

<<Processes: parameters>>

<<Processes: types>>

<<Processes: process part types>>

<<Processes: process type>>

<<Processes: interfaces>>

<<Processes: test types>>

contains

<<Processes: procedures>>

<<Processes: tests>>

end module processes
@ %def processes
@
\subsection{The Process Object}
A process object is the workspace for creating process instances for
event generation.  After initialization, its contents are filled by
integration passes which shape the integration grids and compute cross
sections.  Processes are set up initially from user-level
configuration data.  After calculating integrals and thus developing
integration grid data, the program may use a process
object or a copy of it for the purpose of generating events

The process object consists of several subobjects with their specific
purposes.  The corresponding types are defined below.  (Technically,
the subobject type definitions have to come before the process type
definition, but with NOWEB magic we reverse this order here.)

The [[type]] determines whether we are considering a decay or a
scattering process.

The [[meta]] object describes the process and its environment.  All
contents become fixed when the object is initialized.

The [[config]] object holds physical and technical configuration data
that have been obtained during process initialization, and which are
common to all process components.

The individual process components are configured in the [[component]]
objects.  These objects contain more configuration parameters and
workspace, as needed for the specific process variant.

The [[term]] objects describe parton configurations which are
technically used as phase-space points.  Each process component may
split into several terms with distinct kinematics and particle
content.  Furthermore, each term may project on a different physical
state, e.g., by particle recombination.  The [[term]] object provides
the framework for this projection, for applying cuts, weight, and thus
completing the process calculation.

The [[beam_config]] object describes the incoming particles, either the
decay mother or the scattering beams.  It also contains the structure-function
information.

The [[mci_entry]] objects configure a MC input parameter set and integrator,
each.  The number of parameters depends on the process component and on the
beam and structure-function setup.
<<Processes: public>>=
  public :: process_t
<<Processes: process type>>=
  type :: process_t
     private
     type(process_metadata_t) :: &
          meta
     type(process_config_data_t) :: &
          config
     type(process_counter_t) :: &
          counter
     type(process_component_t), dimension(:), allocatable :: &
          component
     type(process_term_t), dimension(:), allocatable :: &
          term
     type(process_beam_config_t) :: &
          beam_config
     type(process_mci_entry_t), dimension(:), allocatable :: &
          mci_entry
     logical :: nlo_process
   contains
   <<Processes: process: TBP>>
  end type process_t

@ %def process_t
@ 
This procedure is an important debugging and inspection tool; it is
not used during normal operation.  The process object is written
to a file (identified by unit, which may also be standard output).
Optional flags determine whether we show everything or just the
interesting parts.
<<Processes: process: TBP>>=
  procedure :: write => process_write
@ 
<<Processes: procedures>>=
  subroutine process_write (process, screen, unit, &
       show_all, show_var_list, &
       show_os_data, &
       show_rng_factory, show_model, show_expressions, &
       show_sfchain, &
       show_equivalences, show_history, show_histories, &
       show_forest, show_x, &
       show_subevt, show_evaluators, pacify)
    class(process_t), intent(in) :: process
    logical, intent(in) :: screen
    integer, intent(in), optional :: unit    
    logical, intent(in), optional :: show_all
    logical, intent(in), optional :: show_var_list
    logical, intent(in), optional :: show_os_data
    logical, intent(in), optional :: show_rng_factory
    logical, intent(in), optional :: show_model, show_expressions
    logical, intent(in), optional :: show_sfchain
    logical, intent(in), optional :: show_equivalences
    logical, intent(in), optional :: show_history, show_histories
    logical, intent(in), optional :: show_forest, show_x
    logical, intent(in), optional :: show_subevt, show_evaluators
    logical, intent(in), optional :: pacify
    logical :: all
    logical :: var_list
    logical :: counters
    logical :: os_data
    logical :: rng_factory, model, expressions
    integer :: u, i
    u = given_output_unit (unit)
    if (present (show_all)) then
       all = show_all
    else
       all = .false.
    end if
    var_list = .false.
    counters = .true.
    os_data = .false.
    model = .false.
    rng_factory = .true.
    expressions = .false.
    if (present (show_var_list)) then
       all = .false.; var_list = show_var_list
    end if
    if (present (show_os_data)) then
       all = .false.; os_data = show_os_data
    end if
    if (present (show_rng_factory)) then
       all = .false.; rng_factory = show_rng_factory
    end if
    if (present (show_model)) then
       all = .false.; model = show_model
    end if
    if (present (show_expressions)) then
       all = .false.; expressions = show_expressions
    end if
    if (all) then
       var_list = .true.
       rng_factory = .true.
       model = .true.
       expressions = .true.
    end if
    if (screen) then
       write (msg_buffer, "(A)")  repeat ("-", 72)
       call msg_message ()
    else
       call write_separator (u, 2)
    end if
    call process%meta%write (u, var_list, screen)
    if (process%meta%type == PRC_UNKNOWN) then
       call write_separator (u, 2)
       return
    else
       if (.not. screen)  call write_separator (u)
    end if
    if (screen)  return
    call process%config%write &
         (u, counters, os_data, rng_factory, model, expressions)
    call write_separator (u, 2)
    if (allocated (process%component)) then
       write (u, "(1x,A)") "Process component configuration:"
       do i = 1, size (process%component)
          call write_separator (u)
          call process%component(i)%write (u)
       end do
    else
       write (u, "(1x,A)") "Process component configuration: [undefined]"
    end if
    call write_separator (u, 2)
    if (allocated (process%term)) then
       write (u, "(1x,A)") "Process term configuration:"
       do i = 1, size (process%term)
          call write_separator (u)
          call process%term(i)%write (u)
       end do
    else
       write (u, "(1x,A)") "Process term configuration: [undefined]"
    end if
    call write_separator (u, 2)
    call process%beam_config%write (u)
    call write_separator (u, 2)
    if (allocated (process%mci_entry)) then
       write (u, "(1x,A)") "Multi-channel integrator configurations:"
       do i = 1, size (process%mci_entry)
          call write_separator (u)
          write (u, "(1x,A,I0,A)")  "MCI #", i, ":"
          call process%mci_entry(i)%write (u, pacify)
       end do
    end if
    call write_separator (u, 2)
  end subroutine process_write
      
@ %def process_write
@ Screen output.  Write a short account of the process configuration
and the current results.  The verbose version lists the components,
the short version just the results.
<<Processes: process: TBP>>=
  procedure :: show => process_show
<<Processes: procedures>>=
  subroutine process_show (object, unit, verbose)
    class(process_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    logical :: verb
    u = given_output_unit (unit)
    verb = .true.;  if (present (verbose)) verb = verbose
    if (verb) then
       call object%meta%show (u, object%config%model%get_name ())
       select case (object%meta%type)
       case (PRC_DECAY)
          write (u, "(2x,A)", advance="no")  "Computed width ="
       case (PRC_SCATTERING)
          write (u, "(2x,A)", advance="no")  "Computed cross section ="
       case default;  return
       end select
    else 
       write (u, "(A)", advance="no") char (object%meta%id)
       select case (object%meta%num_id)
       case (0)
          write (u, "(':')")
       case default
          write (u, "(1x,'(',I0,')',':')") object%meta%num_id
       end select
       write (u, "(2x)", advance="no")
    end if
    write (u, "(ES14.7,1x,'+-',ES9.2)", advance="no") &
         object%get_integral_tot (), object%get_error_tot ()
    select case (object%meta%type)
    case (PRC_DECAY)
       write (u, "(1x,A)")  "GeV"
    case (PRC_SCATTERING)
       write (u, "(1x,A)")  "fb"
    end select
  end subroutine process_show
    
@ %def process_show
@ Finalizer.  Explicitly iterate over all subobjects that may contain
allocated pointers.
<<Processes: process: TBP>>=
  procedure :: final => process_final
<<Processes: procedures>>=
  subroutine process_final (process)
    class(process_t), intent(inout) :: process
    integer :: i
    call process%meta%final ()
    call process%config%final ()
    if (allocated (process%component)) then
       do i = 1, size (process%component)
          call process%component(i)%final ()
       end do
    end if
    if (allocated (process%term)) then
       do i = 1, size (process%term)
          call process%term(i)%final ()
       end do
    end if
    call process%beam_config%final ()
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          call process%mci_entry(i)%final ()
       end do
    end if
  end subroutine process_final
    
@ %def process_final
@
\subsubsection{Process setup}
Initialize a process.  We need a process library, the name of the process,
and a run ID.
<<Processes: process: TBP>>=
  procedure :: init => process_init
<<Processes: procedures>>=
  subroutine process_init &
       (process, proc_id, run_id, lib, os_data, qcd, rng_factory, model_list)
    class(process_t), intent(out) :: process
    type(string_t), intent(in) :: proc_id
    type(string_t), intent(in) :: run_id
    type(process_library_t), intent(in), target :: lib
    type(os_data_t), intent(in) :: os_data
    type(qcd_t), intent(in) :: qcd
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    type(model_list_t), intent(inout) :: model_list
    if (.not. lib%is_active ()) then
       call msg_bug ("Process init: inactive library not handled yet")
    end if
    if (.not. lib%contains (proc_id)) then
       call msg_fatal ("Process library doesn't contain process '" &
            // char (proc_id) // "'")
       return
    end if
    associate (meta => process%meta)
      call meta%init (proc_id, run_id, lib)
      call process%config%init (meta, os_data, qcd, rng_factory, model_list)
      allocate (process%component (meta%n_components))
    end associate
    process%nlo_process = lib%get_nlo_process (proc_id)
  end subroutine process_init
  
@ %def process_init
@ Store a snapshot of a variable list.  We link this snapshot
to the current model instance and use it to update the model
parameters in this instance.  After update, synchronize the var list, i.e.,
fetch any new values of derived parameters.
<<Processes: process: TBP>>=
  procedure :: set_var_list => process_set_var_list
<<Processes: procedures>>=
  subroutine process_set_var_list (process, var_list)
    class(process_t), intent(inout) :: process
    type(var_list_t), intent(in) :: var_list
    call var_list_init_snapshot (process%meta%var_list, var_list)
    call var_list_set_original_pointers (process%meta%var_list, &
         process%config%model%get_var_list_ptr ())
    call var_list_restore (process%meta%var_list)
    call process%config%model%update_parameters ()
    call var_list_synchronize (process%meta%var_list, &
         process%config%model%get_var_list_ptr ())
  end subroutine process_set_var_list
  
@ %def process_set_var_list
@ Initialize the process components, one by one, using a template for
the process core object.  The template is taken only for allocating
the correct type; the contents are set by extracting the process entry
from the library.
<<Processes: process: TBP>>=
  procedure :: init_component => process_init_component
<<Processes: procedures>>=
  subroutine process_init_component &
       (process, index, core_template, mci_template, phs_config_template, &
        fks_template, gosam_template)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: index
    class(prc_core_t), intent(in), allocatable :: core_template
    class(mci_t), intent(in), allocatable :: mci_template
    class(phs_config_t), intent(in), allocatable :: phs_config_template
    type(fks_template_t), intent(in), optional :: fks_template
    type(gosam_writer_template_t), intent(inout), optional :: gosam_template
    call process%component(index)%init (index, &
         process%meta, process%config, &
         core_template, mci_template, phs_config_template, &
         gosam_template, fks_template)
    if (.not. process%component(index)%active) then
       call process%meta%deactivate_component(index)
    end if
  end subroutine process_init_component

@ %def process_init_component
@ Determine the process terms for each process component. 
<<Processes: process: TBP>>=
  procedure :: setup_terms => process_setup_terms
<<Processes: procedures>>=
  subroutine process_setup_terms (process)
    class(process_t), intent(inout) :: process
    type(model_t), pointer :: model
    integer :: i, j, k
    integer, dimension(:), allocatable :: n_entry
    integer :: n_components, n_tot
    model => process%config%model
    n_components = process%meta%n_components
    allocate (n_entry (n_components), source = 0)
    do i = 1, n_components
       associate (component => process%component(i))
         if (component%active)  n_entry(i) = component%core%get_n_terms () 
       end associate
    end do
    n_tot = sum (n_entry)
    allocate (process%term (n_tot))
    k = 0
    do i = 1, n_components
       associate (component => process%component(i))
         if (.not. component%active)  cycle
         associate (core => component%core)
           allocate (component%i_term (n_entry(i)))
           do j = 1, n_entry(i)
              component%i_term(j) = k + j
              call process%term(k+j)%init (k+j, i, j, core, model)
           end do
         end associate
       end associate
       k = k + n_entry(i)
    end do
    process%config%n_terms = n_tot
  end subroutine process_setup_terms

@ %def process_setup_terms
@ Initialize the beam setup.  This is the trivial version where the
incoming state of the matrix element coincides with the initial state
of the process.  For a scattering process, we need the c.m. energy,
all other variables are set to their default values (no polarization,
lab frame and c.m.\ frame coincide, etc.)

We assume that all components consistently describe a scattering
process, i.e., two incoming particles.

Note: The current layout of the [[beam_data_t]] record requires that the
flavor for each beam is unique.  For processes with multiple
flavors in the initial state, one has to set up beams explicitly.
This restriction could be removed by extending the code in the
[[beams]] module.
<<Processes: process: TBP>>=
  procedure :: setup_beams_sqrts => process_setup_beams_sqrts
<<Processes: procedures>>=
  subroutine process_setup_beams_sqrts (process, sqrts, beam_structure)
    class(process_t), intent(inout) :: process
    real(default), intent(in) :: sqrts
    type(beam_structure_t), intent(in), optional :: beam_structure
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_in
    integer, dimension(2) :: pdg_scattering
    type(flavor_t), dimension(2) :: flv_in
    integer :: i, i0
    allocate (pdg_in (2, process%meta%n_components))
    i0 = 0
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
          if (i0 == 0)  i0 = i
       end if
    end do
    do i = 1, process%meta%n_components
       if (.not. process%component(i)%active) then
          pdg_in(:,i) = pdg_in(:,i0)
       end if
    end do
    if (all (pdg_array_get_length (pdg_in) == 1) .and. &
         all (pdg_in(1,:) == pdg_in(1,i0)) .and. &
         all (pdg_in(2,:) == pdg_in(2,i0))) then
       pdg_scattering = pdg_array_get (pdg_in(:,i0), 1)
       call flavor_init (flv_in, pdg_scattering, process%config%model)
       call process%beam_config%init_scattering (flv_in, sqrts, beam_structure)
    else
       call msg_fatal ("Setting up process '" // char (process%meta%id) // "':", &
           [var_str ("   --------------------------------------------"), &
            var_str ("Inconsistent initial state. This happens if either "), &
            var_str ("several processes with non-matching initial states "), &
            var_str ("have been added, or for a single process with an "), &
            var_str ("initial state flavor sum. In that case, please set beams "), &
            var_str ("explicitly [singling out a flavor / structure function.]")]) 
    end if
  end subroutine process_setup_beams_sqrts

@ %def process_setup_beams_sqrts
@ This is the version that applies to decay processes.  The energy is the
particle mass, hence no extra argument.
<<Processes: process: TBP>>=
  procedure :: setup_beams_decay => process_setup_beams_decay
<<Processes: procedures>>=
  subroutine process_setup_beams_decay (process, rest_frame, beam_structure)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: rest_frame
    type(beam_structure_t), intent(in), optional :: beam_structure
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_in
    integer, dimension(1) :: pdg_decay
    type(flavor_t), dimension(1) :: flv_in
    integer :: i, i0
    allocate (pdg_in (1, process%meta%n_components))
    i0 = 0
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
          if (i0 == 0)  i0 = i
       end if
    end do
    do i = 1, process%meta%n_components
       if (.not. process%component(i)%active) then
          pdg_in(:,i) = pdg_in(:,i0)
       end if
    end do
    if (all (pdg_array_get_length (pdg_in) == 1) &
         .and. all (pdg_in(1,:) == pdg_in(1,i0))) then
       pdg_decay = pdg_array_get (pdg_in(:,i0), 1)
       call flavor_init (flv_in, pdg_decay, process%config%model)
       call process%beam_config%init_decay (flv_in, rest_frame, beam_structure)
    else
       call msg_fatal ("Setting up decay '" &
            // char (process%meta%id) // "': decaying particle not unique")
    end if
  end subroutine process_setup_beams_decay
    
@ %def process_setup_beams_decay
@ We have to make sure that the masses of the various flavors
in a given position in the particle string coincide.
<<Processes: process: TBP>>=
  procedure :: check_masses => process_check_masses
<<Processes: procedures>>=
  subroutine process_check_masses (process)
       class(process_t), intent(in) :: process
       type(flavor_t), dimension(:), allocatable :: flv
       real(default), dimension(:), allocatable :: mass
       integer :: i, j
       do i = 1, process%meta%n_components
          if (.not. process%component(i)%active)  cycle
          associate (data => process%component(i)%core%data)
            allocate (flv (data%n_flv), mass (data%n_flv))
            do j = 1, data%n_in + data%n_out
               call flavor_init (flv, data%flv_state(j,:), process%config%model)
               mass = flavor_get_mass (flv)
               if (any (mass /= mass(1))) then
                  call msg_fatal ("Process '" // char (process%meta%id) // "': " &
                       // "mass values in flavor combination do not coincide. ")
               end if
            end do
            deallocate (flv, mass)
          end associate
       end do
   end subroutine process_check_masses
  
@ %def process_check_masses
@ For some structure functions we need to get the list of initial
state flavors.  This is a two-dimensional array.  The first index is
the beam index, the second index is the component index.  Each array
element is itself a PDG array object, which consists of the list of
incoming PDG values for this beam and component.
<<Processes: process: TBP>>=
  procedure :: get_pdg_in => process_get_pdg_in
<<Processes: procedures>>=
  subroutine process_get_pdg_in (process, pdg_in)
    class(process_t), intent(in) :: process
    type(pdg_array_t), dimension(:,:), allocatable, intent(out) :: pdg_in
    integer :: i
    allocate (pdg_in (process%config%n_in, process%meta%n_components))
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
       end if
    end do    
  end subroutine process_get_pdg_in
  
@ %def process_get_pdg_in
@ Initialize from a complete beam setup.
<<Processes: process: TBP>>=
  procedure :: setup_beams_beam_structure => process_setup_beams_beam_structure
<<Processes: procedures>>=
  subroutine process_setup_beams_beam_structure &
       (process, beam_structure, sqrts, model, decay_rest_frame)
    class(process_t), intent(inout) :: process
    type(beam_structure_t), intent(in) :: beam_structure
    real(default), intent(in) :: sqrts
    type(model_t), intent(in), target :: model
    logical, intent(in), optional :: decay_rest_frame
    if (process%get_n_in () == beam_structure%get_n_beam ()) then
       call process%beam_config%init_beam_structure &
            (beam_structure, sqrts, model, decay_rest_frame)
    else if (beam_structure%get_n_beam () == 0) then
       call msg_fatal ("Asymmetric beams: missing beam particle specification")
    else
       call msg_fatal ("Mismatch of process and beam setup (scattering/decay)")
    end if
  end subroutine process_setup_beams_beam_structure
  
@ %def process_setup_beams_beam_structure
@ Notify the user about beam setup.
<<Processes: process: TBP>>=
  procedure :: beams_startup_message => process_beams_startup_message
<<Processes: procedures>>=     
  subroutine process_beams_startup_message (process, unit, beam_structure)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: unit
    type(beam_structure_t), intent(in), optional :: beam_structure
    call process%beam_config%startup_message (unit, beam_structure)
  end subroutine process_beams_startup_message
  
@ %def process_beams_startup_message
@ We complete the kinematics configuration after the beam setup, but before we
configure the chain of structure functions.  The reason is that we need the
total energy [[sqrts]] for the kinematics, but the structure-function setup
requires the number of channels, which depends on the kinematics
configuration.  For instance, the kinematics module may return the need for
parameterizing an s-channel resonance.
<<Processes: process: TBP>>=
  procedure :: configure_phs => process_configure_phs
<<Processes: procedures>>=
  subroutine process_configure_phs (process, rebuild, ignore_mismatch)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    real(default) :: sqrts
    integer :: i, i_born
    class(phs_config_t), allocatable :: phs_config_born
    sqrts = process%get_sqrts ()
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
            if (process%nlo_process) then
               select case (char (component%config%get_nlo_type ()))
               case ('Born', 'Virtual', 'Subtraction')
                  call component%configure_phs &
                      (sqrts, process%beam_config, rebuild, ignore_mismatch)
               case ('Real')
                  i_born = component%config%get_associated_born ()
                  call process%component(i_born)%extract_phs_config (phs_config_born)
                  select type (phs_config_born)
                  type is (phs_wood_config_t)
                     call  component%configure_phs &
                          (sqrts, process%beam_config, rebuild, ignore_mismatch, &
                           phs_config_born)
                  end select
                  call process%component(i_born)%restore_phs_config (phs_config_born)
               end select
            else
               call component%configure_phs &
                    (sqrts, process%beam_config, rebuild, ignore_mismatch)
            end if
         end if
       end associate
    end do
  end subroutine process_configure_phs
         
@ %def process_configure_phs
@ Insert the structure-function configuration data.  First allocate the
storage, then insert data one by one.  The third procedure declares a
mapping (of the MC input parameters) for a specific channel and
structure-function combination.

We take the number of channels from the corresponding entry in the
[[config_data]] section.

Otherwise, these a simple wrapper routines.  The extra level in the
call tree may allow for simple addressing of multiple concurrent beam
configurations, not implemented currently.

If we do not want structure functions, we simply do not call those procedures.
<<Processes: process: TBP>>=
  procedure :: init_sf_chain => process_init_sf_chain
  generic :: set_sf_channel => set_sf_channel_single
  procedure :: set_sf_channel_single => process_set_sf_channel
  generic :: set_sf_channel => set_sf_channel_array
  procedure :: set_sf_channel_array => process_set_sf_channel_array
<<Processes: procedures>>=
  subroutine process_init_sf_chain (process, sf_config, sf_trace_file)
    class(process_t), intent(inout) :: process
    type(sf_config_t), dimension(:), intent(in) :: sf_config
    type(string_t), intent(in), optional :: sf_trace_file
    type(string_t) :: file
    if (present (sf_trace_file)) then
       if (sf_trace_file /= "") then
          file = sf_trace_file
       else
          file = process%get_id () // "_sftrace.dat"
       end if
       call process%beam_config%init_sf_chain (sf_config, file)
    else
       call process%beam_config%init_sf_chain (sf_config)
    end if
  end subroutine process_init_sf_chain

  subroutine process_set_sf_channel (process, c, sf_channel)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: c
    type(sf_channel_t), intent(in) :: sf_channel
    call process%beam_config%set_sf_channel (c, sf_channel)
  end subroutine process_set_sf_channel
  
  subroutine process_set_sf_channel_array (process, sf_channel)
    class(process_t), intent(inout) :: process
    type(sf_channel_t), dimension(:), intent(in) :: sf_channel
    integer :: c
    call process%beam_config%allocate_sf_channels (size (sf_channel))
    do c = 1, size (sf_channel)
       call process%beam_config%set_sf_channel (c, sf_channel(c))
    end do
  end subroutine process_set_sf_channel_array
  
@ %def process_init_sf_chain
@ %def process_set_sf_channel
@ Notify about the structure-function setup.
<<Processes: process: TBP>>=
  procedure :: sf_startup_message => process_sf_startup_message
<<Processes: procedures>>=
  subroutine process_sf_startup_message (process, sf_string, unit)
    class(process_t), intent(in) :: process
    type(string_t), intent(in) :: sf_string
    integer, intent(in), optional :: unit
    call process%beam_config%sf_startup_message (sf_string, unit)
  end subroutine process_sf_startup_message
  
@ %def process_sf_startup_message
@ As soon as both the kinematics configuration and the
structure-function setup are complete, we match parameterizations
(channels) for both.  The matching entries are (re)set in the
[[component]] phase-space configuration, while the structure-function
configuration is left intact.
<<Processes: process: TBP>>=
  procedure :: collect_channels => process_collect_channels
<<Processes: procedures>>=
  subroutine process_collect_channels (process, coll)
    class(process_t), intent(inout) :: process
    type(phs_channel_collection_t), intent(inout) :: coll
    integer :: i
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
            call component%collect_channels (coll)
         end if
       end associate
    end do
  end subroutine process_collect_channels
         
@ %def process_collect_channels
@ Independently, we should be able to check if any component doesn't
contain phase-space parameters.  Such a process can only be integrated
if there are structure functions.
<<Processes: process: TBP>>=
  procedure :: contains_trivial_component => process_contains_trivial_component
<<Processes: procedures>>=
  function process_contains_trivial_component (process) result (flag)
    class(process_t), intent(in) :: process
    logical :: flag
    integer :: i
    flag = .true.
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
            if (component%get_n_phs_par () == 0)  return
         end if
       end associate
    end do
    flag = .false.
  end function process_contains_trivial_component
  
@ %def process_contains_trivial_component
@ Determine the MC parameter set structure and the MCI configuration for each
process component.  We need data from the structure-function and phase-space
setup, so those should be complete before this is called.  We also
make a random-number generator instance for each MCI group.
<<Processes: process: TBP>>=
  procedure :: setup_mci => process_setup_mci
<<Processes: procedures>>=
  subroutine process_setup_mci (process)
    class(process_t), intent(inout) :: process
    integer :: n_mci, i_mci
    integer :: i
    n_mci = 0
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active .and. component%core%needs_mcset ()) then
            n_mci = n_mci + 1
            component%i_mci = n_mci
         end if
       end associate
    end do
    process%config%n_mci = n_mci
    if (.not. allocated (process%config%rng_factory)) &
         call msg_bug ("Process setup: rng factory not allocated")
    allocate (process%mci_entry (n_mci))
    i_mci = 0
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active .and. component%core%needs_mcset ()) then
            i_mci = i_mci + 1
            associate (mci_entry => process%mci_entry(i_mci))
              call mci_entry%init (process%meta%type, &
                   i_mci, i, component, process%beam_config, &
                   process%config%rng_factory)
            end associate
         end if
       end associate
    end do
    do i_mci = 1, size (process%mci_entry)
       call process%mci_entry(i_mci)%set_parameters (process%meta%var_list)
    end do
  end subroutine process_setup_mci
  
@ %def process_setup_mci
@ Set cuts.  This is a parse node, namely the right-hand side of the [[cut]]
assignment.  When creating an instance, we compile this into an evaluation
tree.  The parse node may be null.
<<Processes: process: TBP>>=
  procedure :: set_cuts => process_set_cuts
<<Processes: procedures>>=
  subroutine process_set_cuts (process, ef_cuts)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_cuts
    allocate (process%config%ef_cuts, source = ef_cuts)
  end subroutine process_set_cuts
  
@ %def process_set_cuts
@ Analogously for the other expressions.
<<Processes: process: TBP>>=
  procedure :: set_scale => process_set_scale
  procedure :: set_fac_scale => process_set_fac_scale
  procedure :: set_ren_scale => process_set_ren_scale
  procedure :: set_weight => process_set_weight
<<Processes: procedures>>=
  subroutine process_set_scale (process, ef_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_scale
    allocate (process%config%ef_scale, source = ef_scale)
  end subroutine process_set_scale
  
  subroutine process_set_fac_scale (process, ef_fac_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_fac_scale
    allocate (process%config%ef_fac_scale, source = ef_fac_scale)
  end subroutine process_set_fac_scale
  
  subroutine process_set_ren_scale (process, ef_ren_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_ren_scale
    allocate (process%config%ef_ren_scale, source = ef_ren_scale)
  end subroutine process_set_ren_scale
  
  subroutine process_set_weight (process, ef_weight)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_weight
    allocate (process%config%ef_weight, source = ef_weight)
  end subroutine process_set_weight
  
@ %def process_set_scale
@ %def process_set_fac_scale
@ %def process_set_ren_scale
@ %def process_set_weight
@
\subsubsection{MD5 sum}
The MD5 sum of the process object should reflect the state completely,
including integration results.  It is used for checking the integrity
of event files.  This global checksum includes checksums for the
various parts.  In particular, the MCI object receives a checksum that
includes the configuration of all configuration parts relevant for an
individual integration.  This checksum is used for checking the
integrity of integration grids.

We do not need MD5 sums for the process terms, since these are
generated from the component definitions.
<<Processes: process: TBP>>=
  procedure :: compute_md5sum => process_compute_md5sum
<<Processes: procedures>>=
  subroutine process_compute_md5sum (process)
    class(process_t), intent(inout) :: process
    integer :: i
    call process%config%compute_md5sum ()
    do i = 1, process%config%n_components
       associate (component => process%component(i))
         if (component%active) then
            call component%compute_md5sum ()
         end if
       end associate
    end do
    call process%beam_config%compute_md5sum ()
    do i = 1, process%config%n_mci
       call process%mci_entry(i)%compute_md5sum &
            (process%config, process%component, process%beam_config)
    end do
  end subroutine process_compute_md5sum
  
@ %def process_compute_md5sum
@
\subsubsection{Integration and event generation}
The sampler test should just evaluate the squared matrix element [[n_calls]]
times, discarding the results, and return.  This can be done before
integration, e.g., for timing estimates.
<<Processes: process: TBP>>=
  procedure :: sampler_test => process_sampler_test
<<Processes: procedures>>=
  subroutine process_sampler_test (process, instance, i_mci, n_calls)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout), target :: instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: n_calls
    call process%mci_entry(i_mci)%sampler_test (instance, n_calls)
  end subroutine process_sampler_test

@ %def process_sampler_test
@ Integrate the process, using a previously initialized process
instance.  We select one of the available MCI integrators by its index
[[i_mci]] and thus integrate over (structure functions and) phase
space for the associated (group of) process component(s).

The finalizer should be called after all integration passes have been
completed.  It will, for instance, write a summary of the integration
results.

[[integrate_dummy]] does a ``dummy'' integration in the sense that
nothing is done but just empty integration results appended.
<<Processes: process: TBP>>=
  procedure :: integrate => process_integrate
  procedure :: final_integration => process_final_integration
  procedure :: integrate_dummy => process_integrate_dummy
<<Processes: procedures>>=
  subroutine process_integrate (process, instance, i_mci, n_it, n_calls, &
       adapt_grids, adapt_weights, final, pacify)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    logical, intent(in), optional :: adapt_grids
    logical, intent(in), optional :: adapt_weights
    logical, intent(in), optional :: final, pacify
    call process%mci_entry(i_mci)%integrate (instance, n_it, n_calls, &
         adapt_grids, adapt_weights, final, pacify, i_mci)        
    call instance%display_real_kinematics (i_mci)
  end subroutine process_integrate

  subroutine process_final_integration (process, i_mci)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%final_integration ()
  end subroutine process_final_integration
  
  subroutine process_integrate_dummy (process)
    class(process_t), intent(inout) :: process
    type(integration_results_t) :: results
    integer :: u_log
    u_log = logfile_unit ()
    call results%init (process%meta%type)
    call results%display_init (process%meta%type, screen = .true., unit = u_log)
    call results%new_pass ()
    call results%record (1, 0, 0._default, 0._default, 0._default)
    call results%display_final ()
  end subroutine process_integrate_dummy
  
@ %def process_integrate
@ %def process_final_integration
@ %def process_integrate_dummy
@ Display the final results for the sum of all components.  (This is useful,
obviously, only if there is more than one component.)
<<Processes: process: TBP>>=
  procedure :: display_summed_results => process_display_summed_results
<<Processes: procedures>>=
  subroutine process_display_summed_results (process)
    class(process_t), intent(inout) :: process
    type(integration_results_t) :: results
    integer :: u_log
    u_log = logfile_unit ()
    call results%init (process%meta%type)
    call results%display_init (process%meta%type, screen = .true., unit = u_log)
    call results%new_pass ()
    call results%record (1, 0, &
         process%get_integral (), &
         process%get_error (), &
         process%get_efficiency ())
    if (process%nlo_process) &
       call results%record_correction (process%get_correction (), &
                                       process%get_correction_error ())
    call results%display_final ()
  end subroutine process_display_summed_results

@ %def process_display_summed_results
@ Run LaTeX/Metapost to generate a ps/pdf file for the integration
history.  We (re)write the driver file -- just in case it has been
missed before -- then we compile it.
<<Processes: process: TBP>>=
  procedure :: display_integration_history => &
       process_display_integration_history
<<Processes: procedures>>=
  subroutine process_display_integration_history &
       (process, i_mci, filename, os_data, eff_reset)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    type(string_t), intent(in) :: filename
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: eff_reset
    call integration_results_write_driver &
         (process%mci_entry(i_mci)%results, filename, eff_reset)
    call integration_results_compile_driver &
         (process%mci_entry(i_mci)%results, filename, os_data)
  end subroutine process_display_integration_history

@ %def subroutine process_display_integration_history
@ Write a complete logfile (with hardcoded name based on the process ID).
We do not write internal data.
<<Processes: process: TBP>>=
  procedure :: write_logfile => process_write_logfile
<<Processes: procedures>>=
  subroutine process_write_logfile (process, i_mci, filename)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    type(string_t), intent(in) :: filename    
    type(time_t) :: time
    integer :: unit, u
    unit = free_unit ()
    open (unit = unit, file = char (filename), action = "write", &
          status = "replace")
    u = given_output_unit (unit)
    write (u, "(A)")  repeat ("#", 79)
    call process%meta%write (u, .false., .false.)
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(3x,A,ES17.10)")  "Integral   = ", &
         process%mci_entry(i_mci)%get_integral ()
    write (u, "(3x,A,ES17.10)")  "Error      = ", &
         process%mci_entry(i_mci)%get_error ()
    write (u, "(3x,A,ES17.10)")  "Accuracy   = ", &
         process%mci_entry(i_mci)%get_accuracy ()
    write (u, "(3x,A,ES17.10)")  "Chi2       = ", &
         process%mci_entry(i_mci)%get_chi2 ()
    write (u, "(3x,A,ES17.10)")  "Efficiency = ", &
         process%mci_entry(i_mci)%get_efficiency ()
    call process%mci_entry(i_mci)%get_time (time, 10000)
    if (time%is_known ()) then
       write (u, "(3x,A,1x,A)")  "T(10k evt) = ", char (time%to_string_dhms ())
    else
       write (u, "(3x,A)")  "T(10k evt) =  [undefined]"
    end if
    call process%mci_entry(i_mci)%results%write (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%mci_entry(i_mci)%results%write_chain_weights (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%mci_entry(i_mci)%counter%write (u)
    write (u, "(A)")  repeat ("#", 79)
    select type (mci => process%mci_entry(i_mci)%mci)
    type is (mci_midpoint_t)
       write (u, "(1x,A)")  "MC Integrator is Midpoint rule"
    type is (mci_vamp_t)
       write (u, "(1x,A)")  "MC Integrator is VAMP"       
       call write_separator (u)
       call mci%write_history (u)
       call write_separator (u)       
       if (mci%grid_par%use_vamp_equivalences) then
          call vamp_equivalences_write (mci%equivalences, u)          
       else
          write (u, "(3x,A)") "No VAMP equivalences have been used"
       end if
       call write_separator (u)
       call process%mci_entry(i_mci)%write_chain_weights (u) 
    class default
       write (u, "(1x,A)")  "MC Integrator: [unknown]"
    end select
    write (u, "(A)")  repeat ("#", 79)
    call process%beam_config%data%write (u)
    write (u, "(A)")  repeat ("#", 79)
    if (allocated (process%config%ef_cuts)) then
       write (u, "(3x,A)") "Cut expression:"
       call process%config%ef_cuts%write (u)
    else
       write (u, "(3x,A)") "No cuts used."         
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_scale)) then
       write (u, "(3x,A)") "Scale expression:"
       call process%config%ef_scale%write (u)
    else
       write (u, "(3x,A)") "No scale expression was given."
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_fac_scale)) then
       write (u, "(3x,A)") "Factorization scale expression:"
       call process%config%ef_fac_scale%write (u)
    else
       write (u, "(3x,A)") "No factorization scale expression was given."       
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_ren_scale)) then
       write (u, "(3x,A)") "Renormalization scale expression:"
       call process%config%ef_ren_scale%write (u)
    else
       write (u, "(3x,A)") "No renormalization scale expression was given."
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_weight)) then
       call write_separator (u)
       write (u, "(3x,A)") "Weight expression:"
       call process%config%ef_weight%write (u)
    else
       write (u, "(3x,A)") "No weight expression was given."
    end if
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(1x,A)") "Summary of quantum-number states:" 
    write (u, "(1x,A)")  " + sign: allowed and contributing"
    write (u, "(1x,A)")  " no +  : switched off at runtime"
    call process%write_state_summary (u)
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(A)")  "Variable list:"
    call var_list_write (process%meta%var_list, u)
    write (u, "(A)")  repeat ("#", 79)
    close (u)
  end subroutine process_write_logfile

@ %def process_write_logfile
@ Display the quantum-number combinations of the process components, and their
current status (allowed or switched off).
<<Processes: process: TBP>>=
  procedure :: write_state_summary => process_write_state_summary
<<Processes: procedures>>=
  subroutine process_write_state_summary (process, unit)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: unit
    integer :: i, i_component, u
    u = given_output_unit (unit)
    do i = 1, size (process%term)
       call write_separator (u)
       i_component = process%term(i)%i_component
       if (i_component /= 0) then
          call process%term(i)%write_state_summary &
               (process%component(i_component)%core, unit)
       end if
    end do
  end subroutine process_write_state_summary
       
@ %def process_write_state_summary
@ Prepare event generation for the specified MCI entry.  This implies, in
particular, checking the phase-space file.
<<Processes: process: TBP>>=
  procedure :: prepare_simulation => process_prepare_simulation
<<Processes: procedures>>=
  subroutine process_prepare_simulation (process, i_mci)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%prepare_simulation ()
  end subroutine process_prepare_simulation

@ %def process_prepare_simulation
@ 
Generate a weighted event.  We select one of the available MCI
integrators by its index [[i_mci]] and thus generate an event for the
associated (group of) process component(s).  The arguments exactly
correspond to the initializer and finalizer above.

The resulting event is stored in the [[prcoess_instance]] object,
which also holds the workspace of the integrator.

Note: The [[process]] object is declared [[intent(inout)]] because it
contains the random-number state, which changes for each event.
Otherwise, all volatile data are inside the [[instance]] object.
<<Processes: process: TBP>>=
  procedure :: generate_weighted_event => process_generate_weighted_event
  procedure :: generate_unweighted_event => process_generate_unweighted_event
<<Processes: procedures>>=
  subroutine process_generate_weighted_event (process, instance, i_mci)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%generate_weighted_event (instance)
  end subroutine process_generate_weighted_event

  subroutine process_generate_unweighted_event (process, instance, i_mci)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%generate_unweighted_event (instance)
  end subroutine process_generate_unweighted_event

@ %def process_generate_weighted_event
@ %def process_generate_unweighted_event
@ 
This replaces the event generation methods for the situation that the
process instance object has been filled by other means (i.e., reading
and/or recalculating its contents).  We just have to fill in missing
MCI data, especially the event weight.
<<Processes: process: TBP>>=
  procedure :: recover_event => process_recover_event
<<Processes: procedures>>=
  subroutine process_recover_event (process, instance, i_term)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    call process%mci_entry(instance%i_mci)%recover_event (instance, i_term)
  end subroutine process_recover_event

@ %def process_recover_event
@
\subsubsection{Retrieve process data}
Tell whether integral (and error) are known.
<<Processes: process: TBP>>=
  generic :: has_integral => has_integral_tot, has_integral_mci
  procedure :: has_integral_tot => process_has_integral_tot
  procedure :: has_integral_mci => process_has_integral_mci
<<Processes: procedures>>=
  function process_has_integral_mci (process, i_mci) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    logical :: flag
    flag = process%mci_entry(i_mci)%has_integral ()
  end function process_has_integral_mci

  function process_has_integral_tot (process) result (flag)
    class(process_t), intent(in) :: process
    logical :: flag
    integer :: i
    flag = .true.
    do i = 1, size (process%mci_entry)
       flag = flag .and. process%mci_entry(i)%has_integral ()
    end do
  end function process_has_integral_tot
  
@ %def process_has_integral 
@
Return the current integral and error obtained by the integrator [[i_mci]].
<<Processes: process: TBP>>=
  generic :: get_integral => get_integral_tot, get_integral_mci
  generic :: get_error => get_error_tot, get_error_mci
  generic :: get_efficiency => get_efficiency_tot, get_efficiency_mci
  procedure :: get_integral_tot => process_get_integral_tot
  procedure :: get_integral_mci => process_get_integral_mci
  procedure :: get_error_tot => process_get_error_tot
  procedure :: get_error_mci => process_get_error_mci
  procedure :: get_efficiency_tot => process_get_efficiency_tot
  procedure :: get_efficiency_mci => process_get_efficiency_mci
<<Processes: procedures>>=
  function process_get_integral_mci (process, i_mci) result (integral)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: integral
    integral = process%mci_entry(i_mci)%get_integral ()
  end function process_get_integral_mci
  
  function process_get_error_mci (process, i_mci) result (error)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: error
    error = process%mci_entry(i_mci)%get_error ()
  end function process_get_error_mci
  
  function process_get_efficiency_mci (process, i_mci) result (efficiency)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: efficiency
    efficiency = process%mci_entry(i_mci)%get_efficiency ()
  end function process_get_efficiency_mci
  
  function process_get_integral_tot (process) result (integral)
    class(process_t), intent(in) :: process
    real(default) :: integral
    integer :: i
    integral = 0
    do i = 1, size (process%mci_entry)
       if (process%is_active_nlo_component(i)) &
          integral = integral + process%mci_entry(i)%get_integral ()
    end do
  end function process_get_integral_tot
  
  function process_get_error_tot (process) result (error)
    class(process_t), intent(in) :: process
    real(default) :: error
    real(default) :: variance
    integer :: i
    variance = 0
    do i = 1, size (process%mci_entry)
       if (process%is_active_nlo_component(i)) &
          variance = variance + process%mci_entry(i)%get_error () ** 2
    end do
    error = sqrt (variance)
  end function process_get_error_tot
  
  function process_get_efficiency_tot (process) result (efficiency)
    class(process_t), intent(in) :: process
    real(default) :: efficiency
    real(default) :: den, eff, int
    integer :: i
    den = 0
    do i = 1, size (process%mci_entry)
       if (process%is_active_nlo_component(i)) then
         int = process%get_integral (i)
         if (int > 0) then
            eff = process%mci_entry(i)%get_efficiency ()
            if (eff > 0) then
               den = den + int / eff
            else
               efficiency = 0
               return
            end if
         end if
       end if
    end do
    if (den > 0) then
       efficiency = process%get_integral () / den
    else
       efficiency = 0
    end if
  end function process_get_efficiency_tot
  
@ %def process_get_integral process_get_efficiency
<<Processes: process: TBP>>=
  procedure :: get_correction => process_get_correction
  procedure :: get_correction_error => process_get_correction_error
<<Processes: procedures>>=
  function process_get_correction (process) result (ratio)
    class(process_t), intent(in) :: process
    real(default) :: ratio
    real(default) :: int_real, int_virt, int_born
    int_born = process%mci_entry(1)%get_integral ()
    int_real = process%mci_entry(2)%get_integral ()
    int_virt = process%mci_entry(3)%get_integral ()
    ratio = (int_real + int_virt) / int_born
  end function process_get_correction

  function process_get_correction_error (process) result (error)
    class(process_t), intent(in) :: process
    real(default) :: error
    real(default) :: int_born, int_real, int_virt
    real(default) :: err_born, err_real, err_virt
    real(default) :: err2
    int_born = process%mci_entry(1)%get_integral ()
    int_real = process%mci_entry(2)%get_integral ()
    int_virt = process%mci_entry(3)%get_integral ()
    err_born = process%mci_entry(1)%get_error ()
    err_real = process%mci_entry(2)%get_error ()
    err_virt = process%mci_entry(3)%get_error ()
    err2 = (int_real + int_virt)**2 / int_born**4 * err_born**2 &
             + (err_real**2 + err_virt**2) / int_born**2
    error = sqrt (err2)
  end function process_get_correction_error

@ %def process_get_correction process_get_correction_error
@
<<Processes: process: TBP>>=
  procedure :: component_reset_helicity => process_component_reset_helicity
<<Processes: procedures>>=
  subroutine process_component_reset_helicity(proc, i)
    class(process_t), intent(inout) :: proc
    integer, intent(in) :: i
    select type (core => proc%component(i)%core)
      type is (prc_omega_t)
        call core%reset_helicity_selection ()
    end select
    if (i == 2) then
      select type (core_sub_born => proc%component(i)%core_sub_born)
      type is (prc_omega_t)
         call core_sub_born%reset_helicity_selection ()
      end select
    end if
  end subroutine process_component_reset_helicity

@ %def process_component_reset_helicity
@ Initialize the simultaneous Born calculation.
<<Processes: process: TBP>>=
  procedure :: init_sub_born => process_init_sub_born
<<Processes: procedures>>=
  subroutine process_init_sub_born (proc, i_component, core_born_in)
    class(process_t), intent(inout) :: proc
    integer, intent(in) :: i_component
    class(prc_core_t), intent(inout) :: core_born_in
    associate (component => proc%component(i_component))
      allocate (component%core_sub_born, source = core_born_in)
    end associate
  end subroutine process_init_sub_born

@ %def process_init_sub_born
<<Processes: process: TBP>>=
  procedure :: is_nlo_calculation => process_is_nlo_calculation
<<Processes: procedures>>=
  function process_is_nlo_calculation (process) result (nlo)
    class(process_t), intent(in) :: process
    logical :: nlo
    nlo = process%nlo_process
  end function process_is_nlo_calculation

@ %def process_is_nlo_calculation
@ Return nlo data of a process component
<<Processes: process: TBP>>=
  procedure :: get_component_nlo_type => process_get_component_nlo_type
<<Processes: procedures>>=
  function process_get_component_nlo_type (process, i_component) &
           result (nlo_type)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    type(string_t) :: nlo_type
    nlo_type = process%component(i_component)%config%get_nlo_type ()
  end function process_get_component_nlo_type

<<Processes: process: TBP>>=
  procedure :: get_component_associated_born &
            => process_get_component_associated_born
<<Processes: procedures>>=
  function process_get_component_associated_born (process, i_component) &
           result (i_born)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    integer :: i_born
    i_born = process%component(i_component)%config%get_associated_born ()
  end function process_get_component_associated_born

<<Processes: process: TBP>>=
  procedure :: is_active_nlo_component => process_is_active_nlo_component 
<<Processes: procedures>>=
  function process_is_active_nlo_component (process, i_component) &
           result (active)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    logical :: active
    active = process%component(i_component)%config%is_active_nlo_component ()
  end function process_is_active_nlo_component

@ %def process_get_component_nlo_type, process_get_component_associated_born
@ %def process_is_active_nlo_component
@ Return the MD5 sums that summarize the process component
definitions.  These values should be independent of parameters, beam
details, expressions, etc.  They can be used for checking the
integrity of a process when reusing an old event file.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_prc => process_get_md5sum_prc
<<Processes: procedures>>=
  function process_get_md5sum_prc (process, i_component) result (md5sum)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    character(32) :: md5sum
    if (process%component(i_component)%active) then
       md5sum = process%component(i_component)%config%get_md5sum ()
    else
       md5sum = ""
    end if
  end function process_get_md5sum_prc
    
@ %def process_get_md5sum_prc
@ Return the MD5 sums that summarize the state of the MCI integrators.
These values should encode all process data, integration and phase
space configuration, etc., and the integration results.  They can thus
be used for checking the integrity of an event-generation setup when
reusing an old event file.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_mci => process_get_md5sum_mci
<<Processes: procedures>>=
  function process_get_md5sum_mci (process, i_mci) result (md5sum)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    character(32) :: md5sum
    md5sum = process%mci_entry(i_mci)%get_md5sum ()
  end function process_get_md5sum_mci
    
@ %def process_get_md5sum_mci
@ Return the MD5 sum of the process configuration.  This should encode
the process setup, data, and expressions, but no integration results.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_cfg => process_get_md5sum_cfg
<<Processes: procedures>>=
  function process_get_md5sum_cfg (process) result (md5sum)
    class(process_t), intent(in) :: process
    character(32) :: md5sum
    md5sum = process%config%md5sum
  end function process_get_md5sum_cfg

@ %def process_get_md5sum_cfg
@ 
\subsection{Metadata}
This information describes the process and its environment.  It is
fixed upon initialization.

The [[id]] string is the name of the process object, as given by the
user.  The matrix element generator will use this string for naming
Fortran procedures and types, so it should qualify as a Fortran name.

The [[num_id]] is meaningful if nonzero.  It is used for communication
with external programs or file standards which do not support string IDs.

The [[run_id]] string distinguishes among several runs for the same
process.  It identifies process instances with respect to adapted
integration grids and similar run-specific data.  The run ID is kept
when copying processes for creating instances, however, so it does not
distinguish event samples. 

The [[var_list]] is a snapshot of the variable list, taken at the
point where the process was initialized.

The [[lib]] pointer accesses the process library where the process
definition and the process driver are located.

The [[lib_index]] is the index of entry in the process library that
corresponds to the current process.

The [[component_id]] array identifies the individual process components.

The [[component_description]] is an array of human-readable strings
that characterize the process components, for instance [[a, b => c, d]].

The [[active]] mask array marks those components which are active.  The others
are skipped.
<<Processes: process part types>>=
  type :: process_metadata_t
     private
     integer :: type = PRC_UNKNOWN
     type(string_t) :: id
     integer :: num_id = 0
     type(string_t) :: run_id
     type(var_list_t) :: var_list
     type(process_library_t), pointer :: lib => null ()
     integer :: lib_index = 0
     integer :: n_components = 0
     type(string_t), dimension(:), allocatable :: component_id
     type(string_t), dimension(:), allocatable :: component_description
     logical, dimension(:), allocatable :: active
   contains
   <<Processes: process metadata: TBP>>
  end type process_metadata_t

@ %def process_metadata_t
@ The local var list is a snapshot and needs a finalizer.
<<Processes: process metadata: TBP>>=
  procedure :: final => process_metadata_final
<<Processes: procedures>>=
  subroutine process_metadata_final (meta)
    class(process_metadata_t), intent(inout) :: meta
    call var_list_final (meta%var_list, follow_link=.true.)
  end subroutine process_metadata_final
  
@ %def process_metadata_final
@ Output: ID and run ID.
We write the variable list only upon request.
<<Processes: process metadata: TBP>>=
  procedure :: write => process_metadata_write
<<Processes: procedures>>=
  subroutine process_metadata_write (meta, u, var_list, screen)
    class(process_metadata_t), intent(in) :: meta
    integer, intent(in) :: u
    logical, intent(in) :: var_list, screen    
    integer :: i
    select case (meta%type)
    case (PRC_UNKNOWN)
       if (screen) then
          write (msg_buffer, "(A)") "Process [undefined]"
       else
          write (u, "(1x,A)") "Process [undefined]"
       end if
       return
    case (PRC_DECAY)
       if (screen) then
          write (msg_buffer, "(A,1x,A,A,A)") "Process [decay]:", & 
               "'", char (meta%id), "'"
       else
          write (u, "(1x,A)", advance="no") "Process [decay]:"
       end if
    case (PRC_SCATTERING)
       if (screen) then
          write (msg_buffer, "(A,1x,A,A,A)") "Process [scattering]:", &
               "'", char (meta%id), "'"
       else
          write (u, "(1x,A)", advance="no") "Process [scattering]:"
       end if
    case default
       call msg_bug ("process_write: undefined process type")
    end select    
    if (screen)  then
       call msg_message ()
    else
       write (u, "(1x,A,A,A)") "'", char (meta%id), "'"
    end if
    if (meta%num_id /= 0) then
       if (screen) then
          write (msg_buffer, "(2x,A,I0)") "ID (num)      = ", meta%num_id
          call msg_message ()
       else
          write (u, "(3x,A,I0)") "ID (num)      = ", meta%num_id            
       end if
    end if
    if (screen) then
       if (meta%run_id /= "") then
          write (msg_buffer, "(2x,A,A,A)") "Run ID        = '", &
               char (meta%run_id), "'"
          call msg_message ()
       end if
    else
       write (u, "(3x,A,A,A)") "Run ID        = '", char (meta%run_id), "'"       
    end if
    if (associated (meta%lib)) then
       if (screen) then
          write (msg_buffer, "(2x,A,A,A)")  "Library name  = '", &
               char (meta%lib%get_name ()), "'"
          call msg_message ()
       else          
          write (u, "(3x,A,A,A)")  "Library name  = '", &
               char (meta%lib%get_name ()), "'"          
       end if
    else
       if (screen) then
          write (msg_buffer, "(2x,A)")  "Library name  = [not associated]"
          call msg_message ()
       else
          write (u, "(3x,A)")  "Library name  = [not associated]"
       end if
    end if
    if (screen) then
       write (msg_buffer, "(2x,A,I0)")  "Process index = ", meta%lib_index
       call msg_message ()
    else
       write (u, "(3x,A,I0)")  "Process index = ", meta%lib_index
    end if
    if (allocated (meta%component_id)) then
       if (screen) then
          if (any (meta%active)) then
             write (msg_buffer, "(2x,A)")  "Process components:"
          else
             write (msg_buffer, "(2x,A)")  "Process components: [none]"
          end if
          call msg_message ()
       else
          write (u, "(3x,A)")  "Process components:"
       end if
       do i = 1, size (meta%component_id)
          if (.not. meta%active(i))  cycle
          if (screen) then
             write (msg_buffer, "(4x,I0,9A)")  i, ": '", &
                  char (meta%component_id (i)), "':   ", &
                  char (meta%component_description (i))
             call msg_message ()
          else
             write (u, "(5x,I0,9A)")  i, ": '", &
                  char (meta%component_id (i)), "':   ", &
                  char (meta%component_description (i))             
          end if
       end do
    end if
    if (screen) then
       write (msg_buffer, "(A)")  repeat ("-", 72)
       call msg_message ()
    else
       call write_separator (u)       
    end if
    if (screen)  return
    if (var_list) then
       write (u, "(1x,A)")  "Variable list:"
       call write_separator (u)
       call var_list_write (meta%var_list, u)
    else
       write (u, "(1x,A)")  "Variable list: [not shown]"
    end if
  end subroutine process_metadata_write

@ %def process_metadata_write 
@ Short output: list components.
<<Processes: process metadata: TBP>>=
  procedure :: show => process_metadata_show
<<Processes: procedures>>=
  subroutine process_metadata_show (meta, u, model_name)
    class(process_metadata_t), intent(in) :: meta
    integer, intent(in) :: u
    type(string_t), intent(in) :: model_name
    integer :: i
    select case (meta%type)
    case (PRC_UNKNOWN)
       write (u, "(A)") "Process: [undefined]"
       return
    case default
       write (u, "(A)", advance="no") "Process:"
    end select
    write (u, "(1x,A)", advance="no") char (meta%id)
    select case (meta%num_id)
    case (0)
    case default
       write (u, "(1x,'(',I0,')')", advance="no") meta%num_id
    end select
    select case (char (model_name))
    case ("")
    case default
       write (u, "(1x,'[',A,']')", advance="no")  char (model_name)
    end select
    write (u, *)
    if (allocated (meta%component_id)) then
       do i = 1, size (meta%component_id)
          if (meta%active(i)) then
             write (u, "(2x,I0,':',1x,A)")  i, &
                  char (meta%component_description (i))
          end if
       end do
    end if
  end subroutine process_metadata_show

@ %def process_metadata_show 
@ Initialize.
<<Processes: process metadata: TBP>>=
  procedure :: init => process_metadata_init
<<Processes: procedures>>=
  subroutine process_metadata_init (meta, id, run_id, lib)
    class(process_metadata_t), intent(out) :: meta
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: run_id
    type(process_library_t), intent(in), target :: lib
    select case (lib%get_n_in (id))
    case (1);  meta%type = PRC_DECAY
    case (2);  meta%type = PRC_SCATTERING
    case default
       call msg_bug ("Process '" // char (id) // "': impossible n_in")
    end select
    meta%id = id
    meta%run_id = run_id
    meta%lib => lib
    meta%lib_index = lib%get_entry_index (id)
    meta%num_id = lib%get_num_id (id)
    call lib%get_component_list (id, meta%component_id)
    meta%n_components = size (meta%component_id)
    call lib%get_component_description_list (id, meta%component_description)
    allocate (meta%active (meta%n_components), source = .true.)
  end subroutine process_metadata_init
  
@ %def process_metadata_init
@ Mark a component as inactive.
<<Processes: process metadata: TBP>>=
  procedure :: deactivate_component => process_metadata_deactivate_component
<<Processes: procedures>>=
  subroutine process_metadata_deactivate_component (meta, i)
    class(process_metadata_t), intent(inout) :: meta
    integer, intent(in) :: i
    call msg_message ("Process component '" &
         // char (meta%component_id(i)) // "': matrix element vanishes")
    meta%active(i) = .false.
  end subroutine process_metadata_deactivate_component
  
@ %def process_metadata_deactivate_component
@
\subsection{Generic Configuration Data}
This information concerns physical and technical properties of the
process.  It is fixed upon initialization, using data from the
process specification and the variable list.

The number [[n_in]] is the number of incoming beam particles,
simultaneously the number of incoming partons, 1 for a decay and 2 for
a scattering process. (The number of outgoing partons may depend on
the process component.)

The number [[n_components]] is the number of components that constitute
the current process.

The number [[n_terms]] is the number of distinct contributions to the
scattering matrix that constitute the current process.  Each component
may generate several terms.

The number [[n_mci]] is the number of independent MC
integration configurations that this process uses.  Distinct process
components that share a MCI configuration may be combined pointwise.
(Nevertheless, a given MC variable set may correspond to several
``nearby'' kinematical configurations.)  This is also the number of
distinct sampling-function results that this process can generate.
Process components that use distinct variable sets are added only once
after an integration pass has completed.

The [[model]] pointer identifies the physics model and its
parameters.  This is a pointer to an external object.

The [[rng_factory]] component spawns independent random-number generators for
use in integration, event generation, and event postprocessing.

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions for evaluating cuts and scales.  The
workspaces for evaluating those expressions are set up in the
[[effective_state]] subobjects.  Note that these are really pointers,
so the actual nodes are not stored inside the process object.

The [[md5sum]] is taken and used to verify the process configuration
when re-reading data from file.
<<Processes: process part types>>=
  type :: process_config_data_t
     private
     integer :: n_in = 0
     integer :: n_components = 0
     integer :: n_terms = 0
     integer :: n_mci = 0
     type(os_data_t) :: os_data
     class(rng_factory_t), allocatable :: rng_factory
     type(string_t) :: model_name
     type(model_t), pointer :: model => null ()
     type(qcd_t) :: qcd
     class(expr_factory_t), allocatable :: ef_cuts
     class(expr_factory_t), allocatable :: ef_scale
     class(expr_factory_t), allocatable :: ef_fac_scale
     class(expr_factory_t), allocatable :: ef_ren_scale
     class(expr_factory_t), allocatable :: ef_weight
     character(32) :: md5sum = ""
   contains
   <<Processes: process config data: TBP>>
  end type process_config_data_t

@ %def process_config_data_t
@ Here, we may compress the expressions for cuts etc.
<<Processes: process config data: TBP>>=
  procedure :: write => process_config_data_write
<<Processes: procedures>>=
  subroutine process_config_data_write (config, u, &
       counters, os_data, rng_factory, model, expressions)
    class(process_config_data_t), intent(in) :: config
    integer, intent(in) :: u
    logical, intent(in) :: counters
    logical, intent(in) :: os_data
    logical, intent(in) :: rng_factory
    logical, intent(in) :: model
    logical, intent(in) :: expressions
    write (u, "(1x,A)") "Configuration data:"
    if (counters) then
       write (u, "(3x,A,I0)") "Number of incoming particles = ", &
            config%n_in
       write (u, "(3x,A,I0)") "Number of process components = ", &
            config%n_components
       write (u, "(3x,A,I0)") "Number of process terms      = ", &
            config%n_terms
       write (u, "(3x,A,I0)") "Number of MCI configurations = ", &
            config%n_mci
    end if
    if (os_data) then
       call os_data_write (config%os_data, u)
    end if
    if (associated (config%model)) then
       write (u, "(3x,A,A)")  "Model = ", char (config%model_name)
       if (model) then
          call write_separator (u)
          call config%model%write (u)
          call write_separator (u)
       end if
    else
       write (u, "(3x,A,A,A)")  "Model = ", char (config%model_name), &
            " [not associated]"
    end if
    call config%qcd%write (u, show_md5sum = .false.)
    if (rng_factory) then
       if (allocated (config%rng_factory)) then
          write (u, "(2x)", advance = "no")
          call config%rng_factory%write (u)
       end if
    end if
    call write_separator (u)
    if (expressions) then
       if (allocated (config%ef_cuts)) then
          call write_separator (u)
          write (u, "(3x,A)") "Cut expression:"
          call config%ef_cuts%write (u)
       end if
       if (allocated (config%ef_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Scale expression:"
          call config%ef_scale%write (u)
       end if
       if (allocated (config%ef_fac_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Factorization scale expression:"
          call config%ef_fac_scale%write (u)
       end if
       if (allocated (config%ef_ren_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Renormalization scale expression:"
          call config%ef_ren_scale%write (u)
       end if
       if (allocated (config%ef_weight)) then
          call write_separator (u)
          write (u, "(3x,A)") "Weight expression:"
          call config%ef_weight%write (u)
       end if
    else
       call write_separator (u)
       write (u, "(3x,A)") "Expressions (cut, scales, weight): [not shown]"
    end if
    if (config%md5sum /= "") then
       call write_separator (u)
       write (u, "(3x,A,A,A)")  "MD5 sum (config)  = '", config%md5sum, "'"
    end if
  end subroutine process_config_data_write
       
@ %def process_config_data_write
@ Initialize.  We use information from the process metadata and from
the process library, given the process ID.  We also store the
currently active OS data set.

Using the model name that the library gives us, we try to load the
model here.  Reading from the global model library, we are sure that
we are looking at the model associated to the process, not the
selected one at the user level.  However, when the mode names are the
same, the models will be identical.

Instead of storing a model pointer, we create an instance which
contains the current values of model parameters.  The captured values
are now disconnected from user-level changes and will stay for the
lifetime of the process object.  Allocating the model via a pointer
guarantees the [[target]] attribute.

The RNG factory object is imported by moving the allocation.
<<Processes: process config data: TBP>>=
  procedure :: init => process_config_data_init
<<Processes: procedures>>=
  subroutine process_config_data_init &
       (config, meta, os_data, qcd, rng_factory, model_list)
    class(process_config_data_t), intent(out) :: config
    type(process_metadata_t), intent(in) :: meta
    type(os_data_t), intent(in) :: os_data
    type(qcd_t), intent(in) :: qcd
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    type(model_list_t), intent(inout) :: model_list
    type(string_t) :: filename
    type(model_t), pointer :: model
    config%n_in = meta%lib%get_n_in (meta%id)
    config%n_components = size (meta%component_id)
    config%os_data = os_data
    config%qcd = qcd
    call move_alloc (from = rng_factory, to = config%rng_factory)
    config%model_name = meta%lib%get_model_name (meta%id)
    if (config%model_name /= "") then
       filename = config%model_name // ".mdl"
       call model_list%read_model (config%model_name, &
            filename, config%os_data, model)
       allocate (config%model)
       call config%model%init_instance (model)
    end if
  end subroutine process_config_data_init

@ %def process_config_data_init
@ Since the captured model is a separate object allocated via a
pointer, we need a finalizer.
<<Processes: process config data: TBP>>=
  procedure :: final => process_config_data_final
<<Processes: procedures>>=
  subroutine process_config_data_final (config)
    class(process_config_data_t), intent(inout) :: config
    if (associated (config%model)) then
       call config%model%final ()
       deallocate (config%model)
    end if
  end subroutine process_config_data_final
  
@ %def process_config_data_final
@ Compute the MD5 sum of the configuration data.  This encodes, in
particular, the model and the expressions for cut, scales, weight,
etc.  It should not contain the IDs and number of components, etc.,
since the MD5 sum should be useful for integrating individual
components.

This is done only once.  If the MD5 sum is nonempty, the calculation
is skipped.
<<Processes: process config data: TBP>>=
  procedure :: compute_md5sum => process_config_data_compute_md5sum
<<Processes: procedures>>=
  subroutine process_config_data_compute_md5sum (config)
    class(process_config_data_t), intent(inout) :: config
    integer :: u
    if (config%md5sum == "") then
       u = free_unit ()
       open (u, status = "scratch", action = "readwrite")
       call config%write (u, counters = .false., os_data = .false., &
            rng_factory = .false., model = .true., expressions = .true.)
       rewind (u)
       config%md5sum = md5sum (u)
       close (u)
    end if
  end subroutine process_config_data_compute_md5sum
  
@ %def process_config_data_compute_md5sum
@
\subsection{Beam configuration}
The object [[data]] holds all details about the initial beam
configuration.  The allocatable array [[sf]] holds the structure-function
configuration blocks.  There are [[n_strfun]] entries in the
structure-function chain (not counting the initial beam object).  We
maintain [[n_channel]] independent parameterizations of this chain.
If this is greater than zero, we need a multi-channel sampling
algorithm, where for each point one channel is selected to generate
kinematics.

The number of parameters that are required for generating a
structure-function chain is [[n_sfpar]].

The flag [[azimuthal_dependence]] tells whether the process setup is
symmetric about the beam axis in the c.m.\ system.  This implies that
there is no transversal beam polarization.  The flag [[lab_is_cm_frame]] is
obvious.
<<Processes: process part types>>=
  type :: process_beam_config_t
     private
     type(beam_data_t) :: data
     integer :: n_strfun = 0
     integer :: n_channel = 1
     integer :: n_sfpar = 0
     type(sf_config_t), dimension(:), allocatable :: sf
     type(sf_channel_t), dimension(:), allocatable :: sf_channel
     logical :: azimuthal_dependence = .false.
     logical :: lab_is_cm_frame = .true.
     character(32) :: md5sum = ""
     logical :: sf_trace = .false.
     type(string_t) :: sf_trace_file
   contains
   <<Processes: process beam config: TBP>>
  end type process_beam_config_t

@ %def process_beam_config_t
@ Here we write beam data only if they are actually used.
<<Processes: process beam config: TBP>>=
  procedure :: write => process_beam_config_write
<<Processes: procedures>>=
  subroutine process_beam_config_write (object, u)
    class(process_beam_config_t), intent(in) :: object
    integer, intent(in) :: u
    integer :: i, c
    call object%data%write (u)
    if (object%data%initialized) then
       write (u, "(3x,A,L1)")  "Azimuthal dependence    = ", &
            object%azimuthal_dependence
       write (u, "(3x,A,L1)")  "Lab frame is c.m. frame = ", &
            object%lab_is_cm_frame
       if (object%md5sum /= "") then
          write (u, "(3x,A,A,A)")  "MD5 sum (beams/strf) = '", &
               object%md5sum, "'"
       end if
       if (allocated (object%sf)) then
          do i = 1, size (object%sf)
             call object%sf(i)%write (u)
          end do
          if (any_sf_channel_has_mapping (object%sf_channel)) then
             write (u, "(1x,A,L1)")  "Structure-function mappings per channel:"
             do c = 1, object%n_channel
                write (u, "(3x,I0,':')", advance="no")  c
                call object%sf_channel(c)%write (u)
             end do
          end if
       end if
    end if
  end subroutine process_beam_config_write
  
@ %def process_beam_config_write
@ The beam data have a finalizer.  We assume that there is none for the
structure-function data.
<<Processes: process beam config: TBP>>=
  procedure :: final => process_beam_config_final
<<Processes: procedures>>=
  subroutine process_beam_config_final (object)
    class(process_beam_config_t), intent(inout) :: object
    call beam_data_final (object%data)
  end subroutine process_beam_config_final

@ %def process_beam_config_final
@ Initialize the beam setup with a given beam structure object.
<<Processes: process beam config: TBP>>=
  procedure :: init_beam_structure => process_beam_config_init_beam_structure
<<Processes: procedures>>=
  subroutine process_beam_config_init_beam_structure &
       (beam_config, beam_structure, sqrts, model, decay_rest_frame)
    class(process_beam_config_t), intent(out) :: beam_config
    type(beam_structure_t), intent(in) :: beam_structure
    logical, intent(in), optional :: decay_rest_frame
    real(default), intent(in) :: sqrts
    type(model_t), intent(in), target :: model
    call beam_data_init_structure (beam_config%data, &
         beam_structure, sqrts, model, decay_rest_frame)
    beam_config%lab_is_cm_frame = beam_data_cm_frame (beam_config%data)
  end subroutine process_beam_config_init_beam_structure
  
@ %def process_beam_config_init_beam_structure
@ Initialize the beam setup for a scattering process with specified
flavor combination, other properties taken from the beam structure
object (if any).
<<Processes: process beam config: TBP>>=
  procedure :: init_scattering => process_beam_config_init_scattering
<<Processes: procedures>>=
  subroutine process_beam_config_init_scattering &
       (beam_config, flv_in, sqrts, beam_structure)
    class(process_beam_config_t), intent(out) :: beam_config
    type(flavor_t), dimension(2), intent(in) :: flv_in
    real(default), intent(in) :: sqrts
    type(beam_structure_t), intent(in), optional :: beam_structure
    if (present (beam_structure)) then
       if (beam_structure%polarized ()) then
          call beam_data_init_sqrts (beam_config%data, sqrts, flv_in, &
               beam_structure%get_smatrix (), beam_structure%get_pol_f ())
       else
          call beam_data_init_sqrts (beam_config%data, sqrts, flv_in)
       end if
    else
       call beam_data_init_sqrts (beam_config%data, sqrts, flv_in)
    end if
  end subroutine process_beam_config_init_scattering
    
@ %def process_beam_config_init_scattering    
@ Initialize the beam setup for a decay process with specified flavor,
other properties taken from the beam structure object (if present).

For a cascade decay, we set
[[rest_frame]] to false, indicating a event-wise varying momentum.
The beam data itself are initialized for the particle at rest.
<<Processes: process beam config: TBP>>=
  procedure :: init_decay => process_beam_config_init_decay
<<Processes: procedures>>=
  subroutine process_beam_config_init_decay &
       (beam_config, flv_in, rest_frame, beam_structure)
    class(process_beam_config_t), intent(out) :: beam_config
    type(flavor_t), dimension(1), intent(in) :: flv_in
    logical, intent(in), optional :: rest_frame
    type(beam_structure_t), intent(in), optional :: beam_structure
    if (present (beam_structure)) then
       if (beam_structure%polarized ()) then
          call beam_data_init_decay (beam_config%data, flv_in, &
               beam_structure%get_smatrix (), beam_structure%get_pol_f (), &
               rest_frame = rest_frame)
       else
          call beam_data_init_decay (beam_config%data, flv_in, &
               rest_frame = rest_frame)
       end if
    else
       call beam_data_init_decay (beam_config%data, flv_in, &
            rest_frame = rest_frame)
    end if 
    beam_config%lab_is_cm_frame = beam_data_cm_frame (beam_config%data)
  end subroutine process_beam_config_init_decay
    
@ %def process_beam_config_init_decay
@ Print an informative message.
<<Processes: process beam config: TBP>>=
  procedure :: startup_message => process_beam_config_startup_message
<<Processes: procedures>>=
  subroutine process_beam_config_startup_message &
       (beam_config, unit, beam_structure)
    class(process_beam_config_t), intent(in) :: beam_config
    integer, intent(in), optional :: unit
    type(beam_structure_t), intent(in), optional :: beam_structure
    integer :: u
    u = free_unit ()
    open (u, status="scratch", action="readwrite")
    if (present (beam_structure)) then
       call beam_structure%write (u)
    end if
    call beam_data_write (beam_config%data, u)
    rewind (u)
    do
       read (u, "(1x,A)", end=1)  msg_buffer
       call msg_message ()
    end do
1   continue
    close (u)
  end subroutine process_beam_config_startup_message

@ %def process_beam_config_startup_message
@ Allocate the structure-function array.
<<Processes: process beam config: TBP>>=
  procedure :: init_sf_chain => process_beam_config_init_sf_chain
<<Processes: procedures>>=
  subroutine process_beam_config_init_sf_chain &
       (beam_config, sf_config, sf_trace_file)
    class(process_beam_config_t), intent(inout) :: beam_config
    type(sf_config_t), dimension(:), intent(in) :: sf_config
    type(string_t), intent(in), optional :: sf_trace_file
    integer :: i
    beam_config%n_strfun = size (sf_config)
    allocate (beam_config%sf (beam_config%n_strfun))
    do i = 1, beam_config%n_strfun
       associate (sf => sf_config(i))
         call beam_config%sf(i)%init (sf%i, sf%data)
         if (.not. sf%data%is_generator ()) then
            beam_config%n_sfpar = beam_config%n_sfpar + sf%data%get_n_par ()
         end if
       end associate
    end do
    if (present (sf_trace_file)) then
       beam_config%sf_trace = .true.
       beam_config%sf_trace_file = sf_trace_file
    end if
  end subroutine process_beam_config_init_sf_chain

@ %def process_beam_config_init_sf_chain
@ Allocate the structure-function mapping channel array, given the
requested number of channels.
<<Processes: process beam config: TBP>>=
  procedure :: allocate_sf_channels => process_beam_config_allocate_sf_channels
<<Processes: procedures>>=
  subroutine process_beam_config_allocate_sf_channels (beam_config, n_channel)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer, intent(in) :: n_channel
    beam_config%n_channel = n_channel
    call allocate_sf_channels (beam_config%sf_channel, &
         n_channel = n_channel, &
         n_strfun = beam_config%n_strfun)
  end subroutine process_beam_config_allocate_sf_channels
    
@ %def process_beam_config_allocate_sf_channels
@ Set a structure-function mapping channel for an array of
structure-function entries, for a single channel.  (The default is no mapping.)
<<Processes: process beam config: TBP>>=
  procedure :: set_sf_channel => process_beam_config_set_sf_channel
<<Processes: procedures>>=
  subroutine process_beam_config_set_sf_channel (beam_config, c, sf_channel)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer, intent(in) :: c
    type(sf_channel_t), intent(in) :: sf_channel
    beam_config%sf_channel(c) = sf_channel
  end subroutine process_beam_config_set_sf_channel
  
@ %def process_beam_config_set_sf_channel
@ Print an informative startup message.
<<Processes: process beam config: TBP>>=
  procedure :: sf_startup_message => process_beam_config_sf_startup_message
<<Processes: procedures>>=
  subroutine process_beam_config_sf_startup_message &
       (beam_config, sf_string, unit)
    class(process_beam_config_t), intent(in) :: beam_config
    type(string_t), intent(in) :: sf_string
    integer, intent(in), optional :: unit
    if (beam_config%n_strfun > 0) then
       call msg_message ("Beam structure: " // char (sf_string), unit = unit)
       write (msg_buffer, "(A,3(1x,I0,1x,A))") &
            "Beam structure:", &
            beam_config%n_channel, "channels,", &
            beam_config%n_sfpar, "dimensions"
       call msg_message (unit = unit)
       if (beam_config%sf_trace) then
          call msg_message ("Beam structure: tracing &
               &values in '" // char (beam_config%sf_trace_file) // "'")
       end if
    end if
  end subroutine process_beam_config_sf_startup_message
    
@ %def process_beam_config_startup_message
@ Return the PDF set currently in use, if any.  This should be unique,
so we scan the structure functions until we get a nonzero number.

(This implies that if the PDF set is not unique (e.g., proton and
photon structure used together), this doesn't work correctly.)
<<Processes: process beam config: TBP>>=
  procedure :: get_pdf_set => process_beam_config_get_pdf_set
<<Processes: procedures>>=
  function process_beam_config_get_pdf_set (beam_config) result (pdf_set)
    class(process_beam_config_t), intent(in) :: beam_config
    integer :: pdf_set
    integer :: i
    if (allocated (beam_config%sf)) then
       do i = 1, size (beam_config%sf)
          pdf_set = beam_config%sf(i)%get_pdf_set ()
          if (pdf_set /= 0)  return
       end do
    else
       pdf_set = 0
    end if
  end function process_beam_config_get_pdf_set
  
@ %def process_beam_config_get_pdf_set
@ Compute the MD5 sum for the complete beam setup.  We rely on the
default output of [[write]] to contain all relevant data.

This is done only once, when the MD5 sum is still empty.
<<Processes: process beam config: TBP>>=
  procedure :: compute_md5sum => process_beam_config_compute_md5sum
<<Processes: procedures>>=
  subroutine process_beam_config_compute_md5sum (beam_config)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer :: u
    if (beam_config%md5sum == "") then
       u = free_unit ()
       open (u, status = "scratch", action = "readwrite")
       call beam_config%write (u)
       rewind (u)
       beam_config%md5sum = md5sum (u)
       close (u)
    end if
  end subroutine process_beam_config_compute_md5sum

@ %def process_beam_config_compute_md5sum
@
\subsubsection{Process call statistics}
This object can record process calls, categorized by evaluation
status.  It is a part of the [[mci_entry]] component below.
<<Processes: types>>=
  type :: process_counter_t
     integer :: total = 0
     integer :: failed_kinematics = 0
     integer :: failed_cuts = 0
     integer :: passed = 0
     integer :: evaluated = 0
     integer :: complete = 0
   contains
   <<Processes: process counter: TBP>>
  end type process_counter_t
  
@ %def process_counter_t
@ 
@ Here are the corresponding numeric codes:
<<Processes: parameters>>=
  integer, parameter :: STAT_UNDEFINED = 0
  integer, parameter :: STAT_INITIAL = 1
  integer, parameter :: STAT_ACTIVATED = 2
  integer, parameter :: STAT_BEAM_MOMENTA = 3
  integer, parameter :: STAT_FAILED_KINEMATICS = 4
  integer, parameter :: STAT_SEED_KINEMATICS = 5
  integer, parameter :: STAT_HARD_KINEMATICS = 6
  integer, parameter :: STAT_EFF_KINEMATICS = 7
  integer, parameter :: STAT_FAILED_CUTS = 8
  integer, parameter :: STAT_PASSED_CUTS = 9
  integer, parameter :: STAT_EVALUATED_TRACE = 10
  integer, parameter :: STAT_EVENT_COMPLETE = 11
  
@ %def STAT_UNDEFINED STAT_INITIAL STAT_ACTIVATED 
@ %def STAT_BEAM_MOMENTA STAT_FAILED_KINEMATICS
@ %def STAT_SEED_KINEMATICS STAT_HARD_KINEMATICS STAT_EFF_KINEMATICS
@ %def STAT_EVALUATED_TRACE STAT_EVENT_COMPLETE
@ Output.
<<Processes: process counter: TBP>>=
  procedure :: write => process_counter_write
<<Processes: procedures>>=
  subroutine process_counter_write (object, unit)
    class(process_counter_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%total > 0) then
       write (u, "(1x,A)")  "Call statistics (current run):"
       write (u, "(3x,A,I0)")  "total       = ", object%total
       write (u, "(3x,A,I0)")  "failed kin. = ", object%failed_kinematics
       write (u, "(3x,A,I0)")  "failed cuts = ", object%failed_cuts
       write (u, "(3x,A,I0)")  "passed cuts = ", object%passed
       write (u, "(3x,A,I0)")  "evaluated   = ", object%evaluated
    else
       write (u, "(1x,A)")  "Call statistics (current run): [no calls]"
    end if
  end subroutine process_counter_write
    
@ %def process_counter_write
@ Reset.  Just enforce default initialization.
<<Processes: process counter: TBP>>=
  procedure :: reset => process_counter_reset
<<Processes: procedures>>=
  subroutine process_counter_reset (counter)
    class(process_counter_t), intent(out) :: counter
  end subroutine process_counter_reset

@ %def process_counter_reset
@ We record an event according to the lowest status code greater or
equal to the actual status.  This is actually done by the process
instance; the process object just copies the instance counter.
<<Processes: process counter: TBP>>=
  procedure :: record => process_counter_record
<<Processes: procedures>>=
  subroutine process_counter_record (counter, status)
    class(process_counter_t), intent(inout) :: counter
    integer, intent(in) :: status
    if (status <= STAT_FAILED_KINEMATICS) then
       counter%failed_kinematics = counter%failed_kinematics + 1
    else if (status <= STAT_FAILED_CUTS) then
       counter%failed_cuts = counter%failed_cuts + 1
    else if (status <= STAT_PASSED_CUTS) then
       counter%passed = counter%passed + 1
    else
       counter%evaluated = counter%evaluated + 1
    end if
    counter%total = counter%total + 1
  end subroutine process_counter_record
       
@ %def process_counter_record
@
\subsection{Multi-channel integration}
The [[process_mci_entry_t]] block contains, for each process component that is
integrated independently, the configuration data for its MC input parameters.
Each input parameter set is handled by a [[mci_t]] integrator.

The MC input parameter set is broken down into the parameters required by the
structure-function chain and the parameters required by the phase space of the
elementary process.

The MD5 sum collects all information about the associated processes
that may affect the integration.  It does not contain the MCI object
itself or integration results.

MC integration is organized in passes.  Each pass may consist of
several iterations, and for each iteration there is a number of
calls.  We store explicitly the values that apply to the current
pass.  Previous values are archived in the [[results]] object.

The [[counter]] receives the counter statistics from the associated
process instance, for diagnostics.

The [[results]] object records results, broken down in passes and iterations.
<<Processes: process part types>>=
  type :: process_mci_entry_t
     integer :: i_mci = 0
     integer, dimension(:), allocatable :: i_component
     integer :: process_type = PRC_UNKNOWN
     integer :: n_par = 0
     integer :: n_par_sf = 0
     integer :: n_par_phs = 0
     character(32) :: md5sum = ""
     integer :: pass = 0
     integer :: n_it = 0
     integer :: n_calls = 0
     logical :: activate_timer = .false.
     real(default) :: error_threshold = 0
     class(mci_t), allocatable :: mci
     type(process_counter_t) :: counter
     type(integration_results_t) :: results
     logical :: negative_weights
   contains
   <<Processes: process mci entry: TBP>>
  end type process_mci_entry_t

@ %def process_mci_entry_t
@ Finalizer for the [[mci]] component.
<<Processes: process mci entry: TBP>>=
  procedure :: final => process_mci_entry_final
<<Processes: procedures>>=
  subroutine process_mci_entry_final (object)
    class(process_mci_entry_t), intent(inout) :: object
    if (allocated (object%mci))  call object%mci%final ()
  end subroutine process_mci_entry_final
  
@ %def process_mci_entry_final
@ Output.  Write pass/iteration information only if set (the pass
index is nonzero).  Write the MCI block only if it exists (for some
self-tests it does not).  Write results only if there are any.
<<Processes: process mci entry: TBP>>=
  procedure :: write => process_mci_entry_write
<<Processes: procedures>>=
  subroutine process_mci_entry_write (object, unit, pacify)
    class(process_mci_entry_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,I0)")  "Associated components = ", object%i_component
    write (u, "(3x,A,I0)")  "MC input parameters   = ", object%n_par
    write (u, "(3x,A,I0)")  "MC parameters (SF)    = ", object%n_par_sf
    write (u, "(3x,A,I0)")  "MC parameters (PHS)   = ", object%n_par_phs
    if (object%pass > 0) then
       write (u, "(3x,A,I0)")  "Current pass          = ", object%pass
       write (u, "(3x,A,I0)")  "Number of iterations  = ", object%n_it
       write (u, "(3x,A,I0)")  "Number of calls       = ", object%n_calls
    end if
    if (object%md5sum /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (components)  = '", object%md5sum, "'"
    end if
    if (allocated (object%mci)) then
       call object%mci%write (u)
    end if
    call object%counter%write (u)
    if (object%results%exist ()) then
       call object%results%write (u, suppress = pacify)
       call object%results%write_chain_weights (u)
    end if
  end subroutine process_mci_entry_write
       
@ %def process_mci_entry_write
@ Write the weights that are assigned to the chains of channels (call groves in
the [[wood]] phase-space implementation.  This depends on the implementation
and is delegated to the [[mci]] component.
<<Processes: process mci entry: TBP>>=
  procedure :: write_chain_weights => process_mci_entry_write_chain_weights
<<Processes: procedures>>=
  subroutine process_mci_entry_write_chain_weights (mci_entry, unit)
    class(process_mci_entry_t), intent(in) :: mci_entry
    integer, intent(in), optional :: unit
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%write_chain_weights (unit)
    end if
  end subroutine process_mci_entry_write_chain_weights
       
@ %def process_mci_entry_write_chain_weights
@ Initialize.  From the existing configuration, we obtain the number of
channels and the number of parameters, separately for the structure-function
chain and for the associated process component.  We assume that the
phase-space object has already been configured.

The allocation of the MCI integrator with the appropriate concrete type is the
duty of the process core.

We assume that there is only one component associated with a MCI entry.  This
restriction should be relaxed.
<<Processes: process mci entry: TBP>>=
  procedure :: init => process_mci_entry_init
<<Processes: procedures>>=
  subroutine process_mci_entry_init (mci_entry, &
       process_type, i_mci, i_component, component,&
       beam_config, rng_factory)
    class(process_mci_entry_t), intent(out) :: mci_entry
    integer, intent(in) :: process_type
    integer, intent(in) :: i_mci
    integer, intent(in) :: i_component
    type(process_component_t), intent(in), target :: component
    type(process_beam_config_t), intent(in) :: beam_config
    class(rng_factory_t), intent(inout) :: rng_factory
    class(rng_t), allocatable :: rng
    associate (phs_config => component%phs_config)
      mci_entry%i_mci = i_mci
      allocate (mci_entry%i_component (1))
      mci_entry%i_component(1) = i_component
      mci_entry%n_par_sf = beam_config%n_sfpar
      mci_entry%n_par_phs = phs_config%get_n_par ()
      mci_entry%n_par = mci_entry%n_par_sf + mci_entry%n_par_phs
      mci_entry%process_type = process_type
      if (allocated (component%mci_template)) then
         allocate (mci_entry%mci, source=component%mci_template)
         call mci_entry%mci%record_index (mci_entry%i_mci)
         call mci_entry%mci%set_dimensions &
              (mci_entry%n_par, phs_config%get_n_channel ())
         call mci_entry%mci%declare_flat_dimensions &
              (phs_config%get_flat_dimensions ())
         if (phs_config%provides_equivalences) then
            call mci_entry%mci%declare_equivalences &
                 (phs_config%channel, mci_entry%n_par_sf)
         end if
         if (phs_config%provides_chains) then
            call mci_entry%mci%declare_chains (phs_config%chain)
         end if
         call rng_factory%make (rng)
         call mci_entry%mci%import_rng (rng)
      end if
    end associate
    call mci_entry%results%init (process_type)
  end subroutine process_mci_entry_init
  
@ %def process_mci_entry_init
@ Set some additional parameters.
<<Processes: process mci entry: TBP>>=
  procedure :: set_parameters => process_mci_entry_set_parameters
<<Processes: procedures>>=
  subroutine process_mci_entry_set_parameters (mci_entry, var_list)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(var_list_t), intent(in) :: var_list
    real(default) :: error_threshold
    error_threshold = &
         var_list_get_rval (var_list, var_str ("error_threshold"))
    mci_entry%activate_timer = &
         var_list_get_lval (var_list, var_str ("?integration_timer"))
    call mci_entry%results%set_error_threshold (error_threshold)
  end subroutine process_mci_entry_set_parameters
  
@ %def process_mci_entry_set_parameters
@ Compute a MD5 sum that summarizes all information that could
influence integration results, for the associated process components.
We take the process-configuration MD5 sum which represents parameters,
cuts, etc., the MD5 sums for the process component definitions and
their phase space objects (which should be configured), and the beam
configuration MD5 sum.  (The QCD setup is included in the process
configuration data MD5 sum.)

Done only once, when the MD5 sum is still empty.
<<Processes: process mci entry: TBP>>=
  procedure :: compute_md5sum => process_mci_entry_compute_md5sum
<<Processes: procedures>>=
  subroutine process_mci_entry_compute_md5sum (mci_entry, &
       config, component, beam_config)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_config_data_t), intent(in) :: config
    type(process_component_t), dimension(:), intent(in) :: component
    type(process_beam_config_t), intent(in) :: beam_config
    type(string_t) :: buffer
    integer :: i
    if (mci_entry%md5sum == "") then
       buffer = config%md5sum // beam_config%md5sum
       do i = 1, size (component)
          if (component(i)%active) then
             buffer = buffer // component(i)%config%get_md5sum () &
                  // component(i)%md5sum_phs
          end if
       end do
       mci_entry%md5sum = md5sum (char (buffer))
    end if
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%set_md5sum (mci_entry%md5sum)
    end if
  end subroutine process_mci_entry_compute_md5sum
  
@ %def process_mci_entry_compute_md5sum
@ Test the MCI sampler by calling it a given number of time, discarding the
results.  The instance should be initialized.

The [[mci_entry]] is [[intent(inout)]] because the integrator contains
the random-number state.
<<Processes: process mci entry: TBP>>=
  procedure :: sampler_test => process_mci_entry_sampler_test
<<Processes: procedures>>=
  subroutine process_mci_entry_sampler_test (mci_entry, instance, n_calls)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout), target :: instance
    integer, intent(in) :: n_calls
    call instance%choose_mci (mci_entry%i_mci)
    call instance%reset_counter ()
    call mci_entry%mci%sampler_test (instance, n_calls)
    mci_entry%counter = instance%get_counter ()
  end subroutine process_mci_entry_sampler_test

@ %def process_mci_entry_sampler_test
@ Integrate.  The instance should be initialized.

The [[integrate]] method counts as an integration pass; the pass count is
increased by one.  We transfer the pass parameters (number of iterations and
number of calls) to the actual integration routine.

The [[mci_entry]] is [[intent(inout)]] because the integrator contains
the random-number state.

Note: The results are written to screen and to logfile.  This behavior
is hardcoded.
<<Processes: process mci entry: TBP>>=
  procedure :: integrate => process_mci_entry_integrate
  procedure :: final_integration => process_mci_entry_final_integration
<<Processes: procedures>>=
  subroutine process_mci_entry_integrate (mci_entry, instance, n_it, n_calls, &
       adapt_grids, adapt_weights, final, pacify, &
       i_component)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    logical, intent(in), optional :: adapt_grids
    logical, intent(in), optional :: adapt_weights
    logical, intent(in), optional :: final, pacify
    integer, intent(in), optional :: i_component
    integer :: u_log
    type(string_t) :: nlo_type
    if (present (i_component)) then
      if (associated (instance%component(i_component)%config)) then
        nlo_type = instance%component(i_component)%config%config%get_nlo_type ()
      end if
    else
      nlo_type = 'Born'
    end if
    u_log = logfile_unit ()
    call instance%choose_mci (mci_entry%i_mci)
    call instance%reset_counter ()
    mci_entry%pass = mci_entry%pass + 1
    mci_entry%n_it = n_it
    mci_entry%n_calls = n_calls
    if (mci_entry%pass == 1)  &
         call mci_entry%mci%startup_message (n_calls = n_calls)
    call mci_entry%mci%set_timer (active = mci_entry%activate_timer)
    call mci_entry%results%display_init &
         (mci_entry%process_type, screen = .true., unit = u_log)
    call mci_entry%results%new_pass ()
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      select case (char (nlo_type))
      case ('Virtual', 'Real')
        select type (mci_instance)
        type is (mci_vamp_instance_t)
          mci_instance%negative_weights = .true.
        end select
      end select
      call mci_entry%mci%add_pass (adapt_grids, adapt_weights, final)
      call mci_entry%mci%start_timer ()
      call mci_entry%mci%integrate (mci_instance, instance, n_it, &
           n_calls, mci_entry%results, pacify = pacify)
      call mci_entry%mci%stop_timer ()
      if (signal_is_pending ())  return
    end associate
    mci_entry%counter = instance%get_counter ()
    call mci_entry%results%display_pass (pacify)
  end subroutine process_mci_entry_integrate

  subroutine process_mci_entry_final_integration (mci_entry)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    call mci_entry%results%display_final ()
    call mci_entry%time_message ()
  end subroutine process_mci_entry_final_integration

@ %def process_mci_entry_integrate
@ %def process_mci_entry_final_integration
@ If appropriate, issue an informative message about the expected time
for an event sample.
<<Processes: process mci entry: TBP>>=
  procedure :: get_time => process_mci_entry_get_time
  procedure :: time_message => process_mci_entry_time_message
<<Processes: procedures>>=
  subroutine process_mci_entry_get_time (mci_entry, time, sample)
    class(process_mci_entry_t), intent(in) :: mci_entry
    type(time_t), intent(out) :: time
    integer, intent(in) :: sample
    real(default) :: time_last_pass, efficiency, calls
    time_last_pass = mci_entry%mci%get_time ()
    calls = mci_entry%results%get_n_calls ()
    efficiency = mci_entry%mci%get_efficiency ()
    if (time_last_pass > 0 .and. calls > 0 .and. efficiency > 0) then
       time = nint (time_last_pass / calls / efficiency * sample)
    end if
  end subroutine process_mci_entry_get_time   

  subroutine process_mci_entry_time_message (mci_entry)
    class(process_mci_entry_t), intent(in) :: mci_entry
    type(time_t) :: time
    integer :: sample
    sample = 10000
    call mci_entry%get_time (time, sample)
    if (time%is_known ()) then
       call msg_message ("Time estimate for generating 10000 events: " &
            // char (time%to_string_dhms ()))
    end if
  end subroutine process_mci_entry_time_message
  
@ %def process_mci_entry_time_message
@ Prepare event generation.  (For the test integrator, this does nothing.  It
is relevant for the VAMP integrator.)
<<Processes: process mci entry: TBP>>=
  procedure :: prepare_simulation => process_mci_entry_prepare_simulation
<<Processes: procedures>>=
  subroutine process_mci_entry_prepare_simulation (mci_entry)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    call mci_entry%mci%prepare_simulation ()
  end subroutine process_mci_entry_prepare_simulation

@ %def process_mci_entry_prepare_simulation
@ Generate an event.  The instance should be initialized,
otherwise event generation is directed by the [[mci]] integrator
subobject.  The integrator instance is contained in a [[mci_work]]
subobject of the process instance, which simultaneously serves as the
sampler object.  (We avoid the anti-aliasing rules if we assume that
the sampling itself does not involve the integrator instance contained in the
process instance.)

Regarding weighted events, we only take events which are valid, which
means that they have valid kinematics and have passed cuts.
Therefore, we have a rejection loop.  For unweighted events, the
unweighting routine should already take care of this.
<<Processes: process mci entry: TBP>>=
  procedure :: generate_weighted_event => &
       process_mci_entry_generate_weighted_event
  procedure :: generate_unweighted_event => &
       process_mci_entry_generate_unweighted_event
  procedure :: recover_event => process_mci_entry_recover_event
<<Processes: procedures>>=
  subroutine process_mci_entry_generate_weighted_event (mci_entry, instance)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    call instance%choose_mci (mci_entry%i_mci)
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      REJECTION: do
         call mci_entry%mci%generate_weighted_event (mci_instance, instance)
         if (signal_is_pending ())  return
         if (instance%is_valid ())  exit REJECTION
      end do REJECTION
    end associate
  end subroutine process_mci_entry_generate_weighted_event
  
  subroutine process_mci_entry_generate_unweighted_event (mci_entry, instance)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    call instance%choose_mci (mci_entry%i_mci)
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      call mci_entry%mci%generate_unweighted_event (mci_instance, instance)
    end associate
  end subroutine process_mci_entry_generate_unweighted_event
  
  subroutine process_mci_entry_recover_event (mci_entry, instance, i_term)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: channel
    mci_entry%i_mci = instance%i_mci
    channel = instance%get_channel ()
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      call mci_instance%fetch (instance, channel)
    end associate
  end subroutine process_mci_entry_recover_event
  
@ %def process_mci_entry_generate_weighted_event
@ %def process_mci_entry_generate_unweighted_event
@ %def process_mci_entry_recover_event
@ Extract results.
<<Processes: process mci entry: TBP>>=
  procedure :: has_integral => process_mci_entry_has_integral
  procedure :: get_integral => process_mci_entry_get_integral
  procedure :: get_error => process_mci_entry_get_error  
  procedure :: get_accuracy => process_mci_entry_get_accuracy
  procedure :: get_chi2 => process_mci_entry_get_chi2
  procedure :: get_efficiency => process_mci_entry_get_efficiency
<<Processes: procedures>>=
  function process_mci_entry_has_integral (mci_entry) result (flag)
    class(process_mci_entry_t), intent(in) :: mci_entry
    logical :: flag
    flag = mci_entry%results%exist ()
  end function process_mci_entry_has_integral
    
  function process_mci_entry_get_integral (mci_entry) result (integral)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: integral
    integral = mci_entry%results%get_integral ()
  end function process_mci_entry_get_integral

  function process_mci_entry_get_error (mci_entry) result (error)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: error
    error = mci_entry%results%get_error ()
  end function process_mci_entry_get_error
  
  function process_mci_entry_get_accuracy (mci_entry) result (accuracy)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: accuracy
    accuracy = mci_entry%results%get_accuracy ()
  end function process_mci_entry_get_accuracy
  
  function process_mci_entry_get_chi2 (mci_entry) result (chi2)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: chi2
    chi2 = mci_entry%results%get_chi2 ()
  end function process_mci_entry_get_chi2

  function process_mci_entry_get_efficiency (mci_entry) result (efficiency)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: efficiency
    efficiency = mci_entry%results%get_efficiency ()
  end function process_mci_entry_get_efficiency  
  
@ %def process_mci_entry_get_integral process_mci_entry_get_error
@ %def process_mci_entry_get_accuracy process_mci_entry_get_chi2
@ %def process_mci_entry_get_efficiency
@ Return the MCI checksum.  This may be the one used for
configuration, but may also incorporate results, if they change the
state of the integrator (adaptation).
<<Processes: process mci entry: TBP>>=
  procedure :: get_md5sum => process_mci_entry_get_md5sum
<<Processes: procedures>>=
  function process_mci_entry_get_md5sum (entry) result (md5sum)
    class(process_mci_entry_t), intent(in) :: entry
    character(32) :: md5sum
    md5sum = entry%mci%get_md5sum ()
  end function process_mci_entry_get_md5sum
  
@ %def process_mci_entry_get_md5sum
@
\subsection{Process Components}
A process component is an individual contribution to a process
(scattering or decay) which needs not be physical.  The sum over all
components should be physical.

The [[index]] indentifies this component within its parent process.

The actual process component is stored in the [[core]] subobject.  We
use a polymorphic subobject instead of an extension of
[[process_component_t]], because the individual entries in the array
of process components can have different types.  In short,
[[process_component_t]] is a wrapper for the actual process variants.

If the [[active]] flag is false, we should skip this component.  This happens
if the associated process has vanishing matrix element.

The index array [[i_term]] points to the individual terms generated by
this component.  The indices refer to the parent process.

The index [[i_mci]] is the index of the MC integrator and parameter set which
are associated to this process component.
<<Processes: process part types>>=
  type :: process_component_t
     private
     type(process_component_def_t), pointer :: config => null ()
     integer :: index = 0
     class(prc_core_t), allocatable :: core
     class(prc_core_t), allocatable :: core_sub_born
     logical :: active = .false.
     class(mci_t), allocatable :: mci_template
     integer, dimension(:), allocatable :: i_term
     integer :: i_mci = 0
     class(phs_config_t), allocatable :: phs_config
     character(32) :: md5sum_phs = ""
     type(fks_template_t) :: fks_template
   contains
   <<Processes: process component: TBP>>
  end type process_component_t

@ %def process_component_t
@ Finalizer.  The MCI template may (potentially) need a finalizer.  The process
configuration finalizer may include closing an open scratch file.
<<Processes: process component: TBP>>=
  procedure :: final => process_component_final
<<Processes: procedures>>=
  subroutine process_component_final (object)
    class(process_component_t), intent(inout) :: object
    if (allocated (object%mci_template)) then
       call object%mci_template%final ()
    end if
    if (allocated (object%phs_config)) then
       call object%phs_config%final ()
    end if
  end subroutine process_component_final
  
@ %def process_component_final
@ The meaning of [[verbose]] depends on the process variant.
<<Processes: process component: TBP>>=
  procedure :: write => process_component_write
<<Processes: procedures>>=
  subroutine process_component_write (object, unit)
    class(process_component_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (allocated (object%core)) then
       write (u, "(1x,A,I0)")  "Component #", object%index
       if (associated (object%config)) then
          call object%config%write (u)
          if (object%md5sum_phs /= "") then
             write (u, "(3x,A,A,A)")  "MD5 sum (phs)       = '", &
                  object%md5sum_phs, "'"
          end if
       end if
       write (u, "(1x,A)") "Process core:"
       call object%core%write (u)
    else
       write (u, "(1x,A)") "Process component: [not allocated]"
    end if
    if (.not. object%active) then
       write (u, "(1x,A)") "[Inactive]"
       return
    end if
    write (u, "(1x,A)") "Referenced data:"
    if (allocated (object%i_term)) then
       write (u, "(3x,A,999(1x,I0))") "Terms                    =", &
            object%i_term
    else
       write (u, "(3x,A)") "Terms                    = [undefined]"
    end if
    if (object%i_mci /= 0) then
       write (u, "(3x,A,I0)") "MC dataset               = ", object%i_mci
    else
       write (u, "(3x,A)") "MC dataset               = [undefined]"
    end if
    if (allocated (object%phs_config)) then
       call object%phs_config%write (u)
    end if
  end subroutine process_component_write

@ %def process_component_write
@ Initialize the component.
<<Processes: process component: TBP>>=
  procedure :: init => process_component_init
<<Processes: procedures>>=
  subroutine process_component_init (component, &
       i_component, meta, config, &
       core_template, mci_template, phs_config_template, &
       gosam_template, fks_template)
    class(process_component_t), intent(out) :: component
    integer, intent(in) :: i_component
    type(process_metadata_t), intent(in) :: meta
    type(process_config_data_t), intent(in) :: config
    class(prc_core_t), intent(in), allocatable :: core_template
    class(mci_t), intent(in), allocatable :: mci_template
    class(phs_config_t), intent(in), allocatable :: phs_config_template
    type(gosam_writer_template_t), intent(inout), optional :: gosam_template
    type(fks_template_t), intent(in), optional :: fks_template
    integer, dimension(3) :: amp_type

    component%index = i_component
    component%config => meta%lib%get_component_def_ptr (meta%id, i_component)
    allocate (component%core, source=core_template)
    call component%core%init (component%config%get_core_def_ptr (), &
         meta%lib, meta%id, i_component)
    if (present (gosam_template)) then
      call component%fill_constants (gosam_template%data)
    end if
    if (present (fks_template)) then
      component%fks_template = fks_template
    end if
    select type (core => component%core)
    type is (prc_gosam_t)
      if (present (gosam_template)) then
        call core%init_writer (gosam_template, config%os_data, config%model)
        call core%set_n_proc ()
      else
        call msg_bug ("process_component_init: gosam core cannot be initialized - &
                       & missing template")
      end if
      call core%init_driver (config%os_data)
      call core%set_initialized ()
    end select
    component%active = component%core%has_matrix_element ()
    if (component%active .or. component%config%get_nlo_type () == 'Subtraction') then
       if (allocated (mci_template)) &
            allocate (component%mci_template, source=mci_template)
       allocate (component%phs_config, source=phs_config_template)
       call component%phs_config%init (component%core%data, config%model)
    end if
  end subroutine process_component_init

@ %def process_component_init
@ Finalize the phase-space configuration. 
<<Processes: process component: TBP>>=
  procedure :: configure_phs => process_component_configure_phs
<<Processes: procedures>>=
  subroutine process_component_configure_phs &
       (component, sqrts, beam_config, rebuild, &
        ignore_mismatch, phs_config)
    class(process_component_t), intent(inout) :: component
    real(default), intent(in) :: sqrts
    type(process_beam_config_t), intent(in) :: beam_config
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(phs_wood_config_t), intent(in), optional, target :: phs_config
    logical :: no_strfun
    type(string_t) :: nlo_type
    no_strfun = beam_config%n_strfun == 0
    nlo_type = component%config%get_nlo_type ()
    if (present (phs_config)) then
       select type (config => component%phs_config)
       type is (phs_fks_config_t)
          call config%set_born_config (phs_config)
       end select
    end if
    call component%phs_config%configure (sqrts, &
         azimuthal_dependence = beam_config%azimuthal_dependence, &
         sqrts_fixed = no_strfun, &
         cm_frame = beam_config%lab_is_cm_frame .and. no_strfun, &
         rebuild = rebuild, ignore_mismatch = ignore_mismatch, &
         nlo_type = nlo_type)
    call component%phs_config%startup_message ()
  end subroutine process_component_configure_phs
    
@ %def process_component_configure_phs
@ The process component possesses two MD5 sums: the checksum of the
component definition, which should be available when the component is
initialized, and the phase-space MD5 sum, which is available after
configuration.
<<Processes: process component: TBP>>=
  procedure :: compute_md5sum => process_component_compute_md5sum
<<Processes: procedures>>=
  subroutine process_component_compute_md5sum (component)
    class(process_component_t), intent(inout) :: component
    component%md5sum_phs = component%phs_config%get_md5sum ()
  end subroutine process_component_compute_md5sum
  
@ %def process_component_compute_md5sum
@ Match phase-space channels with structure-function channels, where
applicable.

This calls a method of the [[phs_config]] phase-space implementation.
<<Processes: process component: TBP>>=
  procedure :: collect_channels => process_component_collect_channels
<<Processes: procedures>>=
  subroutine process_component_collect_channels (component, coll)
    class(process_component_t), intent(inout) :: component
    type(phs_channel_collection_t), intent(inout) :: coll
    call component%phs_config%collect_channels (coll)
  end subroutine process_component_collect_channels
    
@ %def process_component_collect_channels
@ Return the number of phase-space parameters.
<<Processes: process component: TBP>>=
  procedure :: get_n_phs_par => process_component_get_n_phs_par
<<Processes: procedures>>=
  function process_component_get_n_phs_par (component) result (n_par)
    class(process_component_t), intent(in) :: component
    integer :: n_par
    n_par = component%phs_config%get_n_par ()
  end function process_component_get_n_phs_par
    
@ %def process_component_get_n_phs_par
@ Return the incoming flavor combination as an array of PDG arrays,
one for a decay or two for a scattering process.
<<Processes: process component: TBP>>=
  procedure :: get_pdg_in => process_component_get_pdg_in
<<Processes: procedures>>=
  function process_component_get_pdg_in (component) result (pdg_in)
    class(process_component_t), intent(in) :: component
    type(pdg_array_t), dimension(:), allocatable :: pdg_in
    type(pdg_array_t) :: pdg_tmp
    integer :: i
    associate (data => component%core%data)
      allocate (pdg_in (data%n_in))
      do i = 1, data%n_in
         pdg_tmp = data%flv_state(i,:)
         pdg_in(i) = sort_abs (pdg_tmp, unique = .true.)
      end do
    end associate
  end function process_component_get_pdg_in
  
@ %def process_component_get_pdg_in
@
<<Processes: process component: TBP>>=
  procedure :: fill_constants => process_component_fill_constants
<<Processes: procedures>>=
  subroutine process_component_fill_constants (component, data)
    class(process_component_t), intent(inout) :: component
    type(process_constants_t), intent(in) :: data
    select type(core => component%core)
    type is (prc_gosam_t)
       call core%fill_constants (data)
    end select
  end subroutine process_component_fill_constants

@ %def process_component_fill_constants
@
<<Processes: process component: TBP>>=
  procedure :: extract_phs_config => process_component_extract_phs_config
  procedure :: restore_phs_config => process_component_restore_phs_config
<<Processes: procedures>>=
  subroutine process_component_extract_phs_config (component, phs_config)
    class(process_component_t), intent(inout) :: component
    class(phs_config_t), intent(inout), allocatable :: phs_config
    call move_alloc (from = component%phs_config, to = phs_config)
  end subroutine process_component_extract_phs_config

  subroutine process_component_restore_phs_config (component, phs_config)
    class(process_component_t), intent(inout) :: component
    class(phs_config_t), intent(inout), allocatable :: phs_config
    call move_alloc (from = phs_config, to = component%phs_config)
  end subroutine process_component_restore_phs_config

@ %def process_component_fill_constants
@
\subsection{Process terms}
For straightforward tree-level calculations, each process component
corresponds to a unique elementary interaction.  However, in the case
of NLO calculations with subtraction terms, a process component may
split into several separate contributions to the scattering, which are
qualified by interactions with distinct kinematics and particle
content.  We represent their configuration as [[process_term_t]]
objects, the actual instances will be introduced below as
[[term_instance_t]].  In any case, the process term contains an
elementary interaction with a definite quantum-number and momentum
content.

The index [[i_term_global]] identifies the term relative to the
process.

The index [[i_component]] identifies the process component which
generates this term, relative to the parent process.

The index [[i_term]] identifies the term relative to the process
component (not the process).

The [[data]] subobject holds all process constants.

The number of allowed flavor/helicity/color combinations is stored as
[[n_allowed]].  This is the total number of independent entries in the
density matrix.  For each combination, the index of the flavor,
helicity, and color state is stored in the arrays [[flv]], [[hel]],
and [[col]], respectively.

The flag [[rearrange]] is true if we need to rearrange the particles of the
hard interaction, to obtain the effective parton state.

The interaction [[int]] holds the quantum state for the (resolved) hard
interaction, the parent-child relations of the particles, and their momenta.
The momenta are not filled yet; this is postponed to copies of [[int]] which
go into the process instances.

If recombination is in effect, we should allocate [[int_eff]] to describe the
rearranged partonic state.
<<Processes: process part types>>=
  type :: process_term_t
     integer :: i_term_global = 0
     integer :: i_component = 0
     integer :: i_term = 0
     integer :: n_allowed = 0
     integer :: n_allowed_sub_born = 0
     type(process_constants_t) :: data
     real(default) :: alpha_s = 0
     integer, dimension(:), allocatable :: flv, hel, col
     logical :: rearrange = .false.
     type(interaction_t) :: int
     type(interaction_t), pointer :: int_eff => null ()
   contains
   <<Processes: process term: TBP>>
  end type process_term_t
  
@ %def process_term_t
@ For the output, we skip the process constants and the tables of
allowed quantum numbers.  Those can also be read off from the
interaction object.
<<Processes: process term: TBP>>=
  procedure :: write => process_term_write
<<Processes: procedures>>=
  subroutine process_term_write (term, unit)
    class(process_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,I0)")  "Term #", term%i_term_global
    write (u, "(3x,A,I0)")  "Process component index      = ", &
         term%i_component
    write (u, "(3x,A,I0)")  "Term index w.r.t. component  = ", &
         term%i_term
    write (u, "(3x,A,L1)")  "Rearrange partons            = ", &
         term%rearrange
    call write_separator (u)
    write (u, "(1x,A)")  "Hard interaction:"
    call write_separator (u)
    call interaction_write (term%int, u)
    if (term%rearrange) then
       call write_separator (u)
       write (u, "(1x,A)")  "Rearranged hard interaction:"
       call write_separator (u)
       call interaction_write (term%int_eff, u)
    end if
  end subroutine process_term_write
     
@ %def process_term_write
@ Write an account of all quantum number states and their current status.
<<Processes: process term: TBP>>=
  procedure :: write_state_summary => process_term_write_state_summary
<<Processes: procedures>>=
  subroutine process_term_write_state_summary (term, core, unit)
    class(process_term_t), intent(in) :: term
    class(prc_core_t), intent(in) :: core
    integer, intent(in), optional :: unit
    integer :: u, i, f, h, c
    type(state_iterator_t) :: it
    character :: sgn
    u = given_output_unit (unit)
    write (u, "(1x,A,I0)")  "Term #", term%i_term_global
    call state_iterator_init (it, interaction_get_state_matrix_ptr (term%int))
    do while (state_iterator_is_valid (it))
       i = state_iterator_get_me_index (it)
       f = term%flv(i)
       h = term%hel(i)
       c = term%col(i)
       if (core%is_allowed (term%i_term, f, h, c)) then
          sgn = "+"
       else
          sgn = " "
       end if
       write (u, "(1x,A1,1x,I0,2x)", advance="no")  sgn, i
       call quantum_numbers_write (state_iterator_get_quantum_numbers (it), u)
       write (u, *)
       call state_iterator_advance (it)
    end do
  end subroutine process_term_write_state_summary
  
@ %def process_term_write_state_summary
@ Finalizer: the [[int]] and potentially [[int_eff]] components have a
finalizer that we must call.
<<Processes: process term: TBP>>=
  procedure :: final => process_term_final
<<Processes: procedures>>=
  subroutine process_term_final (term)
    class(process_term_t), intent(inout) :: term
    call interaction_final (term%int)
    if (term%rearrange) then
       call interaction_final (term%int_eff)
       deallocate (term%int_eff)
    end if
  end subroutine process_term_final

@ %def process_term_final
@ Initialize the term.  We copy the process constants from the [[core]]
object and set up the [[int]] hard interaction accordingly.

The [[alpha_s]] value is useful for writing external event records.  This is
the constant value which may be overridden by a event-specific running value.
If the model does not contain the strong coupling, the value is zero.

The [[rearrange]] part is commented out; this or something equivalent
could become relevant for NLO algorithms.
<<Processes: process term: TBP>>=
  procedure :: init => process_term_init
<<Processes: procedures>>=
  subroutine process_term_init &
       (term, i_term_global, i_component, i_term, core, model)
    class(process_term_t), intent(inout), target :: term
    integer, intent(in) :: i_term_global
    integer, intent(in) :: i_component
    integer, intent(in) :: i_term
    class(prc_core_t), intent(in) :: core
    type(model_t), intent(in), target :: model
    type(var_list_t), pointer :: var_list
    term%i_term_global = i_term_global
    term%i_component = i_component
    term%i_term = i_term
    call core%get_constants (term%data, i_term)
    var_list => model%get_var_list_ptr ()
    if (var_list_exists (var_list, var_str ("alphas"))) then
       term%alpha_s = var_list_get_rval (var_list, var_str ("alphas"))
    else
       term%alpha_s = -1
    end if
    call term%setup_interaction (core, model)
!     if (term%rearrange) then
!       call term%setup_effective_interaction (core, term%int, term%int_eff)
!     end if
  end subroutine process_term_init
    
@ %def process_term_init
@ We fetch the process constants which determine the quantum numbers and
use those to create the interaction.  The interaction contains
incoming and outgoing particles, no virtuals.  The incoming particles
are parents of the outgoing ones.

Keeping previous \whizard\ conventions, we invert the color assignment
(but not flavor or helicity) for the incoming particles.  When the
color-flow square matrix is evaluated, this inversion is done again,
so in the color-flow sequence we get the color assignments of the
matrix element.
<<Processes: process term: TBP>>=
  procedure :: setup_interaction => process_term_setup_interaction
<<Processes: procedures>>=
  subroutine process_term_setup_interaction (term, core, model)
    class(process_term_t), intent(inout) :: term
    class(prc_core_t), intent(in) :: core
    type(model_t), intent(in), target :: model
    integer :: n_tot
    type(flavor_t), dimension(:), allocatable :: flv
    type(color_t), dimension(:), allocatable :: col
    type(helicity_t), dimension(:), allocatable :: hel
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, n, f, h, c
    associate (data => term%data)
      n_tot = data%n_in + data%n_out
      n = 0
      do f = 1, data%n_flv
         do h = 1, data%n_hel
            do c = 1, data%n_col
               if (core%is_allowed (term%i_term, f, h, c))  n = n + 1
            end do
         end do
      end do
      allocate (term%flv (n), term%col (n), term%hel (n))
      term%n_allowed = n
      allocate (flv (n_tot), col (n_tot), hel (n_tot))
      allocate (qn (n_tot))
      call interaction_init &
           (term%int, data%n_in, 0, data%n_out, set_relations=.true.)
      i = 0
      do f = 1, data%n_flv
         do h = 1, data%n_hel
            do c = 1, data%n_col
               if (core%is_allowed (term%i_term, f, h, c)) then
                  i = i + 1
                  term%flv(i) = f
                  term%hel(i) = h
                  term%col(i) = c
                  call flavor_init (flv, data%flv_state(:,f), model)
                  call color_init_from_array (col, data%col_state(:,:,c), &
                       data%ghost_flag(:,c))
                  call color_invert (col(:data%n_in))
                  call helicity_init (hel, data%hel_state(:,h))
                  call quantum_numbers_init (qn, flv, col, hel)
                  call interaction_add_state (term%int, qn)
               end if
            end do
         end do
      end do
      call interaction_freeze (term%int)
    end associate
  end subroutine process_term_setup_interaction
  
@ %def process_term_setup_interaction
@
<<Processes: process term: TBP>>=
  procedure :: fetch_constants => process_term_fetch_process_constants
<<Processes: procedures>>= 
   subroutine process_term_fetch_process_constants &
       (term, prc_constants)
    class(process_term_t), intent(inout) :: term
    type(process_constants_t), intent(out) :: prc_constants
    prc_constants = term%data
  end subroutine process_term_fetch_process_constants

@ %def process_term_fetch_process_constants
@
\subsection{Default Iterations}
If the user does not specify the passes and iterations for
integration, we should be able to give reasonable defaults.  These
depend on the process, therefore we implement the following procedures
as methods of the process object.  The algorithm is not very
sophisticated yet, it may be improved by looking at the process in
more detail.

We investigate only the first process component, assuming that it
characterizes the complexity of the process reasonable well.

The number of passes is limited to two: one for adaption, one for
integration.
<<Processes: process: TBP>>=
  procedure :: get_n_pass_default => process_get_n_pass_default
  procedure :: adapt_grids_default => process_adapt_grids_default
  procedure :: adapt_weights_default => process_adapt_weights_default
<<Processes: procedures>>=
  function process_get_n_pass_default (process) result (n_pass)
    class(process_t), intent(in) :: process
    integer :: n_pass
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       n_pass = 1
    case default
       n_pass = 2
    end select
  end function process_get_n_pass_default
  
  function process_adapt_grids_default (process, pass) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    logical :: flag
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       flag = .false.
    case default
       select case (pass)
       case (1);  flag = .true.
       case (2);  flag = .false.
       case default
          call msg_bug ("adapt grids default: impossible pass index")
       end select
    end select
  end function process_adapt_grids_default
  
  function process_adapt_weights_default (process, pass) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    logical :: flag
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       flag = .false.
    case default
       select case (pass)
       case (1);  flag = .true.
       case (2);  flag = .false.
       case default
          call msg_bug ("adapt weights default: impossible pass index")
       end select
    end select
  end function process_adapt_weights_default
  
@ %def process_get_n_pass_default
@ %def process_adapt_grids_default
@ %def process_adapt_weights_default
@ The number of iterations and calls per iteration depends on the
number of outgoing particles.
<<Processes: process: TBP>>=
  procedure :: get_n_it_default => process_get_n_it_default
  procedure :: get_n_calls_default => process_get_n_calls_default
<<Processes: procedures>>=
  function process_get_n_it_default (process, pass) result (n_it)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    integer :: n_it
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (pass)
    case (1)
       select case (n_eff)
       case (1);   n_it = 1
       case (2);   n_it = 3
       case (3);   n_it = 5
       case (4:5); n_it = 10
       case (6);   n_it = 15
       case (7:);  n_it = 20
       end select
    case (2)
       select case (n_eff)
       case (:3);   n_it = 3
       case (4:);   n_it = 5
       end select
    end select
  end function process_get_n_it_default
  
  function process_get_n_calls_default (process, pass) result (n_calls)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    integer :: n_calls
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (pass)
    case (1)
       select case (n_eff)
       case (1);   n_calls =   100
       case (2);   n_calls =  1000
       case (3);   n_calls =  5000
       case (4);   n_calls = 10000
       case (5);   n_calls = 20000
       case (6:);  n_calls = 50000
       end select
    case (2)
       select case (n_eff)
       case (:3);  n_calls =  10000
       case (4);   n_calls =  20000
       case (5);   n_calls =  50000
       case (6);   n_calls = 100000
       case (7:);  n_calls = 200000
       end select
    end select
  end function process_get_n_calls_default
  
@ %def process_get_n_it_default
@ %def process_get_n_calls_default
@ 
\subsection{Constant process data}
The following methods return basic process data that stay constant
after initialization.

The process and IDs.
<<Processes: process: TBP>>=
  procedure :: get_id => process_get_id
  procedure :: get_num_id => process_get_num_id
  procedure :: get_run_id => process_get_run_id
  procedure :: get_library_name => process_get_library_name
<<Processes: procedures>>=
  function process_get_id (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%id
  end function process_get_id

  function process_get_num_id (process) result (id)
    class(process_t), intent(in) :: process
    integer :: id
    id = process%meta%num_id
  end function process_get_num_id

  function process_get_run_id (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%run_id
  end function process_get_run_id

  function process_get_library_name (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%lib%get_name ()
  end function process_get_library_name

@ %def process_get_id process_get_num_id 
@ %def process_get_run_id process_get_library_name
@ The number of incoming particles.
<<Processes: process: TBP>>=
  procedure :: get_n_in => process_get_n_in
<<Processes: procedures>>=
  function process_get_n_in (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_in
  end function process_get_n_in
    
@ %def process_get_n_in
@ The number of MCI data sets.
<<Processes: process: TBP>>=
  procedure :: get_n_mci => process_get_n_mci
<<Processes: procedures>>=
  function process_get_n_mci (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_mci
  end function process_get_n_mci
    
@ %def process_get_n_mci
@ The number of process components, total.
<<Processes: process: TBP>>=
  procedure :: get_n_components => process_get_n_components
<<Processes: procedures>>=
  function process_get_n_components (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%meta%n_components
  end function process_get_n_components
    
@ %def process_get_n_components
@ The number of process terms, total.
<<Processes: process: TBP>>=
  procedure :: get_n_terms => process_get_n_terms
<<Processes: procedures>>=
  function process_get_n_terms (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_terms
  end function process_get_n_terms
    
@ %def process_get_n_terms
@ Return the indices of the components that belong to a
specific MCI entry.
<<Processes: process: TBP>>=
  procedure :: get_i_component => process_get_i_component
<<Processes: procedures>>=
  subroutine process_get_i_component (process, i_mci, i_component)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    integer, dimension(:), intent(out), allocatable :: i_component
    associate (mci_entry => process%mci_entry(i_mci))
      allocate (i_component (size (mci_entry%i_component)))
      i_component = mci_entry%i_component
    end associate
  end subroutine process_get_i_component

@ %def process_get_i_component
@ Return the ID of a specific component.
<<Processes: process: TBP>>=
  procedure :: get_component_id => process_get_component_id
<<Processes: procedures>>=
  function process_get_component_id (process, i_component) result (id)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    type(string_t) :: id
    id = process%meta%component_id(i_component)
  end function process_get_component_id
    
@ %def process_get_component_id
@ Return a pointer to the definition of a specific component.
<<Processes: process: TBP>>=
  procedure :: get_component_def_ptr => process_get_component_def_ptr
<<Processes: procedures>>=
  function process_get_component_def_ptr (process, i_component) result (ptr)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    type(process_component_def_t), pointer :: ptr
    ptr => process%meta%lib%get_component_def_ptr (process%meta%id, i_component)
  end function process_get_component_def_ptr
  
@ %def process_get_component_def_ptr
@ These procedures extract and restore (by transferring the
allocation) the process core.  This is useful for changing process
parameters from outside this module.
<<Processes: process: TBP>>=
  procedure :: extract_component_core => process_extract_component_core
  procedure :: restore_component_core => process_restore_component_core
<<Processes: procedures>>=
  subroutine process_extract_component_core (process, i_component, core)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_component
    class(prc_core_t), intent(inout), allocatable :: core
    call move_alloc (from = process%component(i_component)%core, to = core)
  end subroutine process_extract_component_core
    
  subroutine process_restore_component_core (process, i_component, core)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_component
    class(prc_core_t), intent(inout), allocatable :: core
    call move_alloc (from = core, to = process%component(i_component)%core)
  end subroutine process_restore_component_core
    
@ %def process_extract_component_core
@ %def process_restore_component_core
@ The block of process constants.
<<Processes: process: TBP>>=
  procedure :: get_constants => process_get_constants
<<Processes: procedures>>=
  function process_get_constants (process, i) result (data)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i
    type(process_constants_t) :: data
    data = process%component(i)%core%data
  end function process_get_constants
  
@ %def process_get_constants
@ Return the set of outgoing flavors that are associated with a particular
term. We deduce this from the effective interaction.
<<Processes: process: TBP>>=
  procedure :: get_term_flv_out => process_get_term_flv_out
<<Processes: procedures>>=
  subroutine process_get_term_flv_out (process, i_term, flv)
    class(process_t), intent(in), target :: process
    integer, intent(in) :: i_term
    type(flavor_t), dimension(:,:), allocatable, intent(out) :: flv
    type(interaction_t), pointer :: int
    int => process%term(i_term)%int_eff
    if (.not. associated (int))  int => process%term(i_term)%int
    call interaction_get_flv_out (int, flv)
  end subroutine process_get_term_flv_out

@ %def process_get_term_flv_out
@ Return true if there is any unstable particle in any of the process
terms.  We decide this based on the provided model instance, not the
one that is stored in the process object.
<<Processes: process: TBP>>=
  procedure :: contains_unstable => process_contains_unstable
<<Processes: procedures>>=
  function process_contains_unstable (process, model) result (flag)
    class(process_t), intent(in) :: process
    type(model_t), intent(in), target :: model
    logical :: flag
    integer :: i_term
    type(flavor_t), dimension(:,:), allocatable :: flv
    flag = .false.
    do i_term = 1, process%get_n_terms ()
       call process%get_term_flv_out (i_term, flv)
       call flavor_set_model (flv, model)
       flag = .not. all (flavor_is_stable (flv))
       deallocate (flv)
       if (flag)  return
    end do
  end function process_contains_unstable
    
@ %def process_contains_unstable
@ The nominal process energy.
<<Processes: process: TBP>>=
  procedure :: get_sqrts => process_get_sqrts
<<Processes: procedures>>=
  function process_get_sqrts (process) result (sqrts)
    class(process_t), intent(in) :: process
    real(default) :: sqrts
    sqrts = beam_data_get_sqrts (process%beam_config%data)
  end function process_get_sqrts
  
@ %def process_get_sqrts
<<Processes: process: TBP>>=
  procedure :: has_matrix_element => process_has_matrix_element
<<Processes: procedures>>=
  function process_has_matrix_element (process, i) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: i
    logical :: flag
    if (present (i)) then
       flag = process%component(i)%active
    else
       flag = any (process%component%active)
    end if
  end function process_has_matrix_element
  
@ %def process_has_matrix_element
@ Pointer to the beam data object.
<<Processes: process: TBP>>=
  procedure :: get_beam_data_ptr => process_get_beam_data_ptr
<<Processes: procedures>>=
  function process_get_beam_data_ptr (process) result (beam_data)
    class(process_t), intent(in), target :: process
    type(beam_data_t), pointer :: beam_data
    beam_data => process%beam_config%data
  end function process_get_beam_data_ptr

@ %def process_get_beam_data_ptr
@ Return true if lab and c.m.\ frame coincide for this process.
<<Processes: process: TBP>>=
  procedure :: cm_frame => process_cm_frame
<<Processes: procedures>>=
  function process_cm_frame (process) result (flag)
    class(process_t), intent(in), target :: process
    logical :: flag
    type(beam_data_t), pointer :: beam_data
    beam_data => process%beam_config%data
    flag = beam_data_cm_frame (beam_data)
  end function process_cm_frame
  
@ %def process_cm_frame
@ Get the PDF set currently in use, if any.
<<Processes: process: TBP>>=
  procedure :: get_pdf_set => process_get_pdf_set
<<Processes: procedures>>=
  function process_get_pdf_set (process) result (pdf_set)
    class(process_t), intent(in) :: process
    integer :: pdf_set
    pdf_set = process%beam_config%get_pdf_set ()
  end function process_get_pdf_set
  
@ %def process_get_pdf_set
@ Pointer to the process variable list.
<<Processes: process: TBP>>=
  procedure :: get_var_list_ptr => process_get_var_list_ptr
<<Processes: procedures>>=
  function process_get_var_list_ptr (process) result (ptr)
    class(process_t), intent(in), target :: process
    type(var_list_t), pointer :: ptr
    ptr => process%meta%var_list
  end function process_get_var_list_ptr
  
@ %def process_get_var_list_ptr
@ Pointer to the common model.
<<Processes: process: TBP>>=
  procedure :: get_model_ptr => process_get_model_ptr
<<Processes: procedures>>=
  function process_get_model_ptr (process) result (ptr)
    class(process_t), intent(in) :: process
    type(model_t), pointer :: ptr
    ptr => process%config%model
  end function process_get_model_ptr
  
@ %def process_get_model_ptr
@ Use the embedded RNG factory to spawn a new random-number generator
instance.  (This modifies the state of the factory.)
<<Processes: process: TBP>>=
  procedure :: make_rng => process_make_rng
<<Processes: procedures>>=
  subroutine process_make_rng (process, rng)
    class(process_t), intent(inout) :: process
    class(rng_t), intent(out), allocatable :: rng
    if (allocated (process%config%rng_factory)) then
       call process%config%rng_factory%make (rng)
    else
       call msg_bug ("Process: make rng: factory not allocated")
    end if
  end subroutine process_make_rng
  
@ %def process_make_rng
@
\subsection{Compute an amplitude}
Each process variant should allow for computing an amplitude value
directly, without generating a process instance. 

The process component is selected by the index [[i]].  The term within the
process component is selected by [[j]].  The momentum
combination is transferred as the array [[p]].  The function sets the specific
quantum state via the indices of a flavor [[f]], helicity [[h]], and color
[[c]] combination.  Each index refers to the list of flavor, helicity, and
color states, respectively, as stored in the process data.

Optionally, we may set factorization and renormalization scale.  If unset, the
partonic c.m.\ energy is inserted.

The function checks arguments for validity.
For invalid arguments (quantum states), we return zero.
<<Processes: process: TBP>>=
  procedure :: compute_amplitude => process_compute_amplitude
<<Processes: procedures>>=
  function process_compute_amplitude &
       (process, i, j, p, f, h, c, fac_scale, ren_scale) result (amp)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i, j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in), optional :: fac_scale, ren_scale
    real(default) :: fscale, rscale
    complex(default) :: amp
    amp = 0
    if (0 < i .and. i <= process%meta%n_components) then
       if (process%component(i)%active) then
          associate (data => process%component(i)%core%data)
            if (size (p) == data%n_in + data%n_out &
                 .and. 0 < f .and. f <= data%n_flv &
                 .and. 0 < h .and. h <= data%n_hel &
                 .and. 0 < c .and. c <= data%n_col) then
               if (present (fac_scale)) then
                  fscale = fac_scale
               else
                  fscale = sum (p(data%n_in+1:)) ** 1
               end if
               if (present (ren_scale)) then
                  rscale = ren_scale
               else
                  rscale = fscale
               end if
               amp = process%component(i)%core% &
                    compute_amplitude (j, p, f, h, c, fscale, rscale)
            end if
          end associate
       else
          amp = 0
       end if
    end if
  end function process_compute_amplitude

@ %def process_compute_amplitude
@ This is for suppression of numerical noise in the integration results
stored in the [[process_mci_entry]] type. As the error and efficiency
enter the MD5 sum, we recompute it. 
<<Processes: process: TBP>>=
  procedure :: pacify => process_pacify
<<Processes: procedures>>=
  subroutine process_pacify (process, efficiency_reset, error_reset)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: efficiency_reset, error_reset
    logical :: eff_reset, err_reset
    integer :: i
    eff_reset = .false.
    err_reset = .false.
    if (present (efficiency_reset))  eff_reset = efficiency_reset
    if (present (error_reset))  err_reset = error_reset
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          call process%mci_entry(i)%results%pacify (efficiency_reset)
          if (allocated (process%mci_entry(i)%mci)) then
             if (process%mci_entry(i)%mci%error_known .and. err_reset) &
               process%mci_entry(i)%mci%error = 0
             if (process%mci_entry(i)%mci%efficiency_known .and. &
               eff_reset)  process%mci_entry(i)%mci%efficiency = 1             
             select type (mci => process%mci_entry(i)%mci) 
             type is (mci_vamp_t)
                call mci%pacify (efficiency_reset, error_reset)
	        call mci%compute_md5sum ()
             end select
          end if
       end do
    end if
  end subroutine process_pacify

@ %def process_pacify
@
\subsection{Process instances}

\subsubsection{Kinematics instance}
In this data type we combine all objects (instances) necessary for
generating (or recovering) a kinematical configuration.  The
components work together as an implementation of multi-channel phase
space.

[[sf_chain]] is an instance of the structure-function chain.  It is
used both for generating kinematics and, after the proper scale has
been determined, evaluating the structure function entries.

[[phs]] is an instance of the phase space for the elementary process.

The array [[f]] contains the products of the Jacobians that originate
from parameter mappings in the structure-function chain or in the
phase space.  We allocate this explicitly if either [[sf_chain]] or
[[phs]] are explicitly allocated, otherwise we can take over a pointer.

All components are implemented as pointers to (anonymous) targets.
For each component, there is a flag that tells whether this component
is to be regarded as a proper component (`owned' by the object) or as
a pointer.
<<Processes: types>>=
  type :: kinematics_t
     integer :: n_in = 0
     integer :: n_channel = 0
     integer :: selected_channel = 0
     type(sf_chain_instance_t), pointer :: sf_chain => null ()
     class(phs_t), pointer :: phs => null ()
     real(default), dimension(:), pointer :: f => null ()
     real(default) :: phs_factor
     logical :: sf_chain_allocated = .false.
     logical :: phs_allocated = .false.
     logical :: f_allocated = .false.
     type(string_t) :: nlo_type
     integer :: emitter
   contains
   <<Processes: kinematics: TBP>>
  end type kinematics_t

@ %def kinematics_t
@ Output.  Show only those components which are marked as owned.
<<Processes: kinematics: TBP>>=
  procedure :: write => kinematics_write
<<Processes: procedures>>=
  subroutine kinematics_write (object, unit)
    class(kinematics_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, c
    u = given_output_unit (unit)
    if (object%f_allocated) then
       write (u, "(1x,A)")  "Flux * PHS volume:"
       write (u, "(2x,ES19.12)")  object%phs_factor
       write (u, "(1x,A)")  "Jacobian factors per channel:"
       do c = 1, size (object%f)
          write (u, "(3x,I0,':',1x,ES13.7)", advance="no")  c, object%f(c)
          if (c == object%selected_channel) then
             write (u, "(1x,A)")  "[selected]"
          else
             write (u, *)
          end if
       end do
    end if
    if (object%sf_chain_allocated) then
       call write_separator (u)
       call object%sf_chain%write (u)
    end if
    if (object%phs_allocated) then
       call write_separator (u)
       call object%phs%write (u)
    end if
  end subroutine kinematics_write
    
@ %def kinematics_write
@ Finalizer.  Delete only those components which are marked as owned.
<<Processes: kinematics: TBP>>=
  procedure :: final => kinematics_final
<<Processes: procedures>>=
  subroutine kinematics_final (object)
    class(kinematics_t), intent(inout) :: object
    if (object%sf_chain_allocated) then
       call object%sf_chain%final ()
       deallocate (object%sf_chain)
       object%sf_chain_allocated = .false.
    end if
    if (object%phs_allocated) then
       call object%phs%final ()
       deallocate (object%phs)
       object%phs_allocated = .false.
    end if
    if (object%f_allocated) then
       deallocate (object%f)
       object%f_allocated = .false.
    end if
  end subroutine kinematics_final
  
@ %def kinematics_final
@ Set the flags indicating whether the phase space shall be set up for the calculation of the real contribution. For this case, also set the emitter.
<<Processes: kinematics: TBP>>=
  procedure :: set_nlo_data => kinematics_set_nlo_data
<<Processes: procedures>>=
  subroutine kinematics_set_nlo_data (k, nlo_type, emitter)
    class(kinematics_t), intent(inout) :: k
!    integer, intent(in) :: nlo_type
    type(string_t) :: nlo_type
    integer, intent(in), optional :: emitter
    k%nlo_type = nlo_type
    if (present (emitter)) then
      k%emitter = emitter
    end if
  end subroutine kinematics_set_nlo_data

@ %def kinematics_set_nlo_data
@ Allocate the structure-function chain instance, initialize it as a
copy of the [[sf_chain]] template, and prepare it for evaluation.

The [[sf_chain]] remains a target because the (usually constant) beam momenta
are taken from there.
<<Processes: kinematics: TBP>>=
  procedure :: init_sf_chain => kinematics_init_sf_chain
<<Processes: procedures>>=
  subroutine kinematics_init_sf_chain (k, core, sf_chain, config, tmp)
    class(kinematics_t), intent(inout) :: k
    class(prc_core_t), intent(in) :: core
    type(sf_chain_t), intent(in), target :: sf_chain
    type(process_beam_config_t), intent(in) :: config
    class(workspace_t), intent(inout), allocatable :: tmp
    integer :: n_strfun, n_channel
    integer :: c
    k%n_in = beam_data_get_n_in (config%data)
    n_strfun = config%n_strfun
    n_channel = config%n_channel
    allocate (k%sf_chain)
    k%sf_chain_allocated = .true.
    call core%init_sf_chain (k%sf_chain, sf_chain, n_channel, tmp)
    if (n_strfun /= 0) then
       do c = 1, n_channel
          call k%sf_chain%set_channel (c, config%sf_channel(c))
       end do
    end if
    call k%sf_chain%link_interactions ()
    call k%sf_chain%exchange_mask ()
    call k%sf_chain%init_evaluators ()
  end subroutine kinematics_init_sf_chain

@ %def kinematics_init_sf_chain
@ Allocate and initialize the phase-space part and the array of
Jacobian factors.
<<Processes: kinematics: TBP>>=
  procedure :: init_phs => kinematics_init_phs
<<Processes: procedures>>=
  subroutine kinematics_init_phs (k, config)
    class(kinematics_t), intent(inout) :: k
    class(phs_config_t), intent(in), target :: config
    k%n_channel = config%get_n_channel ()
    call config%allocate_instance (k%phs)
    call k%phs%init (config)
    k%phs_allocated = .true.
    allocate (k%f (k%n_channel))
    k%f = 0
    k%f_allocated = .true.
  end subroutine kinematics_init_phs
    
@ %def kinematics_init_phs
@ Initialize the kinematics in form of simple pointers.  In essence,
this is a shallow copy, but we have to set the flags correctly to
indicate this fact.
<<Processes: kinematics: TBP>>=
  procedure :: init_ptr => kinematics_init_ptr
<<Processes: procedures>>=
  subroutine kinematics_init_ptr (k, k_in)
    class(kinematics_t), intent(out) :: k
    type(kinematics_t), intent(in) :: k_in
    k%n_in = k_in%n_in
    k%n_channel = k_in%n_channel
    k%sf_chain => k_in%sf_chain
    k%phs => k_in%phs
    k%f => k_in%f
  end subroutine kinematics_init_ptr
  
@ %def kinematics_init_ptr
@ Generate kinematics, given a phase-space channel and a MC
parameter set. The main result is the momentum array [[p]], but we
also fill the momentum entries in the structure-function chain and the
Jacobian-factor array [[f]].  Regarding phase space, We fill only the
parameter arrays for the selected channel.
<<Processes: kinematics: TBP>>=
  procedure :: compute_selected_channel => kinematics_compute_selected_channel
<<Processes: procedures>>=
  subroutine kinematics_compute_selected_channel &
       (k, mci_work, phs_channel, p, success, nlo_data)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    type(vector4_t), dimension(:), intent(out) :: p
    logical, intent(out) :: success
    type(nlo_data_t), intent(inout), optional :: nlo_data
    integer :: sf_channel
    real(default) :: xit, y, phi
    real(default), dimension(:), allocatable :: xi_max
    real(default), dimension(3) :: jac
    k%selected_channel = phs_channel
    sf_channel = k%phs%config%get_sf_channel (phs_channel)
    call k%sf_chain%compute_kinematics (sf_channel, mci_work%get_x_strfun ())
    call k%sf_chain%get_out_momenta (p(1:k%n_in))
    call k%phs%set_incoming_momenta (p(1:k%n_in))
    call k%phs%compute_flux ()
    call k%phs%select_channel (phs_channel)
    select type (phs => k%phs)
    type is (phs_fks_t)
      call phs%set_emitters (nlo_data%reg_data%emitters)
      call phs%evaluate_selected_channel (phs_channel, mci_work%get_x_process ())
      if (phs%q_defined) then
         call phs%get_real_kinematics (xit, y, phi, xi_max, jac)
         if (present (nlo_data)) call nlo_data%set_real_kinematics (xit, y, phi, xi_max, jac)
         call phs%get_born_momenta (p)
         k%phs_factor = phs%get_overall_factor ()
         success = .true.
      else
         k%phs_factor = 0
         success = .false.
      end if
!    type is (phs_wood_t)
    class default
      call phs%evaluate_selected_channel &
         (phs_channel, mci_work%get_x_process ())
      if (phs%q_defined) then
         call k%phs%get_outgoing_momenta (p(k%n_in+1:))
         k%phs_factor = k%phs%get_overall_factor ()
         success = .true.
      else
       k%phs_factor = 0
       success = .false.
      end if
    end select
  end subroutine kinematics_compute_selected_channel
  
@ %def kinematics_compute_selected_channel
@ Complete kinematics by filling the non-selected phase-space parameter
arrays.
<<Processes: kinematics: TBP>>=
  procedure :: compute_other_channels => kinematics_compute_other_channels
<<Processes: procedures>>=
  subroutine kinematics_compute_other_channels (k, mci_work, phs_channel)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    integer :: c, c_sf
    call k%phs%evaluate_other_channels (phs_channel)
    do c = 1, k%n_channel
       c_sf = k%phs%config%get_sf_channel (c)
       k%f(c) = k%sf_chain%get_f (c_sf) * k%phs%get_f (c)
    end do
  end subroutine kinematics_compute_other_channels
  
@ %def kinematics_compute_other_channels
@ Just fetch the outgoing momenta of the [[sf_chain]] subobject, which
become the incoming (seed) momenta of the hard interaction.

This is a stripped down-version of the above which we use when
recovering kinematics.  Momenta are known, but no MC parameters yet.

(We do not use the [[get_out_momenta]] method of the chain, since this
relies on the structure-function interactions, which are not necessary
filled here.  We do rely on the momenta of the last evaluator in the
chain, however.)
<<Processes: kinematics: TBP>>=
  procedure :: get_incoming_momenta => kinematics_get_incoming_momenta
<<Processes: procedures>>=
  subroutine kinematics_get_incoming_momenta (k, p)
    class(kinematics_t), intent(in) :: k
    type(vector4_t), dimension(:), intent(out) :: p
    type(interaction_t), pointer :: int
    integer :: i
    int => k%sf_chain%get_out_int_ptr ()
    do i = 1, k%n_in
       p(i) = interaction_get_momentum (int, k%sf_chain%get_out_i (i))
    end do
  end subroutine kinematics_get_incoming_momenta
  
@ %def kinematics_get_incoming_momenta
@ This inverts the remainder of the above [[compute]] method.  We know
the momenta and recover the rest, as far as needed.  If we select a
channel, we can complete the inversion and reconstruct the 
MC parameter set.
<<Processes: kinematics: TBP>>=
  procedure :: recover_mcpar => kinematics_recover_mcpar
<<Processes: procedures>>=
  subroutine kinematics_recover_mcpar (k, mci_work, phs_channel, p)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: phs_channel
    type(vector4_t), dimension(:), intent(in) :: p
    integer :: c, c_sf
    real(default), dimension(:), allocatable :: x_sf, x_phs
    c = phs_channel
    c_sf = k%phs%config%get_sf_channel (c)
    k%selected_channel = c
    call k%sf_chain%recover_kinematics (c_sf)
    call k%phs%set_incoming_momenta (p(1:k%n_in))
    call k%phs%compute_flux ()
    call k%phs%set_outgoing_momenta (p(k%n_in+1:))
    call k%phs%inverse ()
    do c = 1, k%n_channel
       c_sf = k%phs%config%get_sf_channel (c)
       k%f(c) = k%sf_chain%get_f (c_sf) * k%phs%get_f (c)
    end do
    k%phs_factor = k%phs%get_overall_factor ()
    c = phs_channel
    c_sf = k%phs%config%get_sf_channel (c)
    allocate (x_sf (k%sf_chain%config%get_n_bound ()))
    allocate (x_phs (k%phs%config%get_n_par ()))
    call k%phs%select_channel (c)
    call k%sf_chain%get_mcpar (c_sf, x_sf)
    call k%phs%get_mcpar (c, x_phs)
    call mci_work%set_x_strfun (x_sf)
    call mci_work%set_x_process (x_phs)
  end subroutine kinematics_recover_mcpar

@ %def kinematics_recover_mcpar
@ Retrieve the MC input parameter array for a specific channel.  We assume
that the kinematics is complete, so this is known for all channels.
<<Processes: kinematics: TBP>>=
  procedure :: get_mcpar => kinematics_get_mcpar
<<Processes: procedures>>=
  subroutine kinematics_get_mcpar (k, phs_channel, r)
    class(kinematics_t), intent(in) :: k
    integer, intent(in) :: phs_channel
    real(default), dimension(:), intent(out) :: r
    integer :: sf_channel, n_par_sf, n_par_phs
    sf_channel = k%phs%config%get_sf_channel (phs_channel)
    n_par_phs = k%phs%config%get_n_par ()
    n_par_sf = k%sf_chain%config%get_n_bound ()
    if (n_par_sf > 0) then
       call k%sf_chain%get_mcpar (sf_channel, r(1:n_par_sf))
    end if
    if (n_par_phs > 0) then
       call k%phs%get_mcpar (phs_channel, r(n_par_sf+1:))
    end if
  end subroutine kinematics_get_mcpar
  
@ %def kinematics_get_mcpar
@ Evaluate the structure function chain, assuming that kinematics is known.

The status must be precisely [[SF_DONE_KINEMATICS]].  We thus avoid
evaluating the chain twice via different pointers to the same target.
<<Processes: kinematics: TBP>>=
  procedure :: evaluate_sf_chain => kinematics_evaluate_sf_chain
<<Processes: procedures>>=
  subroutine kinematics_evaluate_sf_chain (k, fac_scale)
    class(kinematics_t), intent(inout) :: k
    real(default), intent(in) :: fac_scale
    select case (k%sf_chain%get_status ())
    case (SF_DONE_KINEMATICS)
       call k%sf_chain%evaluate (fac_scale)
    end select
  end subroutine kinematics_evaluate_sf_chain
  
@ %def kinematics_evaluate_sf_chain
@ Recover beam momenta, i.e., return the beam momenta stored in the
current [[sf_chain]] to their source.  This is a side effect.
<<Processes: kinematics: TBP>>=
  procedure :: return_beam_momenta => kinematics_return_beam_momenta
<<Processes: procedures>>=
  subroutine kinematics_return_beam_momenta (k)
    class(kinematics_t), intent(in) :: k
    call k%sf_chain%return_beam_momenta ()
  end subroutine kinematics_return_beam_momenta
  
@ %def kinematics_return_beam_momenta
@
<<Processes: kinematics: TBP>>=
  procedure :: display_real_kinematics => kinematics_display_real_kinematics
<<Processes: procedures>>=
  subroutine kinematics_display_real_kinematics (k)
     class(kinematics_t), intent(in) :: k
     select type (phs => k%phs)
     type is (phs_fks_t)
        call phs%display_kinematics ()
     end select
  end subroutine kinematics_display_real_kinematics

@ %def kinematics_display_real_kinematics
@ 
\subsubsection{Process component instance}
The actual calculation of a sampling point is done from here.

The [[config]] pointer accesses the corresponding
configuration in the [[process]] object.

The [[active]] flag indicates that we are currently computing this
component, together with all other components that share the same MC
parameter set.  Inactive components are using a different MC parameter
set and are not in use for this sampling point.

The [[k_seed]] subobject contains the kinematics (structure-function
chain, phase space, etc.) that implements the `seed' configuration of
momenta.  This version of the process kinematics is accessed by the MCI
setup.

[[p_seed]] is the array of momenta that we compute from the MC input
parameters, via the [[k_seed]] subobject.  Depending on the process
variant, these may or may not coincide with the momenta that enter the
process terms associated to this component.

The [[tmp]] object can be used for storing intermediate results.  Its precise
type and contents depend on the process variant.
<<Processes: types>>=
  type :: component_instance_t
     type(process_component_t), pointer :: config => null ()
     logical :: active = .false.
     type(kinematics_t) :: k_seed
     type(vector4_t), dimension(:), allocatable :: p_seed
     logical :: sqme_known = .false.
     real(default) :: sqme = 0
     class(workspace_t), allocatable :: tmp
     type(nlo_data_t), pointer :: nlo_data => null ()
   contains
   <<Processes: component instance: TBP>>
  end type component_instance_t
  
@ %def component_instance_t
@ In the header, fetch the component index from the configuration record.
[[process_component_t]] configuration block.

We write the [[sf_chain]] subobject only upon request, since its instances
appear elsewhere.
<<Processes: component instance: TBP>>=
  procedure :: write => component_instance_write
<<Processes: procedures>>=
  subroutine component_instance_write (object, unit, testflag)
    class(component_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    if (object%active) then
       if (associated (object%config)) then
          write (u, "(1x,A,I0)")  "Component #", object%config%index
       else
          write (u, "(1x,A)")  "Component [undefined]"
       end if
    else
       write (u, "(1x,A,I0,A)")  "Component #", object%config%index, &
            " [inactive]"
    end if
    if (allocated (object%p_seed)) then
       write (u, "(1x,A)")  "Seed momenta:"
       do i = 1, size (object%p_seed)
          call vector4_write (object%p_seed(i), u, testflag = testflag)
       end do
    end if
    write (u, "(1x,A)")  "Squared matrix element:"
    if (object%sqme_known) then
       write (u, "(2x,ES19.12)")  object%sqme
    else
       write (u, "(2x,A)")  "[undefined]"
    end if
    call object%k_seed%write (u)
    if (allocated (object%tmp)) then
       call write_separator (u)
       call object%tmp%write (u)
    end if
  end subroutine component_instance_write
    
@ %def component_instance_write
@ Finalizer
<<Processes: component instance: TBP>>=
  procedure :: final => component_instance_final
<<Processes: procedures>>=
  subroutine component_instance_final (object)
    class(component_instance_t), intent(inout) :: object
    call object%k_seed%final ()
  end subroutine component_instance_final
  
@ %def component_instance_final
@ Initialize: associate the configuration pointer.  Also initialize the
process workspace, if there is anything to do.  This initialization is a
matter of the process core.
<<Processes: component instance: TBP>>=
  procedure :: init => component_instance_init
<<Processes: procedures>>=
  subroutine component_instance_init (component, config)
    class(component_instance_t), intent(out) :: component
    type(process_component_t), intent(in), target :: config
    type(string_t) :: nlo_type
    integer :: n_in, n_tot
    component%config => config
    nlo_type = component%config%config%get_nlo_type ()
    associate (core => component%config%core)
      n_in = core%data%n_in
      n_tot = n_in + core%data%n_out
      select case (char (nlo_type))
      case ('Real')
        allocate (component%p_seed (n_tot -1))
      case ('Born', 'Virtual')
        allocate (component%p_seed (n_tot))
      end select
      call core%allocate_workspace (component%tmp)
    end associate
  end subroutine component_instance_init

@ %def component_instance_init
@ Initialize the seed-kinematics configuration.  All subobjects are
allocated explicitly.
<<Processes: component instance: TBP>>=
  procedure :: setup_kinematics => component_instance_setup_kinematics
<<Processes: procedures>>=
  subroutine component_instance_setup_kinematics (component, sf_chain, config)
    class(component_instance_t), intent(inout) :: component
    type(sf_chain_t), intent(in), target :: sf_chain
    type(process_beam_config_t), intent(in) :: config
    class(phs_config_t), pointer :: fks_config
    type(string_t) :: nlo_type
    nlo_type = component%config%config%get_nlo_type ()
    if (component%config%phs_config%nlo_type == "") &
      component%config%phs_config%nlo_type = nlo_type
    call component%k_seed%init_sf_chain &
         (component%config%core, sf_chain, config, component%tmp)
    call component%k_seed%init_phs (component%config%phs_config)
  end subroutine component_instance_setup_kinematics

@ %def component_instance_setup_kinematics
@ Setup seed kinematics, starting from the MC parameter set given as
argument.  As a result, the [[k_seed]] kinematics object is evaluated
(except for the structure-function matrix-element evaluation, which we
postpone until we know the factorization scale), and we have a valid
[[p_seed]] momentum array.
<<Processes: component instance: TBP>>=
  procedure :: compute_seed_kinematics => &
       component_instance_compute_seed_kinematics
<<Processes: procedures>>=
  subroutine component_instance_compute_seed_kinematics &
       (component, mci_work, phs_channel, success)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    logical, intent(out) :: success
    select type (phs => component%k_seed%phs)
    type is (phs_fks_t)
      call component%k_seed%compute_selected_channel &
           (mci_work, phs_channel, component%p_seed, success, &
            component%nlo_data)
!      call component%nlo_data%set_active_emitter (phs%ch_to_em (phs_channel))
    class default
      call component%k_seed%compute_selected_channel &
         (mci_work, phs_channel, component%p_seed, success)
    end select
  end subroutine component_instance_compute_seed_kinematics
    
@ %def component_instance_compute_seed_kinematics
@ Inverse: recover missing parts of the kinematics, given a complete
set of seed momenta.  Select a channel and reconstruct the MC parameter set.
<<Processes: component instance: TBP>>=
  procedure :: recover_mcpar => component_instance_recover_mcpar
<<Processes: procedures>>=
  subroutine component_instance_recover_mcpar (component, mci_work, phs_channel)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: phs_channel
    call component%k_seed%recover_mcpar &
         (mci_work, phs_channel, component%p_seed)
  end subroutine component_instance_recover_mcpar
  
@ %def component_instance_recover
@ Compute the momenta in the hard interactions, one for each term that
constitutes this process component.  In simple cases this amounts to
just copying momenta.  In more advanced cases, we may generate
distinct sets of momenta from the seed kinematics.

The interactions in the term instances are accessed individually.  We may
choose to calculate all terms at once together with the seed kinematics, use
[[component%tmp]] for storage, and just fill the interactions here.
<<Processes: component instance: TBP>>=
  procedure :: compute_hard_kinematics => &
       component_instance_compute_hard_kinematics
<<Processes: procedures>>=
  subroutine component_instance_compute_hard_kinematics &
       (component, term, skip_term, real_phsp)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), dimension(:), intent(inout) :: term
    integer, intent(in), optional :: skip_term
    logical, intent(in), optional :: real_phsp
    integer :: j, i
    associate (core => component%config%core)
      associate (i_term => component%config%i_term)
        do j = 1, size (i_term)
           i = i_term(j)
           if (present (skip_term)) then
              if (i == skip_term)  cycle
           end if
           if (present (real_phsp)) then
             if (real_phsp) then
               call core%compute_hard_kinematics &
                     (component%p_seed, i, term(i)%nlo_data%int_born, component%tmp)
             else 
               call core%compute_hard_kinematics &
                     (component%p_seed, i, term(i)%int_hard, component%tmp)
             end if
          else
             call core%compute_hard_kinematics & 
                 (component%p_seed, i, term(i)%int_hard, component%tmp)
          end if
        end do
      end associate
    end associate
  end subroutine component_instance_compute_hard_kinematics
    
@ %def component_instance_compute_hard_kinematics
@ Here, we invert this.  We fetch the incoming momenta which reside
in the appropriate [[sf_chain]] object, stored within the [[k_seed]]
subobject.  On the other hand, we have the outgoing momenta of the
effective interaction.  We rely on the process core to compute the
remaining seed momenta and to fill the momenta within the hard
interaction.  (The latter is trivial if hard and effective interaction
coincide.)

After this is done, the incoming momenta in the trace evaluator that
corresponds to the hard (effective) interaction, are still
left undefined.  We remedy this by calling [[receive_kinematics]] once.
<<Processes: component instance: TBP>>=
  procedure :: recover_seed_kinematics => &
       component_instance_recover_seed_kinematics
<<Processes: procedures>>=
  subroutine component_instance_recover_seed_kinematics (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), intent(inout) :: term
    integer :: n_in
    n_in = component%k_seed%n_in
    call component%k_seed%get_incoming_momenta (component%p_seed(1:n_in))
    associate (core => component%config%core)
      call core%recover_kinematics &
           (component%p_seed, term%int_hard, term%isolated%int_eff, &
           component%tmp)
      call term%isolated%receive_kinematics ()
    end associate
  end subroutine component_instance_recover_seed_kinematics
  
@ %def component_instance_recover_seed_kinematics
@ Compute the integration parameters for all channels except the selected
one.
<<Processes: component instance: TBP>>=
  procedure :: compute_other_channels => &
       component_instance_compute_other_channels
<<Processes: procedures>>=
  subroutine component_instance_compute_other_channels &
       (component, mci_work, phs_channel)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    call component%k_seed%compute_other_channels (mci_work, phs_channel)
  end subroutine component_instance_compute_other_channels
    
@ %def component_instance_compute_other_channels
@ Recover beam momenta, i.e., return the beam momenta as currently
stored in the kinematics subobject to their source.  This is a side effect.
<<Processes: component instance: TBP>>=
  procedure :: return_beam_momenta => component_instance_return_beam_momenta
<<Processes: procedures>>=
  subroutine component_instance_return_beam_momenta (component)
    class(component_instance_t), intent(in) :: component
    call component%k_seed%return_beam_momenta ()
  end subroutine component_instance_return_beam_momenta
    
@ %def component_instance_return_beam_momenta
@ Evaluate the trace of the transition matrix, convoluted with the initial
state, and summed over all terms.  The trace evaluators of the
individual terms have only a single matrix element. We implicitly drop the
imaginary part of the terms, which should be zero anyway.
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme => component_instance_evaluate_sqme
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), dimension(:), intent(inout), target :: term
    type(interaction_t), pointer :: int
    type(vector4_t), dimension(:), allocatable :: p_real
    real(default) :: sqme
    real(default), dimension(4) :: sqme_virt
    integer :: j, i
    logical :: bad_point
    integer :: i_proc
    component%sqme = 0
    select case (char (component%config%config%get_nlo_type ()))
    case ('Real', 'Virtual')
      component%nlo_data%sqme_born = 0
      component%nlo_data%sqme_real = 0
    end select
    associate (i_term => component%config%i_term)
      do j = 1, size (i_term)
         i = i_term(j)
         if (term(i)%passed) then
            int => evaluator_get_int_ptr (term(i)%connected%trace)
            sqme = interaction_get_matrix_element (int, 1)
            select case (char (term(i)%nlo_data%nlo_type))
            case ('Born')
              component%sqme = component%sqme + sqme * term(i)%weight
            case ('Real', 'Virtual')
              component%nlo_data%sqme_born = component%nlo_data%sqme_born + sqme * term(i)%weight
            end select
            select case (char (term(i)%nlo_data%nlo_type))
              case ('Real')
                p_real = term(i)%nlo_data%get_real_momenta ()
                int => evaluator_get_int_ptr (term(i)%connected_real%trace)
                sqme = interaction_get_matrix_element (int, 1)
                select type (core_born => component%config%core_sub_born)
                type is (prc_gosam_t)
                   if (.not. term(i)%nlo_data%use_internal_color_correlations) &
                     call core_born%compute_sqme_cc &
                               (interaction_get_momenta (component%nlo_data%int_born), &
                                0._default, component%nlo_data%sqme_born(1), &
                                component%nlo_data%sqme_born_cc (:,:,1), &
                                bad_point)
                   if (.not. term(i)%nlo_data%use_internal_spin_correlations .and. &
                       term(i)%nlo_data%sc_required(1)) &
                     call core_born%compute_sqme_sc (5, &
                                interaction_get_momenta (component%nlo_data%int_born), &
                                0._default, component%nlo_data%sqme_born_sc (:,:,1), &
                                bad_point)
                end select
                call term(i)%nlo_data%set_alpha_s_born &
                    (component%config%core%get_alpha_s (component%tmp))
                component%nlo_data%sqme_real = term(i)%nlo_data%compute_sqme_real_fin &
                                      (term(i)%weight, p_real, sqme) 
             case ('Virtual')
                call term(i)%nlo_data%set_alpha_s_born &
                          (component%config%core%get_alpha_s (component%tmp))
                call term(i)%nlo_data%virtual_terms%set_ren_scale &
                          (term(i)%int_hard, term(i)%ren_scale) 
                select type (core => component%config%core)
                type is (prc_gosam_t)
                    do i_proc = 0, core%get_n_proc()-1
                      call core%compute_sqme_virt &
                            (interaction_get_momenta (term(i)%int_hard), &
                             term(i)%ren_scale, &
                             core%get_alpha_s (component%tmp), &
                             sqme_virt, bad_point)
                      if (.not. term(i)%nlo_data%use_internal_color_correlations) then
                        call core%compute_sqme_cc &
                            (interaction_get_momenta (term(i)%int_hard), &
                             term(i)%ren_scale, &
                             born_cc = component%nlo_data%sqme_born_cc (:,:,1), &
                             bad_point = bad_point)
                      end if
                      call term(i)%nlo_data%virtual_terms%set_vfin (sqme_virt(3))
                      call term(i)%nlo_data%virtual_terms%set_bad_point (bad_point)
                      component%nlo_data%sqme_born = sqme_virt (4)             
                    end do
                 type is (prc_omega_t)
                    call term(i)%nlo_data%virtual_terms%compute_vfin_test &
                                 (interaction_get_momenta (term(i)%int_hard), &
                                  term(i)%nlo_data%sqme_born(1))
                 end select    
                 component%sqme = component%sqme + &
                            term(i)%nlo_data%compute_virt (1, term(i)%int_hard) * &
                            term(i)%weight
             end select
         end if
      end do
    end associate
    component%sqme_known = .true.
  end subroutine component_instance_evaluate_sqme
  
@ %def component_instance_evaluate_sqme
@ Get nlo-type and emitter of the component.
<<Processes: component instance: TBP>>=
  procedure :: get_nlo_type => component_instance_get_nlo_type
<<Processes: procedures>>=
  function component_instance_get_nlo_type (component) result (nlo_type)
    class(component_instance_t), intent(inout) :: component
!    integer :: nlo_type
    type(string_t) :: nlo_type
    if (component%nlo_data%get_nlo_type () == "") then
      nlo_type = 'Born'
    else
      nlo_type = component%nlo_data%get_nlo_type ()
    end if
  end function component_instance_get_nlo_type

@ %def component_instance_get_nlo_type
@
\subsubsection{Term instance}
A [[term_instance_t]] object contains all data that describe a term.  Each
process component consists of one or more distinct terms which may differ in
kinematics, but whose squared transition matrices have to be added pointwise.

The [[active]] flag is set when this term is connected to an active
process component.  Inactive terms are skipped for kinematics and evaluation.

The [[k_term]] object is the instance of the kinematics setup
(structure-function chain, phase space, etc.) that applies
specifically to this term.  In ordinary cases, it consists of straight
pointers to the seed kinematics.

The [[amp]] array stores the amplitude values when we get them from evaluating
the associated matrix-element code.

The [[int_hard]] interaction describes the elementary hard process.
It receives the momenta and the amplitude entries for each sampling point.

The [[isolated]] object holds the effective parton state for the
elementary interaction.  The amplitude entries are
computed from [[int_hard]].  

The [[connected]] evaluator set
convolutes this scattering matrix with the beam (and possibly
structure-function) density matrix.

The [[checked]] flag is set once we have applied cuts on this term.
The result of this is stored in the [[passed]] flag.  Once the term
has passed cuts, we calculate the various scale and weight expressions.
<<Processes: types>>=
  type :: term_instance_t
     type(process_term_t), pointer :: config => null ()
     logical :: active = .false.
     type(kinematics_t) :: k_term
     complex(default), dimension(:), allocatable :: amp
     type(interaction_t) :: int_hard
     type(interaction_t) :: int_hard_real
     type(isolated_state_t) :: isolated
     type(connected_state_t) :: connected
     type(isolated_state_t) :: isolated_real
     type(connected_state_t) :: connected_real
     logical :: checked = .false.
     logical :: passed = .false.
     real(default) :: scale = 0
     real(default) :: fac_scale = 0
     real(default) :: ren_scale = 0
     real(default) :: weight = 1
     type(vector4_t), dimension(:), allocatable :: p_hard
     type(nlo_data_t), pointer :: nlo_data
   contains
   <<Processes: term instance: TBP>>
  end type term_instance_t
  
@ %def term_instance_t
@
<<Processes: term instance: TBP>>=
  procedure :: write => term_instance_write
<<Processes: procedures>>=
  subroutine term_instance_write (term, unit, show_eff_state, testflag)
    class(term_instance_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_eff_state
    logical, intent(in), optional :: testflag 
    integer :: u
    logical :: state
    u = given_output_unit (unit)
    state = .true.;  if (present (show_eff_state))  state = show_eff_state
    if (term%active) then
       if (associated (term%config)) then
          write (u, "(1x,A,I0,A,I0,A)")  "Term #", term%config%i_term, &
               " (component #", term%config%i_component, ")"
       else
          write (u, "(1x,A)")  "Term [undefined]"
       end if
    else
       write (u, "(1x,A,I0,A)")  "Term #", term%config%i_term, &
            " [inactive]"
    end if
    if (term%checked) then
       write (u, "(3x,A,L1)")      "passed cuts           = ", term%passed
    end if
    if (term%passed) then
       write (u, "(3x,A,ES19.12)")  "overall scale         = ", term%scale
       write (u, "(3x,A,ES19.12)")  "factorization scale   = ", term%fac_scale
       write (u, "(3x,A,ES19.12)")  "renormalization scale = ", term%ren_scale
       write (u, "(3x,A,ES19.12)")  "reweighting factor    = ", term%weight
    end if
    call term%k_term%write (u)
    call write_separator (u)
    write (u, "(1x,A)")  "Amplitude (transition matrix of the &
         &hard interaction):"
    call write_separator (u)
    call interaction_write (term%int_hard, u, testflag = testflag)
    if (state .and. term%isolated%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)")  "Evaluators for the hard interaction:"
       call term%isolated%write (u, testflag = testflag)
    end if
    if (state .and. term%connected%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)")  "Evaluators for the connected process:"
       call term%connected%write (u, testflag = testflag)
    end if
  end subroutine term_instance_write
    
@ %def term_instance_write
@ The interactions and evaluators must be finalized.
<<Processes: term instance: TBP>>=
  procedure :: final => term_instance_final
<<Processes: procedures>>=
  subroutine term_instance_final (term)
    class(term_instance_t), intent(inout) :: term
    call term%k_term%final ()
    call term%connected%final ()
    call term%isolated%final ()
    call interaction_final (term%int_hard)
    select case (char (term%nlo_data%nlo_type))
    case ('Real')
      call term%connected_real%final ()
      call term%isolated_real%final ()
      call interaction_final (term%int_hard_real)
    end select
  end subroutine term_instance_final
  
@ %def term_instance_final
@ For initialization, we make use of defined assignment for the
[[interaction_t]] type.  This creates a deep copy.

The hard interaction (incoming momenta) is linked to the structure
function instance.  In the isolated state, we either set pointers to
both, or we create modified copies ([[rearrange]]) as effective
structure-function chain and interaction, respectively.

Finally, we set up the [[subevt]] component that will be used for
evaluating observables, collecting particles from the trace evaluator
in the effective connected state.  Their quantum numbers must be
determined by following back source links and set explicitly, since
they are already eliminated in that trace.

The [[rearrange]] parts are still commented out; they could become
relevant for a NLO algorithm.
<<Processes: term instance: TBP>>=
  procedure :: init => term_instance_init
<<Processes: procedures>>=
  subroutine term_instance_init (term, &
       config, k_seed, beam_config, core, process_var_list, nlo_data)
    class(term_instance_t), intent(out), target :: term
    type(process_term_t), intent(in), target :: config
    type(kinematics_t), intent(in) :: k_seed
    type(process_beam_config_t), intent(in) :: beam_config
    type(interaction_t), pointer :: sf_chain_int, trace_int, src_int
    class(prc_core_t), intent(in) :: core
    type(var_list_t), intent(in), target :: process_var_list
    type(nlo_data_t), intent(in), pointer :: nlo_data
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    type(state_matrix_t), pointer :: state_matrix
    type(flavor_t), dimension(:), allocatable :: flv_int, flv_src, f_in, f_out
    type(flavor_t), dimension(:), allocatable :: f_out_real
    integer :: n_in, n_vir, n_out, n_tot
    integer :: i, j
    type(interaction_t), pointer, save :: int_sav 
    type(sf_chain_instance_t), pointer, save :: sf_sav
    integer, dimension(:), allocatable, save :: col_sav
    type(prc_omega_t), save :: core_sav

    term%nlo_data => nlo_data

    term%config => config
    if (config%rearrange) then
       ! rearrangement of seed to hard kinematics not implemented yet
       ! allocate k_term distinct from k_seed as needed.
    else
       ! here, k_term trivially accesses k_seed via pointers
       call term%k_term%init_ptr (k_seed)
    end if
    allocate (term%amp (config%n_allowed))
    term%int_hard = config%int
    allocate (term%p_hard (interaction_get_n_tot (term%int_hard)))
    sf_chain_int => term%k_term%sf_chain%get_out_int_ptr ()
    n_in = interaction_get_n_in (term%int_hard)
    do j = 1, n_in
       i = term%k_term%sf_chain%get_out_i (j)
       call interaction_set_source_link (term%int_hard, j, sf_chain_int, i)
    end do
    if (config%rearrange) then
       ! rearrangement hard to effective kinematics not implemented yet
       ! should use term%config%int_eff as template
       ! allocate distinct sf_chain in term%connected as needed
    else
      select type (phs => term%k_term%phs)
        type is (phs_wood_t)
          ! here, int_hard and sf_chain are trivially accessed via pointers
          call term%isolated%init (term%k_term%sf_chain, term%int_hard)
          int_sav => term%int_hard
          sf_sav => term%k_term%sf_chain
        type is (phs_fks_t)
          term%nlo_data%int_born = int_sav
          call term%isolated%init (sf_sav, term%nlo_data%int_born)
          call term%setup_real_interaction (term%int_hard)
        class default
          call term%isolated%init (term%k_term%sf_chain, term%int_hard)
      end select
    end if
    allocate (mask_in (n_in))
    mask_in = term%k_term%sf_chain%get_out_mask ()
    select type (phs => term%k_term%phs)
      type is (phs_wood_t)
      call term%isolated%setup_square_trace (core, mask_in, term%config%col)
      if (.not. allocated (col_sav)) then
        allocate (col_sav (size (term%config%col)))
        col_sav = term%config%col
      end if
      select type (core)
      type is (prc_omega_t)
        core_sav = core
      end select
      type is (phs_fks_t)
        mask_in = sf_sav%get_out_mask ()
        call term%isolated%setup_square_trace (core_sav, mask_in, col_sav)
        call term%init_states (core)
      class default
        call term%isolated%setup_square_trace (core, mask_in, term%config%col)
    end select
    call term%connected%setup_connected_trace (term%isolated)
    associate (int_eff => term%isolated%int_eff)
      state_matrix => interaction_get_state_matrix_ptr (int_eff)
      n_tot = interaction_get_n_tot  (int_eff)
      allocate (flv_int (n_tot))
      flv_int = quantum_numbers_get_flavor &
           (state_matrix_get_quantum_numbers (state_matrix, 1))
      allocate (f_in (n_in))
      f_in = flv_int(1:n_in)
      deallocate (flv_int)
    end associate
    trace_int => evaluator_get_int_ptr (term%connected%trace)
    n_in = interaction_get_n_in (trace_int)
    n_vir = interaction_get_n_vir (trace_int)
    n_out = interaction_get_n_out (trace_int)
    allocate (f_out (n_out))
    do j = 1, n_out
       call interaction_find_source (trace_int, n_in + n_vir + j, src_int, i)
       if (associated (src_int)) then
          state_matrix => interaction_get_state_matrix_ptr (src_int)
          allocate (flv_src (interaction_get_n_tot (src_int)))
          flv_src = quantum_numbers_get_flavor &
               (state_matrix_get_quantum_numbers (state_matrix, 1))
          f_out(j) = flv_src(i)
          deallocate (flv_src)
       end if
    end do
    call term%connected%setup_subevt (term%isolated%sf_chain_eff, &
         beam_config%data%flv, f_in, f_out)
    call term%connected%setup_var_list (process_var_list, beam_config%data)
    select case (char (term%nlo_data%get_nlo_type ()))
    case ('Real')
      allocate (f_out_real (n_out+1))
      f_out_real (1:n_out) = f_out
      f_out_real (n_out+1) = term%nlo_data%reg_data%flv_extra
      call term%connected_real%setup_subevt (term%isolated_real%sf_chain_eff, &
           beam_config%data%flv, f_in, f_out_real)
      call term%connected_real%setup_var_list (process_var_list, beam_config%data)
    end select

  end subroutine term_instance_init

@ %def term_instance_init
@ Set up the state objects.
<<Processes: term instance: TBP>>=
  procedure :: init_states => term_instance_init_states
<<Processes: procedures>>=
  subroutine term_instance_init_states (term, core)
    class(term_instance_t), intent(inout), target :: term
    class(prc_core_t), intent(in) :: core
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    integer :: i
    mask_in = term%k_term%sf_chain%get_out_mask ()
    call term%isolated_real%init (term%k_term%sf_chain, term%int_hard_real)
    call term%isolated_real%setup_square_trace (core, mask_in, term%config%col)
    call term%connected_real%setup_connected_trace (term%isolated_real) 
  end subroutine term_instance_init_states

@ %def term_instance_init_states 
@ For initializing the expressions, we need the local variable list and the
parse trees.
<<Processes: term instance: TBP>>=
  procedure :: setup_expressions => term_instance_setup_expressions
<<Processes: procedures>>=
  subroutine term_instance_setup_expressions (term, meta, config)
    class(term_instance_t), intent(inout), target :: term
    type(process_metadata_t), intent(in), target :: meta
    type(process_config_data_t), intent(in) :: config
    if (allocated (config%ef_cuts)) &
         call term%connected%setup_cuts (config%ef_cuts)
    if (allocated (config%ef_scale)) &
         call term%connected%setup_scale (config%ef_scale)
    if (allocated (config%ef_fac_scale)) &
         call term%connected%setup_fac_scale (config%ef_fac_scale)
    if (allocated (config%ef_ren_scale)) &
         call term%connected%setup_ren_scale (config%ef_ren_scale)
    if (allocated (config%ef_weight)) &
         call term%connected%setup_weight (config%ef_weight)
  end subroutine term_instance_setup_expressions
    
@ %def term_instance_setup_expressions
@
<<Processes: term instance: TBP>>=
  procedure :: setup_expressions_real => term_instance_setup_expressions_real
<<Processes: procedures>>=
  subroutine term_instance_setup_expressions_real (term, meta, config)
    class(term_instance_t), intent(inout), target :: term
    type(process_metadata_t), intent(in), target :: meta
    type(process_config_data_t), intent(in) :: config
    if (allocated (config%ef_cuts)) &
         call term%connected_real%setup_cuts (config%ef_cuts)
    if (allocated (config%ef_scale)) &
         call term%connected_real%setup_scale (config%ef_scale)
    if (allocated (config%ef_fac_scale)) &
         call term%connected_real%setup_fac_scale (config%ef_fac_scale)
    if (allocated (config%ef_ren_scale)) &
         call term%connected_real%setup_ren_scale (config%ef_ren_scale)
    if (allocated (config%ef_weight)) &
         call term%connected_real%setup_weight (config%ef_weight)
  end subroutine term_instance_setup_expressions_real

@ %def term_instance_setup_expressions_real
@ Prepare the extra evaluators that we need for processing events.

The quantum numbers mask of the incoming particle
<<Processes: term instance: TBP>>=
  procedure :: setup_event_data => term_instance_setup_event_data
<<Processes: procedures>>=
  subroutine term_instance_setup_event_data (term, core, model)
    class(term_instance_t), intent(inout), target :: term
    class(prc_core_t), intent(in) :: core
    type(model_t), intent(in), target :: model
    integer :: n_in
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    n_in = interaction_get_n_in (term%int_hard)
    allocate (mask_in (n_in))
    mask_in = term%k_term%sf_chain%get_out_mask ()
    select case (char (term%nlo_data%nlo_type))
    case ('Born', 'Virtual')
      call term%isolated%setup_square_matrix (core, model, mask_in, &
         term%config%col)
      call term%isolated%setup_square_flows (core, model, mask_in)
      call term%connected%setup_connected_matrix (term%isolated)
      call term%connected%setup_connected_flows (term%isolated)
    case ('Real')
      call term%isolated_real%setup_square_matrix (core, model, mask_in, &
               term%config%col)
      call term%isolated_real%setup_square_flows (core, model, mask_in)
      call term%connected_real%setup_connected_matrix &
                (term%isolated_real)
      call term%connected_real%setup_connected_flows &
                (term%isolated_real)
    end select
  end subroutine term_instance_setup_event_data
    
@ %def term_instance_setup_event_data
@ Associate the hard real interaction.
<<Processes: term instance: TBP>>=
  procedure :: setup_real_interaction => term_instance_setup_real_interaction
<<Processes: procedures>>=
  subroutine term_instance_setup_real_interaction (term, int)
    class(term_instance_t), intent(inout) :: term
    type(interaction_t), intent(in) :: int
    integer :: i
    term%int_hard_real = int
  end subroutine term_instance_setup_real_interaction

@ %def term_instance_setup_real_interaction    
@ Reset the term instance: clear the parton-state expressions and deactivate.
<<Processes: term instance: TBP>>=
  procedure :: reset => term_instance_reset
<<Processes: procedures>>=
  subroutine term_instance_reset (term)
    class(term_instance_t), intent(inout) :: term
    call term%connected%reset_expressions ()
    term%active = .false.
  end subroutine term_instance_reset
  
@ %def term_instance_reset
@ Complete the kinematics computation for the effective parton states.

We assume that the [[compute_hard_kinematics]] method of the process
component instance has already been called, so the [[int_hard]]
contains the correct hard kinematics.  The duty of this procedure is
first to compute the effective kinematics and store this in the
[[int_eff]] effective interaction inside the [[isolated]] parton
state.  The effective kinematics may differ from the kinematics in the hard
interaction.  It may involve parton recombination or parton splitting.
The [[rearrange_partons]] method is responsible for this part.  

We may also call a method to compute the effective structure-function
chain at this point.  This is not implemented yet.

In the simple case that no rearrangement is necessary, as indicated by
the [[rearrange]] flag, the effective interaction is a pointer to the
hard interaction, and we can skip the rearrangement method.  Similarly
for the effective structure-function chain.  (If we have an algorithm
that uses rarrangement, it should evaluate [[k_term]] explicitly.)

The final step of kinematics setup is to transfer the effective
kinematics to the evaluators and to the [[subevt]].
<<Processes: term instance: TBP>>=
  procedure :: compute_eff_kinematics => &
       term_instance_compute_eff_kinematics
<<Processes: procedures>>=
  subroutine term_instance_compute_eff_kinematics (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    integer :: i_component, i_term
    term%checked = .false.
    term%passed = .false.
    if (term%config%rearrange) then
       ! should evaluate k_term first if allocated separately, not impl. yet
       i_component = term%config%i_component
       i_term = term%config%i_term
      associate (core => component(i_component)%config%core)
         select case (char (term%nlo_data%nlo_type))
         case ('Born', 'Virtual')
           call core%compute_eff_kinematics &
              (i_term, term%int_hard, term%isolated%int_eff, &
              component(i_component)%tmp)
         case ('Real')
           call component(i_component)%config%core_sub_born%compute_eff_kinematics & 
                (i_term, term%nlo_data%int_born, term%isolated%int_eff, &
                component(i_component)%tmp)
         end select
        select case (char (term%nlo_data%nlo_type))
        case ('Real')
          call core%compute_eff_kinematics &
                (i_term, term%int_hard_real, term%isolated_real%int_eff, &
                 component(i_component)%tmp)
        end select
      end associate
    end if
    call term%isolated%receive_kinematics ()
    call term%connected%receive_kinematics ()
  end subroutine term_instance_compute_eff_kinematics
    
@ %def term_instance_compute_eff_kinematics
@ Inverse.  Reconstruct the connected state from the momenta in the
trace evaluator (which we assume to be set), then reconstruct the
isolated state as far as possible.  The second part finalizes the
momentum configuration, using the incoming seed momenta
<<Processes: term instance: TBP>>=
  procedure :: recover_hard_kinematics => &
       term_instance_recover_hard_kinematics
<<Processes: procedures>>=
  subroutine term_instance_recover_hard_kinematics (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    term%checked = .false.
    term%passed = .false.
    call term%connected%send_kinematics ()
    call term%isolated%send_kinematics ()
  end subroutine term_instance_recover_hard_kinematics

@ %def term_instance_recover_hard_kinematics
@ Check the term whether it passes cuts and, if successful, evaluate
scales and weights.  The factorization scale is also given to the term
kinematics, enabling structure-function evaluation.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_expressions => &
       term_instance_evaluate_expressions
<<Processes: procedures>>=
  subroutine term_instance_evaluate_expressions (term)
    class(term_instance_t), intent(inout) :: term
    call term%connected%evaluate_expressions (term%passed, &
         term%scale, term%fac_scale, term%ren_scale, term%weight)
    term%checked = .true.
  end subroutine term_instance_evaluate_expressions
       
@ %def term_instance_evaluate_expressions
@ Evaluate the trace: first evaluate the hard interaction, then the trace
evaluator.  We use the [[evaluate_interaction]] method of the process
component which generated this term.  The [[subevt]] and cut expressions are
not yet filled.

The [[component]] argument is intent(inout) because the [[compute_amplitude]]
method may modify the [[tmp]] workspace object.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_interaction => term_instance_evaluate_interaction
<<Processes: procedures>>=
  subroutine term_instance_evaluate_interaction (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    integer :: i_component, i_term, i
    type(vector4_t), dimension(:), allocatable :: p_born, p_real
    real(default) :: xi_tilde, xi, y, phi, xi_max
    real(default), dimension(3) :: jac
    integer :: emitter
    i_component = term%config%i_component
    i_term = term%config%i_term
    term%p_hard = interaction_get_momenta (term%int_hard)
    associate (core => component(i_component)%config%core)
      select case (char (term%nlo_data%nlo_type))
      case ('Born', 'Virtual')
        do i = 1, term%config%n_allowed
          term%amp(i) = core%compute_amplitude (i_term, term%p_hard, &
              term%config%flv(i), term%config%hel(i), term%config%col(i), &
              term%fac_scale, term%ren_scale, &
              component(i_component)%tmp)
        end do
        call interaction_set_matrix_element (term%int_hard, term%amp)
      case ('Real')
        emitter = term%nlo_data%get_active_emitter ()
        call term%nlo_data%get_real_kinematics (emitter, xi_tilde, y, xi_max, phi = phi)
        p_born = interaction_get_momenta (term%nlo_data%int_born)
        if (emitter > 2) then
          xi = xi_tilde * xi_max
          call fks_born_to_real_fsr (emitter, xi, y, phi, &
                                       p_born, p_real, jac)
        else
          call msg_fatal ("ISR not implemented yet!")
        end if
        call term%nlo_data%set_jacobian (jac)
        call term%nlo_data%set_real_momenta (p_real)
        call interaction_set_momenta (term%int_hard_real, p_real)

        call term%isolated_real%receive_kinematics ()
        call term%connected_real%receive_kinematics ()

        call term%connected_real%evaluate_expressions (term%passed, &
             term%scale, term%fac_scale, term%ren_scale, term%weight)

        if (term%passed) then
           call component(i_component)%tmp%reset_new_kinematics ()
           do i = 1, term%config%n_allowed
              term%amp(i) = core%compute_amplitude (i_term, &
                 interaction_get_momenta (term%int_hard_real), &
                 term%config%flv(i), term%config%hel(i), term%config%col(i), &
                 term%fac_scale, term%ren_scale, &
                 component(i_component)%tmp)
           end do
           call interaction_set_matrix_element (term%int_hard_real, term%amp)
           associate (core_sub_born => component(i_component)%config%core_sub_born)
@ Unless the kinematics are resetted, the calculation would use the same Born phase space point multiple times.
<<Processes: procedures>>=           
             call component(i_component)%tmp%reset_new_kinematics ()
             do i = 1, term%nlo_data%n_allowed_born
                term%nlo_data%amp_born(i) = core_sub_born%compute_amplitude (i_term, &
                interaction_get_momenta (term%nlo_data%int_born), &
                term%nlo_data%flv_born(i), term%nlo_data%hel_born(i), &
                term%nlo_data%col_born(i), term%fac_scale, term%ren_scale, &
                component(i_component)%tmp)
             end do
             call interaction_set_matrix_element (term%nlo_data%int_born, term%nlo_data%amp_born) 
           end associate
         end if
      end select
    end associate
  end subroutine term_instance_evaluate_interaction
  
@ %def term_instance_evaluate_interaction
@ Evaluate the trace.  First evaluate the
structure-function chain (i.e., the density matrix of the incoming
partons).  Do this twice, in case the sf-chain instances within
[[k_term]] and [[isolated]] differ.  Next, evaluate the hard
interaction, then compute the convolution with the initial state.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_trace => term_instance_evaluate_trace
<<Processes: procedures>>=
  subroutine term_instance_evaluate_trace (term)
    class(term_instance_t), intent(inout) :: term
    call term%k_term%evaluate_sf_chain (term%fac_scale)
    call term%isolated%evaluate_sf_chain (term%fac_scale)
    call term%isolated%evaluate_trace ()
    call term%connected%evaluate_trace ()
    select case (char (term%nlo_data%nlo_type))
    case ('Real')
      call term%isolated_real%evaluate_trace ()
      call term%connected_real%evaluate_trace ()
    end select
  end subroutine term_instance_evaluate_trace
  
@ %def term_instance_evaluate_trace
@ Evaluate the extra data that we need for processing the object as a
physical event.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_event_data => term_instance_evaluate_event_data
<<Processes: procedures>>=
  subroutine term_instance_evaluate_event_data (term)
    class(term_instance_t), intent(inout) :: term
    select case (char (term%nlo_data%nlo_type))
    case ('Born', 'Virtual')
      call term%isolated%evaluate_event_data ()
      call term%connected%evaluate_event_data ()
    case ('Real')
      call term%isolated_real%evaluate_event_data ()
      call term%connected_real%evaluate_event_data ()
    end select
  end subroutine term_instance_evaluate_event_data
  
@ %def term_instance_evaluate_event_data
@ Return data that might be useful for external processing.  The
factorization scale:
<<Processes: term instance: TBP>>=
  procedure :: get_fac_scale => term_instance_get_fac_scale
<<Processes: procedures>>=
  function term_instance_get_fac_scale (term) result (fac_scale)
    class(term_instance_t), intent(in) :: term
    real(default) :: fac_scale
    fac_scale = term%fac_scale
  end function term_instance_get_fac_scale
  
@ %def term_instance_get_fac_scale
@ We take the strong coupling from the process core.  The value is calculated
when a new event is requested, so we should call it only after the event has
been evaluated.  If it is not available there (a negative number is returned),
we take the value stored in the term configuration, which should be determined
by the model.  If the model does not provide a value, the result is zero.
<<Processes: term instance: TBP>>=
  procedure :: get_alpha_s => term_instance_get_alpha_s
<<Processes: procedures>>=
  function term_instance_get_alpha_s (term, component) result (alpha_s)
    class(term_instance_t), intent(in) :: term
    type(component_instance_t), dimension(:), intent(in) :: component
    real(default) :: alpha_s
    integer :: i_component
    i_component = term%config%i_component
    associate (core => component(i_component)%config%core)
      alpha_s = core%get_alpha_s (component(i_component)%tmp)
    end associate
    if (alpha_s < 0)  alpha_s = term%config%alpha_s
  end function term_instance_get_alpha_s
  
@ %def term_instance_get_alpha_s
@
\subsubsection{MC parameter set and MCI instance}
For each process component that is associated with a multi-channel integration
(MCI) object, the [[mci_work_t]] object contains the currently active
parameter set.  It also holds the implementation of the [[mci_instance_t]]
that the integrator needs for doing its work.
<<Processes: types>>=
  type :: mci_work_t
     type(process_mci_entry_t), pointer :: config => null ()
     real(default), dimension(:), allocatable :: x
     class(mci_instance_t), pointer :: mci => null ()
     type(process_counter_t) :: counter
   contains
   <<Processes: mci work: TBP>>
  end type mci_work_t

@ %def mci_work_t
@ First write configuration data, then the current values.
<<Processes: mci work: TBP>>=
  procedure :: write => mci_work_write
<<Processes: procedures>>=
  subroutine mci_work_write (mci_work, unit, testflag)
    class(mci_work_t), intent(in) :: mci_work
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A,I0,A)")  "Active MCI instance #", &
         mci_work%config%i_mci, " ="
    write (u, "(2x)", advance="no")
    do i = 1, mci_work%config%n_par
       write (u, "(1x,F7.5)", advance="no")  mci_work%x(i)
       if (i == mci_work%config%n_par_sf) &
            write (u, "(1x,'|')", advance="no")
    end do
    write (u, *)
    if (associated (mci_work%mci)) then
       call mci_work%mci%write (u, pacify = testflag)
       call mci_work%counter%write (u)
    end if
  end subroutine mci_work_write
         
@ %def mci_work_write
@ The [[mci]] component may require finalization.
<<Processes: mci work: TBP>>=
  procedure :: final => mci_work_final
<<Processes: procedures>>=
  subroutine mci_work_final (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    if (associated (mci_work%mci)) then
       call mci_work%mci%final ()
       deallocate (mci_work%mci)
    end if
  end subroutine mci_work_final
  
@ %def mci_work_final
@ Initialize with the maximum length that we will need.  Contents are
not initialized.

The integrator inside the [[mci_entry]] object is responsible for
allocating and initializing its own instance, which is referred to by
a pointer in the [[mci_work]] object.
<<Processes: mci work: TBP>>=
  procedure :: init => mci_work_init
<<Processes: procedures>>=
  subroutine mci_work_init (mci_work, mci_entry)
    class(mci_work_t), intent(out) :: mci_work
    type(process_mci_entry_t), intent(in), target :: mci_entry
    mci_work%config => mci_entry
    allocate (mci_work%x (mci_entry%n_par))
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%allocate_instance (mci_work%mci)
       call mci_work%mci%init (mci_entry%mci)
    end if
  end subroutine mci_work_init
  
@ %def mci_work_init
@ Set parameters explicitly, either all at once, or separately for the
structure-function and process parts.
<<Processes: mci work: TBP>>=
  procedure :: set => mci_work_set
  procedure :: set_x_strfun => mci_work_set_x_strfun
  procedure :: set_x_process => mci_work_set_x_process
<<Processes: procedures>>=
  subroutine mci_work_set (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x = x
  end subroutine mci_work_set
    
  subroutine mci_work_set_x_strfun (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x(1 : mci_work%config%n_par_sf) = x
  end subroutine mci_work_set_x_strfun
    
  subroutine mci_work_set_x_process (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x(mci_work%config%n_par_sf + 1 : mci_work%config%n_par) = x
  end subroutine mci_work_set_x_process
    
@ %def mci_work_set
@ %def mci_work_set_x_strfun
@ %def mci_work_set_x_process
@ Return the array of active components, i.e., those that correspond
to the currently selected MC parameter set.
<<Processes: mci work: TBP>>=
  procedure :: get_active_components => mci_work_get_active_components
<<Processes: procedures>>=
  function mci_work_get_active_components (mci_work) result (i_component)
    class(mci_work_t), intent(in) :: mci_work
    integer, dimension(:), allocatable :: i_component
    allocate (i_component (size (mci_work%config%i_component)))
    i_component = mci_work%config%i_component
  end function mci_work_get_active_components

@ %def mci_work_get_active_components
@ Return the active parameters as a simple array with correct length.
Do this separately for the structure-function parameters and the
process parameters.
<<Processes: mci work: TBP>>=
  procedure :: get_x_strfun => mci_work_get_x_strfun
  procedure :: get_x_process => mci_work_get_x_process
<<Processes: procedures>>=
  function mci_work_get_x_strfun (mci_work) result (x)
    class(mci_work_t), intent(in) :: mci_work
    real(default), dimension(mci_work%config%n_par_sf) :: x
    x = mci_work%x(1 : mci_work%config%n_par_sf)
  end function mci_work_get_x_strfun

  function mci_work_get_x_process (mci_work) result (x)
    class(mci_work_t), intent(in) :: mci_work
    real(default), dimension(mci_work%config%n_par_phs) :: x
    x = mci_work%x(mci_work%config%n_par_sf + 1 : mci_work%config%n_par)
  end function mci_work_get_x_process

@ %def mci_work_get_x_strfun
@ %def mci_work_get_x_process
@ Initialize and finalize event generation for the specified MCI
entry.  This also resets the counter.
<<Processes: mci work: TBP>>=
  procedure :: init_simulation => mci_work_init_simulation
  procedure :: final_simulation => mci_work_final_simulation
<<Processes: procedures>>=
  subroutine mci_work_init_simulation (mci_work, safety_factor)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), intent(in), optional :: safety_factor
    call mci_work%mci%init_simulation (safety_factor)
    call mci_work%counter%reset ()
  end subroutine mci_work_init_simulation

  subroutine mci_work_final_simulation (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    call mci_work%mci%final_simulation ()
  end subroutine mci_work_final_simulation

@ %def mci_work_init_simulation
@ %def mci_work_final_simulation
@ Counter.
<<Processes: mci work: TBP>>=
  procedure :: reset_counter => mci_work_reset_counter
  procedure :: record_call => mci_work_record_call
  procedure :: get_counter => mci_work_get_counter
<<Processes: procedures>>=
  subroutine mci_work_reset_counter (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    call mci_work%counter%reset ()
  end subroutine mci_work_reset_counter
  
  subroutine mci_work_record_call (mci_work, status)
    class(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: status
    call mci_work%counter%record (status)
  end subroutine mci_work_record_call
    
  function mci_work_get_counter (mci_work) result (counter)
    class(mci_work_t), intent(in) :: mci_work
    type(process_counter_t) :: counter
    counter = mci_work%counter
  end function mci_work_get_counter
  
@ %def mci_work_reset_counter
@ %def mci_work_record_call
@ %def mci_work_get_counter
@ 
\subsubsection{The process instance}
A process instance contains all process data that depend on the
sampling point and thus change often.  In essence, it is an event
record at the elementary (parton) level.  We do not call it such, to
avoid confusion with the actual event records.  If decays are
involved, the latter are compositions of several elementary processes
(i.e., their instances).

We implement the process instance as an extension of the [[mci_sampler_t]]
that we need for computing integrals and generate events.

The base type contains: the [[integrand]], the [[selected_channel]], the
two-dimensional array [[x]] of parameters, and the one-dimensional array [[f]]
of Jacobians.  These subobjects are public and used for communicating with the
multi-channel integrator.

The [[process]] pointer accesses the process of which this record is
an instance.  It is required whenever the calculation needs invariant
configuration data, therefore the process should stay in memory for
the whole lifetime of its instances.

The [[evaluation_status]] code is used to check the current status.
In particular, failure at various stages is recorded there.

The [[count]] object records process evaluations, broken down
according to status.

The [[sqme]] value is the single real number that results from
evaluating and tracing the kinematics and matrix elements.  This
is the number that is handed over to an integration routine.

The [[weight]] value is the event weight.  It is defined when an event
has been generated from the process instance, either weighted or
unweighted.  The value is the [[sqme]] value times Jacobian weights
from the integration, or unity, respectively.

The [[i_mci]] index chooses a subset of components that are associated with
a common parameter set and integrator, i.e., that are added coherently.

The [[sf_chain]] subobject is a realization of the beam and
structure-function configuration in the [[process]] object.  It is not
used for calculation directly but serves as the template for the
sf-chain instances that are contained in the [[component]] objects.

The [[component]] subobjects determine the state of each component.

The [[term]] subobjects are workspace for evaluating kinematics,
matrix elements, cuts etc.

The [[mci_work]] subobject contains the array of real input parameters (random
numbers) that generates the kinematical point.  It also contains the workspace
for the MC integrators.  The active entry of the [[mci_work]] array is
selected by the [[i_mci]] index above.
<<Processes: public>>=
  public :: process_instance_t
<<Processes: types>>=
  type, extends (mci_sampler_t) :: process_instance_t
     type(process_t), pointer :: process => null ()
     integer :: evaluation_status = STAT_UNDEFINED
     real(default) :: sqme = 0
     real(default), dimension(:), allocatable :: sqme_real
     real(default) :: weight = 0
     real(default) :: excess = 0
     integer :: i_mci = 0
     integer :: selected_channel = 0
     type(sf_chain_t) :: sf_chain
     type(component_instance_t), dimension(:), allocatable :: component
     type(term_instance_t), dimension(:), allocatable :: term
     type(mci_work_t), dimension(:), allocatable :: mci_work
   contains
   <<Processes: process instance: TBP>>
  end type process_instance_t
     
@ %def process_instance
@ The output routine contains a header with the most relevant
information about the process, copied from
[[process_metadata_write]].  We mark the active components by an asterisk.

The next section is the MC parameter input.  The following sections
are written only if the evaluation status is beyond setting the
parameters, or if the [[verbose]] option is set.
<<Processes: process instance: TBP>>=
  procedure :: write_header => process_instance_write_header
  procedure :: write => process_instance_write
<<Processes: procedures>>=
  subroutine process_instance_write_header (object, unit, testflag)
    class(process_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    if (associated (object%process)) then
       associate (meta => object%process%meta)
         select case (meta%type)
         case (PRC_UNKNOWN)
            write (u, "(1x,A)") "Process instance [undefined]"
            return
         case (PRC_DECAY)
            write (u, "(1x,A)", advance="no") "Process instance [decay]:"
         case (PRC_SCATTERING)
            write (u, "(1x,A)", advance="no") "Process instance [scattering]:"
         case default
            call msg_bug ("process_instance_write: undefined process type")
         end select
         write (u, "(1x,A,A,A)") "'", char (meta%id), "'"
         write (u, "(3x,A,A,A)") "Run ID = '", char (meta%run_id), "'"
         if (allocated (meta%component_id)) then
            write (u, "(3x,A)")  "Process components:"
            do i = 1, size (meta%component_id)
               if (object%component(i)%active) then
                  write (u, "(3x,'*')", advance="no")
               else
                  write (u, "(4x)", advance="no")
               end if
               write (u, "(1x,I0,9A)")  i, ": '", &
                    char (meta%component_id (i)), "':   ", &
                    char (meta%component_description (i))
            end do
         end if
       end associate
    else
       write (u, "(1x,A)") "Process instance [undefined process]"
       return
    end if
    write (u, "(3x,A)", advance = "no")  "status = "
    select case (object%evaluation_status)
    case (STAT_INITIAL);            write (u, "(A)")  "initialized"
    case (STAT_ACTIVATED);          write (u, "(A)")  "activated"
    case (STAT_BEAM_MOMENTA);       write (u, "(A)")  "beam momenta set"
    case (STAT_FAILED_KINEMATICS);  write (u, "(A)")  "failed kinematics"
    case (STAT_SEED_KINEMATICS);    write (u, "(A)")  "seed kinematics"
    case (STAT_HARD_KINEMATICS);    write (u, "(A)")  "hard kinematics"
    case (STAT_EFF_KINEMATICS);     write (u, "(A)")  "effective kinematics"
    case (STAT_FAILED_CUTS);        write (u, "(A)")  "failed cuts"
    case (STAT_PASSED_CUTS);        write (u, "(A)")  "passed cuts"
    case (STAT_EVALUATED_TRACE);    write (u, "(A)")  "evaluated trace"
       call write_separator (u)
       write (u, "(3x,A,ES19.12)")  "sqme   = ", object%sqme
    case (STAT_EVENT_COMPLETE);   write (u, "(A)")  "event complete"
       call write_separator (u)
       write (u, "(3x,A,ES19.12)")  "sqme   = ", object%sqme
       write (u, "(3x,A,ES19.12)")  "weight = ", object%weight
       if (object%excess /= 0) &
            write (u, "(3x,A,ES19.12)")  "excess = ", object%excess
    case default;                 write (u, "(A)")  "undefined"
    end select
    if (object%i_mci /= 0) then
       call write_separator (u)
       call object%mci_work(object%i_mci)%write (u, testflag)
    end if
    call write_separator (u, 2)
  end subroutine process_instance_write_header

  subroutine process_instance_write (object, unit, testflag)
    class(process_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    call object%write_header (u)
    if (object%evaluation_status >= STAT_BEAM_MOMENTA) then
       call object%sf_chain%write (u)
       call write_separator (u, 2)
       if (object%evaluation_status >= STAT_SEED_KINEMATICS) then
          write (u, "(1x,A)") "Active components:"
          do i = 1, size (object%component)
             if (object%component(i)%active) then
                call write_separator (u)
                call object%component(i)%write (u, testflag)
             end if
          end do
          if (object%evaluation_status >= STAT_HARD_KINEMATICS) then
             call write_separator (u, 2)
             write (u, "(1x,A)") "Active terms:"
             if (any (object%term%active)) then
                do i = 1, size (object%term)
                   if (object%term(i)%active) then
                      call write_separator (u)
                      call object%term(i)%write (u, &
                           show_eff_state = &
                           object%evaluation_status >= STAT_EFF_KINEMATICS, &
                           testflag = testflag)
                   end if
                end do
             end if
          end if
          call write_separator (u, 2)
       end if
    end if
  end subroutine process_instance_write

@ %def process_instance_write_header
@ %def process_instance_write
@ Finalize all subobjects that may contain allocated pointers.
<<Processes: process instance: TBP>>=
  procedure :: final => process_instance_final
<<Processes: procedures>>=
  subroutine process_instance_final (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i
    if (allocated (instance%mci_work)) then
       do i = 1, size (instance%mci_work)
          call instance%mci_work(i)%final ()
       end do
    end if
    call instance%sf_chain%final ()
    if (allocated (instance%component)) then
       do i = 1, size (instance%component)
          call instance%component(i)%final ()
       end do
    end if
    if (allocated (instance%term)) then
       do i = 1, size (instance%term)
          call instance%term(i)%final ()
       end do
    end if
    instance%evaluation_status = STAT_UNDEFINED
  end subroutine process_instance_final

@ %def process_instance_final
@ Revert the process instance to initial state.  We do not deallocate
anything, just reset the state index and deactivate all components and
terms.

We do not reset the choice of the MCI set [[i_mci]] unless this is
required explicitly.
<<Processes: process instance: TBP>>=
  procedure :: reset => process_instance_reset
<<Processes: procedures>>=
  subroutine process_instance_reset (instance, reset_mci)
    class(process_instance_t), intent(inout) :: instance
    logical, intent(in), optional :: reset_mci
    integer :: i
    instance%component%active = .false.
    do i = 1, size (instance%term)
       call instance%term(i)%reset ()
    end do
    instance%term%checked = .false.
    instance%term%passed = .false.
    if (present (reset_mci)) then
       if (reset_mci)  instance%i_mci = 0
    end if
    instance%selected_channel = 0
    instance%evaluation_status = STAT_INITIAL
  end subroutine process_instance_reset
  
@ %def process_instance_reset
@ Activate the components and terms that correspond to a currently
selected MCI parameter set.
<<Processes: process instance: TBP>>=
  procedure :: activate => process_instance_activate
<<Processes: procedures>>=
  subroutine process_instance_activate (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i, j
    associate (mci_work => instance%mci_work(instance%i_mci))
      instance%component(mci_work%get_active_components ())%active &
           = .true.
      do i = 1, size (instance%component)
         associate (component => instance%component(i))
           if (component%active) then
              do j = 1, size (component%config%i_term)
                 instance%term(component%config%i_term(j))%active &
                      = .true.
              end do
           end if
         end associate
      end do
    end associate
    instance%evaluation_status = STAT_ACTIVATED
  end subroutine process_instance_activate
  
@ %def process_instance_activate
@ Initialization connects the instance with a process.  All initial
information is transferred from the process object.  The process
object contains templates for the interaction subobjects (beam and
term), but no evaluators.  The initialization routine
creates evaluators for the matrix element trace, other evaluators
are left untouched.

The [[instance]] object must have the [[target]] attribute (also in
any caller) since the initialization routine assigns various pointers to
subobject of [[instance]].
<<Processes: process instance: TBP>>=
  procedure :: init => process_instance_init
<<Processes: procedures>>=
  subroutine process_instance_init (instance, process)
    class(process_instance_t), intent(out), target :: instance
    type(process_t), intent(inout), target :: process
    integer :: i, i_component
    type(process_constants_t), dimension(2), save :: prc_constants
    type(string_t) :: nlo_type
    integer :: i_born, i_real
    type(nlo_pointer_t), dimension(:), allocatable :: nlo_p

    instance%process => process
    call instance%setup_sf_chain (process%beam_config)
    allocate (instance%mci_work (process%config%n_mci))
    do i = 1, size (instance%mci_work)
       call instance%mci_work(i)%init (process%mci_entry(i))
    end do
    allocate (instance%component (process%config%n_components))
    allocate (nlo_p (process%config%n_components))
    do i = 1, size (nlo_p)
      allocate (nlo_p(i)%nlo_data)
    end do
    do i_component = 1, size (instance%component)
       if (process%component(i_component)%active) then
          associate (component => instance%component(i_component))
            call component%init (process%component(i_component))
            nlo_type = component%config%config%get_nlo_type ()
            select case (char (nlo_type))
            case ('Born')
              call nlo_p(i_component)%nlo_data%set_nlo_type (var_str ('Born'))
            case ('Real')
              i_born = component%config%config%get_associated_born ()
              call process%term(i_born)%fetch_constants (prc_constants(1))
              call process%term(i_component)%fetch_constants(prc_constants(2))
              call nlo_p(i_component)%nlo_data%init (var_str ('Real'), prc_constants, &
                                               process%component(i_component)%fks_template, &
                                               process%config%model)
              call nlo_p(i_component)%nlo_data%set_flv_born (process%term(i_born)%flv)
              call nlo_p(i_component)%nlo_data%set_col_born (process%term(i_born)%col)
              call nlo_p(i_component)%nlo_data%set_hel_born (process%term(i_born)%hel)
              allocate (instance%sqme_real (size (nlo_p(i_component)%nlo_data%reg_data%regions)))
            end select
            call component%setup_kinematics &
                 (instance%sf_chain, process%beam_config)
          end associate
       end if
    end do
    allocate (instance%term (process%config%n_terms))
    do i = 1, size (instance%term)
       associate (term => instance%term(i))
         i_component = process%term(i)%i_component
         if (i_component /= 0) then
            associate (component => instance%component(i_component))
              nlo_type = component%config%config%get_nlo_type ()
              call component%k_seed%set_nlo_data (nlo_type)
              select case (char (nlo_type))
              case ('Virtual')
                i_born = component%config%config%get_associated_born ()
                i_real = i_born + process%config%n_components / 3
                nlo_p(i_component)%nlo_data = instance%term(i_real)%nlo_data
                call nlo_p(i_component)%nlo_data%set_nlo_type (var_str ('Virtual'))
                call nlo_p(i_component)%nlo_data%init_virtual ()
              end select

              call term%init (process%term(i), &
                   component%k_seed, &
                   process%beam_config, &
                   process%component(i_component)%core, &
                   process%meta%var_list, nlo_p(i_component)%nlo_data)
              call term%setup_expressions (process%meta, process%config)
              select case (char (nlo_type))
              case ('Real')
                call term%setup_expressions_real (process%meta, process%config)
              end select
              component%nlo_data => term%nlo_data
           end associate
         end if
       end associate
    end do
    instance%evaluation_status = STAT_INITIAL
  end subroutine process_instance_init
  
@ %def process_instance_init
@ Subroutine of the initialization above: initialize the beam and
structure-function chain template.  We establish pointers to the
configuration data, so [[beam_config]] must have a [[target]]
attribute.

The resulting chain is not used directly for calculation.  It will
acquire instances which are stored in the process-component instance
objects.
<<Processes: process instance: TBP>>=
  procedure :: setup_sf_chain => process_instance_setup_sf_chain
<<Processes: procedures>>=
  subroutine process_instance_setup_sf_chain (instance, config)
    class(process_instance_t), intent(inout) :: instance
    type(process_beam_config_t), intent(in), target :: config
    integer :: n_strfun
    n_strfun = config%n_strfun
    if (n_strfun /= 0) then
       call instance%sf_chain%init (config%data, config%sf)
    else
       call instance%sf_chain%init (config%data)
    end if
    if (config%sf_trace) then
       call instance%sf_chain%setup_tracing (config%sf_trace_file)
    end if
  end subroutine process_instance_setup_sf_chain
    
@ %def process_instance_setup_sf_chain
@ This initialization routine should be called only for process
instances which we intend as a source for physical events.  It
initializes the evaluators in the parton states of the terms.  They
describe the (semi-)exclusive transition matrix and the distribution
of color flow for the partonic process, convoluted with the beam and
structure-function chain.

If the model is not provided explicitly, we may use the model instance that
belongs to the process.  However, an explicit model allows us to override
particle settings.
<<Processes: process instance: TBP>>=
  procedure :: setup_event_data => process_instance_setup_event_data
<<Processes: procedures>>=
  subroutine process_instance_setup_event_data (instance, model)
    class(process_instance_t), intent(inout), target :: instance
    type(model_t), intent(in), optional, target :: model
    type(model_t), pointer :: current_model
    integer :: i, i_component
    if (present (model)) then
       current_model => model
    else
       current_model => instance%process%config%model
    end if
    do i = 1, size (instance%term)
       associate (term => instance%term(i))
         if (associated (term%config)) then
            i_component = term%config%i_component
            associate (component => instance%process%component(i_component))
              call term%setup_event_data (component%core, current_model)
            end associate
         end if
       end associate
    end do
  end subroutine process_instance_setup_event_data

@ %def process_instance_setup_event_data
@
<<Processes: process instance: TBP>>=
  procedure :: init_born_amps => process_instance_init_born_amps
<<Processes: procedures>>=
  subroutine process_instance_init_born_amps (instance, i_component, i_born)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_component, i_born
    select type (core_born => instance%component(i_component)%config%core_sub_born)
    type is (prc_omega_t)
      call instance%component(i_component)%nlo_data%init_born_amps &
                          (instance%term(i_born)%config%n_allowed, .true.)
    type is (prc_gosam_t)
      call instance%component(i_component)%nlo_data%init_born_amps &
                          (instance%term(i_born)%config%n_allowed, .false.)
    end select
  end subroutine process_instance_init_born_amps

@ %def process_instance_init_born_amps
@   
@ Choose a MC parameter set and the corresponding integrator. 

The choice persists beyond calls of the [[reset]] method above.  This method
is automatically called here.
<<Processes: process instance: TBP>>=
  procedure :: choose_mci => process_instance_choose_mci
<<Processes: procedures>>=
  subroutine process_instance_choose_mci (instance, i_mci)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    instance%i_mci = i_mci
    call instance%reset ()
  end subroutine process_instance_choose_mci
    
@ %def process_instance_choose_mci
@ Explicitly set a MC parameter set.  Works only if we are in initial
state.  We assume that the length of the parameter set is correct.  

After setting the parameters, activate the components and terms that
correspond to the chosen MC parameter set.
<<Processes: process instance: TBP>>=
  procedure :: set_mcpar => process_instance_set_mcpar
<<Processes: procedures>>=
  subroutine process_instance_set_mcpar (instance, x)
    class(process_instance_t), intent(inout) :: instance
    real(default), dimension(:), intent(in) :: x
    if (instance%evaluation_status == STAT_INITIAL) then
       associate (mci_work => instance%mci_work(instance%i_mci))
         call mci_work%set (x)
       end associate
       call instance%activate ()
    end if
  end subroutine process_instance_set_mcpar

@ %def process_instance_set_mcpar
@ Receive the beam momentum/momenta from a source interaction.  This
applies to a cascade decay process instance, where the `beam' momentum
varies event by event.

The master beam momentum array is contained in the main structure
function chain subobject [[sf_chain]].  The sf-chain instance that
reside in the components will take their beam momenta from there.

The procedure transforms the instance status into
[[STAT_BEAM_MOMENTA]].  For process instance with fixed beam, this
intermediate status is skipped.
<<Processes: process instance: TBP>>=
  procedure :: receive_beam_momenta => process_instance_receive_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_receive_beam_momenta (instance)
    class(process_instance_t), intent(inout) :: instance
    if (instance%evaluation_status >= STAT_INITIAL) then
       call instance%sf_chain%receive_beam_momenta ()
       instance%evaluation_status = STAT_BEAM_MOMENTA
    end if
  end subroutine process_instance_receive_beam_momenta
    
@ %def process_instance_receive_beam_momenta
@ Set the beam momentum/momenta explicitly.  Otherwise, analogous to
the previous procedure.
<<Processes: process instance: TBP>>=
  procedure :: set_beam_momenta => process_instance_set_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_set_beam_momenta (instance, p)
    class(process_instance_t), intent(inout) :: instance
    type(vector4_t), dimension(:), intent(in) :: p
    if (instance%evaluation_status >= STAT_INITIAL) then
       call instance%sf_chain%set_beam_momenta (p)
       instance%evaluation_status = STAT_BEAM_MOMENTA
    end if
  end subroutine process_instance_set_beam_momenta
    
@ %def process_instance_set_beam_momenta
@ Recover the initial beam momenta (those in the [[sf_chain]]
component), given a valid (recovered) [[sf_chain_instance]] in one of
the active components.  We need to do this only if the lab frame is
not the c.m.\ frame, otherwise those beams would be fixed anyway.
<<Processes: process instance: TBP>>=
  procedure :: recover_beam_momenta => process_instance_recover_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_recover_beam_momenta (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: i
    if (.not. instance%process%beam_config%lab_is_cm_frame) then
       if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
          i = instance%term(i_term)%config%i_component
          call instance%component(i)%return_beam_momenta ()
       end if
    end if
  end subroutine process_instance_recover_beam_momenta

@ %def process_instance_recover_beam_momenta
@ Explicitly choose MC integration channel.  We assume here that the channel
count is identical for all active components.
<<Processes: process instance: TBP>>=
  procedure :: select_channel => process_instance_select_channel
<<Processes: procedures>>=
  subroutine process_instance_select_channel (instance, channel)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    instance%selected_channel = channel
  end subroutine process_instance_select_channel
  
@ %def process_instance_select_channel
@ First step of process evaluation: set up seed kinematics.  That is, for each
active process component, compute a momentum array from the MC input
parameters.

If [[skip_term]] is set, we skip the component that accesses this
term.  We can assume that the associated data have already been
recovered, and we are just computing the rest.
<<Processes: process instance: TBP>>=
  procedure :: compute_seed_kinematics => &
       process_instance_compute_seed_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_seed_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: channel, skip_component, i
    logical :: success
    channel = instance%selected_channel
    if (channel == 0) then
       call msg_bug ("Compute seed kinematics: undefined integration channel")
    end if
    if (present (skip_term)) then
       skip_component = instance%term(skip_term)%config%i_component
    else
       skip_component = 0
    end if
    if (instance%evaluation_status >= STAT_ACTIVATED) then
       success = .true.
       do i = 1, size (instance%component)
          if (i == skip_component)  cycle
          if (instance%component(i)%active) then
             call instance%component(i)%compute_seed_kinematics &
                  (instance%mci_work(instance%i_mci), channel, success)
             if (.not. success)  exit
          end if
       end do
       if (success) then
          instance%evaluation_status = STAT_SEED_KINEMATICS
       else
          instance%evaluation_status = STAT_FAILED_KINEMATICS
       end if
    end if
  end subroutine process_instance_compute_seed_kinematics

@ %def process_instance_compute_seed_kinematics
@ Inverse: recover missing parts of the kinematics from the momentum
configuration, which we know for a single term and component.   Given
a channel, reconstruct the MC parameter set.
<<Processes: process instance: TBP>>=
  procedure :: recover_mcpar => process_instance_recover_mcpar
<<Processes: procedures>>=
  subroutine process_instance_recover_mcpar (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: channel
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       channel = instance%selected_channel
       if (channel == 0) then
          call msg_bug ("Recover MC parameters: undefined integration channel")
       end if
       i = instance%term(i_term)%config%i_component
       call instance%component(i)%recover_mcpar &
                  (instance%mci_work(instance%i_mci), channel)
    end if
  end subroutine process_instance_recover_mcpar

@ %def process_instance_recover_mcpar
@ Second step of process evaluation: compute all momenta, for all active
components, from the seed kinematics.
<<Processes: process instance: TBP>>=
  procedure :: compute_hard_kinematics => &
       process_instance_compute_hard_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_hard_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: i
    logical :: real_phsp
    if (instance%evaluation_status >= STAT_SEED_KINEMATICS) then
       do i = 1, size (instance%component)
          if (instance%component(i)%active) then
            select case (char (instance%component(i)%config%config%get_nlo_type()))
            case ('Born', 'Virtual')
              real_phsp = .false.
            case ('Real')
              real_phsp = .true.
            end select
              call instance%component(i)% &
                  compute_hard_kinematics (instance%term, skip_term, real_phsp)
          end if
       end do
       instance%evaluation_status = STAT_HARD_KINEMATICS
    end if
  end subroutine process_instance_compute_hard_kinematics

@ %def process_instance_setup_compute_hard_kinematics
@ Inverse: recover seed kinematics.  We know the beam momentum
configuration and the outgoing momenta of the effective interaction,
for one specific term.
<<Processes: process instance: TBP>>=
  procedure :: recover_seed_kinematics => &
       process_instance_recover_seed_kinematics
<<Processes: procedures>>=
  subroutine process_instance_recover_seed_kinematics (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       associate (i_component => instance%term(i_term)%config%i_component)
         call instance%component(i_component)% &
              recover_seed_kinematics (instance%term(i_term))
       end associate
    end if
  end subroutine process_instance_recover_seed_kinematics
  
@ %def process_instance_recover_seed_kinematics
@ Third step of process evaluation: compute the effective momentum
configurations, for all active terms, from the hard kinematics.
<<Processes: process instance: TBP>>=
  procedure :: compute_eff_kinematics => &
       process_instance_compute_eff_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_eff_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: i
    if (instance%evaluation_status >= STAT_HARD_KINEMATICS) then
       do i = 1, size (instance%term)
          if (present (skip_term)) then
             if (i == skip_term)  cycle
          end if
          if (instance%term(i)%active) then
             call instance%term(i)% &
                  compute_eff_kinematics (instance%component)
          end if
       end do
       instance%evaluation_status = STAT_EFF_KINEMATICS
    end if
  end subroutine process_instance_compute_eff_kinematics

@ %def process_instance_setup_compute_eff_kinematics
@ Inverse: recover the hard kinematics from effective kinematics for
one term, then compute effective kinematics for the other terms.
<<Processes: process instance: TBP>>=
  procedure :: recover_hard_kinematics => &
       process_instance_recover_hard_kinematics
<<Processes: procedures>>=
  subroutine process_instance_recover_hard_kinematics (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       call instance%term(i_term)%recover_hard_kinematics (instance%component)
       do i = 1, size (instance%term)
          if (i /= i_term) then
             if (instance%term(i)%active) then
                call instance%term(i)% &
                     compute_eff_kinematics (instance%component)
             end if
          end if
       end do
       instance%evaluation_status = STAT_EFF_KINEMATICS
    end if
  end subroutine process_instance_recover_hard_kinematics
       
@ %def recover_hard_kinematics
@ Fourth step of process evaluation: check cuts for all terms.  Where
sucessful, compute any scales and weights.  Otherwise, deactive the term.
If any of the terms has passed, set the state to [[STAT_PASSED_CUTS]].
<<Processes: process instance: TBP>>=
  procedure :: evaluate_expressions => &
       process_instance_evaluate_expressions
<<Processes: procedures>>=
  subroutine process_instance_evaluate_expressions (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       do i = 1, size (instance%term)
          if (instance%term(i)%active) then
             call instance%term(i)%evaluate_expressions ()
          end if
       end do
       if (any (instance%term%passed)) then
          instance%evaluation_status = STAT_PASSED_CUTS
       else
          instance%evaluation_status = STAT_FAILED_CUTS
       end if
    end if
  end subroutine process_instance_evaluate_expressions

@ %def process_instance_evaluate_expressions
@ Fifth step of process evaluation: fill the parameters for the non-selected
,channels, that have not been used for seeding.  We should do this after
evaluating cuts, since we may save some expensive calculations if the phase
space point fails the cuts.

If [[skip_term]] is set, we skip the component that accesses this
term.  We can assume that the associated data have already been
recovered, and we are just computing the rest.
<<Processes: process instance: TBP>>=
  procedure :: compute_other_channels => &
       process_instance_compute_other_channels
<<Processes: procedures>>=
  subroutine process_instance_compute_other_channels (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: channel, skip_component, i
    channel = instance%selected_channel
    if (channel == 0) then
       call msg_bug ("Compute other channels: undefined integration channel")
    end if
    if (present (skip_term)) then
       skip_component = instance%term(skip_term)%config%i_component
    else
       skip_component = 0
    end if
    if (instance%evaluation_status >= STAT_PASSED_CUTS) then
       do i = 1, size (instance%component)
          if (i == skip_component)  cycle
          if (instance%component(i)%active) then
             call instance%component(i)%compute_other_channels &
                  (instance%mci_work(instance%i_mci), channel)
          end if
       end do
    end if
  end subroutine process_instance_compute_other_channels

@ %def process_instance_compute_other_channels
@ Sixth step of process evaluation: evaluate the matrix elements, and compute
the trace (summed over quantum numbers) for all terms.  Finally, sum up the
terms, iterating over all active process components.
<<Processes: process instance: TBP>>=
  procedure :: evaluate_trace => process_instance_evaluate_trace
<<Processes: procedures>>=
  subroutine process_instance_evaluate_trace (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i, j
    integer :: n_legs
    logical :: passed
    integer :: ireg
    instance%sqme = 0
    if (instance%evaluation_status >= STAT_PASSED_CUTS) then
       do i = 1, size (instance%term)
          associate (term => instance%term(i))
            if (term%active .and. term%passed) then
              select case (char (term%nlo_data%nlo_type))
              case ('Real')
                instance%sqme_real = 0
                n_legs = term%nlo_data%reg_data%nlegs_real
                passed = .true.
                ireg = 1
                do j = 1, n_legs
                  if (any (term%nlo_data%reg_data%emitters == j)) then
                    call term%nlo_data%set_active_emitter (j)
                    call term%evaluate_interaction (instance%component)
                    passed = passed .and. term%passed
                    if (term%passed) then
                       call term%evaluate_trace ()
                       if (instance%component(i)%active) then 
                          call instance%component(i)%evaluate_sqme (instance%term)
                          instance%sqme_real(ireg) = instance%component(i)%nlo_data%sqme_real
                       end if
                    end if
                    ireg = ireg + 1
                  end if
                end do
                if (passed) then
                   instance%sqme = sum (instance%sqme_real)
                   instance%evaluation_status = STAT_EVALUATED_TRACE
                else
                   instance%evaluation_status = STAT_FAILED_CUTS
                end if 
              case ('Born', 'Virtual')
                call term%evaluate_interaction (instance%component)
                call term%evaluate_trace ()
              end select
            end if
          end associate
       end do
       do i = 1, size (instance%component)
          associate (component => instance%component(i))
            if (component%active) then
              select case (char (component%config%config%get_nlo_type()))
              case ('Born', 'Virtual')
                call component%evaluate_sqme (instance%term)
                instance%sqme = instance%sqme + component%sqme
                instance%evaluation_status = STAT_EVALUATED_TRACE
              end select
            end if
          end associate
       end do
    else
       ! failed kinematics, failed cuts: set sqme to zero
       instance%sqme = 0
    end if
  end subroutine process_instance_evaluate_trace

@ %def process_instance_evaluate_trace
@ Final step of process evaluation: evaluate the matrix elements, and compute
the trace (summed over quantum numbers) for all terms.  Finally, sum up the
terms, iterating over all active process components.

If [[weight]] is provided, we already know the kinematical event
weight (the MCI weight which depends on the kinematics sampling
algorithm, but not on the matrix element), so we do not need to take
it from the MCI record.
<<Processes: process instance: TBP>>=
  procedure :: evaluate_event_data => process_instance_evaluate_event_data
<<Processes: procedures>>=
  subroutine process_instance_evaluate_event_data (instance, weight)
    class(process_instance_t), intent(inout) :: instance
    real(default), intent(in), optional :: weight
    integer :: i
    if (instance%evaluation_status >= STAT_EVALUATED_TRACE) then
       do i = 1, size (instance%term)
          associate (term => instance%term(i))
            if (term%active .and. term%passed) then
               call term%evaluate_event_data ()
            end if
          end associate
       end do
       if (present (weight)) then
          instance%weight = weight
       else
          instance%weight = &
               instance%mci_work(instance%i_mci)%mci%get_event_weight ()
          instance%excess = &
               instance%mci_work(instance%i_mci)%mci%get_event_excess ()
       end if
       instance%evaluation_status = STAT_EVENT_COMPLETE
    else
       ! failed kinematics etc.: set weight to zero
       instance%weight = 0
    end if
  end subroutine process_instance_evaluate_event_data

@ %def process_instance_evaluate_event_data
@ For unweighted event generation, we should reset the reported event
weight to unity (signed) or zero.  The latter case is appropriate for
an event which failed for whatever reason.
<<Processes: process instance: TBP>>=
  procedure :: normalize_weight => process_instance_normalize_weight
<<Processes: procedures>>=
  subroutine process_instance_normalize_weight (instance)
    class(process_instance_t), intent(inout) :: instance
    if (instance%weight /= 0) then
       instance%weight = sign (1._default, instance%weight)
    end if
  end subroutine process_instance_normalize_weight
  
@ %def process_instance_normalize_weight
@ This is a convenience routine that performs the computations of the
steps 1 to 5 in a single step.  The arguments are the input for
[[set_mcpar]].  After this, the evaluation status should be either
[[STAT_FAILED_KINEMATICS]], [[STAT_FAILED_CUTS]] or [[STAT_EVALUATED_TRACE]].

Before calling this, we should call [[choose_mci]].
<<Processes: process instance: TBP>>=
  procedure :: evaluate_sqme => process_instance_evaluate_sqme
<<Processes: procedures>>=
  subroutine process_instance_evaluate_sqme (instance, channel, x)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    real(default), dimension(:), intent(in) :: x
    call instance%reset ()
    call instance%set_mcpar (x)
    call instance%select_channel (channel)
    call instance%compute_seed_kinematics ()
    call instance%compute_hard_kinematics ()
    call instance%compute_eff_kinematics ()
    call instance%evaluate_expressions ()
    call instance%compute_other_channels ()
    call instance%evaluate_trace ()
  end subroutine process_instance_evaluate_sqme
  
@ %def process_instance_evaluate_sqme
@ This is the inverse.  Assuming that the final trace evaluator
contains a valid momentum configuration, recover kinematics
and recalculate the matrix elements and their trace.

To be precise, we first recover kinematics for the given term and
associated component, then recalculate from that all other terms and
active components.  The [[channel]] is not really required to obtain
the matrix element, but it allows us to reconstruct the exact MC
parameter set that corresponds to the given phase space point.

Before calling this, we should call [[choose_mci]].
<<Processes: process instance: TBP>>=
  procedure :: recover => process_instance_recover
<<Processes: procedures>>=
  subroutine process_instance_recover (instance, channel, i_term, update_sqme)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    integer, intent(in) :: i_term
    logical, intent(in) :: update_sqme
    call instance%activate ()
    instance%evaluation_status = STAT_EFF_KINEMATICS
    call instance%recover_hard_kinematics (i_term)
    call instance%recover_seed_kinematics (i_term)
    call instance%select_channel (channel)
    call instance%recover_mcpar (i_term)
    call instance%recover_beam_momenta (i_term)
    call instance%compute_seed_kinematics (i_term)
    call instance%compute_hard_kinematics (i_term)
    call instance%compute_eff_kinematics (i_term)
    call instance%compute_other_channels (i_term)
    call instance%evaluate_expressions ()
    if (update_sqme)  call instance%evaluate_trace ()
  end subroutine process_instance_recover
  
@ %def process_instance_recover
@ The [[evaluate]] method is required by the [[sampler_t]] base type of which
the process instance is an extension.

The requirement is that after the process instance is evaluated, the
integrand, the selected channel, the $x$ array, and the $f$ Jacobian array are
exposed by the [[sampler_t]] object.
<<Processes: process instance: TBP>>=
  procedure :: evaluate => process_instance_evaluate
<<Processes: procedures>>=
  subroutine process_instance_evaluate (sampler, c, x_in, val, x, f)
    class(process_instance_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%evaluate_sqme (c, x_in)
    if (sampler%is_valid ())  call sampler%fetch (val, x, f)
    call sampler%record_call ()
  end subroutine process_instance_evaluate

@ %def process_instance_evaluate
@ The phase-space point is valid if the event has valid kinematics and
has passed the cuts.
<<Processes: process instance: TBP>>=
  procedure :: is_valid => process_instance_is_valid
<<Processes: procedures>>=
  function process_instance_is_valid (sampler) result (valid)
    class(process_instance_t), intent(in) :: sampler
    logical :: valid
    valid = sampler%evaluation_status >= STAT_PASSED_CUTS
  end function process_instance_is_valid
  
@ %def process_instance_is_valid
@ The [[rebuild]] method should rebuild the kinematics section out of
the [[x_in]] parameter set.  The integrand value [[val]] should not be
computed, but is provided as input.
<<Processes: process instance: TBP>>=
  procedure :: rebuild => process_instance_rebuild
<<Processes: procedures>>=
  subroutine process_instance_rebuild (sampler, c, x_in, val, x, f)
    class(process_instance_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call msg_bug ("process_instance_rebuild not implemented yet")
    x = 0
    f = 0
  end subroutine process_instance_rebuild

@ %def process_instance_rebuild
@ This is another method required by the [[sampler_t]] base type:
fetch the data that are relevant for the MCI record.
<<Processes: process instance: TBP>>=
  procedure :: fetch => process_instance_fetch
<<Processes: procedures>>=
  subroutine process_instance_fetch (sampler, val, x, f)
    class(process_instance_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    integer :: i, cc
    integer :: n_channel
    val = 0
    FIND_COMPONENT: do i = 1, size (sampler%component)
       associate (component => sampler%component(i))
         if (component%active) then
            associate (k => component%k_seed)
              n_channel = k%n_channel
              do cc = 1, n_channel
                 call k%get_mcpar (cc, x(:,cc))
              end do
              f = k%f
              val = sampler%sqme * k%phs_factor
            end associate
            exit FIND_COMPONENT
         end if
       end associate
    end do FIND_COMPONENT
  end subroutine process_instance_fetch
  
@ %def process_instance_fetch
@ Initialize and finalize event generation for the specified MCI
entry.
<<Processes: process instance: TBP>>=
  procedure :: init_simulation => process_instance_init_simulation
  procedure :: final_simulation => process_instance_final_simulation
<<Processes: procedures>>=
  subroutine process_instance_init_simulation (instance, i_mci, safety_factor)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    real(default), intent(in), optional :: safety_factor
    call instance%mci_work(i_mci)%init_simulation (safety_factor)
  end subroutine process_instance_init_simulation

  subroutine process_instance_final_simulation (instance, i_mci)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call instance%mci_work(i_mci)%final_simulation ()
  end subroutine process_instance_final_simulation

@ %def process_instance_init_simulation
@ %def process_instance_final_simulation
@ 
\subsection{Accessing the process instance}
Once the seed kinematics is complete, we can retrieve the MC input parameters
for all channels, not just the seed channel.

Note: We choose the first active component.  This makes sense only if the seed
kinematics is identical for all active components.
<<Processes: process instance: TBP>>=
  procedure :: get_mcpar => process_instance_get_mcpar
<<Processes: procedures>>=
  subroutine process_instance_get_mcpar (instance, channel, x)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    real(default), dimension(:), intent(out) :: x
    integer :: i
    if (instance%evaluation_status >= STAT_SEED_KINEMATICS) then
       do i = 1, size (instance%component)
          if (instance%component(i)%active) then
             call instance%component(i)%k_seed%get_mcpar (channel, x)
             return
          end if
       end do
       call msg_bug ("Process instance: get_mcpar: no active channels")
    else
       call msg_bug ("Process instance: get_mcpar: no seed kinematics")
    end if
  end subroutine process_instance_get_mcpar

@ %def process_instance_get_mcpar
@ Return true if the [[sqme]] value is known.  This also implies that the
event is kinematically valid and has passed all cuts.
<<Processes: process instance: TBP>>=
  procedure :: has_evaluated_trace => process_instance_has_evaluated_trace
<<Processes: procedures>>=
  function process_instance_has_evaluated_trace (instance) result (flag)
    class(process_instance_t), intent(in) :: instance
    logical :: flag
    flag = instance%evaluation_status >= STAT_EVALUATED_TRACE
  end function process_instance_has_evaluated_trace
  
@ %def process_instance_has_evaluated_trace
@ Return true if the event is complete.  In particular, the event must
be kinematically valid, passed all cuts, and the event data have been
computed.
<<Processes: process instance: TBP>>=
  procedure :: is_complete_event => process_instance_is_complete_event
<<Processes: procedures>>=
  function process_instance_is_complete_event (instance) result (flag)
    class(process_instance_t), intent(in) :: instance
    logical :: flag
    flag = instance%evaluation_status >= STAT_EVENT_COMPLETE
  end function process_instance_is_complete_event
  
@ %def process_instance_is_complete_event
@ Select a term for the process instance which is to provide the event
record.

Note: this should be done using random numbers and applying probabilities for
the various terms and components that belong to the selected MCI group.  The
current implementation simply selects the first term for the first active
component.
<<Processes: process instance: TBP>>=
  procedure :: select_i_term => process_instance_select_i_term
<<Processes: procedures>>=
  subroutine process_instance_select_i_term (instance, i_term)
    class(process_instance_t), intent(in) :: instance
    integer, intent(out) :: i_term
    integer :: i_mci, i_component
    i_mci = instance%i_mci
    i_component = instance%process%mci_entry(i_mci)%i_component(1)
    i_term = instance%process%component(i_component)%i_term(1)
  end subroutine process_instance_select_i_term
    
@ %def process_instance_select_i_term
@ Return pointer to the master beam interaction.
<<Processes: process instance: TBP>>=
  procedure :: get_beam_int_ptr => process_instance_get_beam_int_ptr
<<Processes: procedures>>=
  function process_instance_get_beam_int_ptr (instance) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    type(interaction_t), pointer :: ptr
    ptr => instance%sf_chain%get_beam_int_ptr ()
  end function process_instance_get_beam_int_ptr
  
@ %def process_instance_get_beam_int_ptr
@ Return pointers to the matrix and flows interactions, given a term index.
<<Processes: process instance: TBP>>=
  procedure :: get_trace_int_ptr => process_instance_get_trace_int_ptr
  procedure :: get_matrix_int_ptr => process_instance_get_matrix_int_ptr
  procedure :: get_flows_int_ptr => process_instance_get_flows_int_ptr
<<Processes: procedures>>=
  function process_instance_get_trace_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    ptr => instance%term(i_term)%connected%get_trace_int_ptr ()
  end function process_instance_get_trace_int_ptr
  
  function process_instance_get_matrix_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    select case (char (instance%term(i_term)%nlo_data%nlo_type))
    case ('Born', 'Virtual')
      ptr => instance%term(i_term)%connected%get_matrix_int_ptr ()
    case ('Real')
      ptr => instance%term(i_term)%connected_real%get_matrix_int_ptr ()
    end select
  end function process_instance_get_matrix_int_ptr
  
  function process_instance_get_flows_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    select case (char (instance%term(i_term)%nlo_data%nlo_type))
    case ('Born', 'Virtual')
      ptr => instance%term(i_term)%connected%get_flows_int_ptr ()
    case ('Real')
      ptr => instance%term(i_term)%connected_real%get_flows_int_ptr ()
    end select
  end function process_instance_get_flows_int_ptr
  
@ %def process_instance_get_trace_int_ptr
@ %def process_instance_get_matrix_int_ptr
@ %def process_instance_get_flows_int_ptr
@ Return pointers to the parton states of a selected term.
<<Processes: process instance: TBP>>=
  procedure :: get_isolated_state_ptr => &
       process_instance_get_isolated_state_ptr
  procedure :: get_connected_state_ptr => &
       process_instance_get_connected_state_ptr
<<Processes: procedures>>=
  function process_instance_get_isolated_state_ptr (instance, i_term) &
       result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(isolated_state_t), pointer :: ptr
    ptr => instance%term(i_term)%isolated
  end function process_instance_get_isolated_state_ptr
  
  function process_instance_get_connected_state_ptr (instance, i_term) &
       result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(connected_state_t), pointer :: ptr
    ptr => instance%term(i_term)%connected
  end function process_instance_get_connected_state_ptr
  
@ %def process_instance_get_isolated_state_ptr
@ %def process_instance_get_connected_state_ptr
@ Return the indices of the beam particles and incoming partons within the
currently active state matrix, respectively.
<<Processes: process instance: TBP>>=
  procedure :: get_beam_index => process_instance_get_beam_index
  procedure :: get_in_index => process_instance_get_in_index
<<Processes: procedures>>=
  subroutine process_instance_get_beam_index (instance, i_term, i_beam)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    integer, dimension(:), intent(out) :: i_beam
    call instance%term(i_term)%connected%get_beam_index (i_beam)
  end subroutine process_instance_get_beam_index
  
  subroutine process_instance_get_in_index (instance, i_term, i_in)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    integer, dimension(:), intent(out) :: i_in
    call instance%term(i_term)%connected%get_in_index (i_in)
  end subroutine process_instance_get_in_index
  
@ %def process_instance_get_beam_index
@ %def process_instance_get_in_index
@ Return squared matrix element and event weight, and event weight
excess where applicable.
<<Processes: process instance: TBP>>=
  procedure :: get_sqme => process_instance_get_sqme
  procedure :: get_weight => process_instance_get_weight
  procedure :: get_excess => process_instance_get_excess
<<Processes: procedures>>=
  function process_instance_get_sqme (instance) result (sqme)
    class(process_instance_t), intent(in) :: instance
    real(default) :: sqme
    if (instance%evaluation_status >= STAT_EVALUATED_TRACE) then
       sqme = instance%sqme
    else
       sqme = 0
    end if
  end function process_instance_get_sqme
  
  function process_instance_get_weight (instance) result (weight)
    class(process_instance_t), intent(in) :: instance
    real(default) :: weight
    if (instance%evaluation_status >= STAT_EVENT_COMPLETE) then
       weight = instance%weight
    else
       weight = 0
    end if
  end function process_instance_get_weight
  
  function process_instance_get_excess (instance) result (excess)
    class(process_instance_t), intent(in) :: instance
    real(default) :: excess
    if (instance%evaluation_status >= STAT_EVENT_COMPLETE) then
       excess = instance%excess
    else
       excess = 0
    end if
  end function process_instance_get_excess
  
@ %def process_instance_get_sqme
@ %def process_instance_get_weight
@ %def process_instance_get_excess
@ Return the currently selected MCI channel.
<<Processes: process instance: TBP>>=
  procedure :: get_channel => process_instance_get_channel
<<Processes: procedures>>=
  function process_instance_get_channel (instance) result (channel)
    class(process_instance_t), intent(in) :: instance
    integer :: channel
    channel = instance%selected_channel
  end function process_instance_get_channel

@ %def process_instance_get_channel
@ Return factorization scale and strong coupling.  We have to select a
term instance.
<<Processes: process instance: TBP>>=
  procedure :: get_fac_scale => process_instance_get_fac_scale
  procedure :: get_alpha_s => process_instance_get_alpha_s
<<Processes: procedures>>=
  function process_instance_get_fac_scale (instance, i_term) result (fac_scale)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    real(default) :: fac_scale
    fac_scale = instance%term(i_term)%get_fac_scale ()
  end function process_instance_get_fac_scale
  
  function process_instance_get_alpha_s (instance, i_term) result (alpha_s)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    real(default) :: alpha_s
    alpha_s = instance%term(i_term)%get_alpha_s (instance%component)
  end function process_instance_get_alpha_s
  
@ %def process_instance_get_fac_scale
@ %def process_instance_get_alpha_s
@ Counter.
<<Processes: process instance: TBP>>=
  procedure :: reset_counter => process_instance_reset_counter
  procedure :: record_call => process_instance_record_call
  procedure :: get_counter => process_instance_get_counter
<<Processes: procedures>>=
  subroutine process_instance_reset_counter (process_instance)
    class(process_instance_t), intent(inout) :: process_instance
    call process_instance%mci_work(process_instance%i_mci)%reset_counter ()
  end subroutine process_instance_reset_counter
  
  subroutine process_instance_record_call (process_instance)
    class(process_instance_t), intent(inout) :: process_instance
    call process_instance%mci_work(process_instance%i_mci)%record_call &
         (process_instance%evaluation_status)
  end subroutine process_instance_record_call
    
  function process_instance_get_counter (process_instance) result (counter)
    class(process_instance_t), intent(in) :: process_instance
    type(process_counter_t) :: counter
    counter = process_instance%mci_work(process_instance%i_mci)%get_counter ()
  end function process_instance_get_counter
  
@ %def process_instance_reset_counter
@ %def process_instance_record_call
@ %def process_instance_get_counter
@
\subsection{Particle sets}
Here we provide two procedures that convert the process instance
from/to a particle set.  The conversion applies to the trace evaluator
which has no quantum-number information, thus it involves only the
momenta and the parent-child relations.  We keep virtual particles.

Nevertheless, it is possible to reconstruct the complete structure
from a particle set.  The reconstruction implies a re-evaluation of
the structure function and matrix-element codes.

The [[i_term]] index is needed for both input and output, to select
among different active trace evaluators.

In both cases, the [[instance]] object must be properly initialized.
<<Processes: process instance: TBP>>=
  procedure :: get_trace => process_instance_get_trace
  procedure :: set_trace => process_instance_set_trace
<<Processes: procedures>>=
  subroutine process_instance_get_trace (instance, pset, i_term)
    class(process_instance_t), intent(in), target :: instance
    type(particle_set_t), intent(out) :: pset
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: int
    logical :: ok
    int => instance%get_trace_int_ptr (i_term)
    call particle_set_init (pset, ok, int, int, FM_IGNORE_HELICITY, &
         [0._default, 0._default], .false., .true.)
  end subroutine process_instance_get_trace
    
  subroutine process_instance_set_trace (instance, pset, i_term, recover_beams)
    class(process_instance_t), intent(inout), target :: instance
    type(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i_term
    logical, intent(in), optional :: recover_beams
    type(interaction_t), pointer :: int
    integer :: n_in
    int => instance%get_trace_int_ptr (i_term)
    n_in = instance%process%get_n_in ()
    call particle_set_fill_interaction (pset, int, n_in, recover_beams)
  end subroutine process_instance_set_trace

@ %def process_instance_get_trace
@ %def process_instance_set_trace
@
<<Processes: process instance: TBP>>=
  procedure :: display_real_kinematics => process_instance_display_real_kinematics
<<Processes: procedures>>=
  subroutine process_instance_display_real_kinematics (instance, i)
     class(process_instance_t), intent(in) :: instance
     integer, intent(in) :: i
     if (instance%term(i)%nlo_data%counter_exists) &
         call instance%term(i)%nlo_data%counter%display ()
  end subroutine process_instance_display_real_kinematics

@ %def process_instance_display_real_kinematics
@
The [[pacify]] subroutine has the purpose of setting numbers to zero
which are (by comparing with a [[tolerance]] parameter) considered
equivalent with zero.  We do this in some unit tests.  Here, we a
apply this to the phase space subobject of the process instance.
<<Processes: public>>=
  public :: pacify
<<Processes: interfaces>>=
  interface pacify
     module procedure pacify_process_instance
  end interface pacify
  
<<Processes: procedures>>=
  subroutine pacify_process_instance (instance)
    type(process_instance_t), intent(inout) :: instance
    integer :: i
    do i = 1, size (instance%component)
       call pacify (instance%component(i)%k_seed%phs)
    end do
  end subroutine pacify_process_instance
    
@ %def pacify
@
\subsection{Unit tests}
<<Processes: public>>=
  public :: processes_test
<<Processes: tests>>=
  subroutine processes_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Processes: execute tests>>
  end subroutine processes_test
  
@ %def processes_test
@
\subsubsection{Test process type}
For the following tests, we define a simple implementation of the abstract
[[prc_core_t]], designed such as to complement the [[prc_test_t]]
process definition type.

Note that it is not given that the actual process is defined as
[[prc_test_t]] type.  We enforce this by calling
[[prc_test_create_library]].  The driver component in the process core
will then become of type [[prc_test_t]].
<<Processes: public>>=
  public :: test_t
<<Processes: test types>>=
  type, extends (prc_core_t) :: test_t
   contains
     procedure :: write => test_write
     procedure :: needs_mcset => test_needs_mcset
     procedure :: get_n_terms => test_get_n_terms
     procedure :: is_allowed => test_is_allowed
     procedure :: compute_hard_kinematics => test_compute_hard_kinematics
     procedure :: compute_eff_kinematics => test_compute_eff_kinematics
     procedure :: recover_kinematics => test_recover_kinematics
     procedure :: compute_amplitude => test_compute_amplitude
  end type test_t

@ %def test_t
<<Processes: tests>>=
  subroutine test_write (object, unit)
    class(test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "test type implementing prc_test"
  end subroutine test_write
  
@ %def test_write
@ This process type always needs a MC parameter set and a
single term.  This only state is always allowed.
<<Processes: tests>>=
  function test_needs_mcset (object) result (flag)
    class(test_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function test_needs_mcset
  
  function test_get_n_terms (object) result (n)
    class(test_t), intent(in) :: object
    integer :: n
    n = 1
  end function test_get_n_terms
  
  function test_is_allowed (object, i_term, f, h, c) result (flag)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    flag = .true.
  end function test_is_allowed
  
@ %def test_needs_mcset
@ %def test_get_n_terms
@ %def test_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.
<<Processes: tests>>=
  subroutine test_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, tmp)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(workspace_t), intent(inout), allocatable :: tmp
    call interaction_set_momenta (int_hard, p_seed)
  end subroutine test_compute_hard_kinematics
  
@ %def test_compute_hard_kinematics
@ This procedure is not called for [[test_t]], just a placeholder.
<<Processes: tests>>=
  subroutine test_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, tmp)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
  end subroutine test_compute_eff_kinematics
  
@ %def test_compute_eff_kinematics
@ Transfer the incoming momenta of [[p_seed]] directly to the
effective interaction, and vice versa for the outgoing momenta.

[[int_hard]] is left untouched since [[int_eff]] is an alias (via
pointer) to it.
<<Processes: tests>>=
  subroutine test_recover_kinematics &
       (object, p_seed, int_hard, int_eff, tmp)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
    integer :: n_in
    n_in = interaction_get_n_in (int_eff)
    call interaction_set_momenta (int_eff, p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = interaction_get_momenta (int_eff, outgoing = .true.)
  end subroutine test_recover_kinematics
    
@ %def test_recover_kinematics
@ Compute the amplitude.  The driver ignores all quantum numbers and,
in fact, returns a constant.  Nevertheless, we properly transfer the
momentum vectors.
<<Processes: tests>>=
  function test_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, tmp) result (amp)
    class(test_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    class(workspace_t), intent(inout), allocatable, optional :: tmp
    complex(default) :: amp
    real(default), dimension(:,:), allocatable :: parray
    integer :: i, n_tot
    select type (driver => object%driver)
    type is (prc_test_t)
       if (driver%scattering) then
          n_tot = 4
       else
          n_tot = 3
       end if
       allocate (parray (0:3,n_tot))
       forall (i = 1:n_tot)  parray(:,i) = vector4_get_components (p(i))
       amp = driver%get_amplitude (parray)
    end select
  end function test_compute_amplitude
    
@ %def test_compute_amplitude
@
\subsubsection{Write an empty process object}
The most trivial test is to write an uninitialized process object.
<<Processes: execute tests>>=
  call test (processes_1, "processes_1", &
       "write an empty process object", &
       u, results)
<<Processes: tests>>=
  subroutine processes_1 (u)
    integer, intent(in) :: u
    type(process_t) :: process

    write (u, "(A)")  "* Test output: processes_1"
    write (u, "(A)")  "*   Purpose: display an empty process object"
    write (u, "(A)")

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_1"
    
  end subroutine processes_1
  
@ %def processes_1
@
\subsubsection{Initialize a process object}
Initialize a process and display it.
<<Processes: execute tests>>=
  call test (processes_2, "processes_2", &
       "initialize a simple process object", &
       u, results)
<<Processes: tests>>=
  subroutine processes_2 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template

    write (u, "(A)")  "* Test output: processes_2"
    write (u, "(A)")  "*   Purpose: initialize a simple process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes2"
    procname = libname
    run_id = "run2"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    call process%setup_mci ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_2"
    
  end subroutine processes_2
  
@ %def processes_2
@
\subsubsection{Compute a trivial matrix element}
Initialize a process, retrieve some information and compute a matrix
element.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Processes: execute tests>>=
  call test (processes_3, "processes_3", &
       "retrieve a trivial matrix element", &
       u, results)
<<Processes: tests>>=
  subroutine processes_3 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_constants_t) :: data
    type(vector4_t), dimension(:), allocatable :: p

    write (u, "(A)")  "* Test output: processes_3"
    write (u, "(A)")  "*   Purpose: create a process &
         &and compute a matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes3"
    procname = libname
    run_id = "run3"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t)
       call mci_template%set_dimensions (2, 2)
       call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Return the number of process components"
    write (u, "(A)")

    write (u, "(A,I0)")  "n_components = ", process%get_n_components ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Return the number of flavor states"
    write (u, "(A)")

    data = process%get_constants (1)
    
    write (u, "(A,I0)")  "n_flv(1) = ", data%n_flv
    
    write (u, "(A)")
    write (u, "(A)")  "* Return the first flavor state"
    write (u, "(A)")

    write (u, "(A,4(1x,I0))")  "flv_state(1) =", data%flv_state (:,1)

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics &
         &[arbitrary, the matrix element is constant]"
    
    allocate (p (4))

    write (u, "(A)")
    write (u, "(A)")  "* Retrieve the matrix element"
    write (u, "(A)")

    write (u, "(A,F5.3,' + ',F5.3,' I')")  "me (1, p, 1, 1, 1) = ", &
         process%compute_amplitude (1, 1, p, 1, 1, 1)
    

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_3"
    
  end subroutine processes_3
  
@ %def processes_3
@
\subsubsection{Generate a process instance}
Initialize a process and process instance, choose a sampling point and
fill the process instance.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Processes: execute tests>>=
  call test (processes_4, "processes_4", &
       "create and fill a process instance (partonic event)", &
       u, results)
<<Processes: tests>>=
  subroutine processes_4 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_4"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes4"
    procname = libname
    run_id = "run4"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)

    call process_instance%activate ()
    process_instance%evaluation_status = STAT_EFF_KINEMATICS
    call process_instance%recover_hard_kinematics (i_term = 1)
    call process_instance%recover_seed_kinematics (i_term = 1)
    call process_instance%select_channel (1)
    call process_instance%recover_mcpar (i_term = 1)

    call process_instance%compute_seed_kinematics (skip_term = 1)
    call process_instance%compute_hard_kinematics (skip_term = 1)
    call process_instance%compute_eff_kinematics (skip_term = 1)

    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels (skip_term = 1)
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call particle_set_final (pset)
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_4"
    
  end subroutine processes_4
  
@ %def processes_4
@
\subsubsection{Structure function configuration}
Configure structure functions (multi-channel) in a process object.
<<Processes: execute tests>>=
  call test (processes_7, "processes_7", &
       "process configuration with structure functions", &
       u, results)
<<Processes: tests>>=
  subroutine processes_7 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(model_t), pointer :: model
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t), dimension(2) :: sf_channel

    write (u, "(A)")  "* Test output: processes_7"
    write (u, "(A)")  "*   Purpose: initialize a process with &
         &structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes7"
    procname = libname
    run_id = "run7"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    
    model => model_list%get_model_ptr (var_str ("Test"))
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)

    call process%beam_config%allocate_sf_channels (3)

    call sf_channel(1)%init (2)
    call sf_channel(1)%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel(1))
    
    call sf_channel(2)%init (2)
    call sf_channel(2)%set_s_mapping ([1,2])
    call process%set_sf_channel (3, sf_channel(2))
    
    call process%setup_mci ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_7"
    
  end subroutine processes_7
  
@ %def processes_7
@
\subsubsection{Evaluating a process with structure function}
Configure structure functions (single-channel) in a process object,
create an instance, compute kinematics and evaluate.

Note the order of operations when setting up structure functions and
phase space.  The beams are first, they determine the [[sqrts]] value.
We can also set up the chain of structure functions.  We then
configure the phase space.  From this, we can obtain information about
special configurations (resonances, etc.), which we need for
allocating the possible structure-function channels (parameterizations
and mappings).  Finally, we match phase-space channels onto
structure-function channels.

In the current example, this matching is trivial; we only have one
structure-function channel.
<<Processes: execute tests>>=
  call test (processes_8, "processes_8", &
       "process evaluation with structure functions", &
       u, results)
<<Processes: tests>>=
  subroutine processes_8 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(model_t), pointer :: model
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t) :: sf_channel
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_8"
    write (u, "(A)")  "*   Purpose: evaluate a process with &
         &structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes8"
    procname = libname
    run_id = "run8"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)

    model => model_list%get_model_ptr (var_str ("Test"))
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)
    
    call process%configure_phs ()
    
    call process%beam_config%allocate_sf_channels (1)

    call sf_channel%init (2)
    call sf_channel%activate_mapping ([1,2])
    call process%set_sf_channel (1, sf_channel)
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_mci ()
    call process%setup_terms ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Set up kinematics and evaluate"
    write (u, "(A)")

    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, &
         [0.8_default, 0.8_default, 0.1_default, 0.2_default])
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)
    call process_instance%recover &
         (channel = 1, i_term = 1, update_sqme = .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (pset)

    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_8"
    
  end subroutine processes_8
  
@ %def processes_8
@
\subsubsection{Multi-channel phase space and structure function}
This is an extension of the previous example.  This time, we have two
distinct structure-function channels which are matched to the two
distinct phase-space channels.
<<Processes: execute tests>>=
  call test (processes_9, "processes_9", &
       "multichannel kinematics and structure functions", &
       u, results)
<<Processes: tests>>=
  subroutine processes_9 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(model_t), pointer :: model
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t) :: sf_channel
    real(default), dimension(4) :: x_saved
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_9"
    write (u, "(A)")  "*   Purpose: evaluate a process with &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes9"
    procname = libname
    run_id = "run9"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)

    model => model_list%get_model_ptr (var_str ("Test"))
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)
    
    call process%configure_phs ()
    
    call process%beam_config%allocate_sf_channels (2)

    call sf_channel%init (2)
    call process%set_sf_channel (1, sf_channel)
    
    call sf_channel%init (2)
    call sf_channel%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel)
    
    call process%component(1)%phs_config%set_sf_channel ([1, 2])

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_mci ()
    call process%setup_terms ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Set up kinematics in channel 1 and evaluate"
    write (u, "(A)")

    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, &
         [0.8_default, 0.8_default, 0.1_default, 0.2_default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extract MC input parameters"
    write (u, "(A)")
    
    write (u, "(A)")  "Channel 1:"
    call process_instance%get_mcpar (1, x_saved)
    write (u, "(2x,9(1x,F7.5))")  x_saved

    write (u, "(A)")  "Channel 2:"
    call process_instance%get_mcpar (2, x_saved)
    write (u, "(2x,9(1x,F7.5))")  x_saved

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics in channel 2 and evaluate"
    write (u, "(A)")

    call process_instance%evaluate_sqme (2, x_saved)
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance for channel 2"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)
    call process_instance%recover &
         (channel = 2, i_term = 1, update_sqme = .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (pset)

    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_9"
    
  end subroutine processes_9
  
@ %def processes_9
@
\subsubsection{Event generation}
Activate the MC integrator for the process object and use it to
generate a single event.  Note that the test integrator does not
require integration in preparation for generating events.
<<Processes: execute tests>>=
  call test (processes_10, "processes_10", &
       "event generation", &
       u, results)
<<Processes: tests>>=
  subroutine processes_10 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_10"
    write (u, "(A)")  "*   Purpose: generate events for a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes10"
    procname = libname
    run_id = "run10"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t);  call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Generate weighted event"
    write (u, "(A)")

    select type (mci => process%mci_entry(1)%mci)
    type is (mci_test_t)
       ! This ensures that the next 'random' numbers are 0.3, 0.5, 0.7
       call mci%rng%init (3)
       ! Include the constant PHS factor in the stored maximum of the integrand
       call mci%set_max_factor (conv * twopi4 &
            / (2 * sqrt (lambda (sqrts **2, 125._default**2, 125._default**2))))
    end select

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate unweighted event"
    write (u, "(A)")

    call process%generate_unweighted_event (process_instance, 1)
    select type (mci => process%mci_entry(1)%mci)
    type is (mci_test_t)
       write (u, "(A,I0)")  " Success in try ", mci%tries
       write (u, "(A)")
    end select
    
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_10"
    
  end subroutine processes_10
  
@ %def processes_10
@
\subsubsection{Integration}
Activate the MC integrator for the process object and use it to
integrate over phase space.
<<Processes: execute tests>>=
  call test (processes_11, "processes_11", &
       "integration", &
       u, results)
<<Processes: tests>>=
  subroutine processes_11 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_11"
    write (u, "(A)")  "*   Purpose: integrate a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes11"
    procname = libname
    run_id = "run11"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t)
       call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Integrate with default test parameters"
    write (u, "(A)")

    call process%integrate (process_instance, 1, n_it=1, n_calls=10000)
    call process%final_integration (1)
    
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A,ES13.7)")  " Integral divided by phs factor = ", &
         process%get_integral (1) &
         / process_instance%component(1)%k_seed%phs_factor

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_11"
    
  end subroutine processes_11
  
@ %def processes_11
@
\subsubsection{Complete events}
For the purpose of simplifying further tests, we implement a
convenience routine that initializes a process and prepares a single
event.  This is a wrapup of the test [[processes_10]].
<<Processes: public>>=
  public :: prepare_test_process
<<Processes: procedures>>=
  subroutine prepare_test_process (process, process_instance, model_list)
    type(process_t), intent(out), target :: process
    type(process_instance_t), intent(out), target :: process_instance
    type(model_list_t), intent(inout) :: model_list
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    libname = "processes_test"
    procname = libname
    run_id = "run_test"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call reset_interaction_counter ()
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t);  call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()
    call process_instance%init (process)
    select type (mci => process%mci_entry(1)%mci)
    type is (mci_test_t)
       ! This ensures that the next 'random' numbers are 0.3, 0.5, 0.7
       call mci%rng%init (3)
       ! Include the constant PHS factor in the stored maximum of the integrand
       call mci%set_max_factor (conv * twopi4 &
            / (2 * sqrt (lambda (sqrts **2, 125._default**2, 125._default**2))))
    end select
  end subroutine prepare_test_process

@ %def prepare_test_process
@ Here we do the cleanup of the process and process instance emitted
by the previous routine.
<<Processes: public>>=
  public :: cleanup_test_process
<<Processes: procedures>>=
  subroutine cleanup_test_process (process, process_instance)
    type(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: process_instance
    call process_instance%final ()
    call process%final ()
  end subroutine cleanup_test_process
    
@ %def cleanup_test_process
@ 
This is the actual test.  Prepare the test process and event, fill
all evaluators, and display the results.  Use a particle set as
temporary storage, read kinematics and recalculate the event.
<<Processes: execute tests>>=
  call test (processes_12, "processes_12", &
       "event post-processing", &
       u, results)
<<Processes: tests>>=
  subroutine processes_12 (u)
    integer, intent(in) :: u
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset
    type(model_list_t) :: model_list

    write (u, "(A)")  "* Test output: processes_12"
    write (u, "(A)")  "*   Purpose: generate a complete partonic event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Build and initialize process and process instance &
         &and generate event"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    call process%prepare_simulation (1)
    call process_instance%init_simulation (1)
    call process%generate_weighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)

    call process_instance%final_simulation (1)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover kinematics and recalculate"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)
    call process_instance%recover &
         (channel = 1, i_term = 1, update_sqme = .true.)

    call process%recover_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    call process_instance%write (u)
    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_12"
    
  end subroutine processes_12
  
@ %def processes_12
@
\subsubsection{Colored interaction}
This test specifically checks the transformation of process data
(flavor, helicity, and color) into an interaction in a process term.

We use the [[test_t]] process core (which has no nontrivial
particles), but call only the [[is_allowed]] method, which always
returns true.
<<Processes: execute tests>>=
  call test (processes_13, "processes_13", &
       "colored interaction", &
       u, results)
<<Processes: tests>>=
  subroutine processes_13 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_term_t) :: term
    class(prc_core_t), allocatable :: core
    
    write (u, "(A)")  "* Test output: processes_13"
    write (u, "(A)")  "*   Purpose: initialized a colored interaction"
    write (u, "(A)")

    write (u, "(A)")  "* Set up a process constants block"
    write (u, "(A)")

    call os_data_init (os_data)
    call syntax_model_file_init ()
    call model_list%read_model (var_str ("QCD"), var_str ("QCD.mdl"), &
         os_data, model)
    allocate (test_t :: core)

    associate (data => term%data)
      data%n_in = 2
      data%n_out = 3
      data%n_flv = 2
      data%n_hel = 2
      data%n_col = 2
      data%n_cin = 2

      allocate (data%flv_state (5, 2))
      data%flv_state (:,1) = [ 1, 21, 1, 21, 21]
      data%flv_state (:,2) = [ 2, 21, 2, 21, 21]

      allocate (data%hel_state (5, 2))
      data%hel_state (:,1) = [1, 1, 1, 1, 0]
      data%hel_state (:,2) = [1,-1, 1,-1, 0]

      allocate (data%col_state (2, 5, 2))
      data%col_state (:,:,1) = &
           reshape ([[1, 0], [2,-1], [3, 0], [2,-3], [0,0]], [2,5])
      data%col_state (:,:,2) = &
           reshape ([[1, 0], [2,-3], [3, 0], [2,-1], [0,0]], [2,5])

      allocate (data%ghost_flag (5, 2))
      data%ghost_flag(1:4,:) = .false.
      data%ghost_flag(5,:) = .true.
     
    end associate
    
    write (u, "(A)")  "* Set up the interaction"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    call term%setup_interaction (core, model)
    call interaction_write (term%int, u)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_13"
  end subroutine processes_13
    
@ %def processes_13
@
\subsubsection{MD5 sums}
Configure a process with structure functions (multi-channel) and
compute MD5 sums
<<Processes: execute tests>>=
  call test (processes_14, "processes_14", &
       "process configuration and MD5 sum", &
       u, results)
<<Processes: tests>>=
  subroutine processes_14 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(model_t), pointer :: model
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t), dimension(3) :: sf_channel

    write (u, "(A)")  "* Test output: processes_14"
    write (u, "(A)")  "*   Purpose: initialize a process with &
         &structure functions"
    write (u, "(A)")  "*            and compute MD5 sum"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes7"
    procname = libname
    run_id = "run7"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call lib%compute_md5sum ()
    
    call syntax_model_file_init ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    
    model => model_list%get_model_ptr (var_str ("Test"))
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select

    call process%beam_config%allocate_sf_channels (3)

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)

    call sf_channel(1)%init (2)
    call process%set_sf_channel (1, sf_channel(1))

    call sf_channel(2)%init (2)
    call sf_channel(2)%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel(2))
    
    call sf_channel(3)%init (2)
    call sf_channel(3)%set_s_mapping ([1,2])
    call process%set_sf_channel (3, sf_channel(3))
    
    call process%setup_mci ()

    call process%compute_md5sum ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_14"
    
  end subroutine processes_14
  
@ %def processes_14
@
\subsubsection{Decay Process Evaluation}
Initialize an evaluate a decay process.
<<Processes: execute tests>>=
  call test (processes_15, "processes_15", &
       "decay process", &
       u, results)
<<Processes: tests>>=
  subroutine processes_15 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(var_list_t), pointer :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_15"
    write (u, "(A)")  "*   Purpose: initialize a decay process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes15"
    procname = libname
    run_id = "run15"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call syntax_model_file_init ()

    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()
    call var_list_set_real (var_list, &
         var_str ("ff"), 0.4_default, is_known = .true.)
    call model%update_parameters ()

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    call process%setup_beams_decay ()
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)
    call process_instance%recover (1, 1, .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (pset)
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_15"
    
  end subroutine processes_15
  
@ %def processes_15
@
\subsubsection{Integration: decay}
Activate the MC integrator for the decay object and use it to
integrate over phase space.
<<Processes: execute tests>>=
  call test (processes_16, "processes_16", &
       "decay integration", &
       u, results)
<<Processes: tests>>=
  subroutine processes_16 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(var_list_t), pointer :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_16"
    write (u, "(A)")  "*   Purpose: integrate a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes16"
    procname = libname
    run_id = "run16"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call syntax_model_file_init ()
    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()
    call var_list_set_real (var_list, &
         var_str ("ff"), 0.4_default, is_known = .true.)
    call model%update_parameters ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    call process%setup_beams_decay ()
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Integrate with default test parameters"
    write (u, "(A)")

    call process%integrate (process_instance, 1, n_it=1, n_calls=10000)
    call process%final_integration (1)
    
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A,ES13.7)")  " Integral divided by phs factor = ", &
         process%get_integral (1) &
         / process_instance%component(1)%k_seed%phs_factor

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_16"
    
  end subroutine processes_16
  
@ %def processes_16
@
\subsubsection{Decay Process Evaluation}
Initialize an evaluate a decay process for a moving particle.
<<Processes: execute tests>>=
  call test (processes_17, "processes_17", &
       "decay of moving particle", &
       u, results)
<<Processes: tests>>=
  subroutine processes_17 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(var_list_t), pointer :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset
    type(flavor_t) :: flv_beam
    real(default) :: m, p, E

    write (u, "(A)")  "* Test output: processes_17"
    write (u, "(A)")  "*   Purpose: initialize a decay process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes17"
    procname = libname
    run_id = "run17"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call syntax_model_file_init ()

    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()
    call var_list_set_real (var_list, &
         var_str ("ff"), 0.4_default, is_known = .true.)
    call model%update_parameters ()

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    call process%setup_beams_decay (rest_frame = .false.)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set parent momentum and random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])

    call flavor_init (flv_beam, 25, model)
    m = flavor_get_mass (flv_beam)
    p = 3 * m / 4
    E = sqrt (m**2 + p**2)
    call process_instance%set_beam_momenta ([vector4_moving (E, p, 3)])
     
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1)
    call process_instance%recover (1, 1, .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (pset)
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_17"
    
  end subroutine processes_17
  
@ %def processes_17
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process Stacks}

For storing and handling multiple processes, we define process stacks.
These are ordinary stacks where new process entries are pushed onto
the top.  We allow for multiple entries with identical process ID, but
distinct run ID.

The implementation is essentially identical to the [[prclib_stacks]] module
above.  Unfortunately, Fortran supports no generic programming, so we do not
make use of this fact.

When searching for a specific process ID, we will get (a pointer to)
the topmost process entry with that ID on the stack, which was entered
last.  Usually, this is the best version of the process (in terms of
integral, etc.)  Thus the stack terminology makes sense.
<<[[process_stacks.f90]]>>=
<<File header>>

module process_stacks
  
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use variables
  use models
  use rng_base

  use process_libraries
  use prc_test
  use processes

<<Standard module head>>

<<Process stacks: public>>

<<Process stacks: types>>

contains
  
<<Process stacks: procedures>>

<<Process stacks: tests>>

end module process_stacks
@ %def process_stacks
@
\subsection{The process entry type}
A process entry is a process object, augmented by a pointer to the
next entry.  We do not need specific methods, all relevant methods are
inherited.

On higher level, processes should be prepared as process entry objects.
<<Process stacks: public>>=
  public :: process_entry_t
<<Process stacks: types>>=
  type, extends (process_t) :: process_entry_t
     type(process_entry_t), pointer :: next => null ()
  end type process_entry_t

@ %def process_entry_t
@
\subsection{The process stack type}
For easy conversion and lookup it is useful to store the filling
number in the object.  The content is stored as a linked list.

The [[var_list]] component stores process-specific results, so they
can be retrieved as (pseudo) variables.

The process stack can be linked to another one.  This allows us to
work with stacks of local scope.
<<Process stacks: public>>=
  public :: process_stack_t
<<Process stacks: types>>=
  type :: process_stack_t
     integer :: n = 0
     type(process_entry_t), pointer :: first => null ()
     type(var_list_t), pointer :: var_list => null ()
     type(process_stack_t), pointer :: next => null ()
   contains
   <<Process stacks: process stack: TBP>>
  end type process_stack_t
  
@ %def process_stack_t
@ Finalize partly: deallocate the process stack and variable list
entries, but keep the variable list as an empty object.  This way, the
variable list links are kept.
<<Process stacks: process stack: TBP>>=
  procedure :: clear => process_stack_clear
<<Process stacks: procedures>>=
  subroutine process_stack_clear (stack)
    class(process_stack_t), intent(inout) :: stack
    type(process_entry_t), pointer :: process
    if (associated (stack%var_list)) then
       call var_list_final (stack%var_list)
    end if
    do while (associated (stack%first))
       process => stack%first
       stack%first => process%next
       call process%final ()
       deallocate (process)
    end do
    stack%n = 0
  end subroutine process_stack_clear
  
@ %def process_stack_clear
@ Finalizer.  Clear and deallocate the variable list.
<<Process stacks: process stack: TBP>>=
  procedure :: final => process_stack_final
<<Process stacks: procedures>>=
  subroutine process_stack_final (object)
    class(process_stack_t), intent(inout) :: object
    type(process_entry_t), pointer :: process
    call object%clear ()
    if (associated (object%var_list)) then
       deallocate (object%var_list)
    end if
  end subroutine process_stack_final
  
@ %def process_stack_final
@ Output.  The processes on the stack will be ordered LIFO, i.e.,
backwards.
<<Process stacks: process stack: TBP>>=
  procedure :: write => process_stack_write
<<Process stacks: procedures>>=
  recursive subroutine process_stack_write (object, unit, pacify)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    type(process_entry_t), pointer :: process
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    select case (object%n)
    case (0)
       write (u, "(1x,A)")  "Process stack: [empty]"
       call write_separator (u, 2)
    case default
       write (u, "(1x,A)")  "Process stack:"
       process => object%first
       do while (associated (process))
          call process%write (.false., u, pacify = pacify)
          process => process%next
       end do
    end select
    if (associated (object%next)) then
       write (u, "(1x,A)")  "[Processes from context environment:]"
       call object%next%write (u, pacify)
    end if
  end subroutine process_stack_write

@ %def process_stack_write
@ The variable list is printed by a separate routine, since
it should be linked to the global variable list, anyway.
<<Process stacks: process stack: TBP>>=
  procedure :: write_var_list => process_stack_write_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_write_var_list (object, unit)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    if (associated (object%var_list)) then
       call var_list_write (object%var_list, unit)
    end if
  end subroutine process_stack_write_var_list

@ %def process_stack_write_var_list
@ Short output.
<<Process stacks: process stack: TBP>>=
  procedure :: show => process_stack_show
<<Process stacks: procedures>>=
  recursive subroutine process_stack_show (object, unit)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(process_entry_t), pointer :: process
    integer :: u
    u = given_output_unit (unit)
    select case (object%n)
    case (0)
    case default
       process => object%first
       do while (associated (process))
          call process%show (u, verbose=.false.)
          process => process%next
       end do
    end select
    if (associated (object%next))  call object%next%show ()
  end subroutine process_stack_show

@ %def process_stack_show
@
\subsection{Link}
Link the current process stack to a global one.
<<Process stacks: process stack: TBP>>=
  procedure :: link => process_stack_link
<<Process stacks: procedures>>=
  subroutine process_stack_link (local_stack, global_stack)
    class(process_stack_t), intent(inout) :: local_stack
    type(process_stack_t), intent(in), target :: global_stack
    local_stack%next => global_stack
  end subroutine process_stack_link

@ %def process_stack_link
@ Initialize the process variable list and link the main variable list
to it.
<<Process stacks: process stack: TBP>>=
  procedure :: init_var_list => process_stack_init_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_init_var_list (stack, var_list)
    class(process_stack_t), intent(inout) :: stack
    type(var_list_t), intent(inout), optional :: var_list
    allocate (stack%var_list)
    if (present (var_list))  call var_list_link (var_list, stack%var_list)
  end subroutine process_stack_init_var_list
  
@ %def process_stack_init_var_list
@ Link the process variable list to a global
variable list.
<<Process stacks: process stack: TBP>>=
  procedure :: link_var_list => process_stack_link_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_link_var_list (stack, var_list)
    class(process_stack_t), intent(inout) :: stack
    type(var_list_t), intent(in), target :: var_list
    call var_list_link (stack%var_list, var_list)
  end subroutine process_stack_link_var_list
  
@ %def process_stack_link_var_list
@
\subsection{Push}
We take a process pointer and push it onto the stack.  The previous
pointer is nullified.  Subsequently, the process is `owned' by the
stack and will be finalized when the stack is deleted.
<<Process stacks: process stack: TBP>>=
  procedure :: push => process_stack_push
<<Process stacks: procedures>>=
  subroutine process_stack_push (stack, process)
    class(process_stack_t), intent(inout) :: stack
    type(process_entry_t), intent(inout), pointer :: process
    process%next => stack%first
    stack%first => process
    process => null ()
    stack%n = stack%n + 1
  end subroutine process_stack_push
  
@ %def process_stack_push
@ Initialize process variables for a given process ID, without setting
values.
<<Process stacks: process stack: TBP>>=
  procedure :: init_result_vars => process_stack_init_result_vars
<<Process stacks: procedures>>=
  subroutine process_stack_init_result_vars (stack, id)
    class(process_stack_t), intent(inout) :: stack
    type(string_t), intent(in) :: id
    call var_list_init_num_id (stack%var_list, id)
    call var_list_init_process_results (stack%var_list, id)
  end subroutine process_stack_init_result_vars
  
@ %def process_stack_init_result_vars
@ Fill process variables with values.  This is executed after the
integration pass.

Note: We set only integral and error.  With multiple MCI records
possible, the results for [[n_calls]], [[chi2]] etc. are not
necessarily unique.  (We might set the efficiency, though.)
<<Process stacks: process stack: TBP>>=
  procedure :: fill_result_vars => process_stack_fill_result_vars
<<Process stacks: procedures>>=
  subroutine process_stack_fill_result_vars (stack, id)
    class(process_stack_t), intent(inout) :: stack
    type(string_t), intent(in) :: id
    type(process_t), pointer :: process
    process => stack%get_process_ptr (id)
    if (associated (process)) then
       call var_list_init_num_id (stack%var_list, id, process%get_num_id ())
       if (process%has_integral ()) then
          call var_list_init_process_results (stack%var_list, id, &
               integral = process%get_integral (), &
               error = process%get_error ())
       end if
    else
       call msg_bug ("process_stack_fill_result_vars: unknown process ID")
    end if
  end subroutine process_stack_fill_result_vars

@ %def process_stack_fill_result_vars
@
\subsection{Data Access}
Tell if a process exists.
<<Process stacks: process stack: TBP>>=
  procedure :: exists => process_stack_exists
<<Process stacks: procedures>>=
  function process_stack_exists (stack, id) result (flag)
    class(process_stack_t), intent(in) :: stack
    type(string_t), intent(in) :: id
    logical :: flag
    type(process_t), pointer :: process
    process => stack%get_process_ptr (id)
    flag = associated (process)
  end function process_stack_exists

@ %def process_stack_exists
@ Return a pointer to a process with specific ID.  Look also at a
linked stack, if necessary.
<<Process stacks: process stack: TBP>>=
  procedure :: get_process_ptr => process_stack_get_process_ptr
<<Process stacks: procedures>>=
  recursive function process_stack_get_process_ptr (stack, id) result (ptr)
    class(process_stack_t), intent(in) :: stack
    type(string_t), intent(in) :: id
    type(process_t), pointer :: ptr
    type(process_entry_t), pointer :: entry
    ptr => null ()
    entry => stack%first
    do while (associated (entry))
       if (entry%get_id () == id) then
          ptr => entry%process_t
          return
       end if
       entry => entry%next
    end do
    if (associated (stack%next))  ptr => stack%next%get_process_ptr (id)
  end function process_stack_get_process_ptr

@ %def process_stack_get_process_ptr
@
\subsection{Unit tests}
<<Process stacks: public>>=
  public :: process_stacks_test
<<Process stacks: tests>>=
  subroutine process_stacks_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Process stacks: execute tests>>
  end subroutine process_stacks_test
  
@ %def process_stacks_test
@
\subsubsection{Write an empty process stack}
The most trivial test is to write an uninitialized process stack.
<<Process stacks: execute tests>>=
  call test (process_stacks_1, "process_stacks_1", &
       "write an empty process stack", &
       u, results)
<<Process stacks: tests>>=
  subroutine process_stacks_1 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack

    write (u, "(A)")  "* Test output: process_stacks_1"
    write (u, "(A)")  "*   Purpose: display an empty process stack"
    write (u, "(A)")

    call stack%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_1"
    
  end subroutine process_stacks_1
  
@ %def process_stacks_1
@
\subsubsection{Fill a process stack}
Fill a process stack with two (identical) processes.
<<Process stacks: execute tests>>=
  call test (process_stacks_2, "process_stacks_2", &
       "fill a process stack", &
       u, results)
<<Process stacks: tests>>=
  subroutine process_stacks_2 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(process_entry_t), pointer :: process => null ()

    write (u, "(A)")  "* Test output: process_stacks_2"
    write (u, "(A)")  "*   Purpose: fill a process stack"
    write (u, "(A)")

    write (u, "(A)")  "* Build, initialize and store two test processes"
    write (u, "(A)")

    libname = "process_stacks2"
    procname = libname
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    allocate (process)
    run_id = "run1"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 
    call stack%push (process)
    
    allocate (process)
    run_id = "run2"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 
    call stack%push (process)
    
    call stack%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_2"
    
  end subroutine process_stacks_2
  
@ %def process_stacks_2
@
\subsubsection{Fill a process stack}
Fill a process stack with two (identical) processes.
<<Process stacks: execute tests>>=
  call test (process_stacks_3, "process_stacks_3", &
       "process variables", &
       u, results)
<<Process stacks: tests>>=
  subroutine process_stacks_3 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack
    type(model_list_t) :: model_list
    type(string_t) :: procname
    type(process_entry_t), pointer :: process => null ()
    type(process_instance_t), target :: process_instance

    write (u, "(A)")  "* Test output: process_stacks_3"
    write (u, "(A)")  "*   Purpose: setup process variables"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    procname = "processes_test"
    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    call stack%init_var_list ()
    call stack%init_result_vars (procname)
    call stack%write_var_list (u)

    write (u, "(A)")
    write (u, "(A)")  "* Build and integrate a test process"
    write (u, "(A)")

    allocate (process)
    call prepare_test_process (process%process_t, process_instance, model_list)
    call process%integrate (process_instance, 1, 1, 1000)
    call process_instance%final ()
    call process%final_integration (1)
    call stack%push (process)
    
    write (u, "(A)")  "* Fill process variables"
    write (u, "(A)")

    call stack%fill_result_vars (procname)
    call stack%write_var_list (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_3"
    
  end subroutine process_stacks_3
  
@ %def process_stacks_3
@
\subsubsection{Linked a process stack}
Fill two process stack, linked to each other.
<<Process stacks: execute tests>>=
  call test (process_stacks_4, "process_stacks_4", &
       "linked stacks", &
       u, results)
<<Process stacks: tests>>=
  subroutine process_stacks_4 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_stack_t), target :: stack1, stack2
    type(model_list_t) :: model_list
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(process_entry_t), pointer :: process => null ()

    write (u, "(A)")  "* Test output: process_stacks_4"
    write (u, "(A)")  "*   Purpose: link process stacks"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    libname = "process_stacks_4_lib"
    procname = "process_stacks_4a"
    call syntax_model_file_init ()
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize first process"
    write (u, "(A)")

    call prc_test_create_library (procname, lib)
    allocate (process)
    run_id = "run1"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 
    call stack1%push (process)
    
    write (u, "(A)")  "* Initialize second process"
    write (u, "(A)")

    call stack2%link (stack1)

    procname = "process_stacks_4b"
    call prc_test_create_library (procname, lib)
    allocate (process)
    run_id = "run2"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 
    call stack2%push (process)
    
    write (u, "(A)")  "* Show linked stacks"
    write (u, "(A)")

    call stack2%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack2%final ()
    call stack1%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_4"
    
  end subroutine process_stacks_4
  
@ %def process_stacks_4
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Events}

With a process object and the associated methods at hand, we can
generate events for elementary processes and, by subsequent
transformation, for complete physical processes.

We have the following modules:
\begin{description}
\item[event\_transforms]
  Abstract base type for transforming a physical process with process
  instance and included evaluators, etc., into a new
  object.  The following modules extend this base type.
\item[decays]
  Combine the elementary process with elementary decay processes and
  thus transform the elementary event into a decayed event, still at
  the parton level.
\item[showers]
  Create QED/QCD showers out of the partons that are emitted by
  elementary processes.  This should be interleaved with showering of
  radiated particles (structure functions) and multiple interactions.
\item[hadrons]
  (not implemented yet) Apply hadronization to the partonic events,
  interleaved with hadron decays.  (The current setup relies on
  hadronizing partonic events externally.)
\item[events]
  Combine all pieces to generate full events.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Event Transforms}
<<[[event_transforms.f90]]>>=
<<File header>>

module event_transforms

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use models
  use state_matrices
  use interactions
  use particles
  use subevents
  use process_libraries
  use prc_core
  use prc_test
  use rng_base
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use processes
  use process_stacks
  
<<Standard module head>>

<<Event transforms: public>>

<<Event transforms: types>>

<<Event transforms: interfaces>>

contains

<<Event transforms: procedures>>

<<Event transforms: tests>>

end module event_transforms

@ %def event_transforms
@
\subsection{Abstract base type}
Essentially, all methods are abstract, but some get minimal base
versions.  We know that there will be a random-number generator at top
level, and that we will relate to an elementary process.

The model is stored separately.  It may contain modified setting that differ
from the model instance stored in the process object.

Each event transform contains a particle set that it can fill for
further use.  There is a flag the indicates this.

We will collect event transforms in a list, therefore we include a
[[previous]] and [[next]] pointers.
<<Event transforms: public>>=
  public :: evt_t
<<Event transforms: types>>=
  type, abstract :: evt_t
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: process_instance => null ()
     type(model_t), pointer :: model => null ()
     class(rng_t), allocatable :: rng
     integer :: rejection_count = 0
     logical :: particle_set_exists = .false.
     type(particle_set_t) :: particle_set
     class(evt_t), pointer :: previous => null ()
     class(evt_t), pointer :: next => null ()
   contains
   <<Event transforms: evt: TBP>>
  end type evt_t
  
@ %def evt_t
@ Finalizer.  In any case, we finalize the r.n.g.  The process
instance is a pointer and should not be finalized here.
<<Event transforms: evt: TBP>>=
  procedure :: final => evt_final
  procedure :: base_final => evt_final
<<Event transforms: procedures>>=
  subroutine evt_final (object)
    class(evt_t), intent(inout) :: object
    if (allocated (object%rng))  call object%rng%final ()
    if (object%particle_set_exists) &
         call particle_set_final (object%particle_set)
  end subroutine evt_final
  
@ %def evt_final
@ Output.  We can print r.n.g. info.
<<Event transforms: evt: TBP>>=
  procedure :: base_write => evt_write
<<Event transforms: procedures>>=
  subroutine evt_write (object, unit, verbose, testflag)
    class(evt_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%process)) then
       write (u, "(3x,A,A,A)")   "Associated process: '", &
            char (object%process%get_id ()), "'"
    end if
    if (allocated (object%rng)) then
       call object%rng%write (u, 1)
       write (u, "(3x,A,I0)")  "Number of tries = ", object%rejection_count
    end if
    if (object%particle_set_exists) then
       call write_separator (u)
       call particle_set_write (object%particle_set, u, testflag)
    end if
  end subroutine evt_write
  
@ %def evt_write
@ Connect the transform with a process instance (and thus with the
associated process).  Use this to allocate the master random-number
generator.

This is not an initializer; we may initialize the transform by
implementation-specific methods.
<<Event transforms: evt: TBP>>=
  procedure :: connect => evt_connect
  procedure :: base_connect => evt_connect
<<Event transforms: procedures>>=
  subroutine evt_connect (evt, process_instance, model, process_stack)
    class(evt_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    evt%process => process_instance%process
    evt%process_instance => process_instance
    evt%model => model
    call evt%process%make_rng (evt%rng)
  end subroutine evt_connect
  
@ %def evt_connect
@ Reset internal state.
<<Event transforms: evt: TBP>>=
  procedure :: reset => evt_reset
  procedure :: base_reset => evt_reset
<<Event transforms: procedures>>=
  subroutine evt_reset (evt)
    class(evt_t), intent(inout) :: evt
    evt%rejection_count = 0
    evt%particle_set_exists = .false.
  end subroutine evt_reset
  
@ %def evt_reset
@ Prepare for a new event: reset internal state, if necessary.  We
provide MCI and term index of the parent process.
<<Event transforms: evt: TBP>>=
  procedure (evt_prepare_new_event), deferred :: prepare_new_event
<<Event transforms: interfaces>>=
  interface
     subroutine evt_prepare_new_event (evt, i_mci, i_term)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: i_mci, i_term
     end subroutine evt_prepare_new_event
  end interface
       
@ %def evt_prepare_new_event
@ Generate a weighted event, using a valid initiator event in the
process instance, and the random-number generator.  The returned event
probability should be a number between zero and one that we can use for
rejection.
<<Event transforms: evt: TBP>>=
  procedure (evt_generate_weighted), deferred :: generate_weighted
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_generate_weighted (evt, probability)
       import
       class(evt_t), intent(inout) :: evt
       real(default), intent(out) :: probability
     end subroutine evt_generate_weighted
  end interface
  
@ %def evt_generate_weighted
@ The unweighted event generation routine is actually implemented.  It
uses the random-number generator for simple rejection.  Of course, the
implementation may override this and implement a different way of
generating an unweighted event.
<<Event transforms: evt: TBP>>=
  procedure :: generate_unweighted => evt_generate_unweighted
  procedure :: base_generate_unweighted => evt_generate_unweighted
<<Event transforms: procedures>>=
  subroutine evt_generate_unweighted (evt)
    class(evt_t), intent(inout) :: evt
    real(default) :: p, x
    evt%rejection_count = 0
    REJECTION: do
       evt%rejection_count = evt%rejection_count + 1
       call evt%generate_weighted (p)
       if (signal_is_pending ())  return
       call evt%rng%generate (x)
       if (x < p)  exit REJECTION
    end do REJECTION
  end subroutine evt_generate_unweighted
    
@ %def evt_generate_unweighted
@ Make a particle set.  This should take the most recent evaluator (or
whatever stores the event), factorize the density matrix if necessary,
and store as a particle set.

If applicable, the factorization should make use of the
[[factorization_mode]] and [[keep_correlations]] settings.

The values [[r]], if set, should control the factorization in more
detail, e.g., bypassing the random-number generator.
<<Event transforms: evt: TBP>>=
  procedure (evt_make_particle_set), deferred :: make_particle_set
<<Event transforms: interfaces>>=
  interface
     subroutine evt_make_particle_set &
          (evt, factorization_mode, keep_correlations, r)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: factorization_mode
       logical, intent(in) :: keep_correlations
       real(default), dimension(:), intent(in), optional :: r
     end subroutine evt_make_particle_set
  end interface
       
@ %def evt_make_particle_set
@ Copy an existing particle set into the event record.  This bypasses
all methods to evaluate the internal state, but may be sufficient for
further processing.
<<Event transforms: evt: TBP>>=
  procedure :: set_particle_set => evt_set_particle_set
<<Event transforms: procedures>>=
  subroutine evt_set_particle_set (evt, particle_set, i_mci, i_term)
    class(evt_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: i_term, i_mci
    call evt%prepare_new_event (i_mci, i_term)
    evt%particle_set = particle_set
    evt%particle_set_exists = .true.
  end subroutine evt_set_particle_set
    
@ %def evt_set_particle_set
@ This procedure can help in the previous task, if the particles are
available in the form of an interaction object.  (We need two
interactions, one with color summed over, and one with the probability
distributed among flows.)

We use the two values from the random number generator for factorizing
the state.  For testing purposes, we can provide those numbers explicitly.
<<Event transforms: evt: TBP>>=
  procedure :: factorize_interactions => evt_factorize_interactions
<<Event transforms: procedures>>=
  subroutine evt_factorize_interactions &
       (evt, int_matrix, int_flows, factorization_mode, keep_correlations, r)
    class(evt_t), intent(inout) :: evt
    type(interaction_t), intent(in), target :: int_matrix, int_flows
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    real(default), dimension(2) :: x
    if (present (r)) then
       if (size (r) == 2) then
          x = r
       else
          call msg_bug ("event factorization: size of r array must be 2")
       end if
    else
       call evt%rng%generate (x)
    end if
    call particle_set_init (evt%particle_set, evt%particle_set_exists, &
         int_matrix, int_flows, factorization_mode, x, &
         keep_correlations, keep_virtual=.true.)
    evt%particle_set_exists = .true.
  end subroutine evt_factorize_interactions
  
@ %def evt_factorize_interactions
@ Mark the incoming particles as incoming in the particle set.  This
is necessary because in the interaction objects they are usually
marked as virtual.

In the inquiry functions we set the term index to one; the indices of
beams and incoming particles should be identical for all process
terms.

We use the initial elementary process for obtaining the indices.
Thus, we implicitly assume that the beam and incoming indices stay the
same across event transforms.  If this is not true for a transform
(say, MPI), it should override this method.
<<Event transforms: evt: TBP>>=
  procedure :: tag_incoming => evt_tag_incoming
<<Event transforms: procedures>>=
  subroutine evt_tag_incoming (evt)
    class(evt_t), intent(inout) :: evt
    integer :: i_term, n_in
    integer, dimension(:), allocatable :: beam_index, in_index
    n_in = evt%process%get_n_in ()
    i_term = 1
    allocate (beam_index (n_in))
    call evt%process_instance%get_beam_index (i_term, beam_index)
    call particle_set_reset_status (evt%particle_set, &
         beam_index, PRT_BEAM)
    allocate (in_index (n_in))
    call evt%process_instance%get_in_index (i_term, in_index)
    call particle_set_reset_status (evt%particle_set, &
         in_index, PRT_INCOMING)
  end subroutine evt_tag_incoming

@ %def evt_tag_incoming
@
\subsection{Implementation: Trivial transform}
This transform contains just a pointer to process and process
instance.  The [[generate]] methods do nothing.
<<Event transforms: public>>=
  public :: evt_trivial_t
<<Event transforms: types>>=
  type, extends (evt_t) :: evt_trivial_t
   contains
   <<Event transforms: evt trivial: TBP>>
  end type evt_trivial_t

@ %def evt_trivial_t
@ The finalizer is trivial.  Some output:
<<Event transforms: evt trivial: TBP>>=
  procedure :: write => evt_trivial_write
<<Event transforms: procedures>>=
  subroutine evt_trivial_write (object, unit, verbose, testflag)
    class(evt_trivial_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: trivial (hard process)"
    call write_separator (u)
    call object%base_write (u, testflag = testflag)
  end subroutine evt_trivial_write
  
@ %def evt_trivial_write
@ Nothing to do here:
<<Event transforms: evt trivial: TBP>>=
  procedure :: prepare_new_event => evt_trivial_prepare_new_event
<<Event transforms: procedures>>=
  subroutine evt_trivial_prepare_new_event (evt, i_mci, i_term)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_trivial_prepare_new_event
  
@ %def evt_trivial_prepare_new_event
@ The weighted generator is, surprisingly, trivial.
<<Event transforms: evt trivial: TBP>>=
  procedure :: generate_weighted => evt_trivial_generate_weighted
<<Event transforms: procedures>>=
  subroutine evt_trivial_generate_weighted (evt, probability)
    class(evt_trivial_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    probability = 1
  end subroutine evt_trivial_generate_weighted
    
@ %def evt_trivial_generate_weighted
@ This routine makes a particle set, using the associated process
instance as-is.
<<Event transforms: evt trivial: TBP>>=
  procedure :: make_particle_set => evt_trivial_make_particle_set
<<Event transforms: procedures>>=
  subroutine evt_trivial_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    integer :: i_term
    type(interaction_t), pointer :: int_matrix, int_flows
    if (evt%process_instance%is_complete_event ()) then
       call evt%process_instance%select_i_term (i_term)
       int_matrix => evt%process_instance%get_matrix_int_ptr (i_term)
       int_flows  => evt%process_instance%get_flows_int_ptr (i_term)
       call evt%factorize_interactions (int_matrix, int_flows, &
            factorization_mode, keep_correlations, r)
       call evt%tag_incoming ()
    else
       call msg_bug ("Event factorization: event is incomplete")
    end if
  end subroutine evt_trivial_make_particle_set
    
@ %def event_trivial_make_particle_set
@
\subsection{Unit tests}
<<Event transforms: public>>=
  public :: event_transforms_test
<<Event transforms: tests>>=
  subroutine event_transforms_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event transforms: execute tests>>
  end subroutine event_transforms_test
  
@ %def event_transforms_test
@
\subsubsection{Test trivial event transform}
The trivial transform, as an instance of the abstract transform, does
nothing but to trigger event generation for an elementary process.
<<Event transforms: execute tests>>=
  call test (event_transforms_1, "event_transforms_1", &
       "trivial event transform", &
       u, results)
<<Event transforms: tests>>=
  subroutine event_transforms_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: libname, procname1, run_id
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(evt_t), allocatable :: evt
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: event_transforms_1"
    write (u, "(A)")  "*   Purpose: handle trivial transform"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)

    libname = "event_transforms_1_lib"
    procname1 = "event_transforms_1_p"
    run_id = "event_transforms_1"

    call prc_test_create_library (libname, lib, &
         scattering = .true., procname1 = procname1)
    call reset_interaction_counter ()
    allocate (process)
    call process%init &
         (procname1, run_id, lib, os_data, qcd, rng_factory, model_list)
    
    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()

    allocate (process_instance)
    call process_instance%init (process)
    call process%integrate (process_instance, 1, n_it=1, n_calls=100)
    call process%final_integration (1)
    call process_instance%final ()
    deallocate (process_instance)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")  "* Initialize trivial event transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt)
    call evt%connect (process_instance, model)
    
    write (u, "(A)")  "* Generate event and subsequent transform"
    write (u, "(A)")
    
    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()
    
    call evt%prepare_new_event (1, 1)
    call evt%generate_unweighted ()

    select type (evt)
    type is (evt_trivial_t)
       call write_separator (u, 2)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Obtain particle set"
    write (u, "(A)")
    
    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    
    call evt%make_particle_set (factorization_mode, keep_correlations)

    select type (evt)
    type is (evt_trivial_t)
       call write_separator (u, 2)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_transforms_1"
    
  end subroutine event_transforms_1
  
@ %def event_transforms_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Decays}
<<[[decays.f90]]>>=
<<File header>>

module decays

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_indent, write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use model_data, only: field_data_t
  use flavors
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use variables
  use models
  use rng_base
  use selectors
  use prc_core
  use prc_test
  use process_libraries
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use parton_states
  use processes
  use process_stacks
  use event_transforms
  
<<Standard module head>>

<<Decays: public>>

<<Decays: types>>

<<Decays: interfaces>>

contains

<<Decays: procedures>>

<<Decays: tests>>

end module decays

@ %def decays
@
\subsection{Final-State Particle Configuration}
A final-state particle may be either stable or unstable.  Here is an
empty abstract type as the parent of both, with holds just the flavor
information.
<<Decays: types>>=
  type, abstract :: any_config_t
   contains
   <<Decays: any config: TBP>>
  end type any_config_t

@ %def any_config_t
@ Finalizer, depends on the implementation.
<<Decays: any config: TBP>>=
  procedure (any_config_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_config_final (object)
       import
       class(any_config_t), intent(inout) :: object
     end subroutine any_config_final
  end interface
  
@ %def any_config_final
@ The output is also deferred:
<<Decays: any config: TBP>>=
  procedure (any_config_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_config_write (object, unit, indent, verbose)
       import
       class(any_config_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
       logical, intent(in), optional :: verbose
     end subroutine any_config_write
  end interface

@ %def any_config_write
@ This is a container for a stable or unstable particle configurator.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_config_t
     class(any_config_t), allocatable :: c
  end type particle_config_t
  
@ %def particle_config_t
@
\subsection{Final-State Particle}
In theory, for the particle instance we only need to consider the
unstable case.  However, it is more straightforward to treat
configuration and instance on the same footing, and to introduce a
wrapper for particle objects as above.  This also works
around a compiler bug in gfortran.
<<Decays: types>>=
  type, abstract :: any_t
   contains
   <<Decays: any: TBP>>
  end type any_t
  
@ %def any_t
@ Finalizer, depends on the implementation.
<<Decays: any: TBP>>=
  procedure (any_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_final (object)
       import
       class(any_t), intent(inout) :: object
     end subroutine any_final
  end interface
  
@ %def any_final
@ The output is also deferred:
<<Decays: any: TBP>>=
  procedure (any_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_write (object, unit, indent)
       import
       class(any_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
     end subroutine any_write
  end interface

@ %def any_write
@ This is a container for a stable or unstable outgoing particle.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_out_t
     class(any_t), allocatable :: c
  end type particle_out_t
  
@ %def particle_config_t
@ 
\subsection{Decay Term Configuration}
A decay term is a distinct final state, corresponding to a process
term.  Each decay process may give rise to several terms with,
possibly, differing flavor content.
<<Decays: types>>=
  type :: decay_term_config_t
     type(particle_config_t), dimension(:), allocatable :: prt
   contains
   <<Decays: decay term config: TBP>>
  end type decay_term_config_t
  
@ %def decay_term_config_t
@ Finalizer, recursive.
<<Decays: decay term config: TBP>>=
  procedure :: final => decay_term_config_final
<<Decays: procedures>>=
  recursive subroutine decay_term_config_final (object)
    class(decay_term_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%prt)) then
       do i = 1, size (object%prt)
          if (allocated (object%prt(i)%c))  call object%prt(i)%c%final ()
       end do
    end if
  end subroutine decay_term_config_final
  
@ %def decay_term_config_final
@ Output, with optional indentation
<<Decays: decay term config: TBP>>=
  procedure :: write => decay_term_config_write
<<Decays: procedures>>=
  recursive subroutine decay_term_config_write (object, unit, indent, verbose)
    class(decay_term_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, j, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,A)", advance="no")  "Final state:"
    do i = 1, size (object%prt)
       select type (prt_config => object%prt(i)%c)
       type is (stable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (flavor_get_name (prt_config%flv(1)))
          do j = 2, size (prt_config%flv)
             write (u, "(':',A)", advance="no") &
                  char (flavor_get_name (prt_config%flv(j)))
          end do
       type is (unstable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (flavor_get_name (prt_config%flv))
       end select
    end do
    write (u, *)
    if (verb) then
       do i = 1, size (object%prt)
          call object%prt(i)%c%write (u, ind)
       end do
    end if
  end subroutine decay_term_config_write

@ %def decay_term_config_write
@ Initialize, given a set of flavors.  For each flavor, we must indicate
whether the particle is stable.  The second index of the flavor array runs
over alternatives for each decay product; alternatives are allowed only if the
decay product is itself stable.
<<Decays: decay term config: TBP>>=
  procedure :: init => decay_term_config_init
<<Decays: procedures>>=
  recursive subroutine decay_term_config_init &
       (term, flv, stable, model, process_stack)
    class(decay_term_config_t), intent(out) :: term
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t), dimension(:), allocatable :: decay
    integer :: i
    allocate (term%prt (size (flv, 1)))
    do i = 1, size (flv, 1)
       associate (prt => term%prt(i))
         if (stable(i)) then
            allocate (stable_config_t :: prt%c)
         else
            allocate (unstable_config_t :: prt%c)
         end if
         select type (prt_config => prt%c)
         type is (stable_config_t)
            call prt_config%init (flv(i,:))
         type is (unstable_config_t)
            if (all (flv(i,:) == flv(i,1))) then
               call prt_config%init (flv(i,1))
               call flavor_get_decays (flv(i,1), decay)
               call prt_config%init_decays (decay, model, process_stack)
            else
               call prt_config%write ()
               call msg_fatal ("Decay configuration: &
                    &unstable product must be unique")
            end if
         end select
       end associate
    end do
  end subroutine decay_term_config_init
  
@ %def decay_term_config_init
@ Recursively compute widths and branching ratios for all unstable particles.
<<Decays: decay term config: TBP>>=
  procedure :: compute => decay_term_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_term_config_compute (term)
    class(decay_term_config_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%prt)
       select type (unstable_config => term%prt(i)%c)
       type is (unstable_config_t)
          call unstable_config%compute ()
       end select
    end do
  end subroutine decay_term_config_compute
  
@ %def decay_term_config_compute
@
\subsection{Decay Term}
A decay term instance is selected when we generate an event for the associated
process instance.  When evaluated, it triggers further decays down the chain.

Only unstable products are allocated as child particles.
<<Decays: types>>=
  type :: decay_term_t
     type(decay_term_config_t), pointer :: config => null ()
     type(particle_out_t), dimension(:), allocatable :: particle_out
   contains
   <<Decays: decay term: TBP>>
  end type decay_term_t

@ %def decay_term_t
@ Finalizer.
<<Decays: decay term: TBP>>=
  procedure :: final => decay_term_final
<<Decays: procedures>>=
  recursive subroutine decay_term_final (object)
    class(decay_term_t), intent(inout) :: object
    integer :: i
    if (allocated (object%particle_out)) then
       do i = 1, size (object%particle_out)
          call object%particle_out(i)%c%final ()
       end do
    end if
  end subroutine decay_term_final
  
@ %def decay_term_final
@ Output.
<<Decays: decay term: TBP>>=
  procedure :: write => decay_term_write
<<Decays: procedures>>=
  recursive subroutine decay_term_write (object, unit, indent)
    class(decay_term_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: i, u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose = .false.)
    do i = 1, size (object%particle_out)
       call object%particle_out(i)%c%write (u, ind)
    end do
  end subroutine decay_term_write

@ %def decay_term_write
@ Recursively write the embedded process instances.
<<Decays: decay term: TBP>>=
  procedure :: write_process_instances => decay_term_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_term_write_process_instances (term, unit, verbose)
    class(decay_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%write_process_instances (unit, verbose)
       end select
    end do
  end subroutine decay_term_write_process_instances
  
@ %def decay_term_write_process_instances
@ Initialization, using the configuration object.  We allocate
particle objects in parallel to the particle configuration objects
which we use to initialize them, one at a time.
<<Decays: decay term: TBP>>=
  procedure :: init => decay_term_init
<<Decays: procedures>>=
  recursive subroutine decay_term_init (term, config)
    class(decay_term_t), intent(out) :: term
    type(decay_term_config_t), intent(in), target :: config
    integer :: i
    term%config => config
    allocate (term%particle_out (size (config%prt)))
    do i = 1, size (config%prt)
       select type (prt_config => config%prt(i)%c)
       type is (stable_config_t)
          allocate (stable_t :: term%particle_out(i)%c)
          select type (stable => term%particle_out(i)%c)
          type is (stable_t)
             call stable%init (prt_config)
          end select
       type is (unstable_config_t)
          allocate (unstable_t :: term%particle_out(i)%c)
          select type (unstable => term%particle_out(i)%c)
          type is (unstable_t)
             call unstable%init (prt_config)
          end select
       end select
    end do
  end subroutine decay_term_init

@ %def decay_term_init
@ Implement a RNG instance, spawned by the process object.
<<Decays: decay term: TBP>>=
  procedure :: make_rng => decay_term_make_rng
<<Decays: procedures>>=
  subroutine decay_term_make_rng (term, process)
    class(decay_term_t), intent(inout) :: term
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call process%make_rng (rng)
          call unstable%import_rng (rng)
       end select
    end do
  end subroutine decay_term_make_rng
    
@ %def decay_term_make_rng
@ Link the interactions for unstable decay products to the
interaction of the parent process.
<<Decays: decay term: TBP>>=
  procedure :: link_interactions => decay_term_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_term_link_interactions (term, trace)
    class(decay_term_t), intent(inout) :: term
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%link_interactions (i, trace)
       end select
    end do
  end subroutine decay_term_link_interactions
  
@ %def decay_term_link_interactions
@ Recursively generate a decay chain, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: select_chain => decay_term_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_term_select_chain (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%select_chain ()
       end select
    end do
  end subroutine decay_term_select_chain

@ %def decay_term_select_chain
@ Recursively generate a decay event, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: generate => decay_term_generate
<<Decays: procedures>>=
  recursive subroutine decay_term_generate (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%generate ()
       end select
    end do
  end subroutine decay_term_generate

@ %def decay_term_generate
@
\subsection{Decay Root Configuration}
At the root of a decay chain, there is a parent process.  The decay root
stores a pointer to the parent process and the set of decay configurations.
<<Decays: types>>=
  type :: decay_root_config_t
     type(string_t) :: process_id
     type(process_t), pointer :: process => null ()
     type(model_t), pointer :: model => null ()
     type(decay_term_config_t), dimension(:), allocatable :: term_config
   contains
   <<Decays: decay root config: TBP>>
  end type decay_root_config_t
  
@ %def decay_root_config_t
@ The finalizer is recursive since there may be cascade decays.
<<Decays: decay root config: TBP>>=
  procedure :: final => decay_root_config_final
<<Decays: procedures>>=
  recursive subroutine decay_root_config_final (object)
    class(decay_root_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%final ()
       end do
    end if
  end subroutine decay_root_config_final
  
@ %def decay_root_config_final
@ The output routine is also recursive, and it contains an adjustable
indentation.
<<Decays: decay root config: TBP>>=
  procedure :: write => decay_root_config_write
  procedure :: write_header => decay_root_config_write_header
  procedure :: write_terms => decay_root_config_write_terms
<<Decays: procedures>>=
  recursive subroutine decay_root_config_write (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Final-state decay tree:"
    call object%write_header (unit, indent)
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_root_config_write

  subroutine decay_root_config_write_header (object, unit, indent)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    if (associated (object%process)) then
       write (u, 3)  "process ID      =", char (object%process_id), "*"
    else
       write (u, 3)  "process ID      =", char (object%process_id)
    end if
3   format (3x,A,2(1x,A))
  end subroutine decay_root_config_write_header
    
  recursive subroutine decay_root_config_write_terms &
       (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb .and. allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine decay_root_config_write_terms
    
@ %def decay_root_config_write
@ Initialize for a named process and (optionally) a pre-determined
number of terms.
<<Decays: decay root config: TBP>>=
  procedure :: init => decay_root_config_init
<<Decays: procedures>>=
  subroutine decay_root_config_init (decay, model, process_id, n_terms)
    class(decay_root_config_t), intent(out) :: decay
    type(model_t), intent(in), target :: model
    type(string_t), intent(in) :: process_id
    integer, intent(in), optional :: n_terms
    decay%model => model
    decay%process_id = process_id
    if (present (n_terms)) then
       allocate (decay%term_config (n_terms))
    end if
  end subroutine decay_root_config_init
       
@ %def decay_root_config_init
@ Declare a decay term, given an array of flavors.
<<Decays: decay root config: TBP>>=
  procedure :: init_term => decay_root_config_init_term
<<Decays: procedures>>=
  recursive subroutine decay_root_config_init_term &
       (decay, i, flv, stable, model, process_stack)
    class(decay_root_config_t), intent(inout) :: decay
    integer, intent(in) :: i
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call decay%term_config(i)%init (flv, stable, model, process_stack)
  end subroutine decay_root_config_init_term
  
@ %def decay_root_config_init_term
@ Connect the decay root configuration with a process object (which should
represent the parent process).  This includes initialization, therefore
intent(out).

The flavor state is retrieved from the process term object.  However, we have
to be careful: the flavor object points to the model instance that is stored
in the process object.  This model instance may not contain the current
setting for unstable particles and decay.  Therefore, we assign the model
directly.

If the [[process_instance]] argument is provided, we use this for the
flavor state.  This applies to the decay root only, where the process
can be entangled with a beam setup, and the latter contains beam
remnants as further outgoing particles.  These must be included in the
set of outgoing flavors, since the decay application is also done on
the connected state.

Infer stability from the particle properties, using the first row in the set
of flavor states.  For unstable particles, we look for decays,
recursively, available from the process stack (if present).
<<Decays: decay root config: TBP>>=
  procedure :: connect => decay_root_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_root_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_root_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    type(connected_state_t), pointer :: connected_state
    type(interaction_t), pointer :: int
    type(flavor_t), dimension(:,:), allocatable :: flv
    logical, dimension(:), allocatable :: stable
    integer :: i
    call decay%init (model, process%get_id (), process%get_n_terms ())
    do i = 1, size (decay%term_config)
       if (present (process_instance)) then
          connected_state => process_instance%get_connected_state_ptr (i)
          int => connected_state%get_matrix_int_ptr ()
          call interaction_get_flv_out (int, flv)
       else
          call process%get_term_flv_out (i, flv)
       end if
       call flavor_set_model (flv, model)
       allocate (stable (size (flv, 1)))
       stable = flavor_is_stable (flv(:,1))
       call decay%init_term (i, flv, stable, model, process_stack)
       deallocate (flv, stable)
    end do
    decay%process => process
  end subroutine decay_root_config_connect

@ %def decay_root_config_connect
@ Recursively compute widths, errors, and branching ratios.
<<Decays: decay root config: TBP>>=
  procedure :: compute => decay_root_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_root_config_compute (decay)
    class(decay_root_config_t), intent(inout) :: decay
    integer :: i
    do i = 1, size (decay%term_config)
       call decay%term_config(i)%compute ()
    end do
  end subroutine decay_root_config_compute
  
@ %def decay_root_config_compute
@
\subsection{Decay Root Instance}
This is the common parent type for decay and decay root.  The process instance
points to the parent process.  The model pointer is separate because particle
settings may be updated w.r.t.\ the parent process object.
<<Decays: types>>=
  type, abstract :: decay_gen_t
     type(decay_term_t), dimension(:), allocatable :: term
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
   contains
   <<Decays: decay gen: TBP>>
  end type decay_gen_t
  
@ %def decay_gen_t
@
The decay root represents the parent process.  When an event is generated, the
generator selects the term to which the decay chain applies (if possible).

The process instance is just a pointer.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_root_t
     type(decay_root_config_t), pointer :: config => null ()
   contains
   <<Decays: decay root: TBP>>
  end type decay_root_t
  
@ %def decay_root_t
@ The finalizer has to recursively finalize the terms, but we can skip the
process instance which is not explicitly allocated.
<<Decays: decay gen: TBP>>=
  procedure :: base_final => decay_gen_final
<<Decays: procedures>>=
  recursive subroutine decay_gen_final (object)
    class(decay_gen_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term)) then
       do i = 1, size (object%term)
          call object%term(i)%final ()
       end do
    end if
  end subroutine decay_gen_final    
  
@ %def decay_gen_final
@ No extra finalization for the decay root.
<<Decays: decay root: TBP>>=
  procedure :: final => decay_root_final
<<Decays: procedures>>=
  subroutine decay_root_final (object)
    class(decay_root_t), intent(inout) :: object
    call object%base_final ()
  end subroutine decay_root_final    
  
@ %def decay_gen_final
@ Output.
<<Decays: decay root: TBP>>=
  procedure :: write => decay_root_write
<<Decays: procedures>>=
  subroutine decay_root_write (object, unit)
    class(decay_root_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%config)) then
       call object%config%write (unit, verbose = .false.)
    else
       write (u, "(1x,A)")  "Final-state decay tree: [not configured]"
    end if
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_root_write

@ %def decay_root_write
@ Write the process instances, recursively.
<<Decays: decay gen: TBP>>=
  procedure :: write_process_instances => decay_gen_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_gen_write_process_instances (decay, unit, verbose)
    class(decay_gen_t), intent(in) :: decay
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (associated (decay%process_instance)) then
       if (verb) then
          call decay%process_instance%write (unit)
       else
          call decay%process_instance%write_header (unit)
       end if
    end if
    if (decay%selected_term > 0) then
       call decay%term(decay%selected_term)%write_process_instances (unit, verb)
    end if
  end subroutine decay_gen_write_process_instances
    
@ %def decay_gen_write_process_instances
@ Generic initializer.  All can be done recursively.
<<Decays: decay gen: TBP>>=
  procedure :: base_init => decay_gen_init
<<Decays: procedures>>=
  recursive subroutine decay_gen_init (decay, term_config)
    class(decay_gen_t), intent(out) :: decay
    type(decay_term_config_t), dimension(:), intent(in), target :: term_config
    integer :: i
    allocate (decay%term (size (term_config)))
    do i = 1, size (decay%term)
       call decay%term(i)%init (term_config(i))
    end do
  end subroutine decay_gen_init

@ %def decay_gen_init
@ Specific initializer.  We assign the configuration object, which should
correspond to a completely initialized decay configuration tree.  We
also connect to an existing process instance.  Then, we recursively
link the child interactions to the parent process.
<<Decays: decay root: TBP>>=
  procedure :: init => decay_root_init
<<Decays: procedures>>=
  subroutine decay_root_init (decay_root, config, process_instance)
    class(decay_root_t), intent(out) :: decay_root
    type(decay_root_config_t), intent(in), target :: config
    type(process_instance_t), intent(in), target :: process_instance
    call decay_root%base_init (config%term_config)
    decay_root%config => config
    decay_root%process_instance => process_instance
    call decay_root%make_term_rng (config%process)
    call decay_root%link_term_interactions ()
  end subroutine decay_root_init

@ %def decay_root_init
@ Implement random-number generators for unstable decay selection in
all terms.  This is not recursive.

We also make use of the fact that [[process]] is a pointer; the (state
of the RNG factory inside the) target process will be modified by the
rng-spawning method, but not the pointer.
<<Decays: decay gen: TBP>>=
  procedure :: make_term_rng => decay_gen_make_term_rng
<<Decays: procedures>>=
  subroutine decay_gen_make_term_rng (decay, process)
    class(decay_gen_t), intent(inout) :: decay
    type(process_t), intent(in), pointer :: process
    integer :: i
    do i = 1, size (decay%term)
       call decay%term(i)%make_rng (process)
    end do
  end subroutine decay_gen_make_term_rng
    
@ %def decay_gen_make_term_rng
@ Recursively link interactions of the enclosed decay terms to the
corresponding terms in the current process instance.

Note: A bug in nagfor requires the extra [[i_term]] variable.
<<Decays: decay gen: TBP>>=
  procedure :: link_term_interactions => decay_gen_link_term_interactions
<<Decays: procedures>>=
  recursive subroutine decay_gen_link_term_interactions (decay)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i, i_term
    type(interaction_t), pointer :: trace
    associate (instance => decay%process_instance)
      do i = 1, size (decay%term)
         i_term = i
         trace => instance%get_trace_int_ptr (i_term)
         call decay%term(i_term)%link_interactions (trace)
      end do
    end associate
  end subroutine decay_gen_link_term_interactions

@ %def decay_gen_link_term_interactions
@ Select a decay chain: decay modes and process components.
<<Decays: decay root: TBP>>=
  procedure :: select_chain => decay_root_select_chain
<<Decays: procedures>>=
  subroutine decay_root_select_chain (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    if (decay_root%selected_term > 0) then
       call decay_root%term(decay_root%selected_term)%select_chain ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_select_chain

@ %def decay_root_select_chain
@ Generate a decay tree, i.e., for the selected term in the parent
process, recursively generate a decay event for all unstable
particles.

Factor out the trace of the connected state of the parent process.
This trace should not be taken into account for unweighting the decay
chain, since it was already used for unweighting the parent event, or
it determines the overall event weight.
<<Decays: decay root: TBP>>=
  procedure :: generate => decay_root_generate
<<Decays: procedures>>=
  subroutine decay_root_generate (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    type(connected_state_t), pointer :: connected_state
    if (decay_root%selected_term > 0) then
       connected_state => decay_root%process_instance%get_connected_state_ptr &
            (decay_root%selected_term)
       call connected_state%normalize_matrix_by_trace ()
       call decay_root%term(decay_root%selected_term)%generate ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_generate

@ %def decay_root_generate
@
\subsection{Decay Configuration}
A decay configuration describes a distinct decay mode of a particle.  Each
decay mode may include several terms, which correspond to the terms in the
associated process.  In addition to the base type, the decay configuration
object contains the integral of the parent process and the selector for the
MCI group inside this process.
<<Decays: types>>=
  type, extends (decay_root_config_t) :: decay_config_t
     real(default) :: weight = 0
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: mci_selector
   contains
   <<Decays: decay config: TBP>>
  end type decay_config_t
  
@ %def decay_config_t
@ The output routine extends the decay-root writer by listing numerical
component values.
<<Decays: decay config: TBP>>=
  procedure :: write => decay_config_write
<<Decays: procedures>>=
  recursive subroutine decay_config_write (object, unit, indent, verbose)
    class(decay_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Decay:"
    call object%write_header (unit, indent)
    call write_indent (u, ind)
    write (u, 2)  "branching ratio =", object%weight * 100
    call write_indent (u, ind)
    write (u, 1)  "partial width   =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs)     =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel)     =", object%rel_error
1   format (3x,A,ES19.12)
2   format (3x,A,F11.6,1x,'%')
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_config_write
    
@ %def decay_config_write
@ Connect a decay configuration with a process object (which should
represent the decay).  This includes initialization, therefore
intent(out).  We first connect the process itself, then do initializations
that are specific for this decay.

Infer stability from the particle properties, using the first row in the set
of flavor states.  Once we can deal with predetermined decay chains, they
should be used instead.
<<Decays: decay config: TBP>>=
  procedure :: connect => decay_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    real(default), dimension(:), allocatable :: integral_mci
    integer :: i, n_mci
    call decay%decay_root_config_t%connect (process, model, process_stack)
    decay%integral = process%get_integral ()
    decay%abs_error = process%get_error ()
    if (process%cm_frame ()) then
       call msg_fatal ("Decay process " // char (process%get_id ()) &
            // ": unusable because rest frame is fixed.")
    end if
    n_mci = process%get_n_mci ()
    allocate (integral_mci (n_mci))
    do i = 1, n_mci
       integral_mci(i) = process%get_integral_mci (i)
    end do
    call decay%mci_selector%init (integral_mci)
  end subroutine decay_config_connect

@ %def decay_config_connect
@ Compute embedded branchings and the relative error.  This method does not
apply to the decay root.
<<Decays: decay config: TBP>>=
  procedure :: compute => decay_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_config_compute (decay)
    class(decay_config_t), intent(inout) :: decay
    call decay%decay_root_config_t%compute ()
    if (decay%integral == 0) then
       call decay%write ()
       call msg_fatal ("Decay configuration: partial width is zero")
    end if
    decay%rel_error = decay%abs_error / decay%integral
  end subroutine decay_config_compute
  
@ %def decay_config_compute
@
\subsection{Decay Instance}
The decay contains a collection of terms.  One of them is selected when the
decay is evaluated.  This is similar to the decay root, but we implement it
independently.

The process instance object is allocated via a pointer, so it automatically
behaves as a target.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_t
     type(decay_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
   contains
   <<Decays: decay: TBP>>
  end type decay_t
     
@ %def decay_t
@ The finalizer is recursive.
<<Decays: decay: TBP>>=
  procedure :: final => decay_final
<<Decays: procedures>>=
  recursive subroutine decay_final (object)
    class(decay_t), intent(inout) :: object
    integer :: i
    call object%base_final ()
    do i = 1, object%config%process%get_n_mci ()
       call object%process_instance%final_simulation (i)
    end do
    call object%process_instance%final ()
    deallocate (object%process_instance)
  end subroutine decay_final
  
@ %def decay_final
@ Output.
<<Decays: decay: TBP>>=
  procedure :: write => decay_write
<<Decays: procedures>>=
  recursive subroutine decay_write (object, unit, indent, recursive)
    class(decay_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent, recursive
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (unit, indent, verbose = .false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 1)
    end if
    call write_indent (u, ind)
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    call write_indent (u, ind)
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, ind + 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_write

@ %def decay_write
@ Initializer.  Base initialization is done recursively.  Then, we
prepare the current process instance and allocate a random-number
generator for term selection.  For all unstable particles, we also
allocate a r.n.g. as spawned by the current process.
<<Decays: decay: TBP>>=
  procedure :: init => decay_init
<<Decays: procedures>>=
  recursive subroutine decay_init (decay, config)
    class(decay_t), intent(out) :: decay
    type(decay_config_t), intent(in), target :: config
    integer :: i
    call decay%base_init (config%term_config)
    decay%config => config
    allocate (decay%process_instance)
    call decay%process_instance%init (decay%config%process)
    call decay%process_instance%setup_event_data (decay%config%model)
    do i = 1, decay%config%process%get_n_mci ()
       call decay%process_instance%init_simulation (i)
    end do
    call decay%config%process%make_rng (decay%rng)
    call decay%make_term_rng (decay%config%process)
  end subroutine decay_init

@ %def decay_init
@ Link interactions to the parent process.  [[i_prt]] is the index of
the current outgoing particle in the parent interaction, for which we
take the trace evaluator.  We link it to the beam particle in the beam
interaction of the decay process instance.  Then, repeat the procedure
for the outgoing particles.
<<Decays: decay: TBP>>=
  procedure :: link_interactions => decay_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_link_interactions (decay, i_prt, trace)
    class(decay_t), intent(inout) :: decay
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    type(interaction_t), pointer :: beam_int
    integer :: n_in, n_vir
    beam_int => decay%process_instance%get_beam_int_ptr ()
    n_in = interaction_get_n_in (trace)
    n_vir = interaction_get_n_vir (trace)
    call interaction_set_source_link (beam_int, 1, trace, &
         n_in + n_vir + i_prt)
    call decay%link_term_interactions ()
  end subroutine decay_link_interactions
    
@ %def decay_link_interactions
@ Determine a decay chain.  For each unstable particle we select one
of the possible decay modes, and for each decay process we select one
of the possible decay MCI components, calling the random-number
generators.  We do not generate momenta, yet.
<<Decays: decay: TBP>>=
  procedure :: select_chain => decay_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_select_chain (decay)
    class(decay_t), intent(inout) :: decay
    real(default) :: x
    integer :: i
    call decay%rng%generate (x)
    decay%selected_mci = decay%config%mci_selector%select (x)
    call decay%process_instance%choose_mci (decay%selected_mci)
    call decay%process_instance%select_i_term (decay%selected_term)
    do i = 1, size (decay%term)
       call decay%term(i)%select_chain ()
    end do
  end subroutine decay_select_chain
  
@ %def decay_select_chain
@ Generate a decay.  We first receive the beam momenta from the parent
process (assuming that this is properly linked), then call the
associated process object for a new event.

Factor out the trace of the helicity density matrix of the isolated
state (the one that will be used for the decay chain).  The trace is
taken into account for unweighting the individual decay event and
should therefore be ignored for unweighting the correlated decay
chain afterwards.
<<Decays: decay: TBP>>=
  procedure :: generate => decay_generate
<<Decays: procedures>>=
  recursive subroutine decay_generate (decay)
    class(decay_t), intent(inout) :: decay
    type(isolated_state_t), pointer :: isolated_state
    integer :: i
    call decay%process_instance%receive_beam_momenta ()
    call decay%config%process%generate_unweighted_event &
         (decay%process_instance, decay%selected_mci)
    if (signal_is_pending ())  return
    call decay%process_instance%evaluate_event_data ()
    isolated_state => &
         decay%process_instance%get_isolated_state_ptr (decay%selected_term)
    call isolated_state%normalize_matrix_by_trace ()
    do i = 1, size (decay%term)
       call decay%term(i)%generate ()
       if (signal_is_pending ())  return
    end do
  end subroutine decay_generate
    
@ %def decay_generate
@
\subsection{Stable Particles}
This is a stable particle.  The flavor can be ambiguous (e.g., partons).
<<Decays: types>>=
  type, extends (any_config_t) :: stable_config_t
     type(flavor_t), dimension(:), allocatable :: flv
   contains
   <<Decays: stable config: TBP>>
  end type stable_config_t

@ %def stable_config_t
@ The finalizer is empty:
<<Decays: stable config: TBP>>=
  procedure :: final => stable_config_final
<<Decays: procedures>>=
  subroutine stable_config_final (object)
    class(stable_config_t), intent(inout) :: object
  end subroutine stable_config_final
  
@ %def stable_config_final
@ Output.
<<Decays: stable config: TBP>>=
  procedure :: write => stable_config_write
<<Decays: procedures>>=
  recursive subroutine stable_config_write (object, unit, indent, verbose)
    class(stable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A)", advance = "no")  "Stable:"
    write (u, "(1x,A)", advance = "no")  char (flavor_get_name (object%flv(1)))
    do i = 2, size (object%flv)
       write (u, "(':',A)", advance = "no") &
            char (flavor_get_name (object%flv(i)))
    end do
    write (u, *)
  end subroutine stable_config_write
  
@ %def stable_config_write
@ Initializer.  We are presented with an array of flavors, but there may be
double entries which we remove, so we store only the distinct flavors.
<<Decays: stable config: TBP>>=
  procedure :: init => stable_config_init
<<Decays: procedures>>=
  subroutine stable_config_init (config, flv)
    class(stable_config_t), intent(out) :: config
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, dimension (size (flv)) :: pdg
    logical, dimension (size (flv)) :: mask
    integer :: i
    pdg = flavor_get_pdg (flv)
    mask(1) = .true.
    forall (i = 2 : size (pdg))
       mask(i) = all (pdg(i) /= pdg(1:i-1))
    end forall
    allocate (config%flv (count (mask)))
    config%flv = pack (flv, mask)
  end subroutine stable_config_init
  
@ %def stable_config_init
@ Here is the corresponding object instance.  Except for the pointer
to the configuration, there is no content.
<<Decays: types>>=
  type, extends (any_t) :: stable_t
     type(stable_config_t), pointer :: config => null ()
   contains
   <<Decays: stable: TBP>>
  end type stable_t

@ %def stable_t
@ The finalizer does nothing.
<<Decays: stable: TBP>>=
  procedure :: final => stable_final
<<Decays: procedures>>=
  subroutine stable_final (object)
    class(stable_t), intent(inout) :: object
  end subroutine stable_final

@ %def stable_final
@ We can delegate output to the configuration object.
<<Decays: stable: TBP>>=
  procedure :: write => stable_write
<<Decays: procedures>>=
  subroutine stable_write (object, unit, indent)
    class(stable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%config%write (unit, indent)
  end subroutine stable_write
  
@ %def stable_write
@ Initializer: just assign the configuration.
<<Decays: stable: TBP>>=
  procedure :: init => stable_init
<<Decays: procedures>>=
  subroutine stable_init (stable, config)
    class(stable_t), intent(out) :: stable
    type(stable_config_t), intent(in), target :: config
    stable%config => config
  end subroutine stable_init
  
@ %def stable_init
@
\subsection{Unstable Particles}
A branching configuration enables us to select among distinct decay
modes of a particle.  We store the particle flavor (with its implicit
link to a model), an array of decay configurations, and a selector object.

The total width, absolute and relative error are stored as
[[integral]], [[abs_error]], and [[rel_error]], respectively.

The flavor must be unique in this case.
<<Decays: types>>=
  type, extends (any_config_t) :: unstable_config_t
     type(flavor_t) :: flv
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: selector
     type(decay_config_t), dimension(:), allocatable :: decay_config
   contains
   <<Decays: unstable config: TBP>>
  end type unstable_config_t
  
@ %def unstable_config_t
@ Finalizer.  The branching configuration can be a recursive structure.
<<Decays: unstable config: TBP>>=
  procedure :: final => unstable_config_final
<<Decays: procedures>>=
  recursive subroutine unstable_config_final (object)
    class(unstable_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%final ()
       end do
    end if
  end subroutine unstable_config_final

@ %def unstable_config_final
@ Output.  Since this may be recursive, we include indentation.
<<Decays: unstable config: TBP>>=
  procedure :: write => unstable_config_write
<<Decays: procedures>>=
  recursive subroutine unstable_config_write (object, unit, indent, verbose)
    class(unstable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A,1x,A)")  "Unstable:", &
         char (flavor_get_name (object%flv))
    call write_indent (u, ind)
    write (u, 1)  "total width =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs) =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel) =", object%rel_error
1   format (5x,A,ES19.12)
    if (verb .and. allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine unstable_config_write
  
@ %def unstable_config_write
@ Initializer.  For the unstable particle, the flavor is unique.
<<Decays: unstable config: TBP>>=
  procedure :: init => unstable_config_init
<<Decays: procedures>>=
  subroutine unstable_config_init (config, flv)
    class(unstable_config_t), intent(out) :: config
    type(flavor_t), intent(in) :: flv
    config%flv = flv
  end subroutine unstable_config_init
  
@ %def unstable_config_init
@ Further initialization: determine the number of decay modes.  We can assume
that the flavor of the particle has been set already.

If the process stack is given, we can delve recursively into actually
assigning decay processes.  Otherwise, we just initialize with decay
process names.
<<Decays: unstable config: TBP>>=
  procedure :: init_decays => unstable_config_init_decays
<<Decays: procedures>>=
  recursive subroutine unstable_config_init_decays &
       (unstable, decay_id, model, process_stack)
    class(unstable_config_t), intent(inout) :: unstable
    type(string_t), dimension(:), intent(in) :: decay_id
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    integer :: i
    allocate (unstable%decay_config (size (decay_id)))
    do i = 1, size (decay_id)
       associate (decay => unstable%decay_config(i))
         if (present (process_stack)) then
            call decay%connect (process_stack%get_process_ptr (decay_id(i)), &
                 model, process_stack)
         else
            call decay%init (model, decay_id(i))
         end if
       end associate
    end do
  end subroutine unstable_config_init_decays
  
@ %def unstable_config_init
@ Compute the total width and branching ratios, initializing the decay
selector.
<<Decays: unstable config: TBP>>=
  procedure :: compute => unstable_config_compute
<<Decays: procedures>>=
  recursive subroutine unstable_config_compute (unstable)
    class(unstable_config_t), intent(inout) :: unstable
    integer :: i
    do i = 1, size (unstable%decay_config)
       call unstable%decay_config(i)%compute ()
    end do
    unstable%integral = sum (unstable%decay_config%integral)
    if (unstable%integral <= 0) then
       call unstable%write ()
       call msg_fatal ("Decay configuration: computed total width is zero")
    end if
    unstable%abs_error = sqrt (sum (unstable%decay_config%abs_error ** 2))
    unstable%rel_error = unstable%abs_error / unstable%integral
    call unstable%selector%init (unstable%decay_config%integral)
    do i = 1, size (unstable%decay_config)
       unstable%decay_config(i)%weight &
            = unstable%selector%get_weight (i)
    end do
  end subroutine unstable_config_compute
    
@ %def unstable_config_compute
@
Now we define the instance of an unstable particle.
<<Decays: types>>=
  type, extends (any_t) :: unstable_t
     type(unstable_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_decay = 0
     type(decay_t), dimension(:), allocatable :: decay
   contains
   <<Decays: unstable: TBP>>
  end type unstable_t
  
@ %def unstable_t
@ Recursive finalizer.
<<Decays: unstable: TBP>>=
  procedure :: final => unstable_final
<<Decays: procedures>>=
  recursive subroutine unstable_final (object)
    class(unstable_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay)) then
       do i = 1, size (object%decay)
          call object%decay(i)%final ()
       end do
    end if
  end subroutine unstable_final
  
@ %def unstable_final
@ Output.
<<Decays: unstable: TBP>>=
  procedure :: write => unstable_write
<<Decays: procedures>>=
  recursive subroutine unstable_write (object, unit, indent)
    class(unstable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose=.false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 2)
    end if
    call write_indent (u, ind)
    if (object%selected_decay > 0) then
       write (u, "(5x,A,I0)") "Sel. decay  = ", object%selected_decay
       call object%decay(object%selected_decay)%write (u, ind + 1)
    else
       write (u, "(5x,A)")  "Sel. decay  = [undefined]"
    end if
  end subroutine unstable_write
    
@ %def unstable_write
@ Write the embedded process instances.
<<Decays: unstable: TBP>>=
  procedure :: write_process_instances => unstable_write_process_instances
<<Decays: procedures>>=
  recursive subroutine unstable_write_process_instances &
       (unstable, unit, verbose)
    class(unstable_t), intent(in) :: unstable
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    if (unstable%selected_decay > 0) then
       call unstable%decay(unstable%selected_decay)% &
            write_process_instances (unit, verbose)
    end if
  end subroutine unstable_write_process_instances
  
@ %def unstable_write_process_instances
@ Initialization, using the configuration object.
<<Decays: unstable: TBP>>=
  procedure :: init => unstable_init
<<Decays: procedures>>=
  recursive subroutine unstable_init (unstable, config)
    class(unstable_t), intent(out) :: unstable
    type(unstable_config_t), intent(in), target :: config
    integer :: i
    unstable%config => config
    allocate (unstable%decay (size (config%decay_config)))
    do i = 1, size (config%decay_config)
       call unstable%decay(i)%init (config%decay_config(i))
    end do
  end subroutine unstable_init
  
@ %def unstable_init
@ Recursively link interactions to the parent process.  [[i_prt]] is
the index of the current outgoing particle in the parent interaction.
<<Decays: unstable: TBP>>=
  procedure :: link_interactions => unstable_link_interactions
<<Decays: procedures>>=
  recursive subroutine unstable_link_interactions (unstable, i_prt, trace)
    class(unstable_t), intent(inout) :: unstable
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (unstable%decay)
       call unstable%decay(i)%link_interactions (i_prt, trace)
    end do
  end subroutine unstable_link_interactions
    
@ %def unstable_link_interactions
@ Import the random-number generator state.
<<Decays: unstable: TBP>>=
  procedure :: import_rng => unstable_import_rng
<<Decays: procedures>>=
  subroutine unstable_import_rng (unstable, rng)
    class(unstable_t), intent(inout) :: unstable
    class(rng_t), intent(inout), allocatable :: rng
    call move_alloc (from = rng, to = unstable%rng)
  end subroutine unstable_import_rng
  
@ %def unstable_import_rng
@ Generate a decay chain.  First select a decay mode, then call the
[[select_chain]] method of the selected mode.
<<Decays: unstable: TBP>>=
  procedure :: select_chain => unstable_select_chain
<<Decays: procedures>>=
  recursive subroutine unstable_select_chain (unstable)
    class(unstable_t), intent(inout) :: unstable
    real(default) :: x
    call unstable%rng%generate (x)
    unstable%selected_decay = unstable%config%selector%select (x)
    call unstable%decay(unstable%selected_decay)%select_chain ()
  end subroutine unstable_select_chain
    
@ %def unstable_select_chain
@ Generate a decay event.
<<Decays: unstable: TBP>>=
  procedure :: generate => unstable_generate
<<Decays: procedures>>=
  recursive subroutine unstable_generate (unstable)
    class(unstable_t), intent(inout) :: unstable
    call unstable%decay(unstable%selected_decay)%generate ()
  end subroutine unstable_generate
    
@ %def unstable_generate
@
\subsection{Decay Chain}
While the decay configuration tree and the decay tree are static
entities (during a simulation run), the decay chain is dynamically
generated for each event.  The reason is that with the possibility of
several decay modes for each particle, and several terms for each
process, the total number of distinct decay chains is not under control.

Each entry in the decay chain is a connected parton state.  The origin
of the chain is a connected state in the parent process (not part of
the chain itself).  For each decay, mode and term chosen, we convolute
this with the isolated (!) state of the current decay, to generate a
new connected state.  We accumulate this chain by recursively
traversing the allocated decay tree.  Whenever a particle decays, it
becomes virtual and is replaced by its decay product, while all other
particles stay in the parton state as spectators.

Technically, we implement the decay chain as a stack structure and
include information from the associated decay object for easier
debugging.  This is a decay chain entry:
<<Decays: types>>=
  type, extends (connected_state_t) :: decay_chain_entry_t
     integer :: index = 0
     type(decay_config_t), pointer :: config => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
     type(decay_chain_entry_t), pointer :: previous => null ()
  end type decay_chain_entry_t
     
@ %def decay_chain_entry_t
@ This is the complete chain; we need just a pointer to the last
entry.  We also include a pointer to the master process instance,
which serves as the seed for the decay chain.  

The evaluator [[correlated_trace]] traces over all quantum numbers
for the final spin-correlated (but color-summed) evaluator of the
decay chain.  This allows us to compute the probability for a momentum
configuration, given that all individual density matrices (of the
initial process and the subsequent decays) have been normalized to one.

Note: This trace is summed over color, so color is treated exactly
when computing spin correlations.  However, we do not keep
non-diagonal color correlations.  When an event is accepted, we
compute probabilities for all color states and can choose one of them.
<<Decays: types>>=
  type :: decay_chain_t
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_term = 0
     type(evaluator_t) :: correlated_trace
     type(decay_chain_entry_t), pointer :: last => null ()
   contains
   <<Decays: decay chain: TBP>>
  end type decay_chain_t
  
@ %def decay_chain_t
@ The finalizer recursively deletes and deallocates the entries.
<<Decays: decay chain: TBP>>=
  procedure :: final => decay_chain_final
<<Decays: procedures>>=
  subroutine decay_chain_final (object)
    class(decay_chain_t), intent(inout) :: object
    type(decay_chain_entry_t), pointer :: entry
    do while (associated (object%last))
       entry => object%last
       object%last => entry%previous
       call entry%final ()
       deallocate (entry)
    end do
    call evaluator_final (object%correlated_trace)
  end subroutine decay_chain_final
  
@ %def decay_chain_final
@ Doing output recursively allows us to display the chain in
chronological order.
<<Decays: decay chain: TBP>>=
  procedure :: write => decay_chain_write
<<Decays: procedures>>=
  subroutine decay_chain_write (object, unit)
    class(decay_chain_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Decay chain:"
    call write_entries (object%last)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Evaluator (correlated trace of the decay chain):"
    call write_separator (u)
    call object%correlated_trace%write (u)
    call write_separator (u, 2)
  contains
    recursive subroutine write_entries (entry)
      type(decay_chain_entry_t), intent(in), pointer :: entry
      if (associated (entry)) then
         call write_entries (entry%previous)
         call write_separator (u, 2)
         write (u, "(1x,A,I0)")  "Decay #", entry%index
         call entry%config%write_header (u)
         write (u, "(3x,A,I0)")  "Selected MCI    = ", entry%selected_mci
         write (u, "(3x,A,I0)")  "Selected term   = ", entry%selected_term
         call entry%config%term_config(entry%selected_term)%write (u, indent=1)
         call entry%write (u)
      end if
    end subroutine write_entries
  end subroutine decay_chain_write
    
@ %def decay_chain_write
@
Build a decay chain, recursively following the selected decays and
terms in a decay tree.  Before start, we finalize the chain, deleting
any previous contents.
<<Decays: decay chain: TBP>>=
  procedure :: build => decay_chain_build
<<Decays: procedures>>=
  subroutine decay_chain_build (chain, decay_root)
    class(decay_chain_t), intent(inout), target :: chain
    type(decay_root_t), intent(in) :: decay_root
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(interaction_t), pointer :: int_last_decay
    call chain%final ()
    if (decay_root%selected_term > 0) then
       chain%process_instance => decay_root%process_instance
       chain%selected_term = decay_root%selected_term
       call chain%build_term_entries (decay_root%term(decay_root%selected_term))
    end if
    int_last_decay => chain%last%get_matrix_int_ptr ()
    allocate (qn_mask (interaction_get_n_tot (int_last_decay)))
    call quantum_numbers_mask_init (qn_mask, &
         mask_f = .true., mask_c = .true., mask_h = .true.)
    call evaluator_init_qn_sum (chain%correlated_trace, int_last_decay, qn_mask)
  end subroutine decay_chain_build
    
@ %def decay_chain_build
@ Build the entries that correspond to a decay term.  We have to scan
all unstable particles.
<<Decays: decay chain: TBP>>=
  procedure :: build_term_entries => decay_chain_build_term_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_term_entries (chain, term)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_term_t), intent(in) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          if (unstable%selected_decay > 0) then
             call chain%build_decay_entries &
                  (unstable%decay(unstable%selected_decay))
          end if
       end select
    end do
  end subroutine decay_chain_build_term_entries
  
@ %def decay_chain_build_term_entries
@ Build the entries that correspond to a specific decay.  The
decay term should have been determined, so we allocate a decay chain
entry and fill it, then proceed to child decays.

For the first entry, we convolute the connected state of the parent process
instance with the isolated state of the current
decay (which does not contain an extra beam entry for the parent).
For subsequent entries, we take the previous entry as first factor.

In principle, each chain entry (as a parton state) is capable of
holding a subevent object and associated expressions.  We currently do
not make use of that feature.

Before generating the decays, factor out the trace of the helicity
density matrix of the parent parton state.  This trace has
been used for unweighting the original event (unweighted case) or it
determines the overall weight, so it should not be taken into account
in the decay chain generation.
<<Decays: decay chain: TBP>>=
  procedure :: build_decay_entries => decay_chain_build_decay_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_decay_entries (chain, decay)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_t), intent(in) :: decay
    type(decay_chain_entry_t), pointer :: entry
    type(connected_state_t), pointer :: previous_state
    type(isolated_state_t), pointer :: current_decay
    allocate (entry)
    if (associated (chain%last)) then
       entry%previous => chain%last
       entry%index = entry%previous%index + 1
       previous_state => entry%previous%connected_state_t
    else
       entry%index = 1
       previous_state => &
            chain%process_instance%get_connected_state_ptr (chain%selected_term)
    end if
    entry%config => decay%config
    entry%selected_mci = decay%selected_mci
    entry%selected_term = decay%selected_term
    current_decay => decay%process_instance%get_isolated_state_ptr &
         (decay%selected_term)
    call entry%setup_connected_trace &
         (current_decay, previous_state%get_trace_int_ptr (), resonant=.true.)
    call entry%setup_connected_matrix &
         (current_decay, previous_state%get_matrix_int_ptr (), resonant=.true.)
    call entry%setup_connected_flows &
         (current_decay, previous_state%get_flows_int_ptr (), resonant=.true.)
    chain%last => entry
    call chain%build_term_entries (decay%term(decay%selected_term))
  end subroutine decay_chain_build_decay_entries
    
@ %def decay_chain_build_decay_entries
@ Recursively fill the decay chain with momenta and evaluate the
matrix elements.  Since all evaluators should have correct source
entries at this point, momenta are automatically retrieved from the
appropriate process instance.


Like we did above for the parent process, factor out the trace for
each subsequent decay (the helicity density matrix in the isolated
state, which is taken for the convolution).
<<Decays: decay chain: TBP>>=
  procedure :: evaluate => decay_chain_evaluate
<<Decays: procedures>>=
  subroutine decay_chain_evaluate (chain)
    class(decay_chain_t), intent(inout) :: chain
    call evaluate (chain%last)
    call evaluator_receive_momenta (chain%correlated_trace)
    call chain%correlated_trace%evaluate ()
  contains
    recursive subroutine evaluate (entry)
      type(decay_chain_entry_t), intent(inout), pointer :: entry
      if (associated (entry)) then
         call evaluate (entry%previous)
         call entry%receive_kinematics ()
         call entry%evaluate_trace ()
         call entry%evaluate_event_data ()
      end if
    end subroutine evaluate
  end subroutine decay_chain_evaluate
  
@ %def decay_chain_evaluate
@ Return the probability of a decay chain.  This is given as the trace
of the density matrix with intermediate helicity correlations,
normalized by the product of the uncorrelated density matrix traces.  This
works only if an event has been evaluated and the [[correlated_trace]]
evaluator is filled.  By definition, this evaluator has only one
matrix element, and this must be real.
<<Decays: decay chain: TBP>>=
  procedure :: get_probability => decay_chain_get_probability
<<Decays: procedures>>=
  function decay_chain_get_probability (chain) result (x)
    class(decay_chain_t), intent(in) :: chain
    real(default) :: x
    x = evaluator_get_matrix_element (chain%correlated_trace, 1)
  end function decay_chain_get_probability
  
@ %def decay_chain_get_probability
@
\subsection{Decay as Event Transform}
The [[evt_decay]] object combines decay configuration, decay tree, and
chain in a single object, as an implementation of the [[evt]] (event
transform) abstract type.
<<Decays: public>>=
  public :: evt_decay_t
<<Decays: types>>=
  type, extends (evt_t) :: evt_decay_t
     type(decay_root_config_t) :: decay_root_config
     type(decay_root_t) :: decay_root
     type(decay_chain_t) :: decay_chain
   contains
   <<Decays: evt decay: TBP>>
  end type evt_decay_t
  
@ %def evt_decay_t
@ Output.  We display the currently selected decay tree, which
includes configuration data, and the decay chain, i.e., the evaluators.
<<Decays: evt decay: TBP>>=
  procedure :: write => evt_decay_write
<<Decays: procedures>>=
  subroutine evt_decay_write (object, unit, &
       show_decay_tree, &
       show_processes, &
       verbose)
    class(evt_decay_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_decay_tree, show_processes, verbose
    logical :: dec, prc, verb
    integer :: u
    u = given_output_unit (unit)
    dec = .true.;  if (present (show_decay_tree))  dec = show_decay_tree
    prc = .false.;  if (present (show_processes))  prc = show_processes
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: partonic decays"
    call write_separator (u, 2)
    call object%base_write (u)
    if (dec) then
       call write_separator (u)
       call object%decay_root%write (u)
       if (verb) then
          call object%decay_chain%write (u)
       end if
       if (prc) then
          call object%decay_root%write_process_instances (u, verb)
       end if
    else
       call write_separator (u, 2)
    end if
  end subroutine evt_decay_write
    
@ %def evt_decay_write
@ Connect with a process instance and process.  This initializes the
decay configuration.  The process stack is used to look for process
objects that implement daughter decays.

When all processes are assigned, configure the decay tree instance, using the
decay tree configuration.  First obtain the branching ratios, then allocate
the decay tree.  This is done once for all events.
<<Decays: evt decay: TBP>>=
  procedure :: connect => evt_decay_connect
<<Decays: procedures>>=
  subroutine evt_decay_connect (evt, process_instance, model, process_stack)
    class(evt_decay_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model)
    call evt%decay_root_config%connect (process_instance%process, &
         model, process_stack, process_instance)
    call evt%decay_root_config%compute ()
    call evt%decay_root%init (evt%decay_root_config, evt%process_instance)
  end subroutine evt_decay_connect
  
@ %def evt_decay_connect
@ Prepare a new event: Select a decay chain and build the corresponding chain
object.
<<Decays: evt decay: TBP>>=
  procedure :: prepare_new_event => evt_decay_prepare_new_event
<<Decays: procedures>>=
  subroutine evt_decay_prepare_new_event (evt, i_mci, i_term)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    evt%decay_root%selected_mci = i_mci
    evt%decay_root%selected_term = i_term
    call evt%decay_root%select_chain ()
    call evt%decay_chain%build (evt%decay_root)
  end subroutine evt_decay_prepare_new_event
  
@ %def evt_decay_prepare_new_event
@ Generate a weighted event and assign the resulting weight
(probability).  We use a chain initialized by the preceding
subroutine, fill it with momenta and evaluate.
<<Decays: evt decay: TBP>>=
  procedure :: generate_weighted => evt_decay_generate_weighted
<<Decays: procedures>>=
  subroutine evt_decay_generate_weighted (evt, probability)
    class(evt_decay_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    call evt%decay_root%generate ()
    if (signal_is_pending ())  return
    call evt%decay_chain%evaluate ()
    probability = evt%decay_chain%get_probability ()
  end subroutine evt_decay_generate_weighted
  
@ %def evt_decay_generate_weighted
@ To create a usable event, we have to transform the interaction into a
particle set; this requires factorization for the correlated density matrix,
according to the factorization mode.
<<Decays: evt decay: TBP>>=
  procedure :: make_particle_set => evt_decay_make_particle_set
<<Decays: procedures>>=
  subroutine evt_decay_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(interaction_t), pointer :: int_matrix, int_flows
    type(decay_chain_entry_t), pointer :: last_entry
    last_entry => evt%decay_chain%last
    int_matrix => last_entry%get_matrix_int_ptr ()
    int_flows  => last_entry%get_flows_int_ptr ()
    call evt%factorize_interactions (int_matrix, int_flows, &
         factorization_mode, keep_correlations, r)
    call evt%tag_incoming ()
  end subroutine evt_decay_make_particle_set
    
@ %def event_decay_make_particle_set
@
Eliminate numerical noise for the associated process instances.
<<Decays: public>>=
  public :: pacify
<<Decays: interfaces>>=
  interface pacify
     module procedure pacify_decay
  end interface pacify
<<Decays: procedures>>=
  subroutine pacify_decay (evt)
    class(evt_decay_t), intent(inout) :: evt
    call pacify_decay_gen (evt%decay_root)
  contains
    recursive subroutine pacify_decay_gen (decay)
      class(decay_gen_t), intent(inout) :: decay
      if (associated (decay%process_instance)) then
         call pacify (decay%process_instance)
      end if
      if (decay%selected_term > 0) then
         call pacify_term (decay%term(decay%selected_term))
      end if
    end subroutine pacify_decay_gen
    recursive subroutine pacify_term (term)
      class(decay_term_t), intent(inout) :: term
      integer :: i
      do i = 1, size (term%particle_out)
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t);  call pacify_unstable (unstable)
         end select
      end do
    end subroutine pacify_term
    recursive subroutine pacify_unstable (unstable)
      class(unstable_t), intent(inout) :: unstable
      if (unstable%selected_decay > 0) then
         call pacify_decay_gen (unstable%decay(unstable%selected_decay))
      end if
    end subroutine pacify_unstable
  end subroutine pacify_decay
  
@ %def pacify
@
\subsection{Unit tests}
<<Decays: public>>=
  public :: decays_test
<<Decays: tests>>=
  subroutine decays_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Decays: execute tests>>
  end subroutine decays_test
  
@ %def decays_test
@
\subsubsection{Testbed}
As a variation of the [[prepare_test_process]] routine used elsewhere, we
define here a routine that creates two processes (scattering $ss\to ss$ and
decay $s\to f\bar f$), compiles and integrates them and prepares for event
generation. 
<<Decays: public>>=
  public :: prepare_testbed
<<Decays: tests>>=
  subroutine prepare_testbed &
       (lib, process_stack, model_list, model, prefix, os_data, &
        scattering, decay, decay_rest_frame)
    type(process_library_t), intent(out), target :: lib
    type(process_stack_t), intent(out) :: process_stack
    type(model_list_t), intent(out) :: model_list
    type(model_t), pointer, intent(out) :: model
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: scattering, decay
    logical, intent(in), optional :: decay_rest_frame
    type(string_t) :: libname, procname1, procname2, run_id
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(var_list_t), pointer :: var_list
    type(process_entry_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(field_data_t), pointer :: field_data
    real(default) :: sqrts

    libname = prefix // "_lib"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    run_id = prefix

    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()
    call var_list_set_real (var_list, &
         var_str ("ff"), 0.4_default, is_known = .true.)
    call model%update_parameters ()

    if (scattering .and. decay) then
       field_data => model%get_field_ptr (25)
       call field_data%set (p_is_stable = .false.)
    end if
    
    call prc_test_create_library (libname, lib, &
         scattering = .true., decay = .true., &
         procname1 = procname1, procname2 = procname2)

    call reset_interaction_counter ()

    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    if (scattering) then
       allocate (rng_test_factory_t :: rng_factory)
       allocate (process)
       call process%init (procname1, &
            run_id, lib, os_data, qcd, rng_factory, model_list)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       sqrts = 1000
       call process%setup_beams_sqrts (sqrts)
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
    if (decay) then
       allocate (rng_test_factory_t :: rng_factory)
       allocate (process)
       call process%init (procname2, &
            run_id, lib, os_data, qcd, rng_factory, model_list)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       if (present (decay_rest_frame)) then
          call process%setup_beams_decay (rest_frame = decay_rest_frame)
       else
          call process%setup_beams_decay (rest_frame = .not. scattering)
       end if
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
  end subroutine prepare_testbed

@ %def prepare_testbed
@
\subsubsection{Simple decay configuration}
We define a branching configuration with two decay modes.  We set the
integral values by hand, so we do not need to evaluate processes, yet.
<<Decays: execute tests>>=
  call test (decays_1, "decays_1", &
       "branching and decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_t), pointer :: model
    type(model_list_t) :: model_list
    type(flavor_t) :: flv_h
    type(flavor_t), dimension(2,1) :: flv_hbb, flv_hgg
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_1"
    write (u, "(A)")  "*   Purpose: Set up branching and decay configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM"), &
         var_str ("SM.mdl"), os_data, model)

    call flavor_init (flv_h, 25, model)
    call flavor_init (flv_hbb(:,1), [5, -5], model)
    call flavor_init (flv_hgg(:,1), [22, 22], model)

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call unstable%init_decays ([var_str ("h_bb"), var_str ("h_gg")], model)
    
    associate (decay => unstable%decay_config(1))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hbb, stable = [.true., .true.], model=model)
      decay%integral = 1.234e-3_default
      decay%abs_error = decay%integral * .02_default
    end associate
    
    associate (decay => unstable%decay_config(2))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hgg, stable = [.true., .true.], model=model)
      decay%integral = 3.085e-4_default
      decay%abs_error = decay%integral * .08_default
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_1"
    
  end subroutine decays_1
  
@ %def decays_1
@
\subsubsection{Cascade decay configuration}
We define a branching configuration with one decay, which is followed
by another branching.
<<Decays: execute tests>>=
  call test (decays_2, "decays_2", &
       "cascade decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_t), pointer :: model
    type(model_list_t) :: model_list
    type(flavor_t) :: flv_h, flv_wp, flv_wm
    type(flavor_t), dimension(2,1) :: flv_hww, flv_wud, flv_wen
    type(unstable_config_t), allocatable :: unstable
    type(string_t), dimension(:), allocatable :: decay

    write (u, "(A)")  "* Test output: decays_2"
    write (u, "(A)")  "*   Purpose: Set up cascade branching"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM"), &
         var_str ("SM.mdl"), os_data, model)

    call model%set_unstable (25, [var_str ("h_ww")])
    call model%set_unstable (24, [var_str ("w_ud"), var_str ("w_en")])

    call flavor_init (flv_h, 25, model)
    call flavor_init (flv_hww(:,1), [24, -24], model)
    call flavor_init (flv_wp, 24, model)
    call flavor_init (flv_wm,-24, model)
    call flavor_init (flv_wud(:,1), [2, -1], model)
    call flavor_init (flv_wen(:,1), [-11, 12], model)
    

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call flavor_get_decays (unstable%flv, decay)
    call unstable%init_decays (decay, model)
    
    associate (decay => unstable%decay_config(1))

      decay%integral = 1.e-3_default
      decay%abs_error = decay%integral * .01_default

      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hww, stable = [.false., .true.], model=model)

      select type (w => decay%term_config(1)%prt(1)%c)
      type is (unstable_config_t)

         associate (w_decay => w%decay_config(1))
           w_decay%integral = 2._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wud, stable = [.true., .true.], &
                model=model)
         end associate
         associate (w_decay => w%decay_config(2))
           w_decay%integral = 1._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wen, stable = [.true., .true.], &
                model=model)
         end associate
         call w%compute ()

      end select
      
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_2"
    
  end subroutine decays_2
  
@ %def decays_2
@
\subsubsection{Decay and Process Object}
We define a branching configuration with one decay and connect this
with an actual process object.
<<Decays: execute tests>>=
  call test (decays_3, "decays_3", &
       "associate process", &
       u, results)
<<Decays: tests>>=
  subroutine decays_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix
    type(string_t) :: procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_3"
    write (u, "(A)")  "*   Purpose: Connect a decay configuration &
         &with a process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and integrate process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call syntax_model_file_init ()

    prefix = "decays_3"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame=.false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    call flavor_init (unstable%flv, 25, model)
    call unstable%init_decays ([procname2], model)
    
    write (u, "(A)")  "* Connect decay with process object"
    write (u, "(A)")

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call process_stack%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_3"
    
  end subroutine decays_3

@ %def decays_3
@
\subsubsection{Decay and Process Object}
Building upon the previous test, we set up a decay instance and generate a
decay event.
<<Decays: execute tests>>=
  call test (decays_4, "decays_4", &
       "decay instance", &
       u, results)
<<Decays: tests>>=
  subroutine decays_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname2
    class(rng_t), allocatable :: rng
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable, target :: unstable
    type(unstable_t), allocatable :: instance

    write (u, "(A)")  "* Test output: decays_4"
    write (u, "(A)")  "*   Purpose: Create a decay process and evaluate &
         &an instance"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment, process, &
         &and decay configuration"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call syntax_model_file_init ()

    prefix = "decays_4"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame = .false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)

    allocate (unstable)
    call flavor_init (unstable%flv, 25, model)
    call unstable%init_decays ([procname2], model)
    
    call model%set_unstable (25, [procname2])

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()

    allocate (rng_test_t :: rng)

    allocate (instance)
    call instance%init (unstable)
    call instance%import_rng (rng)

    call instance%select_chain ()
    call instance%generate ()
    call instance%write (u)

    write (u, *)
    call instance%write_process_instances (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call instance%final ()
    call process_stack%final ()
    call unstable%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_4"
    
  end subroutine decays_4

@ %def decays_4
@
\subsubsection{Decay with Parent Process}
We define a scattering process $ss\to ss$ and subsequent decays $s\to f\bar
f$.
<<Decays: execute tests>>=
  call test (decays_5, "decays_5", &
       "parent process and decay", &
       u, results)
<<Decays: tests>>=
  subroutine decays_5 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(decay_root_config_t), target :: decay_root_config
    type(decay_root_t) :: decay_root
    type(decay_chain_t) :: decay_chain
    integer :: i

    write (u, "(A)")  "* Test output: decays_5"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call syntax_model_file_init ()

    prefix = "decays_5"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"
    write (u, "(A)")

    call model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize decay tree configuration"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname1)
    call decay_root_config%connect (process, model, process_stack)
    call decay_root_config%compute ()
    call decay_root_config%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay tree"

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    call decay_root%init (decay_root_config, process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain"
    write (u, "(A)")

    decay_root%selected_mci = 1
    !!! Not yet implemented; there is only one term anyway:
    ! call process_instance%select_i_term (decay_root%selected_term)
    decay_root%selected_term = 1
    call decay_root%select_chain ()

    call decay_chain%build (decay_root)
    
    call decay_root%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call process%generate_unweighted_event (process_instance, &
         decay_root%selected_mci)
    call process_instance%evaluate_event_data ()
    
    call decay_root%generate ()
    
    associate (term => decay_root%term(1))
      do i = 1, 2
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t)
            associate (decay => unstable%decay(1))
              call pacify (decay%process_instance)
            end associate
         end select
      end do
    end associate
    
    write (u, "(A)")  "* Process instances"
    write (u, "(A)")
    
    call decay_root%write_process_instances (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay chain"
    write (u, "(A)")
    
    call decay_chain%evaluate ()
    call decay_chain%write (u)

    write (u, *)
    write (u, "(A,ES19.12)")  "chain probability =", &
         decay_chain%get_probability ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call decay_chain%final ()
    call decay_root%final ()
    call decay_root_config%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    call process_stack%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_5"
    
  end subroutine decays_5

@ %def decays_5
@
\subsubsection{Decay as Event Transform}
Again, we define a scattering process $ss\to ss$ and subsequent decays
$s\to f\bar f$.
<<Decays: execute tests>>=
  call test (decays_6, "decays_6", &
       "evt_decay object", &
       u, results)
<<Decays: tests>>=
  subroutine decays_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(evt_decay_t), target :: evt_decay
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: decays_6"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)

    prefix = "decays_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    call model%set_unstable (25, [procname2])

    process => process_stack%get_process_ptr (procname1)
    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay object"

    call evt_decay%connect (process_instance, model, process_stack)

    write (u, "(A)")
    write (u, "(A)")  "* Generate scattering event"

    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain and generate event"
    write (u, "(A)")

    call evt_decay%prepare_new_event (1, 1)
    call evt_decay%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_decay%make_particle_set (factorization_mode, keep_correlations)

    call evt_decay%write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_decay%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process_stack%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_6"
    
  end subroutine decays_6

@ %def decays_6
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shower}
<<[[shower.f90]]>>=
<<File header>>

module shower

  use kinds, only: default, double
<<Use strings>>
  use io_units
  use constants, only: pi, twopi
  use format_utils, only: write_separator
  use unit_tests
  use system_defs, only: LF
  use diagnostics
  use lorentz
  
  use shower_base !NODEP!
  use shower_partons !NODEP!
  use shower_core !NODEP!
  use shower_topythia !NODEP!
  use muli, muli_output_unit => output_unit !NODEP!
  use mlm_matching !NODEP!
  use ckkw_pseudo_weights !NODEP!
  use ckkw_matching !NODEP!
  use tao_random_numbers !NODEP!
  use pdf_builtin !NODEP!

  use os_interface
  use xml
  
  use sm_qcd
  use flavors
  use colors
  use particles
  use state_matrices
  use subevents
  use models
  use variables
  use beam_structures
  use hep_common
  use process_libraries
  use prc_core
  use prc_omega
  use rng_base
  use rng_tao
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use processes
  use event_transforms

<<Standard module head>>

<<Shower: public>>

<<Shower: parameters>>

<<Shower: types>>

contains

<<Shower: procedures>>

<<Shower: tests>>

end module shower
@ %def shower
@
\subsection{PDF Parameters}
The shower has to know about the PDF set used for the parent process,
if any.  We support the following:
<<Shower: parameters>>=
  integer, parameter :: STRF_NONE = 0
  integer, parameter :: STRF_LHAPDF = 1
  integer, parameter :: STRF_PDF_BUILTIN = 2
  
@ %def STRF_NONE STRF_LHAPDF STRF_PDF_BUILTIN
@
\subsection{Configuration Parameters}
<<Shower: public>>=
  public :: shower_settings_t
<<Shower: types>>=
  type :: shower_settings_t
     logical :: ps_isr_active = .false.
     logical :: ps_fsr_active = .false.
     logical :: ps_use_PYTHIA_shower = .false.
     logical :: hadronization_active = .false.
     logical :: mlm_matching = .false.
     logical :: ckkw_matching = .false.
     logical :: muli_active = .false.

     logical :: ps_PYTHIA_verbose = .false.
     type(string_t) :: ps_PYTHIA_PYGIVE

     !!! values present in PYTHIA and WHIZARDs PS, 
     !!! comments denote corresponding PYTHIA values
     real(default) :: ps_mass_cutoff = 1._default      ! PARJ(82)
     real(default) :: ps_fsr_lambda = 0.29_default     ! PARP(72)
     real(default) :: ps_isr_lambda = 0.29_default     ! PARP(61)
     integer :: ps_max_n_flavors = 5                   ! MSTJ(45)
     logical :: ps_isr_alpha_s_running = .true.        ! MSTP(64)
     logical :: ps_fsr_alpha_s_running = .true.        ! MSTJ(44)
     real(default) :: ps_fixed_alpha_s = 0._default    ! PARU(111)
     logical :: ps_isr_pt_ordered = .false.
     logical :: ps_isr_angular_ordered = .true.        ! MSTP(62)
     real(default) :: ps_isr_primordial_kt_width = 0._default  ! PARP(91)
     real(default) :: ps_isr_primordial_kt_cutoff = 5._default ! PARP(93)
     real(default) :: ps_isr_z_cutoff = 0.999_default  ! 1-PARP(66)
     real(default) :: ps_isr_minenergy = 2._default    ! PARP(65)
     real(default) :: ps_isr_tscalefactor = 1._default
     logical :: ps_isr_only_onshell_emitted_partons = .true.   ! MSTP(63)

     !!! MLM settings
     type(mlm_matching_settings_t) :: ms

     !!! CKKW Matching
     type(ckkw_matching_settings_t) :: ckkw_settings
     type(ckkw_pseudo_shower_weights_t) :: ckkw_weights
   contains 
   <<Shower: shower settings: TBP>>  
  end type shower_settings_t

@ %def shower_settings_t
@ Read in the shower, matching and hadronization settings
<<Shower: shower settings: TBP>>=
  procedure :: init => shower_settings_init
<<Shower: procedures>>=
  subroutine shower_settings_init (shower_settings, var_list)
    class(shower_settings_t), intent(out) :: shower_settings
    type(var_list_t), intent(in) :: var_list

    shower_settings%ps_isr_active = &
         var_list_get_lval (var_list, var_str ("?ps_isr_active"))
    shower_settings%ps_fsr_active = &
         var_list_get_lval (var_list, var_str ("?ps_fsr_active"))
    shower_settings%hadronization_active = &
         var_list_get_lval (var_list, var_str ("?hadronization_active"))
    shower_settings%mlm_matching = &
         var_list_get_lval (var_list, var_str ("?mlm_matching"))
    shower_settings%ckkw_matching = & 
         var_list_get_lval (var_list, var_str ("?ckkw_matching"))
    shower_settings%muli_active = &
         var_list_get_lval (var_list, var_str ("?muli_active"))

    if (.not. shower_settings%ps_fsr_active .and. &
        .not. shower_settings%ps_isr_active .and. &
        .not. shower_settings%hadronization_active .and. &
        .not. shower_settings%mlm_matching) then
       return
    end if

    shower_settings%ps_use_PYTHIA_shower = &
         var_list_get_lval (var_list, var_str ("?ps_use_PYTHIA_shower"))
    shower_settings%ps_PYTHIA_verbose = &
         var_list_get_lval (var_list, var_str ("?ps_PYTHIA_verbose"))
    shower_settings%ps_PYTHIA_PYGIVE = &
         var_list_get_sval (var_list, var_str ("$ps_PYTHIA_PYGIVE"))
    shower_settings%ps_mass_cutoff = &
         var_list_get_rval (var_list, var_str ("ps_mass_cutoff"))
    shower_settings%ps_fsr_lambda = &
         var_list_get_rval (var_list, var_str ("ps_fsr_lambda"))
    shower_settings%ps_isr_lambda = &
         var_list_get_rval (var_list, var_str ("ps_isr_lambda"))
    shower_settings%ps_max_n_flavors = &
         var_list_get_ival (var_list, var_str ("ps_max_n_flavors"))
    shower_settings%ps_isr_alpha_s_running = &
         var_list_get_lval (var_list, var_str ("?ps_isr_alpha_s_running"))
    shower_settings%ps_fsr_alpha_s_running = &
         var_list_get_lval (var_list, var_str ("?ps_fsr_alpha_s_running"))
    shower_settings%ps_fixed_alpha_s = &
         var_list_get_rval (var_list, var_str ("ps_fixed_alpha_s"))
    shower_settings%ps_isr_pt_ordered = &
         var_list_get_lval (var_list, var_str ("?ps_isr_pt_ordered"))
    shower_settings%ps_isr_angular_ordered = &
         var_list_get_lval (var_list, var_str ("?ps_isr_angular_ordered"))
    shower_settings%ps_isr_primordial_kt_width = &
         var_list_get_rval (var_list, var_str ("ps_isr_primordial_kt_width"))
    shower_settings%ps_isr_primordial_kt_cutoff = &
         var_list_get_rval (var_list, var_str ("ps_isr_primordial_kt_cutoff"))
    shower_settings%ps_isr_z_cutoff = &
         var_list_get_rval (var_list, var_str ("ps_isr_z_cutoff"))
    shower_settings%ps_isr_minenergy = &
         var_list_get_rval (var_list, var_str ("ps_isr_minenergy"))
    shower_settings%ps_isr_tscalefactor = &
         var_list_get_rval (var_list, var_str ("ps_isr_tscalefactor"))
    shower_settings%ps_isr_only_onshell_emitted_partons = &
         var_list_get_lval (var_list, &
         var_str ("?ps_isr_only_onshell_emitted_partons"))

    !!! MLM matching
    shower_settings%ms%mlm_Qcut_ME = &
         var_list_get_rval(var_list, var_str ("mlm_Qcut_ME"))
    shower_settings%ms%mlm_Qcut_PS = &
         var_list_get_rval(var_list, var_str ("mlm_Qcut_PS"))
    shower_settings%ms%mlm_ptmin = &
         var_list_get_rval(var_list, var_str ("mlm_ptmin"))
    shower_settings%ms%mlm_etamax = &
         var_list_get_rval(var_list, var_str ("mlm_etamax"))
    shower_settings%ms%mlm_Rmin = &
         var_list_get_rval(var_list, var_str ("mlm_Rmin"))
    shower_settings%ms%mlm_Emin = &
         var_list_get_rval(var_list, var_str ("mlm_Emin"))
    shower_settings%ms%mlm_nmaxMEjets = &
         var_list_get_ival(var_list, var_str ("mlm_nmaxMEjets"))

    shower_settings%ms%mlm_ETclusfactor = &
         var_list_get_rval(var_list, var_str ("mlm_ETclusfactor"))
    shower_settings%ms%mlm_ETclusminE = &
         var_list_get_rval(var_list, var_str ("mlm_ETclusminE"))
    shower_settings%ms%mlm_etaclusfactor = &
         var_list_get_rval(var_list, var_str ("mlm_etaclusfactor"))
    shower_settings%ms%mlm_Rclusfactor = &
         var_list_get_rval(var_list, var_str ("mlm_Rclusfactor"))
    shower_settings%ms%mlm_Eclusfactor = &
         var_list_get_rval(var_list, var_str ("mlm_Eclusfactor"))

    !!! CKKW matching
    ! TODO
  end subroutine shower_settings_init

@ %def shower_settings_init
 
<<Shower: shower settings: TBP>>=
  procedure :: write => shower_settings_write
<<Shower: procedures>>=
  subroutine shower_settings_write (object, unit)
    class(shower_settings_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)")  "Shower settings:"
    call write_separator (u)
    write (u, "(1x,A)")  "Master switches:"
    write (u, "(3x,A,1x,L1)") &
         "ps_isr_active                = ", object%ps_isr_active
    write (u, "(3x,A,1x,L1)") &
         "ps_fsr_active                = ", object%ps_fsr_active
    write (u, "(1x,A)")  "General settings:"
    if (object%ps_isr_active .or. object%ps_fsr_active) then
       write (u, "(3x,A,1x,L1)") &
            "ps_use_PYTHIA_shower         = ", object%ps_use_PYTHIA_shower
       write (u, "(3x,A,ES19.12)") &
            "ps_mass_cutoff               = ", object%ps_mass_cutoff
       write (u, "(3x,A,1x,I1)") &
            "ps_max_n_flavors             = ", object%ps_max_n_flavors
    else
       write (u, "(3x,A)") " [ISR and FSR off]"
    end if
    if (object%ps_isr_active) then
       write (u, "(1x,A)")  "ISR settings:"
       write (u, "(3x,A,1x,L1)") &
            "ps_isr_pt_ordered            = ", object%ps_isr_pt_ordered
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_lambda                = ", object%ps_isr_lambda
       write (u, "(3x,A,1x,L1)") &
            "ps_isr_alpha_s_running       = ", object%ps_isr_alpha_s_running
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_primordial_kt_width   = ", object%ps_isr_primordial_kt_width
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_primordial_kt_cutoff  = ", &
            object%ps_isr_primordial_kt_cutoff
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_z_cutoff              = ", object%ps_isr_z_cutoff
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_minenergy             = ", object%ps_isr_minenergy
       write (u, "(3x,A,ES19.12)") &
            "ps_isr_tscalefactor          = ", object%ps_isr_tscalefactor
    else if (object%ps_fsr_active) then
       write (u, "(3x,A)") " [ISR off]"       
    end if
    if (object%ps_fsr_active) then
       write (u, "(1x,A)")  "FSR settings:"
       write (u, "(3x,A,ES19.12)") &
            "ps_fsr_lambda                = ", object%ps_fsr_lambda
       write (u, "(3x,A,1x,L1)") &
            "ps_fsr_alpha_s_running       = ", object%ps_fsr_alpha_s_running
    else if (object%ps_isr_active) then
       write (u, "(3x,A)") " [FSR off]"              
    end if
    write (u, "(1x,A)")  "Hadronization settings:"
    write (u, "(3x,A,1x,L1)") &
         "hadronization_active         = ", object%hadronization_active
    write (u, "(1x,A)")  "Matching Settings:"
    write (u, "(3x,A,1x,L1)") &
         "mlm_matching                 = ", object%mlm_matching
    if (object%mlm_matching) then
       call mlm_matching_settings_write (object%ms, u)
    end if
    write (u, "(3x,A,1x,L1)") &
         "ckkw_matching                = ", object%ckkw_matching
    if (object%ckkw_matching) then
       ! TODO ckkw settings etc.
    end if
    write (u, "(1x,A)")  "PYTHIA specific settings:"
    write (u, "(3x,A,1x,L1)") &
         "ps_PYTHIA_verbose            = ", object%ps_PYTHIA_verbose
    write (u, "(3x,A,A,A)") &
         "ps_PYTHIA_PYGIVE             =  '", &
         char(object%ps_PYTHIA_PYGIVE), "'"
  end subroutine shower_settings_write

@ %def shower_settings_write
@ 
\subsection{Shower Application Interface}
The wrapper subroutine for the shower and the hadronization
interface and MLM matching. This should be the only subroutine called
from WHIZARD. 
<<Shower: public>>=
  public :: apply_shower_particle_set
<<Shower: procedures>>=
  subroutine apply_shower_particle_set & 
       (particle_set, shower_settings,  model, model_hadrons, &
        os_data, pdf_type, pdf_set, valid, vetoed)
    type(particle_set_t), intent(inout) :: particle_set
    type(shower_settings_t), intent(in) :: shower_settings
    type(model_t), intent(in), target :: model
    type(model_t), intent(in), target :: model_hadrons
    type(os_data_t), intent(in) :: os_data
    integer, intent(in) :: pdf_type
    integer, intent(in) :: pdf_set
    logical, intent(inout) :: valid
    logical, intent(inout) :: vetoed
    real(kind=double) :: pdftest
    logical, parameter :: debug = .true., to_file = .false.

    type(mlm_matching_data_t) :: mlm_matching_data
    logical, save :: matching_disabled=.false.
    procedure(shower_pdf), pointer :: pdf_func => null()

    interface
       subroutine evolvePDFM (set, x, q, ff)
         integer, intent(in) :: set
         double precision, intent(in) :: x, q
         double precision, dimension(-6:6), intent(out) :: ff
       end subroutine evolvePDFM
    end interface

    if (.not. shower_settings%ps_fsr_active .and. &
        .not. shower_settings%ps_isr_active .and. &
        .not. shower_settings%hadronization_active .and. &
        .not. shower_settings%mlm_matching) then
       ! return if nothing to do
       return
    end if

    ! return if already invalid or vetoed
    if (.not. valid .or. vetoed)  return

    if (signal_is_pending ()) return    
    
    ! ensure that lhapdf is initialized
    if (pdf_type .eq. STRF_LHAPDF) then       
       if (shower_settings%ps_isr_active .and. &
            (abs (particle_get_pdg (particle_set_get_particle &
                 (particle_set, 1))) >= 1000) .and. &
            (abs (particle_get_pdg (particle_set_get_particle &
                 (particle_set, 2))) >= 1000)) then
          call GetQ2max (0,pdftest)
          if (pdftest == 0._double) then
             call msg_fatal ("ISR QCD shower enabled, but LHAPDF not" // &
                  "initialized," // LF // "     aborting simulation")
             return
          end if
       end if
       pdf_func => evolvePDFM
    else if (pdf_type == STRF_PDF_BUILTIN) then
       if (shower_settings%ps_use_PYTHIA_shower) then
          call msg_fatal ("Builtin PDFs cannot be used for PYTHIA showers," &
               // LF // "     aborting simulation")
          return
       end if
       pdf_func => pdf_evolve_LHAPDF
    end if
    if (shower_settings%mlm_matching .and. shower_settings%ckkw_matching) then
       call msg_fatal ("Both MLM and CKKW matching activated," // &
            LF // "     aborting simulation")
       return      
    end if

    if (debug)  call shower_settings%write ()
    
    if (shower_settings%ps_use_PYTHIA_shower .or. &
         shower_settings%hadronization_active) then
       if (.not. shower_settings%ps_PYTHIA_verbose) then
          call PYGIVE ('MSTU(12)=12345')
          call PYGIVE ('MSTU(13)=0')
       else 
          call PYGIVE ('MSTU(13)=1')
       end if
    end if

    if (debug)  print *, "Shower: beam checks for mlm_matching"

    if (.not. matching_disabled) then
       !!! Check if the beams are hadrons
       if ((abs (particle_get_pdg (particle_set_get_particle &
            (particle_set, 1))) <= 18) .and. &
            (abs (particle_get_pdg (particle_set_get_particle &
            (particle_set, 2))) <= 18)) then
          mlm_matching_data%is_hadron_collision = .false.
       else if ((abs (particle_get_pdg (particle_set_get_particle &
            (particle_set, 1))) >= 1000) .and. &
            (abs (particle_get_pdg (particle_set_get_particle &
            (particle_set, 2))) >= 1000)) then
          mlm_matching_data%is_hadron_collision = .true.
       else 
          call msg_error (" Matching didn't recognize beams setup," // &
               LF // "     disabling matching")
          matching_disabled = .true.
          return
       end if
    end if
    
    if (debug)  print *, "Shower: apply shower"

    !!! SHOWER
    if (shower_settings%ps_use_PYTHIA_shower .or. &
         (.not. shower_settings%ps_fsr_active .and. &
          .not. shower_settings%ps_isr_active .and. &
           shower_settings%hadronization_active)) then
       call apply_PYTHIAshower_particle_set (particle_set, &
            shower_settings, mlm_matching_data%P_ME, model, model_hadrons, &
            valid)
       if (debug)  call pylist(2)
    else
       call apply_WHIZARDshower_particle_set (particle_set, &
            shower_settings, mlm_matching_data%P_ME, model, model_hadrons, &
            os_data, pdf_func, pdf_set, valid, vetoed)
       if (vetoed) return
    end if
    if (debug) then
       print *, " after SHOWER"
       call particle_set_write (particle_set)
    end if
       
    if (shower_settings%mlm_matching .and. &
         (matching_disabled.eqv..false.)) then
    !!! MLM stage 2 -> PS jets and momenta
       call matching_transfer_PS &
            (mlm_matching_data, particle_set, shower_settings)
    !!! MLM stage 3 -> reconstruct and possible reject
       call mlm_matching_apply (mlm_matching_data, shower_settings%ms, vetoed)
       if (vetoed) then
          call mlm_matching_data_final (mlm_matching_data)
          return
       end if
    endif

!!! HADRONIZATION
    if (shower_settings%hadronization_active) then
       !! Assume that the event record is still in the PYTHIA COMMON BLOCKS
       !! transferred there by one of the shower routines
       if (valid) then
          call apply_PYTHIAhadronization (particle_set, &
               shower_settings, model, model_hadrons, valid)
       end if
    end if
!!! FINAL

    call mlm_matching_data_final (mlm_matching_data)

    if (debug)  print *, "SHOWER+HADRONIZATION+MATCHING finished"

  contains

    subroutine shower_set_PYTHIA_error (mstu23)
      ! PYTHIA common blocks
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      IMPLICIT INTEGER(I-N)
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      SAVE/PYDAT1/

      integer, intent(in) :: mstu23

      MSTU(23) = mstu23
    end subroutine shower_set_PYTHIA_error

    function shower_get_PYTHIA_error () result (mstu23)
      ! PYTHIA common blocks
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      IMPLICIT INTEGER(I-N)
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      SAVE/PYDAT1/

      integer :: mstu23

      mstu23 = MSTU(23)
    end function shower_get_PYTHIA_error

    subroutine apply_PYTHIAshower_particle_set &
         (particle_set, shower_settings, JETS_ME, model, model_hadrons, valid)
    <<HEP common: parameters>>
    <<HEP common: variables>>
    <<HEP common: common blocks>>

      type(particle_set_t), intent(inout) :: particle_set
      type(particle_set_t) :: pset_reduced
      type(shower_settings_t), intent(in) :: shower_settings
      type(vector4_t), dimension(:), allocatable, intent(inout) :: JETS_ME
      type(model_t), intent(in), target :: model
      type(model_t), intent(in), target :: model_hadrons
      logical, intent(inout) :: valid
      real(kind=default) :: rand
      
      ! units for transfer from WHIZARD to PYTHIA and back
      integer :: u_W2P, u_P2W
      integer, save :: pythia_initialized_for_NPRUP = 0
      logical, save :: pythia_warning_given = .false.
      logical, save :: msg_written = .false.
      type(string_t) :: remaining_PYGIVE, partial_PYGIVE
      character*10 buffer

      if (signal_is_pending ()) return      
      
      if (debug) then
         print *, "debugging the shower"
         print *, IDBMUP(1), IDBMUP(2)
         print *, EBMUP, PDFGUP, PDFSUP, IDWTUP
         print *, "NPRUP = ", NPRUP
      end if
      
      ! check if the beam particles are quarks
      if (any (abs(IDBMUP) <= 8)) then
         ! PYTHIA doesn't support these settings
         if (.not. pythia_warning_given) then
            call msg_error ("PYTHIA doesn't support quarks as beam particles," &
                 // LF // "     neglecting ISR, FSR and hadronization")
            pythia_warning_given = .true.
         end if
         return
      end if
      
      call particle_set_reduce (particle_set, pset_reduced)
      call hepeup_from_particle_set (pset_reduced)
      call hepeup_set_event_parameters (proc_id=1)

      u_W2P = free_unit ()
      if (debug .and. to_file) then
         open (unit=u_W2P, status="replace", &
              file="whizardout1.lhe", action="readwrite")  
      else
         open (unit=u_W2P, status="scratch", action="readwrite")
      end if
      call shower_W2P_write_event (u_W2P)
      rewind (u_W2P)
      if (signal_is_pending ()) return          
      write (buffer, "(I10)")  u_W2P
      call PYGIVE ("MSTP(161)="//buffer)
      call PYGIVE ("MSTP(162)="//buffer)
      if (debug)  write (*, "(A)")  buffer
      if (shower_settings%ps_isr_active) then
         call PYGIVE ("MSTP(61)=1")  
      else
         call PYGIVE ("MSTP(61)=0")  !!! switch off ISR
      end if
      if (shower_settings%ps_fsr_active) then
         call PYGIVE ("MSTP(71)=1")  
      else
         call PYGIVE ("MSTP(71)=0")   !!! switch off FSR
      end if
      call PYGIVE ("MSTP(111)=0")     !!! switch off hadronization

      if (pythia_initialized_for_NPRUP >= NPRUP) then
         if (debug)  print *, "calling upinit"
         call upinit
         if (debug)  print *, "returned from upinit"
      else
         write (buffer, "(F10.5)") shower_settings%ps_mass_cutoff
         call PYGIVE ("PARJ(82)="//buffer)
         write (buffer, "(F10.5)") shower_settings%ps_isr_tscalefactor
         call PYGIVE ("PARP(71)="//buffer)    

         write (buffer, "(F10.5)") shower_settings%ps_fsr_lambda
         call PYGIVE ("PARP(72)="//buffer)
         write(buffer, "(F10.5)") shower_settings%ps_isr_lambda
         call PYGIVE ("PARP(61)="//buffer)
         write (buffer, "(I10)") shower_settings%ps_max_n_flavors
         call PYGIVE ("MSTJ(45)="//buffer)
         if (shower_settings%ps_isr_alpha_s_running) then
            call PYGIVE ("MSTP(64)=2")
         else
            call PYGIVE ("MSTP(64)=0")
         end if
         if (shower_settings%ps_fsr_alpha_s_running) then
            call PYGIVE ("MSTJ(44)=2")
         else
            call PYGIVE ("MSTJ(44)=0")
         end if
         write (buffer, "(F10.5)") shower_settings%ps_fixed_alpha_s
         call PYGIVE ("PARU(111)="//buffer)
         write (buffer, "(F10.5)") shower_settings%ps_isr_primordial_kt_width
         call PYGIVE ("PARP(91)="//buffer)
         write (buffer, "(F10.5)") shower_settings%ps_isr_primordial_kt_cutoff
         call PYGIVE ("PARP(93)="//buffer)
         write (buffer, "(F10.5)") 1._double - shower_settings%ps_isr_z_cutoff
         call PYGIVE ("PARP(66)="//buffer)
         write (buffer, "(F10.5)") shower_settings%ps_isr_minenergy
         call PYGIVE ("PARP(65)="//buffer)
         if (shower_settings%ps_isr_only_onshell_emitted_partons) then
            call PYGIVE ("MSTP(63)=0")
         else
            call PYGIVE ("MSTP(63)=2")
         end if
         if (shower_settings%mlm_matching) then
            CALL PYGIVE ("MSTP(62)=2")
            CALL PYGIVE ("MSTP(67)=0")
         end if
         if (debug)  print *, "calling pyinit"
         call PYINIT ("USER", "", "", 0D0)

         call tao_random_number (rand)
         write (buffer, "(I10)") floor (rand*900000000)
         call pygive ("MRPY(1)="//buffer)
         call pygive ("MRPY(2)=0")

         if (len(shower_settings%ps_PYTHIA_PYGIVE) > 0) then
            remaining_PYGIVE = shower_settings%ps_PYTHIA_PYGIVE
            do while (len (remaining_PYGIVE)>0)
               call split (remaining_PYGIVE, partial_PYGIVE, ";")
               call PYGIVE (char (partial_PYGIVE))
            end do
            if (shower_get_PYTHIA_error() /= 0) then
               call msg_fatal &
                    (" PYTHIA did not recognize ps_PYTHIA_PYGIVE setting.")
            end if
         end if

         pythia_initialized_for_NPRUP = NPRUP
      end if

      if (.not. msg_written) then
         call msg_message ("Using PYTHIA interface for parton showers")
         msg_written = .true.
      end if      
      call PYEVNT ()
            
      if (debug)  write (*, "(A)")  "called pyevnt"
      
      u_P2W = free_unit ()
      write (buffer, "(I10)")  u_P2W
      call PYGIVE ("MSTP(163)="//buffer)
      if (debug .and. to_file) then
         open (unit = u_P2W, file="pythiaout.lhe", status="replace", &
              action="readwrite")  
      else
         open (unit = u_P2W, status="scratch", action="readwrite")
      end if
      if (debug)  write (*, "(A)")  "calling PYLHEO"
      !!! convert pythia /PYJETS/ to lhef given in MSTU(163)=u_P2W
      call PYLHEO
      !!! read and add lhef from u_P2W
      if (signal_is_pending ()) return          
      call shower_add_lhef_to_particle_set &
           (particle_set, u_P2W, model, model_hadrons)
      close (unit=u_P2W)
      
      !!! Transfer momenta of the partons in the final state of 
      !!!     the hard initeraction
      if (shower_settings%mlm_matching)  &
           call get_ME_momenta_from_PYTHIA (JETS_ME)

      if (shower_get_PYTHIA_error () > 0) then
         !!! clean up, discard shower and exit
         call shower_set_PYTHIA_error (0)
         valid = .false.
      end if
      close (unit=u_W2P)
    end subroutine apply_PYTHIAshower_particle_set

    subroutine apply_WHIZARDshower_particle_set & 
         (particle_set, shower_settings, JETS_ME, model, model_hadrons, &
         os_data, pdf_func, pdf_set, valid, vetoed)
      type(particle_set_t), intent(inout) :: particle_set
      type(shower_settings_t), intent(in) :: shower_settings
      type(vector4_t), dimension(:), allocatable, intent(inout) :: JETS_ME
      type(model_t), intent(in), target :: model
      type(model_t), intent(in), target :: model_hadrons
      type(os_data_t), intent(in) :: os_data
      procedure(shower_pdf), pointer, intent(in) :: pdf_func
      integer, intent(in) :: pdf_set
      logical, intent(inout) :: valid
      logical, intent(out) :: vetoed

      type(muli_type),save :: mi
      type(shower_t) :: shower
      type(parton_t), dimension(:), allocatable, target :: partons, hadrons
      type(parton_pointer_t), dimension(:), allocatable :: &
           parton_pointers, final_ME_partons
      real(kind=default) :: mi_scale, ps_scale, shat, phi
      type(parton_pointer_t) :: temppp
      integer, dimension(:), allocatable :: connections
      integer :: n_loop, i, j, k
      integer :: n_hadrons, n_in, n_out
      integer :: n_int
      integer :: max_color_nr
      integer, dimension(2) :: col_array
      integer, dimension(1) :: parent
      type(flavor_t) :: flv
      type(color_t) :: col
      logical, save :: msg_written = .false.
      type(string_t) :: filename
      integer, dimension(2,4) :: color_corr
      integer :: colori, colorj
      character*5 buffer
      integer :: u_S2W

      vetoed = .false.

      if (signal_is_pending ()) return          
      
      if (debug) print *, "Transfer settings from shower_settings to shower"
      call shower_set_D_Min_t (shower_settings%ps_mass_cutoff**2)
      call shower_set_D_Lambda_fsr (shower_settings%ps_fsr_lambda)
      call shower_set_D_Lambda_isr (shower_settings%ps_isr_lambda)
      call shower_set_D_Nf (shower_settings%ps_max_n_flavors)
      call shower_set_D_running_alpha_s_fsr &
           (shower_settings%ps_fsr_alpha_s_running)
      call shower_set_D_running_alpha_s_isr &
           (shower_settings%ps_isr_alpha_s_running)
      call shower_set_D_constantalpha_s &
           (shower_settings%ps_fixed_alpha_s)
      call shower_set_isr_pt_ordered &
           (shower_settings%ps_isr_pt_ordered)
      call shower_set_isr_angular_ordered &
           (shower_settings%ps_isr_angular_ordered)
      Call shower_set_primordial_kt_width &
           (shower_settings%ps_isr_primordial_kt_width)
      call shower_set_primordial_kt_cutoff &
           (shower_settings%ps_isr_primordial_kt_cutoff)
      call shower_set_maxz_isr (shower_settings%ps_isr_z_cutoff)
      call shower_set_minenergy_timelike (shower_settings%ps_isr_minenergy)
      call shower_set_tscalefactor_isr (shower_settings%ps_isr_tscalefactor)
      call shower_set_isr_only_onshell_emitted_partons &
           (shower_settings%ps_isr_only_onshell_emitted_partons)
      call shower_set_pdf_set (pdf_set)
      call shower_set_pdf_func (pdf_func)

      if (.not. msg_written) then
         call msg_message ("Using WHIZARD's internal showering")
         msg_written = .true.
      end if

      n_loop = 0
      TRY_SHOWER: do ! just a loop to be able to discard events
         n_loop = n_loop + 1
         if (n_loop > 1000) call msg_fatal &
              ("Shower: too many loops (try_shower)")
         call shower%create ()
         if (signal_is_pending ()) return             
         max_color_nr = 0

         n_hadrons = 0
         n_in = 0
         n_out = 0
         do i = 1, particle_set_get_n_tot (particle_set)
            if (particle_get_status (particle_set_get_particle &
                 (particle_set, i)) == PRT_BEAM) &
                 n_hadrons = n_hadrons + 1
            if (particle_get_status (particle_set_get_particle &
                 (particle_set, i)) == PRT_INCOMING) &
                 n_in = n_in + 1
            if (particle_get_status (particle_set_get_particle &
                 (particle_set, i)) == PRT_OUTGOING) &
                 n_out = n_out + 1
         end do

         allocate (connections (1:particle_set_get_n_tot (particle_set)))
         connections = 0

         allocate (hadrons (1:2))
         allocate (partons (1:n_in+n_out))
         allocate (parton_pointers (1:n_in+n_out))

         j=0
         if (n_hadrons > 0) then
            if (debug) print *, "Transfer hadrons from particle_set to hadrons"
            do i = 1, particle_set_get_n_tot (particle_set)
               if (particle_get_status (particle_set_get_particle &
                    (particle_set, i)) == PRT_BEAM) then
                  j = j+1
                  hadrons(j)%nr = shower%get_next_free_nr ()
                  hadrons(j)%momentum = particle_get_momentum &
                       (particle_set_get_particle (particle_set, i))
                  hadrons(j)%t = hadrons(j)%momentum**2
                  hadrons(j)%type = particle_get_pdg &
                       (particle_set_get_particle (particle_set, i))
                  col_array=particle_get_color (particle_set_get_particle &
                       (particle_set, i))
                  hadrons(j)%c1 = col_array(1)
                  hadrons(j)%c2 = col_array(2)
                  max_color_nr = max (max_color_nr, abs(hadrons(j)%c1), &
                       abs(hadrons(j)%c2))
                  hadrons(j)%interactionnr = 1
                  connections(i)=j
               end if
            end do
         end if

         j = 0
         if (debug) print *, "Transfer incoming partons from particle_set to partons"
         do i = 1, particle_set_get_n_tot (particle_set)
            if (particle_get_status (particle_set_get_particle &
                 (particle_set, i)) == PRT_INCOMING) then
               j = j+1
               partons(j)%nr = shower%get_next_free_nr ()
               partons(j)%momentum = particle_get_momentum &
                    (particle_set_get_particle (particle_set, i))
               partons(j)%t = partons(j)%momentum**2
               partons(j)%type = particle_get_pdg &
                    (particle_set_get_particle (particle_set, i))
               col_array=particle_get_color &
                    (particle_set_get_particle (particle_set, i))
               partons(j)%c1 = col_array (1)
               partons(j)%c2 = col_array (2)
               parton_pointers(j)%p => partons(j)
               max_color_nr = max (max_color_nr, abs (partons(j)%c1), &
                    abs (partons(j)%c2))
               connections(i)=j
               ! insert dependences on hadrons
               if (particle_get_n_parents (particle_set_get_particle &
                    (particle_set, i))==1) then
                  parent = particle_get_parents (particle_set_get_particle &
                       (particle_set, i))
                  partons(j)%initial => hadrons (connections (parent(1)))
                  partons(j)%x = space_part_norm (partons(j)%momentum) / &
                                 space_part_norm (partons(j)%initial%momentum)
               end if
            end if
         end do
         if (signal_is_pending ()) return             
         if (debug) print *, "Transfer outgoing partons from particle_set to partons"
         do i = 1, particle_set_get_n_tot (particle_set)
            if (particle_get_status (particle_set_get_particle &
                 (particle_set, i)) == PRT_OUTGOING) then
               j = j + 1
               partons(j)%nr = shower%get_next_free_nr ()
               partons(j)%momentum = particle_get_momentum &
                    (particle_set_get_particle (particle_set, i))
               partons(j)%t = partons(j)%momentum**2
               partons(j)%type = particle_get_pdg &
                    (particle_set_get_particle (particle_set, i))
               col_array=particle_get_color &
                    (particle_set_get_particle (particle_set, i))
               partons(j)%c1 = col_array(1)
               partons(j)%c2 = col_array(2)
               parton_pointers(j)%p => partons(j)
               max_color_nr = max (max_color_nr, abs &
                    (partons(j)%c1), abs (partons(j)%c2))
               connections(i) = j
            end if
         end do

         deallocate (connections)

         if (debug) print *, "Insert partons in shower"
         call shower%set_next_color_nr (1 + max_color_nr)
         call shower%add_interaction_2ton_CKKW &
              (parton_pointers, shower_settings%ckkw_weights)

         if (signal_is_pending ()) return             
         if (shower_settings%muli_active) then
            if (debug) print *, "Activate multiple interactions"
            !!! Initialize muli pdf sets, unless initialized
            if (mi%is_initialized ()) then
               call mi%restart ()
            else
               call mi%initialize (&
                    GeV2_scale_cutoff=D_Min_t, &
                    GeV2_s=shower_interaction_get_s &
                    (shower%interactions(1)%i), &
                    muli_dir=char(os_data%whizard_mulipath))
            end if

            !!! initial interaction
            call mi%apply_initial_interaction ( &
                 GeV2_s=shower_interaction_get_s(shower%interactions(1)%i), &
                 x1=shower%interactions(1)%i%partons(1)%p%parent%x, &
                 x2=shower%interactions(1)%i%partons(2)%p%parent%x, &
                 pdg_f1=shower%interactions(1)%i%partons(1)%p%parent%type, &
                 pdg_f2=shower%interactions(1)%i%partons(2)%p%parent%type, &
                 n1=shower%interactions(1)%i%partons(1)%p%parent%nr, &
                 n2=shower%interactions(1)%i%partons(2)%p%parent%nr)
         end if

         if (signal_is_pending ()) return             
         
         if (shower_settings%ckkw_matching) then
            if (debug) print *, "Apply CKKW matching"
            call ckkw_matching_apply (shower, &
                 shower_settings%ckkw_settings, &
                 shower_settings%ckkw_weights, vetoed)
            if (vetoed) then
               return
            end if
         end if

         if (shower_settings%ps_isr_active) then
            i = 0
            BRANCHINGS: do
               i = i+1
               if (signal_is_pending ()) return                   
               if (shower_settings%muli_active) then
                  call mi%generate_gev2_pt2 &
                       (shower%get_ISR_scale (), mi_scale)
               else
                  mi_scale = 0.0
               end if

               !!! Shower: debugging
               !!! shower%generate_next_isr_branching returns a pointer to 
               !!! the parton with the next ISR-branching, this parton's 
               !!! scale is the scale of the next branching 
               ! temppp=shower%generate_next_isr_branching_veto ()
               temppp = shower%generate_next_isr_branching ()
                  
               if (.not. associated (temppp%p) .and. &
                    mi_scale < D_Min_t) then
                  exit BRANCHINGS
               end if
               !!! check if branching or interaction occurs next
               if (associated (temppp%p)) then
                  ps_scale = abs(temppp%p%t)
               else
                  ps_scale = 0._default
               end if
               if (mi_scale > ps_scale) then
                  !!! discard branching evolution lower than mi_scale
                  call shower%set_max_ISR_scale (mi_scale)
                  if (associated (temppp%p)) &
                       call parton_set_simulated(temppp%p, .false.)
                 
                  !!! execute new interaction
                  deallocate (partons)
                  deallocate (parton_pointers)
                  allocate (partons(1:4))
                  allocate (parton_pointers(1:4))
                  do j = 1, 4
                     partons(j)%nr = shower%get_next_free_nr ()
                     partons(j)%belongstointeraction = .true.
                     parton_pointers(j)%p => partons(j)
                  end do
                  call mi%generate_partons (partons(1)%nr, partons(2)%nr, &
                       partons(1)%x, partons(2)%x, &
                       partons(1)%type, partons(2)%type, &
                       partons(3)%type, partons(4)%type)
                  !!! calculate momenta
                  shat = partons(1)%x *partons(2)%x * &
                       shower_interaction_get_s(shower%interactions(1)%i)
                  call parton_set_momentum (partons(1), &
                       0.5_default*sqrt(shat), 0._default, 0._default, &
                       0.5_default*sqrt(shat))
                  call parton_set_momentum (partons(2), &
                       0.5_default*sqrt(shat), 0._default, 0._default, &
                       -0.5_default*sqrt(shat))
                  call parton_set_initial (partons(1), &
                       shower%interactions(1)%i%partons(1)%p%initial)
                  call parton_set_initial (partons(2), &
                       shower%interactions(1)%i%partons(2)%p%initial)
                  partons(1)%belongstoFSR = .false.
                  partons(2)%belongstoFSR = .false.
                  !!! calculate color connection
                  call mi%get_color_correlations &
                      (shower%get_next_color_nr (), &
                      max_color_nr,color_corr)
                  call shower%set_next_color_nr (max_color_nr)

                  partons(1)%c1 = color_corr(1,1)
                  partons(1)%c2 = color_corr(2,1)
                  partons(2)%c1 = color_corr(1,2)
                  partons(2)%c2 = color_corr(2,2)
                  partons(3)%c1 = color_corr(1,3)
                  partons(3)%c2 = color_corr(2,3)
                  partons(4)%c1 = color_corr(1,4)
                  partons(4)%c2 = color_corr(2,4)

                  call tao_random_number (phi)
                  phi = 2*pi*phi
                  call parton_set_momentum (partons(3), &
                       0.5_default*sqrt(shat), sqrt(mi_scale)*cos(phi), &
                       sqrt(mi_scale)*sin(phi), sqrt(0.25_default*shat - &
                       mi_scale))
                  call parton_set_momentum (partons(4), &
                       0.5_default*sqrt(shat), -sqrt(mi_scale)*cos(phi), &
                       -sqrt(mi_scale)*sin(phi), -sqrt(0.25_default*shat - &
                       mi_scale))
                  partons(3)%belongstoFSR = .true.
                  partons(4)%belongstoFSR = .true.

                  call shower%add_interaction_2ton (parton_pointers)
                  n_int = size (shower%interactions)
                  do k = 1, 2
                     call mi%replace_parton &
                       (shower%interactions(n_int)%i%partons(k)%p%initial%nr, &
                        shower%interactions(n_int)%i%partons(k)%p%nr, &
                        shower%interactions(n_int)%i%partons(k)%p%parent%nr, &
                        shower%interactions(n_int)%i%partons(k)%p%type, &
                        shower%interactions(n_int)%i%partons(k)%p%x, &
                        mi_scale)
                  end do
                  call shower%write ()
               else
                  !!! execute the next branching 'found' in the previous step
                  call shower%execute_next_isr_branching (temppp)
                  if (shower_settings%muli_active) then
                     call mi%replace_parton (temppp%p%initial%nr, &
                          temppp%p%child1%nr, temppp%p%nr, &
                          temppp%p%type, temppp%p%x, ps_scale)
                  end if

               end if
            end do BRANCHINGS
               
            call shower%generate_fsr_for_isr_partons ()
         else
            if (signal_is_pending ()) return                
            call shower%simulate_no_isr_shower ()
         end if

         !!! some bookkeeping, needed after the shower is done
         call shower%boost_to_labframe ()
         call shower%generate_primordial_kt ()
         call shower%update_beamremnants ()
         !!! clean-up muli: we should finalize the muli pdf sets when 
         !!!      all runs are done. 
         ! call mi%finalize ()

         if (shower_settings%ps_fsr_active) then
            do i = 1, size (shower%interactions)
               if (signal_is_pending ()) return                   
               call shower%interaction_generate_fsr_2ton &
                    (shower%interactions(i)%i)
            end do
         else
            call shower%simulate_no_fsr_shower ()
         end if
         if (debug) then
            write (*, "(A)")  "SHOWER_FINISHED: "
            call shower%write ()
         end if
            
         if (shower_settings%mlm_matching) then
            !!! transfer momenta of the partons in the final state of 
            !!!        the hard initeraction
            if (signal_is_pending ()) return                
            if (allocated (JETS_ME))  deallocate (JETS_ME)
            call shower%get_final_colored_ME_partons (final_ME_partons)
            if (allocated (final_ME_partons)) then
               allocate (JETS_ME(1:size (final_ME_partons)))
               do i = 1, size (final_ME_partons)
                  !!! transfer
                  JETS_ME(i) = final_ME_partons(i)%p%momentum
               end do
               deallocate (final_ME_partons)
            end if
         end if

         u_S2W = free_unit ()
         if (debug .and. to_file) then
            open (unit=u_S2W, file="showerout.lhe", &
                 status="replace", action="readwrite")  
         else
            open (unit=u_S2W, status="scratch", action="readwrite")
         end if
         call shower%write_lhef (u_S2W)
         call shower_add_lhef_to_particle_set &
              (particle_set, u_S2W, model, model_hadrons)
         close (u_S2W)
         
         !!! move the particle data to the PYTHIA COMMON BLOCKS in case 
         !!! hadronization is active
         if (shower_settings%hadronization_active) then
            if (signal_is_pending ()) return                
            call shower_converttopythia (shower)
         end if
         deallocate (partons)
         deallocate (parton_pointers)
         print *, 'n_loop =    ', n_loop   !!! Debugging
         exit TRY_SHOWER
      end do TRY_SHOWER
      if (debug) then
         call particle_set_write (particle_set)
         print *, &
           "----------------------apply_shower_particle_set------------------"
         print *, &
           "-----------------------------------------------------------------"         
         if (size (shower%interactions) >= 2) then
            call shower%write ()
         end if
      end if         
         
      call shower%final ()
      !!! clean-up muli: we should finalize the muli pdf sets 
      !!!      when all runs are done. 
      ! call mi%finalize()
      return
    end subroutine apply_WHIZARDshower_particle_set

    subroutine get_ME_momenta_from_PYTHIA (JETS_ME)
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      IMPLICIT INTEGER(I-N)
      COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
      SAVE /PYJETS/

      type(vector4_t), dimension(:), allocatable :: JETS_ME
      real(kind=default), dimension(:,:), allocatable :: pdum 
      integer :: i, j, n_jets

      if (allocated (JETS_ME))  deallocate (JETS_ME)
      if (allocated (pdum))  deallocate (pdum)

      if (signal_is_pending ()) return          
      !!! final ME partons start in 7th row of event record
      i = 7
      !!! find number of jets
      n_jets = 0
      do
         if (K(I,1) /= 21) exit
         if ((K(I,2) == 21) .or. (abs(K(I,2)) <= 6)) then
            n_jets = n_jets + 1
         end if
         i = i + 1 
      end do

      if (n_jets == 0) return
      allocate (JETS_ME(1:n_jets))
      allocate (pdum(1:n_jets,4))

      !!! transfer jets
      i = 7
      j = 1
      pdum = p
      do
         if (K(I,1) /= 21) exit
         if ((K(I,2) == 21) .or. (abs(K(I,2)).le.6)) then
            JETS_ME(j)= vector4_moving (pdum(I,4), & 
              vector3_moving ( [pdum(I,1),pdum(I,2),pdum(I,3)] ))
            j = j + 1
         end if
         i = i + 1
      end do
    end subroutine get_ME_momenta_from_PYTHIA
    
    subroutine matching_transfer_PS &
         (data, particle_set, settings)
      !!! transfer partons after parton shower to data%P_PS
      type(mlm_matching_data_t), intent(inout) :: data
      type(particle_set_t), intent(in) :: particle_set
      type(shower_settings_t), intent(in) :: settings
      integer :: i, j, n_jets_PS
      integer, dimension(2) :: col
      type(particle_t) :: tempprt
      real(double) :: eta, E, pl
      type(vector4_t) :: p_tmp      

      !!! loop over particles and extract final colored ones with eta<etamax
      n_jets_PS = 0
      do i = 1, particle_set_get_n_tot (particle_set)
         if (signal_is_pending ()) return             
         tempprt = particle_set_get_particle (particle_set, i)
         if (particle_get_status (tempprt) /= PRT_OUTGOING) cycle
         col = particle_get_color (tempprt)
         if (all (col == 0)) cycle
         if (data%is_hadron_collision) then
            p_tmp = particle_get_momentum (tempprt)
            if (energy (p_tmp) - longitudinal_part (p_tmp) < 1.E-10_default .or. &
                energy (p_tmp) + longitudinal_part (p_tmp) < 1.E-10_default) then
               eta = pseudorapidity (p_tmp)
            else
               eta = rapidity (p_tmp)
            end if
            if (eta > settings%ms%mlm_etaClusfactor * &
                 settings%ms%mlm_etamax)  then
               if (debug) then
                  print *, "REJECTING"
                  call particle_write (tempprt)
               end if
               cycle
            end if
         end if
         n_jets_PS = n_jets_PS + 1
      end do

      allocate (data%P_PS(1:n_jets_PS))
      if (debug)  write (*, "(A,1x,I0)")  "n_jets_ps =", n_jets_ps

      j = 1
      do i = 1, particle_set_get_n_tot (particle_set)
         tempprt = particle_set_get_particle (particle_set, i)
         if (particle_get_status (tempprt) /= PRT_OUTGOING) cycle
         col = particle_get_color (tempprt)
         if(all(col == 0)) cycle
         if (data%is_hadron_collision) then
            p_tmp = particle_get_momentum (tempprt)
            if (energy (p_tmp) - longitudinal_part (p_tmp) < 1.E-10_default .or. &
                energy (p_tmp) + longitudinal_part (p_tmp) < 1.E-10_default) then
               eta = pseudorapidity (p_tmp)
            else
               eta = rapidity (p_tmp)
            end if
            if (eta > settings%ms%mlm_etaClusfactor * &
                 settings%ms%mlm_etamax) cycle
         end if
         data%P_PS(j) = particle_get_momentum (tempprt)
         j = j + 1
      end do
    end subroutine matching_transfer_PS
    
    subroutine apply_PYTHIAhadronization &
         (particle_set, shower_settings, model, model_hadrons, valid)
      type(particle_set_t), intent(inout) :: particle_set
      type(shower_settings_t), intent(in) :: shower_settings
      type(model_t), intent(in), target :: model
      type(model_t), intent(in), target :: model_hadrons
      logical, intent(inout) :: valid
      integer :: u_W2P, u_P2W
      type(string_t) :: remaining_PYGIVE, partial_PYGIVE
      logical, save :: msg_written = .false.
      character*10 buffer

      if (.not. shower_settings%hadronization_active)  return
      if (.not. valid) return
      if (signal_is_pending ()) return          

      u_W2P = free_unit ()
      if (debug) then
         open (unit=u_W2P, status="replace", file="whizardout.lhe", &
              action="readwrite") 
      else
         open (unit=u_W2P, status="scratch", action="readwrite")
      end if
      call shower_W2P_write_event (u_W2P)
      rewind (u_W2P)
      write (buffer, "(I10)")  u_W2P
      call PYGIVE ("MSTP(161)=" // buffer)
      call PYGIVE ("MSTP(162)=" // buffer)

      !!! Assume that the event is still present in the PYTHIA common blocks
      ! call pygive ("MSTP(61)=0")  ! switch off ISR
      ! call pygive ("MSTP(71)=0")  ! switch off FSR

      if (.not. shower_settings%ps_use_PYTHIA_shower .and. &
           len(shower_settings%ps_PYTHIA_PYGIVE) > 0) then
         remaining_PYGIVE = shower_settings%ps_PYTHIA_PYGIVE
         do while (len(remaining_PYGIVE) > 0)
            if (signal_is_pending ()) return                            
            call split (remaining_PYGIVE, partial_PYGIVE, ";")
            call PYGIVE (char (partial_PYGIVE))
         end do
         if (shower_get_PYTHIA_error () /= 0) then
            call msg_fatal ("PYTHIA didn't recognize ps_PYTHIA_PYGIVE setting")
         end if
      end if

      if (.not. (shower_settings%ps_use_PYTHIA_shower .and. &
           (shower_settings%ps_isr_active.or. &
           shower_settings%ps_fsr_active))) then
         if (len(shower_settings%ps_PYTHIA_PYGIVE) > 0) then
            remaining_PYGIVE = shower_settings%ps_PYTHIA_PYGIVE
            do while (len(remaining_PYGIVE) > 0)
               if (signal_is_pending ()) return                   
               call split (remaining_PYGIVE, partial_PYGIVE, ";")
               call PYGIVE (char(partial_PYGIVE))
            end do
            if (shower_get_PYTHIA_error () /= 0) then
               call msg_fatal &
                    ("PYTHIA did not recognize ps_PYTHIA_PYGIVE setting")
            end if
         end if
      end if

      if (.not.msg_written) then
         call msg_message &
              ("Using PYTHIA interface for hadronization and decays")
         msg_written = .true.
      end if

      call PYGIVE ("MSTP(111)=1") !!! switch on hadronization
      if (signal_is_pending ()) return          
      call PYEXEC

      if (shower_get_PYTHIA_error () > 0) then
         !!! clean up, discard shower and exit
         call shower_set_PYTHIA_error (0)
         close (u_W2P)
         valid = .false.
      else
         !!! convert back
         u_P2W = free_unit ()
         write (buffer, "(I10)")  u_P2W
         call PYGIVE ("MSTP(163)=" // buffer)
         if (debug .and. to_file) then
            open (unit=u_P2W, file="pythiaout2.lhe", status="replace", &
                 action="readwrite")  
         else            
            open (unit=u_P2W, status="scratch", action="readwrite")
         end if
         !!! convert pythia /PYJETS/ to lhef given in MSTU(163)=u1
         call pylheo
         !!! read and add lhef from u_P2W
         if (signal_is_pending ()) return             
         call shower_add_lhef_to_particle_set &
              (particle_set, u_P2W, model, model_hadrons)
         close (u_W2P)
         close (u_P2W)
         valid = .true.
      end if
    end subroutine apply_PYTHIAhadronization

    subroutine shower_W2P_write_event (unit)
      integer, intent(in) :: unit
      type(xml_tag_t), allocatable :: tag_lhef, tag_head, tag_init, &
           tag_event, tag_gen_n, tag_gen_v
      allocate (tag_lhef, tag_head, tag_init, tag_event, &
           tag_gen_n, tag_gen_v)
      call tag_lhef%init (var_str ("LesHouchesEvents"), &
         [xml_attribute (var_str ("version"), var_str ("1.0"))], .true.)
      call tag_head%init (var_str ("header"), .true.)
      call tag_init%init (var_str ("init"), .true.)
      call tag_event%init (var_str ("event"), .true.)
      call tag_gen_n%init (var_str ("generator_name"), .true.)
      call tag_gen_v%init (var_str ("generator_version"), .true.)      
      call tag_lhef%write (unit); write (unit, *)
      call tag_head%write (unit); write (unit, *)
      write (unit, "(2x)", advance = "no")
      call tag_gen_n%write (var_str ("WHIZARD"), unit)
      write (unit, *)
      write (unit, "(2x)", advance = "no")      
      call tag_gen_v%write (var_str ("<<Version>>"), unit)
      write (unit, *)
      call tag_head%close (unit); write (unit, *)
      call tag_init%write (unit); write (unit, *)
      call heprup_write_lhef (unit)
      call tag_init%close (unit); write (unit, *)
      call tag_event%write (unit); write (unit, *)
      call hepeup_write_lhef (unit)
      call tag_event%close (unit); write (unit, *)
      call tag_lhef%close (unit); write (unit, *)
      deallocate (tag_lhef, tag_head, tag_init, tag_event, &
           tag_gen_n, tag_gen_v)
    end subroutine shower_W2P_write_event
  
  end subroutine apply_shower_particle_set
@ %def apply_shower_particle_set
@ Read in the LHE file opened in unit [[u]] and add the final
particles to the [[particle_set]], the outgoing particles of the existing
[[particle_set]] are set to be virtual before the outgoing particles from the 
LHEF are added to the [[particle_set]] as outgoing particles. At the same 
time, it is searched for pairs of existing and new particles with
equal momenta and PDG code, these pairs are marked as connected. All 
remaining existing former outgoing particles are set to be the mothers of all 
remaining new outgoing particles.
<<Shower: procedures>>=
  subroutine shower_add_lhef_to_particle_set &
       (particle_set, u, model_in, model_hadrons)
    type(particle_set_t), intent(inout) :: particle_set
    integer, intent(in) :: u
    type(model_t), intent(in), target :: model_in
    type(model_t), intent(in), target :: model_hadrons
    type(string_t) :: filename
    type(flavor_t) :: flv
    type(color_t) :: col
    logical :: logging_save

    type(model_t), pointer :: model
    integer :: newsize, oldsize
    type(particle_t), dimension(:), allocatable :: temp_prt
    integer :: i, j
    integer :: n_available_parents;
    integer, dimension(:), allocatable :: available_parents
    integer, dimension(:), allocatable :: available_children
    logical, dimension(:), allocatable :: direct_child
    type(vector4_t) :: diffmomentum
    integer, PARAMETER :: MAXLEN=200
    CHARACTER*(MAXLEN) STRING
    integer ibeg
    INTEGER :: NUP,IDPRUP,IDUP,ISTUP
    real(kind=double) :: XWGTUP,SCALUP,AQEDUP,AQCDUP,VTIMUP,SPINUP
    integer :: MOTHUP(1:2),ICOLUP(1:2)
    real(kind=double) :: PUP(1:5)
    real(kind=default) :: pup_dum(1:5)
    character*5 buffer

    CHARACTER*6 STRFMT
    STRFMT='(A000)'
    WRITE(STRFMT(3:5),'(I3)') MAXLEN

    rewind (u)

    !!! get newsize of particle_set, newsize = old size of 
    !!!    particle_set + #entries - 2 (incoming partons in lhef)
    oldsize = particle_set_get_n_tot (particle_set)
    !!! Loop until finds line beginning with "<event>" or "<event ".
    do
       read (u,*,END=501,ERR=502) STRING
       IBEG=0
       do
          if (signal_is_pending ()) return              
          IBEG = IBEG + 1
          ! Allow indentation.
          IF (STRING(IBEG:IBEG).EQ.' ' .and. IBEG < MAXLEN-6) cycle
          exit
       end do
       IF (string(IBEG:IBEG+6) /= '<event>' .and. &
            string(IBEG:IBEG+6) /= '<event ') cycle
       exit
    end do
    !!! Read first line of event info -> number of entries
    read (u, *, END=503, ERR=504) NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    newsize = oldsize + NUP - 2
    allocate (temp_prt (1:newsize))

    allocate (available_parents (1:oldsize))
    available_parents = 0
    do i = 1, particle_set_get_n_tot (particle_set)
       if (signal_is_pending ()) return           
       temp_prt (i) = particle_set_get_particle (particle_set, i)
       if (particle_get_status (temp_prt (i)) == PRT_OUTGOING .or. &
            particle_get_status (temp_prt (i)) == PRT_BEAM_REMNANT) then
          call particle_reset_status (temp_prt (i), PRT_VIRTUAL)
          available_parents (i) = i
       end if
    end do

    allocate (available_children (1:newsize))
    allocate (direct_child (1:newsize))
    available_children = 0
    direct_child = .false.

    !!! transfer particles from lhef to particle_set
    !!!...Read NUP subsequent lines with information on each particle.
    DO I = 1, NUP
       READ (u,*,END=200,ERR=505) IDUP, ISTUP, MOTHUP(1), MOTHUP(2), &
            ICOLUP(1), ICOLUP(2), (PUP (J),J=1,5), VTIMUP, SPINUP
       if ((I.eq.1).or.(I.eq.2)) cycle

       call particle_reset_status (temp_prt(oldsize+i-2), PRT_OUTGOING)
       !!! Settings for unpolarized particles
       ! particle_set%prt (oldsize+i-2)%polarization = 0 ! =PRT_UNPOLARIZED !??
       if (model_in%test_field (IDUP)) then
          model => model_in
       else if (model_hadrons%test_field (IDUP)) then
          model => model_hadrons
       else
          write (buffer, "(I5)") IDUP
          call msg_error ("Parton " // buffer // &
               " found neither in given model file nor in SM_hadrons")
          return
       end if
       call flavor_init (flv, IDUP, model)
       call particle_set_flavor (temp_prt (oldsize+i-2), flv)
       
       if (IABS(IDUP) == 2212 .or. IABS(IDUP) == 2112) then
          ! PYTHIA sometimes sets color indices for protons and neutrons (?)
          ICOLUP (1) = 0
          ICOLUP (2) = 0
       end if
       call color_init_col_acl (col, ICOLUP (1), ICOLUP (2))
       call particle_set_color (temp_prt (oldsize+i-2), col)
       !!! Settings for unpolarized particles
       ! particle_set%prt (oldsize+i-2)%hel = ??
       ! particle_set%prt (oldsize+i-2)%pol = ??
       pup_dum = PUP
       call particle_set_momentum (temp_prt (oldsize+i-2), &
            vector4_moving (pup_dum (4), &
            vector3_moving ([pup_dum (1), pup_dum (2), pup_dum (3)])))

       available_children (oldsize+i-2) = oldsize+i-2
       !!! search for an existing particle with the same momentum 
       !!!   -> treat these as mother and daughter
       do j = 1, size (available_parents)
          if (available_parents (j) == 0) cycle
          diffmomentum = particle_get_momentum &
               (temp_prt (available_parents (j))) - &
               particle_get_momentum (temp_prt(oldsize+i-2))
          if (abs(diffmomentum**2) < 1E-10_default .and. &
               particle_get_pdg (temp_prt (available_parents (j))).eq. &
               particle_get_pdg (temp_prt (oldsize+i-2))) then
             direct_child (available_parents (j)) = .true.
             direct_child (oldsize+i-2) = .true.
             call particle_set_parents (temp_prt (oldsize+i-2), &
                  [available_parents(j)] )
             call particle_set_children (temp_prt (available_parents(j)), &
                  [oldsize+i-2] )
             available_parents (j) = 0
             available_children (oldsize+i-2) = 0
          end if
       end do
    end do

    !!! remove zeros in available parents and available children
    available_parents  = pack (available_parents , available_parents  /= 0)
    available_children = pack (available_children, available_children /= 0)

    do i = 1, size (available_parents) 
      if (direct_child (available_parents (i))) cycle
      call particle_set_children &
           (temp_prt (available_parents (i)), available_children)
    end do
    do i = oldsize + 1, newsize
       if (direct_child (i)) cycle
       call particle_set_parents (temp_prt(i), available_parents)
    end do

    ! transfer to particle_set
    call particle_set_replace (particle_set, temp_prt)
    if (allocated (available_children)) deallocate (available_children)
    if (allocated (available_parents))  deallocate (available_parents)
    deallocate (direct_child)
    deallocate (temp_prt)

200 continue
    return

501 write(*,*) "READING LHEF failed 501"
    return
502 write(*,*) "READING LHEF failed 502"
    return
503 write(*,*) "READING LHEF failed 503"
    return
504 write(*,*) "READING LHEF failed 504"
    return
505 write(*,*) "READING LHEF failed 504"
    return
  end subroutine shower_add_lhef_to_particle_set
@ %def shower_add_lhef_to_particle_set

<<Shower: procedures>>=
!!!!!!!!!!PYTHIA STYLE!!!!!!!!!!!!!
!!! originally PYLHEF subroutine from PYTHIA 6.4.22

!C...Write out the showered event to a Les Houches Event File.
!C...Take MSTP(161) as the input for <init>...</init>

      SUBROUTINE PYLHEO

!C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      IMPLICIT INTEGER(I-N)

!C...PYTHIA commonblock: only used to provide read/write units and version.
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
      COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
      SAVE /PYPARS/
      SAVE /PYJETS/

!C...User process initialization commonblock.
      INTEGER MAXPUP
      PARAMETER (MAXPUP=100)
      INTEGER IDBMUP,PDFGUP,PDFSUP,IDWTUP,NPRUP,LPRUP
      DOUBLE PRECISION EBMUP,XSECUP,XERRUP,XMAXUP
      COMMON/HEPRUP/IDBMUP(2),EBMUP(2),PDFGUP(2),PDFSUP(2),IDWTUP,NPRUP,XSECUP(MAXPUP),XERRUP(MAXPUP),XMAXUP(MAXPUP),LPRUP(MAXPUP)
      SAVE /HEPRUP/

!C...User process event common block.
      INTEGER MAXNUP
      PARAMETER (MAXNUP=500)
      INTEGER NUP,IDPRUP,IDUP,ISTUP,MOTHUP,ICOLUP
      PARAMETER (KSUSY1=1000000,KSUSY2=2000000,KTECHN=3000000, &
           KEXCIT=4000000,KDIMEN=5000000)
      DOUBLE PRECISION XWGTUP,SCALUP,AQEDUP,AQCDUP,PUP,VTIMUP,SPINUP
      COMMON/HEPEUP/NUP,IDPRUP,XWGTUP,SCALUP,AQEDUP,AQCDUP,IDUP(MAXNUP),ISTUP(MAXNUP),MOTHUP(2,MAXNUP),ICOLUP(2,MAXNUP), &
                      PUP(5,MAXNUP),VTIMUP(MAXNUP),SPINUP(MAXNUP)
      SAVE /HEPEUP/

!C...Lines to read in assumed never longer than 200 characters.
      PARAMETER (MAXLEN=200)
      CHARACTER*(MAXLEN) STRING

      INTEGER LEN

!C...Format for reading lines.
      CHARACTER*6 STRFMT
      STRFMT='(A000)'
      WRITE(STRFMT(3:5),'(I3)') MAXLEN

!C...Rewind initialization and event files.
      REWIND MSTP(161)
      REWIND MSTP(162)

!C...Write header info.
      WRITE(MSTP(163),'(A)') '<LesHouchesEvents version="1.0">'
      WRITE(MSTP(163),'(A)') '<!--'
      WRITE(MSTP(163),'(A,I1,A1,I3)') 'File generated with PYTHIA ',MSTP(181),'.',MSTP(182)
      WRITE(MSTP(163),'(A)') ' and the WHIZARD2 interface'
      WRITE(MSTP(163),'(A)') '-->'

!C...Loop until finds line beginning with "<init>" or "<init ".
  100 READ(MSTP(161),STRFMT,END=400,ERR=400) STRING
      IBEG=0
  110 IBEG=IBEG+1
!C...Allow indentation.
      IF(STRING(IBEG:IBEG).EQ.' '.AND.IBEG.LT.MAXLEN-5) GOTO 110
      IF(STRING(IBEG:IBEG+5).NE.'<init>'.AND.STRING(IBEG:IBEG+5).NE.'<init ') GOTO 100

!C...Read first line of initialization info and get number of processes.
      READ(MSTP(161),'(A)',END=400,ERR=400) STRING
      READ(STRING,*,ERR=400) IDBMUP(1),IDBMUP(2),EBMUP(1),EBMUP(2),PDFGUP(1),PDFGUP(2),PDFSUP(1),PDFSUP(2),IDWTUP,NPRUP

!C...Copy initialization lines, omitting trailing blanks.
!C...Embed in <init> ... </init> block.
      WRITE(MSTP(163),'(A)') '<init>'
      DO IPR=0,NPRUP
        IF(IPR.GT.0) READ(MSTP(161),'(A)',END=400,ERR=400) STRING
        LEN=MAXLEN+1
  120   LEN=LEN-1
        IF(LEN.GT.1.AND.STRING(LEN:LEN).EQ.' ') GOTO 120
        WRITE(MSTP(163),'(A)',ERR=400) STRING(1:LEN)
     end DO
      WRITE(MSTP(163),'(A)') '</init>'

!!!! Find the numbers of entries of the <event block>
      NENTRIES = 2      ! incoming partons (nearest to the beam particles)
      DO I=1,N
         if((K(I,1).eq.1) .or. (K(I,1).eq.2)) then
            if(P(I,4) < 1D-10) cycle
            NENTRIES = NENTRIES + 1
         end if
      end DO

!C...Begin an <event> block. Copy event lines, omitting trailing blanks.
      WRITE(MSTP(163),'(A)') '<event>'
      WRITE(MSTP(163),*) NENTRIES,IDPRUP,XWGTUP,SCALUP,AQEDUP,AQCDUP

      DO I=3,4       ! the incoming partons nearest to the beam particles
         WRITE(MSTP(163),*)  K(I,2),-1,0,0,0,0,(P(I,J),J=1,5),0, -9
      end DO
      NDANGLING_COLOR = 0
      NCOLOR = 0
      NDANGLING_ANTIC = 0
      NANTIC = 0
      NNEXTC = 1   ! TODO find next free color number ??
      DO I=1,N
         if (signal_is_pending ()) return             
         if((K(I,1).eq.1) .or. (K(I,1).eq.2)) then
            ! workaround for zero energy photon in electron ISR            
            if (P(I,4) < 1E-10_default) cycle   
            if ((K(I,2).eq.21) .or. (IABS(K(I,2)) <= 8) .or. &
                (IABS(K(I,2)) >= KSUSY1+1 .and. IABS(K(I,2)) <= KSUSY1+8) &
                .or. &
                (IABS(K(I,2)) >= KSUSY2+1 .and. IABS(K(I,2)) <= KSUSY2+8) .or. &
                 (IABS(K(I,2)) >= 1000 .and. IABS(K(I,2)) <= 9999) ) then
               if(NDANGLING_COLOR.eq.0 .and. NDANGLING_ANTIC.eq.0) then
                  ! new color string
                  ! Gluon and gluino only color octets implemented so far
                  if(K(I,2).eq.21 .or. K(I,2).eq.1000021) then  
                     NCOLOR = NNEXTC
                     NDANGLING_COLOR = NCOLOR
                     NNEXTC = NNEXTC + 1
                     NANTIC = NNEXTC
                     NDANGLING_ANTIC = NANTIC
                     NNEXTC = NNEXTC + 1
                  elseif(K(I,2) .gt. 0) then  ! particles to have color
                     NCOLOR = NNEXTC
                     NDANGLING_COLOR = NCOLOR
                     NANTIC = 0
                     NNEXTC = NNEXTC + 1
                  elseif(K(I,2) .lt. 0) then  ! antiparticles to have anticolor
                     NANTIC = NNEXTC
                     NDANGLING_ANTIC = NANTIC
                     NCOLOR = 0
                     NNEXTC = NNEXTC + 1
                  end if
               else if(K(I,1).eq.1) then
                  ! end of string
                  NCOLOR = NDANGLING_ANTIC
                  NANTIC = NDANGLING_COLOR
                  NDANGLING_COLOR = 0
                  NDANGLING_ANTIC = 0
               else
                  ! inside the string
                  if(NDANGLING_COLOR .ne. 0) then
                     NANTIC = NDANGLING_COLOR
                     NCOLOR = NNEXTC
                     NDANGLING_COLOR = NNEXTC
                     NNEXTC = NNEXTC +1
                  else if(NDANGLING_ANTIC .ne. 0) then
                     NCOLOR = NDANGLING_ANTIC
                     NANTIC = NNEXTC
                     NDANGLING_ANTIC = NNEXTC
                     NNEXTC = NNEXTC +1
                  else
                     print *, "ERROR IN PYLHEO"
                  end if
               end if
            else
               NCOLOR = 0
               NANTIC = 0
            end if

            !!! As no intermediate are given out here, assume the 
            !!!   incoming partons to be the mothers
            WRITE(MSTP(163),*)  K(I,2),1,1,2,NCOLOR,NANTIC,(P(I,J),J=1,5),0, -9
         end if
      end DO

!C..End the <event> block. Loop back to look for next event.
      WRITE(MSTP(163),'(A)') '</event>'

!C...Successfully reached end of event loop: write closing tag
!C...and remove temporary intermediate files (unless asked not to).
320   WRITE(MSTP(163),'(A)') '</LesHouchesEvents>'
      RETURN

!!C...Error exit.
  400 WRITE(*,*) ' PYLHEO file joining failed!'

      RETURN
    END SUBROUTINE PYLHEO

@ 
\subsection{Event Transform}
<<Shower: public>>=
  public :: evt_shower_t
<<Shower: types>>=
  type, extends (evt_t) :: evt_shower_t
     type(shower_settings_t) :: settings
     type(model_t), pointer :: model_hadrons => null ()
     type(os_data_t) :: os_data
     integer :: pdf_type = STRF_NONE
     integer :: pdf_set = 0
   contains
   <<Shower: evt shower: TBP>>
  end type evt_shower_t
  
@ %def evt_shower_t
@ Output.
<<Shower: evt shower: TBP>>=
  procedure :: write => evt_shower_write
<<Shower: procedures>>=
  subroutine evt_shower_write (object, unit, testflag)
    class(evt_shower_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: shower"
    call write_separator (u)
    call object%base_write (u, testflag = testflag)
    call write_separator (u)
    call object%settings%write (u)
  end subroutine evt_shower_write
    
@ %def evt_shower_write
@ Initialize the parameters.  The [[model_hadrons]] is supposed to be
the SM variant that contains all hadrons that may be generated in the
shower.
<<Shower: evt shower: TBP>>=
  procedure :: init => evt_shower_init
<<Shower: procedures>>=
  subroutine evt_shower_init (evt, settings, model_hadrons, os_data)
    class(evt_shower_t), intent(out) :: evt
    type(shower_settings_t), intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    type(os_data_t), intent(in) :: os_data
    evt%settings = settings
    evt%os_data = os_data
    evt%model_hadrons => model_hadrons
  end subroutine evt_shower_init
  
@ %def evt_shower_init
@ Use the process and beam structure to determine PDF parameters.
<<Shower: evt shower: TBP>>=
  procedure :: setup_pdf => evt_shower_setup_pdf
<<Shower: procedures>>=
  subroutine evt_shower_setup_pdf (evt, process, beam_structure)
    class(evt_shower_t), intent(inout) :: evt
    type(process_t), intent(in) :: process
    type(beam_structure_t), intent(in) :: beam_structure
    if (beam_structure%contains ("lhapdf")) then
       evt%pdf_type = STRF_LHAPDF
       evt%pdf_set = process%get_pdf_set ()
       write (msg_buffer, "(A,I0)")  "Shower: interfacing LHAPDF set #", &
            evt%pdf_set
       call msg_message ()
    else if (beam_structure%contains ("pdf_builtin")) then
       evt%pdf_type = STRF_PDF_BUILTIN
       evt%pdf_set = process%get_pdf_set ()
       write (msg_buffer, "(A,I0)")  "Shower: interfacing PDF builtin set #", &
            evt%pdf_set
       call msg_message ()
    end if
  end subroutine evt_shower_setup_pdf
    
@ %def evt_shower_setup_pdf
@ Prepare: nothing to do here.
<<Shower: evt shower: TBP>>=
  procedure :: prepare_new_event => evt_shower_prepare_new_event
<<Shower: procedures>>=
  subroutine evt_shower_prepare_new_event (evt, i_mci, i_term)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_shower_prepare_new_event

@ %def evt_shower_prepare_new_event
@ Here we take the particle set from the previous event transform (assuming
that there is always one) and apply the shower algorithm. The result is
stored in the event transform of the current object. We always return a
probability of unity as we don't have the analytic weight of the combination of
shower, MLM matching and hadronization. A subdivision into multiple event
transformations might be useful. Invalid or vetoed events have to be discarded
by the caller which is why we mark the particle set as invalid. 
<<Shower: evt shower: TBP>>=
  procedure :: generate_weighted => evt_shower_generate_weighted
<<Shower: procedures>>=
  subroutine evt_shower_generate_weighted (evt, probability)
    class(evt_shower_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    logical :: valid, vetoed
    valid = .true.
    vetoed = .false.
    if (evt%previous%particle_set_exists) then
       evt%particle_set = evt%previous%particle_set
       if (evt%settings%ps_use_PYTHIA_shower .or. &
           evt%settings%hadronization_active) then
          call evt%assure_heprup ()
       end if
       if (evt%settings%ckkw_matching) then
          call ckkw_pseudo_shower_weights_init (evt%settings%ckkw_weights)
          call ckkw_fake_pseudo_shower_weights (evt%settings%ckkw_settings, &
               evt%settings%ckkw_weights, evt%particle_set)
       end if
       call apply_shower_particle_set (evt%particle_set, &
            evt%settings, evt%model, evt%model_hadrons, &
            evt%os_data, evt%pdf_type, evt%pdf_set, valid, vetoed)
       probability = 1
       !!! BCN: WK please check: In 2.1.1 vetoed events reduced sim%n_events by
       ! one while invalid events did not. This bookkeeping should be reenabled
       ! to have the correct cross section / luminosity.
       if (valid .and. .not. vetoed) then
          evt%particle_set_exists = .true.
       else
          evt%particle_set_exists = .false.
       end if
    else
       call msg_bug ("Shower: input particle set does not exist")
    end if
  end subroutine evt_shower_generate_weighted

@ %def evt_shower_generate_weighted
@ The particle set was already made by the routine above (or the event was
vetoed).  So we do nothing here.  The factorization parameters are irrelevant.
<<Shower: evt shower: TBP>>=
  procedure :: make_particle_set => evt_shower_make_particle_set
<<Shower: procedures>>=
  subroutine evt_shower_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
  end subroutine evt_shower_make_particle_set

@ %def event_shower_make_particle_set
@
\subsubsection{Matching and hadronization functions}
The HEPRUP (event) common block is needed for the interface to the shower.
Filling of it is triggered by some output file formats.  If these are not
present, the common block is filled with some dummy information. Be generous
with the number of processes in HEPRUP so that PYTHIA only rarely needs to be
reinitialized in case events with higher process ids are generated.
<<Shower: evt shower: TBP>>=
  procedure :: assure_heprup => event_shower_assure_heprup
<<Shower: procedures>>=
  subroutine event_shower_assure_heprup (evt)
    class(evt_shower_t), intent(in) :: evt
    integer :: i, num_id
    integer, parameter :: min_processes = 10

  <<HEP common: parameters>>
  <<HEP common: variables>>
  <<HEP common: common blocks>>
    
    num_id = 1
    if (LPRUP (num_id) /= 0)  return

    call heprup_init ( &
         [ particle_get_pdg (particle_set_get_particle &
                              (evt%particle_set, 1)), &
           particle_get_pdg (particle_set_get_particle &
                              (evt%particle_set, 2)) ] , &
         [ vector4_get_component (particle_get_momentum &
            (particle_set_get_particle (evt%particle_set, 1)), 0), &
           vector4_get_component (particle_get_momentum &
            (particle_set_get_particle (evt%particle_set, 2)), 0) ], &
         num_id, .false., .false.)
    do i = 1, (num_id / min_processes + 1) * min_processes
       call heprup_set_process_parameters (i = i, process_id = &
            i, cross_section = 1._default, error = 1._default)
    end do
  end subroutine event_shower_assure_heprup

@ %def event_shower_assure_heprup
@ Generate fake ckkw weights. This can be dropped, once information
from the matrix element generation is available.
<<Shower: public>>=
  public :: ckkw_fake_pseudo_shower_weights
<<Shower: procedures>>=
  subroutine ckkw_fake_pseudo_shower_weights &
       (ckkw_pseudo_shower_settings, &
        ckkw_pseudo_shower_weights, particle_set)
    type(ckkw_matching_settings_t), intent(inout) :: &
         ckkw_pseudo_shower_settings
    type(ckkw_pseudo_shower_weights_t), intent(inout) :: &
         ckkw_pseudo_shower_weights
    type(particle_set_t), intent(in) :: particle_set
    integer :: i, j
    integer :: n
    type(vector4_t) :: momentum

    ckkw_pseudo_shower_settings%alphaS = 1.0_default
    ckkw_pseudo_shower_settings%Qmin = 1.0_default
    ckkw_pseudo_shower_settings%n_max_jets = 3

    n = 2**particle_set_get_n_tot(particle_set)
    if (allocated (ckkw_pseudo_shower_weights%weights)) then 
       deallocate (ckkw_pseudo_shower_weights%weights)
    end if
    allocate (ckkw_pseudo_shower_weights%weights (1:n))
    do i = 1, n
       momentum = vector4_null
       do j = 1, particle_set_get_n_tot (particle_set)
          if (btest (i,j-1)) then
             momentum = momentum + particle_get_momentum &
                  (particle_set_get_particle (particle_set, j))
          end if
       end do
       if (momentum**1 > 0.0) then
          ckkw_pseudo_shower_weights%weights(i) = 1.0 / (momentum**2)
       end if
    end do
    ! equally distribute the weights by type
    if (allocated (ckkw_pseudo_shower_weights%weights_by_type)) then
       deallocate (ckkw_pseudo_shower_weights%weights_by_type)
    end if
    allocate (ckkw_pseudo_shower_weights%weights_by_type (1:n, 0:4))
    do i = 1, n
       do j = 0, 4
          ckkw_pseudo_shower_weights%weights_by_type(i,j) = &
               0.2 * ckkw_pseudo_shower_weights%weights(i)
       end do
    end do
  end subroutine ckkw_fake_pseudo_shower_weights
  
@ %def ckkw_fake_pseudo_shower_weights
@
\subsection{Unit Tests}
<<Shower: public>>=
  public :: shower_test
<<Shower: tests>>=
  subroutine shower_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Shower: execute tests>>
  end subroutine shower_test
  
@ %def shower_test
@
\subsubsection{Testbed}
This sequence sets up a two-jet process, ready for generating events.
<<Shower: tests>>=
  subroutine setup_testbed &
       (prefix, os_data, lib, model_list, model, process, process_instance)
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(out) :: os_data
    type(process_library_t), intent(out), target :: lib
    type(model_list_t), intent(out) :: model_list
    type(model_t), pointer, intent(out) :: model
    type(process_t), target, intent(out) :: process
    type(process_instance_t), target, intent(out) :: process_instance
    type(var_list_t), pointer :: model_vars
    type(string_t) :: model_name, libname, procname, run_id
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts

    model_name = "SM"
    libname = prefix // "_lib"
    procname = prefix // "p"
    run_id = "1"
    
    call os_data_init (os_data)
    allocate (rng_tao_factory_t :: rng_factory)
    call model_list%read_model (model_name, model_name // ".mdl", &
         os_data, model)
    model_vars => model%get_var_list_ptr ()
    call var_list_set_real (model_vars, var_str ("me"), 0._default, &
         is_known = .true.)

    call lib%init (libname)

    allocate (prt_in (2), source = [var_str ("e-"), var_str ("e+")])
    allocate (prt_out (2), source = [var_str ("d"), var_str ("dbar")])

    allocate (entry)
    call entry%init (procname, model, n_in = 2, n_components = 1)
    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call lib%append (entry)

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    call process%init (procname, run_id, lib, os_data, &
         qcd, rng_factory, model_list)
    
    allocate (prc_omega_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    select type (core_template)
    type is (prc_omega_t)
       call core_template%set_parameters (model = model)
    end select
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()
    
    call process_instance%init (process)
    call process%integrate (process_instance, 1, 1, 1000)
    call process%final_integration (1)

    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    call process%generate_weighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

  end subroutine setup_testbed

@ %def setup_testbed
@
\subsubsection{FSR Shower}
We generate a two-jet event and shower it using default settings for
the WHIZARD FSR shower.
<<Shower: execute tests>>=
  call test (shower_1, "shower_1", &
       "disabled shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    type(model_t), pointer :: model, model_hadrons
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    integer :: factorization_mode
    logical :: keep_correlations
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_1"
    write (u, "(A)")  "*   Purpose: Two-jet event with disabled shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_1"), &
         os_data, lib, model_list, model, process, process_instance)

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
    end select

    call evt_shower%connect (process_instance, model)
    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_1"
    
  end subroutine shower_1
  
@ %def shower_1
@
\subsubsection{Trivial Test}
We generate a two-jet event and shower it using default settings.
Since the default settings have all 
<<Shower: execute tests>>=
  call test (shower_2, "shower_2", &
       "final-state shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    type(model_t), pointer :: model, model_hadrons
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    integer :: factorization_mode
    logical :: keep_correlations
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_2"
    write (u, "(A)")  "*   Purpose: Two-jet event with FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_2"), &
         os_data, lib, model_list, model, process, process_instance)

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    settings%ps_fsr_active = .true.

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
    end select

    call evt_shower%connect (process_instance, model)
    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u, testflag = .true.)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_2"
    
  end subroutine shower_2
  
@ %def shower_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Events}

This module combines hard processes with decay chains, shower, and
hadronization (not implemented yet) to complete events.  It also
manages the input and output of event records in various formats.
<<[[events.f90]]>>=
<<File header>>

module events
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use string_utils, only: lower_case
  use format_utils, only: write_separator
  use format_defs, only: FMT_12
  use unit_tests
  use diagnostics
  use os_interface
  use subevents
  use variables
  use expr_base
  use models
  use state_matrices
  use particles
  use interactions
  use subevt_expr
  use rng_base
  use process_libraries
  use processes
  use process_stacks
  use event_transforms
  use decays
  use shower

<<Standard module head>>

<<Events: public>>

<<Events: parameters>>

<<Events: types>>

<<Events: interfaces>>

contains
  
<<Events: procedures>>

<<Events: tests>>

end module events
@ %def events
@
\subsection{Event configuration}
The parameters govern the transformation of an event to a particle set.

The [[safety_factor]] reduces the acceptance probability for
unweighting.  If greater than one, excess events become less likely,
but the reweighting efficiency also drops.

The [[sigma]] and [[n]] values, if nontrivial, allow for reweighting
the events according to the requested [[norm_mode]].

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions that apply to the current event.  The
workspaces for evaluating those expressions are set up in the
[[event_expr_t]] objects.  Note that these are really pointers,
so the actual nodes are not stored inside the event object.
<<Events: types>>=
  type :: event_config_t
     logical :: unweighted = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: factorization_mode = FM_IGNORE_HELICITY
     logical :: keep_correlations = .false.
     real(default) :: sigma = 1
     integer :: n = 1
     real(default) :: safety_factor = 1
     class(expr_factory_t), allocatable :: ef_selection
     class(expr_factory_t), allocatable :: ef_reweight
     class(expr_factory_t), allocatable :: ef_analysis
   contains
   <<Events: event config: TBP>>
  end type event_config_t

@ %def event_config_t
@ Output.
<<Events: event config: TBP>>=
  procedure :: write => event_config_write
<<Events: procedures>>=
  subroutine event_config_write (object, unit, show_expressions)
    class(event_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_expressions
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Unweighted         = ", object%unweighted
    write (u, "(3x,A,A)")   "Normalization      = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A)", advance="no")  "Helicity handling  = "
    select case (object%factorization_mode)
    case (FM_IGNORE_HELICITY)
       write (u, "(A)")  "drop"
    case (FM_SELECT_HELICITY)
       write (u, "(A)")  "select"
    case (FM_FACTOR_HELICITY)
       write (u, "(A)")  "factorize"
    end select
    write (u, "(3x,A,L1)")  "Keep correlations  = ", object%keep_correlations
    if (object%safety_factor /= 1) then
       write (u, "(3x,A," // FMT_12 // ")")  &
            "Safety factor      = ", object%safety_factor
    end if
    if (present (show_expressions)) then
       if (show_expressions) then
          if (allocated (object%ef_selection)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event selection expression:"
             call object%ef_selection%write (u)
          end if
          if (allocated (object%ef_reweight)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event reweighting expression:"
             call object%ef_reweight%write (u)
          end if
          if (allocated (object%ef_analysis)) then
             call write_separator (u)
             write (u, "(3x,A)") "Analysis expression:"
             call object%ef_analysis%write (u)
          end if
       end if
    end if
  end subroutine event_config_write
  
@ %def event_config_write
@
\subsection{Event normalization}
The parameters for event normalization.  For unweighted events,
[[NORM_UNIT]] is intended as default, while for weighted events, it is
[[NORM_SIGMA]].

Note: the unit test for this is in [[eio_data_2]] below.
<<Events: parameters>>=
  integer, parameter, public :: NORM_UNDEFINED = 0
  integer, parameter, public :: NORM_UNIT = 1
  integer, parameter, public :: NORM_N_EVT = 2
  integer, parameter, public :: NORM_SIGMA = 3
  integer, parameter, public :: NORM_S_N = 4

@ %def NORM_UNDEFINED NORM_UNIT NORM_N_EVT NORM_SIGMA NORM_S_N
@ These functions translate between the user representation and the
internal one.
<<Events: public>>=
  public :: event_normalization_mode
  public :: event_normalization_string
<<Events: procedures>>=
  function event_normalization_mode (string, unweighted) result (mode)
    integer :: mode
    type(string_t), intent(in) :: string
    logical, intent(in) :: unweighted
    select case (lower_case (char (string)))
    case ("auto")
       if (unweighted) then
          mode = NORM_UNIT
       else
          mode = NORM_SIGMA
       end if
    case ("1")
       mode = NORM_UNIT
    case ("1/n")
       mode = NORM_N_EVT
    case ("sigma")
       mode = NORM_SIGMA
    case ("sigma/n")
       mode = NORM_S_N
    case default
       call msg_fatal ("Event normalization: unknown value '" &
            // char (string) // "'")
    end select
  end function event_normalization_mode
  
  function event_normalization_string (norm_mode) result (string)
    integer, intent(in) :: norm_mode
    type(string_t) :: string
    select case (norm_mode)
    case (NORM_UNDEFINED); string = "[undefined]"
    case (NORM_UNIT);      string = "'1'"
    case (NORM_N_EVT);     string = "'1/n'"
    case (NORM_SIGMA);     string = "'sigma'"
    case (NORM_S_N);       string = "'sigma/n'"
    case default;          string = "???"
    end select
  end function event_normalization_string
  
@ %def event_normalization_mode
@ %def event_normalization_string
@ We place this here as a generic helper, so we can update event
weights whenever we need, not just in connection with an event sample
data object.
<<Events: public>>=
  public :: event_normalization_update
<<Events: procedures>>=
  subroutine event_normalization_update (weight, sigma, n, mode_new, mode_old)
    real(default), intent(inout) :: weight
    real(default), intent(in) :: sigma
    integer, intent(in) :: n
    integer, intent(in) :: mode_new, mode_old
    if (mode_new /= mode_old) then
       if (sigma > 0 .and. n > 0) then
          weight = weight / factor (mode_old) * factor (mode_new)
       else
          call msg_fatal ("Event normalization update: null sample")
       end if
    end if
  contains
    function factor (mode)
      real(default) :: factor
      integer, intent(in) :: mode
      select case (mode)
      case (NORM_UNIT);   factor = 1._default
      case (NORM_N_EVT);  factor = 1._default / n
      case (NORM_SIGMA);  factor = sigma
      case (NORM_S_N);    factor = sigma / n
      case default
         call msg_fatal ("Event normalization update: undefined mode")
      end select
    end function factor
  end subroutine event_normalization_update
  
@ %def event_normalization_update
@
\subsection{The event type}
Each event has a single elementary process as its core.  This process
may be dressed by a shower, a decay chain etc.  For this core we
implement pointers to a process instance.

The actual (dressed) event record is implemented as a [[particle_set]]
object.

A list of event transforms (class [[evt_t]]) transform the connected
interactions of the process instance into the final particle set.  In
this list, the first transform is always the trivial one, which just
factorizes the process instance.  Subsequent transforms may apply
decays, etc.  The [[particle_set]] pointer identifies the particle set
that we want to be analyzed and returned by the event, usually the
last one.

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.

The [[sqme]] and [[weight]] values mirror corresponding values in the
[[expr]] subobject.  The idea is that when generating or reading
events, the event record is filled first, then the [[expr]] object
acquires copies.  These copies are used for writing events and as targets
for pointer variables in the analysis expression.

All data that involve user-provided expressions (selection, reweighting,
analysis) are handled by the [[expr]] subobject.  In particular, evaluating
the event-selection expression sets the [[passed]] flag.  Furthermore,
the [[expr]] subobject collects data that can be used in the analysis
and should be written to file, including copies of [[sqme]] and [[weight]].
<<Events: public>>=
  public :: event_t
<<Events: types>>=
  type :: event_t
     type(event_config_t) :: config
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: instance => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_i_mci = 0
     integer :: selected_i_term = 0
     integer :: selected_channel = 0
     logical :: is_complete = .false.
     class(evt_t), pointer :: transform_first => null ()
     class(evt_t), pointer :: transform_last => null ()
     logical :: particle_set_exists = .false.
     type(particle_set_t), pointer :: particle_set => null ()
     logical :: sqme_ref_is_known = .false.
     real(default) :: sqme_ref = 0
     logical :: sqme_prc_is_known = .false.
     real(default) :: sqme_prc = 0
     logical :: weight_ref_is_known = .false.
     real(default) :: weight_ref = 0
     logical :: weight_prc_is_known = .false.
     real(default) :: weight_prc = 0
     logical :: excess_prc_is_known = .false.
     real(default) :: excess_prc = 0
     integer :: n_alt = 0
     logical :: sqme_alt_is_known = .false.
     real(default), dimension(:), allocatable :: sqme_alt
     logical :: weight_alt_is_known = .false.
     real(default), dimension(:), allocatable :: weight_alt
     type(event_expr_t) :: expr
     logical :: selection_evaluated = .false.
     logical :: passed = .false.
     real(default) :: reweight = 1
     logical :: analysis_flag = .false.
   contains
   <<Events: event: TBP>>
  end type event_t

@ %def event_t
@ Finalizer: the list of event transforms is deleted iteratively.
<<Events: event: TBP>>=
  procedure :: final => event_final
<<Events: procedures>>=
  subroutine event_final (object)
    class(event_t), intent(inout) :: object
    class(evt_t), pointer :: evt
    if (allocated (object%rng))  call object%rng%final ()
    call object%expr%final ()
    do while (associated (object%transform_first))
       evt => object%transform_first
       object%transform_first => evt%next
       call evt%final ()
       deallocate (evt)
    end do
  end subroutine event_final
    
@ %def event_final
@ Output.

Particle set: this is a pointer to one of the event transforms, so it
should suffice to print the latter.
<<Events: event: TBP>>=
  procedure :: write => event_write
<<Events: procedures>>=
  subroutine event_write (object, unit, show_process, show_transforms, &
       show_decay, verbose, testflag)
    class(event_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    logical :: prc, trans, dec, verb
    class(evt_t), pointer :: evt
    integer :: u, i
    u = given_output_unit (unit)
    prc = .true.;  if (present (show_process))  prc = show_process
    trans = .true.;  if (present (show_transforms))  trans = show_transforms
    dec = .true.;  if (present (show_decay))  dec = show_decay
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    if (object%is_complete) then
       write (u, "(1x,A)")  "Event"
    else
       write (u, "(1x,A)")  "Event [incomplete]"
    end if
    call write_separator (u)
    call object%config%write (u)
    if (object%sqme_ref_is_known .or. object%weight_ref_is_known) then
       call write_separator (u)
    end if
    if (object%sqme_ref_is_known) then
       write (u, "(3x,A,ES19.12)")  "Squared matrix el. = ", object%sqme_ref
       if (object%sqme_alt_is_known) then
          do i = 1, object%n_alt
             write (u, "(5x,A,ES19.12,1x,I0)")  &
                  "alternate sqme   = ", object%sqme_alt(i), i
          end do
       end if
    end if
    if (object%weight_ref_is_known) then
       write (u, "(3x,A,ES19.12)")  "Event weight       = ", object%weight_ref
       if (object%weight_alt_is_known) then
          do i = 1, object%n_alt
             write (u, "(5x,A,ES19.12,1x,I0)")  &
                  "alternate weight = ", object%weight_alt(i), i
          end do
       end if
    end if
    if (object%selected_i_mci /= 0) then
       call write_separator (u)
       write (u, "(3x,A,I0)")  "Selected MCI group = ", object%selected_i_mci
       write (u, "(3x,A,I0)")  "Selected term      = ", object%selected_i_term
       write (u, "(3x,A,I0)")  "Selected channel   = ", object%selected_channel
    end if
    if (object%selection_evaluated) then
       call write_separator (u)
       write (u, "(3x,A,L1)")  "Passed selection   = ", object%passed
       if (object%passed) then
          write (u, "(3x,A,ES19.12)") &
               "Reweighting factor = ", object%reweight
          write (u, "(3x,A,L1)") &
               "Analysis flag      = ", object%analysis_flag
       end if
    end if
    if (associated (object%instance)) then
       if (prc) then
          if (verb) then
             call object%instance%write (u, testflag)
          else
             call object%instance%write_header (u)
          end if
       end if
       if (trans) then
          evt => object%transform_first
          do while (associated (evt))
             select type (evt)
             type is (evt_trivial_t)
                call evt%write (u, verbose = verbose, testflag = testflag)
             type is (evt_decay_t)
                call evt%write (u, show_decay_tree = dec, &
                     show_processes = dec .and. verb, verbose = verb)
             type is (evt_shower_t)
                call evt%write (u)
             end select
             call write_separator (u, 2)
             evt => evt%next
          end do
       else
          call write_separator (u, 2)
       end if
       if (object%expr%subevt_filled) then
          call object%expr%write (u)
          call write_separator (u, 2)
       end if
    else
       call write_separator (u, 2)
       write (u, "(1x,A)")  "Process instance: [undefined]"
       call write_separator (u, 2)
    end if
  end subroutine event_write

@ %def event_write
@
\subsection{Initialization}
Initialize: set configuration parameters, using a variable list.  We
do not call this [[init]], because this method name will be used by a type
extension.

The default normalization is [[NORM_SIGMA]], since the default
generation mode is weighted.

For unweighted events, we may want to a apply a safety factor to event
rejection.  (By default, this factor is unity and can be ignored.)

We also allocate the trivial event transform, which is always the
first one.
<<Events: event: TBP>>=
  procedure :: basic_init => event_init
<<Events: procedures>>=
  subroutine event_init (event, var_list, n_alt)
    class(event_t), intent(out) :: event
    type(var_list_t), intent(in), optional :: var_list
    integer, intent(in), optional :: n_alt
    type(string_t) :: norm_string
    logical :: polarized_events
    if (present (var_list)) then
       event%config%unweighted = var_list_get_lval (var_list, &
            var_str ("?unweighted"))
       norm_string = var_list_get_sval (var_list, &
            var_str ("$sample_normalization"))
       event%config%norm_mode = &
            event_normalization_mode (norm_string, event%config%unweighted)
       polarized_events = &
            var_list_get_lval (var_list, var_str ("?polarized_events"))
       if (polarized_events) then
          event%config%factorization_mode = FM_SELECT_HELICITY
       else
          event%config%factorization_mode = FM_IGNORE_HELICITY
       end if
       if (event%config%unweighted) then
          event%config%safety_factor = var_list_get_rval (var_list, &
               var_str ("safety_factor"))
       end if
    else
       event%config%norm_mode = NORM_SIGMA
    end if
    if (present (n_alt)) then
       event%n_alt = n_alt
       allocate (event%sqme_alt (n_alt))
       allocate (event%weight_alt (n_alt))
       call event%expr%init (n_alt)
    end if
    allocate (evt_trivial_t :: event%transform_first)
    event%transform_last => event%transform_first
  end subroutine event_init
    
@ %def event_init
@ Set the [[sigma]] and [[n]] values in the configuration record that
determine non-standard event normalizations.  If these numbers are not
set explicitly, the default value for both is unity, and event
renormalization has no effect.
<<Events: event: TBP>>=
  procedure :: set_sigma => event_set_sigma
  procedure :: set_n => event_set_n
<<Events: procedures>>=
  elemental subroutine event_set_sigma (event, sigma)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: sigma
    event%config%sigma = sigma
  end subroutine event_set_sigma

  elemental subroutine event_set_n (event, n)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: n
    event%config%n = n
  end subroutine event_set_n
  
@ %def event_set_n
@ Append an event transform (decays, etc.).  The transform is not yet
connected to a process.  The transform is then considered to belong to
the event object, and will be finalized together with it.  The
original pointer is removed.

We can assume that the trivial transform is already present in the
event object, at least.
<<Events: event: TBP>>=
  procedure :: import_transform => event_import_transform
<<Events: procedures>>=
  subroutine event_import_transform (event, evt)
    class(event_t), intent(inout) :: event
    class(evt_t), intent(inout), pointer :: evt
    event%transform_last%next => evt
    evt%previous => event%transform_last
    event%transform_last => evt
    evt => null ()
  end subroutine event_import_transform
    
@ %def event_import_transform
@
We link the event to an existing process instance.  This
includes the variable list, which is linked to the process variable
list.  Note that this is not necessarily identical to the variable
list used for event initialization.

The variable list will contain pointers to [[event]] subobjects, therefore the
[[target]] attribute.

Once we have a process connected, we can use it to obtain an event
generator instance.

The model and process stack may be needed by event transforms.  The
current model setting may be different from the model in the process
(regarding unstable particles, etc.).  The process stack can be used
for assigning extra processes that we need for the event transforms.
<<Events: event: TBP>>=
  procedure :: connect => event_connect
<<Events: procedures>>=
  subroutine event_connect (event, process_instance, model, process_stack)
    class(event_t), intent(inout), target :: event
    type(process_instance_t), intent(in), target :: process_instance
    type(model_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t) :: id
    integer :: num_id
    class(evt_t), pointer :: evt
    event%process => process_instance%process
    event%instance => process_instance
    id = event%process%get_id ()
    if (id /= "")  call event%expr%set_process_id (id)
    num_id = event%process%get_num_id ()
    if (num_id /= 0)  call event%expr%set_process_num_id (num_id)
    call event%expr%setup_vars (event%process%get_sqrts ())
    call event%expr%link_var_list (event%process%get_var_list_ptr ())
    call event%process%make_rng (event%rng)
    evt => event%transform_first
    do while (associated (evt))
       call evt%connect (process_instance, model, process_stack)
       evt => evt%next
    end do
  end subroutine event_connect

@ %def event_connect
@ Set the parse nodes for the associated expressions, individually.  The
parse-node pointers may be null.
<<Events: event: TBP>>=
  procedure :: set_selection => event_set_selection
  procedure :: set_reweight => event_set_reweight
  procedure :: set_analysis => event_set_analysis
<<Events: procedures>>=
  subroutine event_set_selection (event, ef_selection)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_selection
    allocate (event%config%ef_selection, source = ef_selection)
  end subroutine event_set_selection

  subroutine event_set_reweight (event, ef_reweight)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_reweight
    allocate (event%config%ef_reweight, source = ef_reweight)
  end subroutine event_set_reweight

  subroutine event_set_analysis (event, ef_analysis)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_analysis
    allocate (event%config%ef_analysis, source = ef_analysis)
  end subroutine event_set_analysis
  
@ %def event_set_selection
@ %def event_set_reweight
@ %def event_set_analysis
@ Create evaluation trees from the parse trees.  The [[target]] attribute is
required because the expressions contain pointers to event subobjects.
<<Events: event: TBP>>=
  procedure :: setup_expressions => event_setup_expressions
<<Events: procedures>>=
  subroutine event_setup_expressions (event)
    class(event_t), intent(inout), target :: event
    call event%expr%setup_selection (event%config%ef_selection)
    call event%expr%setup_analysis (event%config%ef_analysis)
    call event%expr%setup_reweight (event%config%ef_reweight)
  end subroutine event_setup_expressions
  
@ %def event_setup_expressions
@
\subsection{Evaluation}
To fill the [[particle_set]], i.e., the event record proper, we have
to apply all event transforms in order.  The last transform should
fill its associated particle set, factorizing the state matrix
according to the current settings.  There are several parameters
in the event configuration that control this.

We always fill the particle set for the first transform (the hard
process) and the last transform, if different from the first (the
fully dressed process).

Each event transform is an event generator of its own.  We choose to
generate an \emph{unweighted} event for each of them, even if the master
event is assumed to be weighted.  Thus, the overall event weight is
the one of the hard process only.  (There may be more options in future
extensions.)

We can generate the two random numbers that the factorization needs.
For testing purpose, we allow for providing them explicitly, as an option.
<<Events: event: TBP>>=
  procedure :: evaluate_transforms => event_evaluate_transforms
<<Events: procedures>>=
  subroutine event_evaluate_transforms (event, r)
    class(event_t), intent(inout) :: event
    real(default), dimension(:), intent(in), optional :: r
    class(evt_t), pointer :: evt
    integer :: i_term
    event%particle_set_exists = .false.
    call event%check ()
    if (event%instance%is_complete_event ()) then
       call event%instance%select_i_term (i_term)
       event%selected_i_term = i_term
       evt => event%transform_first
       do while (associated (evt))
          call evt%prepare_new_event &
               (event%selected_i_mci, event%selected_i_term)
          evt => evt%next
       end do
       evt => event%transform_first
       do while (associated (evt))
          call evt%generate_unweighted ()
          if (signal_is_pending ())  return
          call evt%make_particle_set (event%config%factorization_mode, &
               event%config%keep_correlations)
          if (signal_is_pending ())  return
          if (.not. evt%particle_set_exists)  exit
          evt => evt%next
       end do
       evt => event%transform_last
       if (associated (evt) .and. evt%particle_set_exists) then
          event%particle_set => evt%particle_set
          call event%accept_particle_set ()
       end if
    end if
  end subroutine event_evaluate_transforms
    
@ %def event_evaluate_transforms
@
Evaluate the event-related expressions, given a valid
[[particle_set]].  If [[update_sqme]] is set, we use the process
instance for the [[sqme_prc]] value.  The [[sqme_ref]] value is
always taken from the event record.
<<Events: event: TBP>>=
  procedure :: evaluate_expressions => event_evaluate_expressions
<<Events: procedures>>=
  subroutine event_evaluate_expressions (event)
    class(event_t), intent(inout) :: event
    if (event%particle_set_exists) then
       call event%expr%fill_subevt (event%particle_set)
    end if
    if (event%weight_ref_is_known) then
       call event%expr%set (weight_ref = event%weight_ref)
    end if
    if (event%weight_prc_is_known) then
       call event%expr%set (weight_prc = event%weight_prc)
    end if
    if (event%excess_prc_is_known) then
       call event%expr%set (excess_prc = event%excess_prc)
    end if
    if (event%sqme_ref_is_known) then
       call event%expr%set (sqme_ref = event%sqme_ref)
    end if
    if (event%sqme_prc_is_known) then
       call event%expr%set (sqme_prc = event%sqme_prc)
    end if
    if (event%particle_set_exists) then
       call event%expr%evaluate &
            (event%passed, event%reweight, event%analysis_flag)
       event%selection_evaluated = .true.
    end if
  end subroutine event_evaluate_expressions
  
@ %def event_evaluate_expressions
@ Set alternate sqme and weight arrays.  This should be merged with
the previous routine, if the expressions are allowed to refer to these
values.
<<Events: event: TBP>>=
  procedure :: store_alt_values => event_store_alt_values
<<Events: procedures>>=
  subroutine event_store_alt_values (event)
    class(event_t), intent(inout) :: event
    if (event%weight_alt_is_known) then
       call event%expr%set (weight_alt = event%weight_alt)
    end if
    if (event%sqme_alt_is_known) then
       call event%expr%set (sqme_alt = event%sqme_alt)
    end if
  end subroutine event_store_alt_values
  
@ %def event_store_alt_values
@
\subsection{Reset to empty state}
Applying this, current event contents are marked as incomplete but
are not deleted.  In particular, the initialization is kept.
<<Events: event: TBP>>=
  procedure :: reset => event_reset
<<Events: procedures>>=
  subroutine event_reset (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    event%selected_i_mci = 0
    event%selected_i_term = 0
    event%selected_channel = 0
    event%is_complete = .false.
    event%particle_set_exists = .false.
    event%sqme_ref_is_known = .false.
    event%sqme_prc_is_known = .false.
    event%sqme_alt_is_known = .false.
    event%weight_ref_is_known = .false.
    event%weight_prc_is_known = .false.
    event%weight_alt_is_known = .false.
    event%excess_prc_is_known = .false.
    call event%expr%reset ()
    event%selection_evaluated = .false.
    event%passed = .false.
    event%analysis_flag = .false.
    if (associated (event%instance)) then
       call event%instance%reset (reset_mci = .true.)
    end if
    evt => event%transform_first
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_reset
  
@ %def event_reset
@
\subsection{Squared Matrix Element and Weight}
Set the appropriate entry directly.
<<Events: event: TBP>>=
  procedure :: set => event_set
<<Events: procedures>>=
  subroutine event_set (event, &
       weight_ref, weight_prc, weight_alt, &
       excess_prc, &
       sqme_ref, sqme_prc, sqme_alt)
    class(event_t), intent(inout) :: event
    real(default), intent(in), optional :: weight_ref, weight_prc
    real(default), intent(in), optional :: sqme_ref, sqme_prc
    real(default), dimension(:), intent(in), optional :: sqme_alt, weight_alt
    real(default), intent(in), optional :: excess_prc
    if (present (sqme_ref)) then
       event%sqme_ref_is_known = .true.
       event%sqme_ref = sqme_ref
    end if
    if (present (sqme_prc)) then
       event%sqme_prc_is_known = .true.
       event%sqme_prc = sqme_prc
    end if 
    if (present (sqme_alt)) then
       event%sqme_alt_is_known = .true.
       event%sqme_alt = sqme_alt
    end if
    if (present (weight_ref)) then
       event%weight_ref_is_known = .true.
       event%weight_ref = weight_ref
    end if
    if (present (weight_prc)) then
       event%weight_prc_is_known = .true.
       event%weight_prc = weight_prc
    end if
    if (present (weight_alt)) then
       event%weight_alt_is_known = .true.
       event%weight_alt = weight_alt
    end if
    if (present (excess_prc)) then
       event%excess_prc_is_known = .true.
       event%excess_prc = excess_prc
    end if
  end subroutine event_set
  
@ %def event_set
@ Transfer the result of the process instance calculation to the
event record header.
<<Events: event: TBP>>=
  procedure :: import_instance_results => event_import_instance_results
<<Events: procedures>>=
  subroutine event_import_instance_results (event)
    class(event_t), intent(inout) :: event
    if (associated (event%instance)) then
       if (event%instance%has_evaluated_trace ()) then
          call event%set ( &
               sqme_prc = event%instance%get_sqme (), &
               weight_prc = event%instance%get_weight (), &
               excess_prc = event%instance%get_excess () &
               )
       end if
    end if
  end subroutine event_import_instance_results
  
@ %def event_import_instance_results
@ Duplicate the instance result / the reference result in the event
record.
<<Events: event: TBP>>=
  procedure :: accept_sqme_ref => event_accept_sqme_ref
  procedure :: accept_sqme_prc => event_accept_sqme_prc
  procedure :: accept_weight_ref => event_accept_weight_ref
  procedure :: accept_weight_prc => event_accept_weight_prc
<<Events: procedures>>=
  subroutine event_accept_sqme_ref (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_ref_is_known) then
       call event%set (sqme_prc = event%sqme_ref)
    end if
  end subroutine event_accept_sqme_ref
  
  subroutine event_accept_sqme_prc (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_prc_is_known) then
       call event%set (sqme_ref = event%sqme_prc)
    end if
  end subroutine event_accept_sqme_prc
  
  subroutine event_accept_weight_ref (event)
    class(event_t), intent(inout) :: event
    if (event%weight_ref_is_known) then
       call event%set (weight_prc = event%weight_ref)
    end if
  end subroutine event_accept_weight_ref
  
  subroutine event_accept_weight_prc (event)
    class(event_t), intent(inout) :: event
    if (event%weight_prc_is_known) then
       call event%set (weight_ref = event%weight_prc)
    end if
  end subroutine event_accept_weight_prc
  
@ %def event_accept_sqme_ref
@ %def event_accept_sqme_prc
@ %def event_accept_weight_ref
@ %def event_accept_weight_prc
@ Update the weight normalization, just after generation.  Unweighted
and weighted events are generated with a different default
normalization.  The intended normalization is stored in the
configuration record.
<<Events: event: TBP>>=
  procedure :: update_normalization => event_update_normalization
<<Events: procedures>>=
  subroutine event_update_normalization (event, mode_ref)
    class(event_t), intent(inout) :: event
    integer, intent(in), optional :: mode_ref
    integer :: mode_old
    if (present (mode_ref)) then
       mode_old = mode_ref
    else if (event%config%unweighted) then
       mode_old = NORM_UNIT
    else
       mode_old = NORM_SIGMA
    end if
    call event_normalization_update (event%weight_prc, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event_normalization_update (event%excess_prc, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
  end subroutine event_update_normalization
  
@ %def event_update_normalization
@
The event is complete if it has a particle set plus valid entries for
the sqme and weight values.
<<Events: event: TBP>>=
  procedure :: check => event_check
<<Events: procedures>>=
  subroutine event_check (event)
    class(event_t), intent(inout) :: event
    event%is_complete = event%particle_set_exists &
         .and. event%sqme_ref_is_known &
         .and. event%sqme_prc_is_known &
         .and. event%weight_ref_is_known &
         .and. event%weight_prc_is_known
    if (event%n_alt /= 0) then
       event%is_complete = event%is_complete &
            .and. event%sqme_alt_is_known &
            .and. event%weight_alt_is_known
    end if
  end subroutine event_check
  
@ %def event_check
@ 
@
\subsection{Generation}
Assuming that we have a valid process associated to the event, we
generate an event.  We complete the event data, then factorize the
spin density matrix and transfer it to the particle set.

When done, we retrieve squared matrix element and weight.  In case of
explicit generation, the reference values coincide with the process
values, so we [[accept]] the latter.

The explicit random number argument [[r]] should be generated by a
random-number generator.  It is taken for the factorization algorithm,
bypassing the event-specific random-number generator.  This is useful
for deterministic testing.
<<Events: event: TBP>>=
  procedure :: generate => event_generate
<<Events: procedures>>=
  subroutine event_generate (event, i_mci, r)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci
    real(default), dimension(:), intent(in), optional :: r
    call event%reset ()
    event%selected_i_mci = i_mci
    if (event%config%unweighted) then
       call event%process%generate_unweighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
       call event%instance%normalize_weight ()
    else
       call event%process%generate_weighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
    end if
    event%selected_channel = event%instance%get_channel ()
    call event%import_instance_results ()
    call event%accept_sqme_prc ()
    call event%update_normalization ()
    call event%accept_weight_prc ()
    call event%evaluate_transforms (r)
    if (signal_is_pending ())  return
    call event%check ()
  end subroutine event_generate
  
@ %def event_generate
@ Get a copy of the particle set belonging to the hard process.
<<Events: event: TBP>>=
  procedure :: get_particle_set_hard_proc => event_get_particle_set_hard_proc
<<Events: procedures>>=
  subroutine event_get_particle_set_hard_proc (event, pset)
    class(event_t), intent(in) :: event
    type(particle_set_t), intent(out) :: pset
    class(evt_t), pointer :: evt
    evt => event%transform_first
    pset = evt%particle_set
  end subroutine event_get_particle_set_hard_proc
    
@ %def event_get_particle_set_hard_proc
@
\subsection{Recovering an event}
Select MC group, term, and integration channel.
<<Events: event: TBP>>=
  procedure :: select => event_select
<<Events: procedures>>=
  subroutine event_select (event, i_mci, i_term, channel)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci, i_term, channel
    if (associated (event%instance)) then
       event%selected_i_mci = i_mci
       event%selected_i_term = i_term
       event%selected_channel = channel
    else
       call msg_bug ("Event: select term: process instance undefined")
    end if
  end subroutine event_select

@ %def event_select
@ 
Copy a particle set into the event record.

We deliberately use the first (the trivial) transform for this, i.e.,
the hard process.  Thus, with the current implementation, event
readers can only be used for reading hard events.  However, once we
have reconstructed the master process, we may apply all event
transforms to generate a fully dressed event.

Since this makes all subsequent event transforms invalid, we call
[[reset]] on them.
<<Events: event: TBP>>=
  procedure :: set_particle_set_hard_proc => event_set_particle_set_hard_proc
<<Events: procedures>>=
  subroutine event_set_particle_set_hard_proc (event, particle_set)
    class(event_t), intent(inout) :: event
    type(particle_set_t), intent(in) :: particle_set
    class(evt_t), pointer :: evt
    evt => event%transform_first
    call evt%set_particle_set (particle_set, &
         event%selected_i_mci, event%selected_i_term)
    event%particle_set => evt%particle_set
    call event%accept_particle_set ()
    evt => evt%next
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_set_particle_set_hard_proc

@ %def event_set_particle_set_hard_proc
@ Mark the particle set as existing, assuming that it has just been
filled somehow.
<<Events: event: TBP>>=
  procedure :: accept_particle_set => event_accept_particle_set
<<Events: procedures>>=
  subroutine event_accept_particle_set (event)
    class(event_t), intent(inout) :: event
    event%particle_set_exists = .true.
  end subroutine event_accept_particle_set
  
@ %def event_accept_particle_set
@
Here we try to recover an event from the [[particle_set]] subobject
and recalculate the structure functions and matrix elements.  We
have the appropriate [[process]] object and an initialized
[[process_instance]] at hand, so beam and configuration data are
known.  From the [[particle_set]], we get the momenta.

The quantum-number information may be incomplete, e.g., helicity
information may be partial or absent.  We recover the event just from
the momentum configuration.

We do not transfer the matrix element from the process instance to the
event record, as we do when generating an event.  The event record may
contain the matrix element as read from file, and the current
calculation may use different parameters.  We thus can compare old and
new values.

The event [[weight]] may also be known already.  If yes, we pass it to the
[[evaluate_event_data]] procedure.  It should already be normalized.  If we
have an [[weight_factor]] value, we obtain the event weight by multiplying the
computed [[sqme]] by this factor.  Otherwise, we make use of the MCI setup
(which should be valid then) to compute the event weight, and we should
normalize the result just as when generating events.

Evaluating event expressions must also be done separately.
<<Events: event: TBP>>=
  procedure :: recalculate => event_recalculate
<<Events: procedures>>=
  subroutine event_recalculate &
       (event, update_sqme, weight_factor, recover_beams)
    class(event_t), intent(inout) :: event
    logical, intent(in) :: update_sqme
    real(default), intent(in), optional :: weight_factor
    logical, intent(in), optional :: recover_beams
    integer :: i_mci, i_term, channel
    if (event%particle_set_exists) then
       i_mci = event%selected_i_mci
       i_term = event%selected_i_term
       channel = event%selected_channel
       if (i_mci == 0 .or. i_term == 0 .or. channel == 0) then
          call msg_bug ("Event: recalculate: undefined selection parameters")
       end if
       call event%instance%choose_mci (i_mci)
       call event%instance%set_trace (event%particle_set, i_term, recover_beams)
       call event%instance%recover (channel, i_term, update_sqme) 
       if (signal_is_pending ())  return
       if (update_sqme .and. present (weight_factor)) then
          call event%instance%evaluate_event_data &
               (weight = event%instance%get_sqme () * weight_factor)
       else if (event%weight_ref_is_known) then
          call event%instance%evaluate_event_data &
               (weight = event%weight_ref)
       else
          call event%process%recover_event (event%instance, i_term)
          if (signal_is_pending ())  return
          call event%instance%evaluate_event_data ()
          if (event%config%unweighted) then
             call event%instance%normalize_weight ()
          end if
       end if
       if (signal_is_pending ())  return
       if (update_sqme) then
          call event%import_instance_results ()
       else
          call event%accept_sqme_ref ()
          call event%accept_weight_ref ()
       end if
    else
       call msg_bug ("Event: can't recalculate, particle set is undefined")
    end if
  end subroutine event_recalculate
  
@ %def event_recalculate
@
\subsection{Access content}
Pointer to the associated process object.
<<Events: event: TBP>>=
  procedure :: get_process_ptr => event_get_process_ptr
<<Events: procedures>>=
  function event_get_process_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_t), pointer :: ptr
    ptr => event%process
  end function event_get_process_ptr

@ %def event_get_process_ptr
@ Tell whether the particle set is defined:
<<Events: event: TBP>>=
  procedure :: has_particle_set => event_has_particle_set
<<Events: procedures>>=
  function event_has_particle_set (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    flag = event%particle_set_exists
  end function event_has_particle_set
  
@ %def event_has_particle_set
@ Pointer to the particle set.
<<Events: event: TBP>>=
  procedure :: get_particle_set_ptr => event_get_particle_set_ptr
<<Events: procedures>>=
  function event_get_particle_set_ptr (event) result (ptr)
    class(event_t), intent(in), target :: event
    type(particle_set_t), pointer :: ptr
    ptr => event%particle_set
  end function event_get_particle_set_ptr
  
@ %def event_get_particle_set_ptr
@ Return the current values of indices: the MCI group of components, the term
index (different terms corresponding, potentially, to different effective
kinematics), and the MC integration channel.  The [[i_mci]] call is delegated
to the current process instance.
<<Events: event: TBP>>=
  procedure :: get_i_mci => event_get_i_mci
  procedure :: get_i_term => event_get_i_term
  procedure :: get_channel => event_get_channel
<<Events: procedures>>=
  function event_get_i_mci (event) result (i_mci)
    class(event_t), intent(in) :: event
    integer :: i_mci
    i_mci = event%selected_i_mci
  end function event_get_i_mci
  
  function event_get_i_term (event) result (i_term)
    class(event_t), intent(in) :: event
    integer :: i_term
    i_term = event%selected_i_term
  end function event_get_i_term
  
  function event_get_channel (event) result (channel)
    class(event_t), intent(in) :: event
    integer :: channel
    channel = event%selected_channel
  end function event_get_channel
  
@ %def event_get_i_mci
@ %def event_get_i_term
@ %def event_get_channel
@ Return the currently selected normalization mode, or alternate
normalization mode.
<<Events: event: TBP>>=
  procedure :: get_norm_mode => event_get_norm_mode
<<Events: procedures>>=
  elemental function event_get_norm_mode (event) result (norm_mode)
    class(event_t), intent(in) :: event
    integer :: norm_mode
    norm_mode = event%config%norm_mode
  end function event_get_norm_mode
  
@ %def event_get_norm_mode
@ Return the kinematical weight, defined as the ratio of event weight
and squared matrix element.
<<Events: event: TBP>>=
  procedure :: get_kinematical_weight => event_get_kinematical_weight
<<Events: procedures>>=
  function event_get_kinematical_weight (event) result (f)
    class(event_t), intent(in) :: event
    real(default) :: f
    if (event%sqme_ref_is_known .and. event%weight_ref_is_known &
         .and. event%sqme_ref /= 0) then
       f = event%weight_ref / event%sqme_ref
    else
       f = 0
    end if
  end function event_get_kinematical_weight
    
@ %def event_get_kinematical_weight
@ Return data used by external event formats.
<<Events: event: TBP>>=
  procedure :: get_fac_scale => event_get_fac_scale
  procedure :: get_alpha_s => event_get_alpha_s
<<Events: procedures>>=
  function event_get_fac_scale (event) result (fac_scale)
    class(event_t), intent(in) :: event
    real(default) :: fac_scale
    fac_scale = event%instance%get_fac_scale (event%selected_i_term)
  end function event_get_fac_scale
    
  function event_get_alpha_s (event) result (alpha_s)
    class(event_t), intent(in) :: event
    real(default) :: alpha_s
    alpha_s = event%instance%get_alpha_s (event%selected_i_term)
  end function event_get_alpha_s
    
@ %def event_get_fac_scale
@ %def event_get_alpha_s
@
Eliminate numerical noise in the [[subevt]] expression and in the event
transforms (which includes associated process instances).
<<Events: public>>=
  public :: pacify
<<Events: interfaces>>=
  interface pacify
     module procedure pacify_event
  end interface pacify
<<Events: procedures>>=
  subroutine pacify_event (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    if (event%particle_set_exists)  call pacify (event%particle_set)
    if (event%expr%subevt_filled)  call pacify (event%expr)
    evt => event%transform_first
    do while (associated (evt))
       select type (evt)
       type is (evt_decay_t);  call pacify (evt)
       end select
       evt => evt%next
    end do
  end subroutine pacify_event
  
@ %def pacify
@
\subsection{Unit tests}
<<Events: public>>=
  public :: events_test
<<Events: tests>>=
  subroutine events_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Events: execute tests>>
  end subroutine events_test
  
@ %def events_test
@
\subsubsection{Empty event record}
<<Events: execute tests>>=
  call test (events_1, "events_1", &
       "empty event record", &
       u, results)
<<Events: tests>>=
  subroutine events_1 (u)
    integer, intent(in) :: u
    type(event_t), target :: event

    write (u, "(A)")  "* Test output: events_1"
    write (u, "(A)")  "*   Purpose: display an empty event object"
    write (u, "(A)")

    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_1"
    
  end subroutine events_1
  
@ %def events_1
@
\subsubsection{Simple event}
<<Events: execute tests>>=
  call test (events_2, "events_2", &
       "generate event", &
       u, results)
<<Events: tests>>=
  subroutine events_2 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(model_list_t) :: model_list

    write (u, "(A)")  "* Test output: events_2"
    write (u, "(A)")  "*   Purpose: generate and display an event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Generate test process event"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process%generate_weighted_event (process_instance, 1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_2"
    
  end subroutine events_2
  
@ %def events_2
@
\subsubsection{Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event from that.
<<Events: execute tests>>=
  call test (events_4, "events_4", &
       "recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_4 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    type(model_list_t) :: model_list

    write (u, "(A)")  "* Test output: events_4"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set = event%particle_set

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_particle_set_hard_proc (particle_set)
    call event%recalculate (update_sqme = .true.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transfer sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%accept_sqme_prc ()
    call event%accept_weight_prc ()
    call event%check ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset contents"
    write (u, "(A)")

    call event%reset ()
    event%transform_first%particle_set_exists = .false.
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (particle_set)

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_4"
    
  end subroutine events_4
  
@ %def events_4
@
\subsubsection{Partially Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event as far as possible
without recomputing the squared matrix element.
<<Events: execute tests>>=
  call test (events_5, "events_5", &
       "partially recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_5 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    real(default) :: sqme, weight
    type(model_list_t) :: model_list

    write (u, "(A)")  "* Test output: events_5"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set = event%particle_set
    sqme = event%sqme_ref
    weight = event%weight_ref

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_particle_set_hard_proc (particle_set)
    call event%recalculate (update_sqme = .false.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Manually set sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%set (sqme_ref = sqme, weight_ref = weight)
    call event%accept_sqme_ref ()
    call event%accept_weight_ref ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set_final (particle_set)

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_5"
    
  end subroutine events_5
  
@ %def events_5
@
\subsubsection{Decays}
Generate an event with subsequent decays.
<<Events: execute tests>>=
  call test (events_6, "events_6", &
       "decays", &
       u, results)
<<Events: tests>>=
  subroutine events_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: prefix, procname1, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    class(evt_t), pointer :: evt_decay
    type(event_t), allocatable, target :: event
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_6"
    write (u, "(A)")  "*   Purpose: generate an event with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process and decay"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)

    prefix = "events_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    call model%set_unstable (25, [procname2])

    process => process_stack%get_process_ptr (procname1)
    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event transform: decay"

    allocate (evt_decay_t :: evt_decay)
    call evt_decay%connect (process_instance, model, process_stack)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"
    write (u, "(A)")

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, model)
    call event%import_transform (evt_decay)
    
    call event%write (u, show_decay = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_6"
    
  end subroutine events_6
  
@ %def events_6
@
\subsubsection{Decays}
Generate a decay event with varying options.
<<Events: execute tests>>=
  call test (events_7, "events_7", &
       "decay options", &
       u, results)
<<Events: tests>>=
  subroutine events_7 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: prefix, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_7"
    write (u, "(A)")  "*   Purpose: check decay options"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare test process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)

    prefix = "events_7"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, model_list, model, prefix, os_data, &
         scattering=.false., decay=.true.)

    write (u, "(A)")  "* Generate decay event, default options"
    write (u, "(A)")

    call model%set_unstable (25, [procname2])

    process => process_stack%get_process_ptr (procname2)
    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, helicity-diagonal decay"
    write (u, "(A)")

    call model%set_unstable (25, [procname2], diagonal = .true.)

    process => process_stack%get_process_ptr (procname2)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, isotropic decay, &
         &polarized final state"
    write (u, "(A)")

    call model%set_unstable (25, [procname2], isotropic = .true.)
    call model%set_polarized (6)
    call model%set_polarized (-6)

    process => process_stack%get_process_ptr (procname2)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_stack%final ()
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_7"
    
  end subroutine events_7
  
@ %def events_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Matrix Element Implementations}

In this chapter, we define concrete implementations for the workflow,
from matrix-element code generation via matrix-element access to
integration and event generation.

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Template matrix elements}

Here, we provide template matrix elements that are in structure 
very similar to \oMega\ matrix elements, but do not need its
infrastructure. Per default, the matrix elements are flat, i.e.
they have the constant value one. Analogous to the \oMega\
implementation, this section implements the interface
to the templates (via the makefile) and the driver.
<<[[prc_template_me.f90]]>>=
<<File header>>

module prc_template_me
  
  use iso_c_binding !NODEP!
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use system_defs, only: TAB
  use diagnostics
  use os_interface
  use lorentz
  use flavors
  use sm_qcd
  use interactions
  use variables
  use models

  use process_constants
  use prclib_interfaces
  use prc_core_def
  use particle_specifiers
  use process_libraries
  use prc_core

<<Standard module head>>

<<Template matrix elements: public>>

<<Template matrix elements: types>>

<<Template matrix elements: interfaces>>

contains
  
<<Template matrix elements: procedures>>

<<Template matrix elements: tests>>

end module prc_template_me
@ %def prc_template_me
@
\subsection{Process definition}
For the process definition we implement an extension of the
[[prc_core_def_t]] abstract type.
<<Template matrix elements: public>>=
  public :: template_me_def_t
<<Template matrix elements: types>>=
  type, extends (prc_core_def_t) :: template_me_def_t
   contains
   <<Template matrix elements: template ME def: TBP>>
  end type template_me_def_t
  
@ %def template_me_def_t
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: type_string => template_me_def_type_string
<<Template matrix elements: procedures>>=
  function template_me_def_type_string () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_def_type_string

@ %def template_me_def_type_string
@ Initialization: allocate the writer for the template matrix element.
Also set any data for this process that the writer needs.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: init => template_me_def_init
<<Template matrix elements: procedures>>=
  subroutine template_me_def_init &
       (object, model, prt_in, prt_out, unity)
    class(template_me_def_t), intent(out) :: object
    type(model_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    allocate (template_me_writer_t :: object%writer)
    select type (writer => object%writer)
    type is (template_me_writer_t)
       call writer%init (model, prt_in, prt_out, unity)
    end select
  end subroutine template_me_def_init

@ %def template_me_def_init
@ Write/read process- and method-specific data.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: write => template_me_def_write
<<Template matrix elements: procedures>>=
  subroutine template_me_def_write (object, unit)
    class(template_me_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (template_me_writer_t)
       call writer%write (unit)
    end select
  end subroutine template_me_def_write
  
@ %def template_me_def_write
@ 
<<Template matrix elements: template ME def: TBP>>=
  procedure :: read => template_me_def_read
<<Template matrix elements: procedures>>=
  subroutine template_me_def_read (object, unit)
    class(template_me_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug &
         ("WHIZARD template process definition: input not supported (yet)")
  end subroutine template_me_def_read
  
@ %def template_me_def_read
@ Allocate the driver for template matrix elements.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: allocate_driver => template_me_def_allocate_driver
<<Template matrix elements: procedures>>=
  subroutine template_me_def_allocate_driver (object, driver, basename)
    class(template_me_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    allocate (template_me_driver_t :: driver)
  end subroutine template_me_def_allocate_driver
  
@ %def template_me_def_allocate_driver
@ We need code:
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: needs_code => template_me_def_needs_code
<<Template matrix elements: procedures>>=
  function template_me_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function template_me_def_needs_code
  
@ %def template_me_def_needs_code
@ These are the features that a template matrix element provides.
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: get_features => template_me_def_get_features
<<Template matrix elements: procedures>>=
  subroutine template_me_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine template_me_def_get_features

@ %def template_me_def_get_features
@ The interface of the specific features.
<<Template matrix elements: interfaces>>=
  abstract interface
     subroutine init_t (par) bind(C)
       import
       real(c_default_float), dimension(*), intent(in) :: par
     end subroutine init_t
  end interface
  
  abstract interface
     subroutine update_alpha_s_t (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine update_alpha_s_t
  end interface
  
  abstract interface
     subroutine is_allowed_t (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine is_allowed_t
  end interface

  abstract interface
     subroutine new_event_t (p) bind(C)
       import
       real(c_default_float), dimension(0:3,*), intent(in) :: p
     end subroutine new_event_t
  end interface
  
  abstract interface
     subroutine get_amplitude_t (flv, hel, col, amp) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       complex(c_default_complex), intent(out):: amp
     end subroutine get_amplitude_t
  end interface

@ %def init_t update_alpha_s_t 
@ %def is_allowed_t new_event_t get_amplitude_t
@ Connect the template matrix element features with the process driver.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: connect => template_me_def_connect
<<Template matrix elements: procedures>>=
  subroutine template_me_def_connect (def, lib_driver, i, proc_driver)
    class(template_me_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    integer(c_int) :: pid, fid
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is  (template_me_driver_t)
       pid = i
       fid = 1
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%init)
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 3
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%new_event)
       fid = 5
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%get_amplitude)
    end select
  end subroutine template_me_def_connect

@ %def template_me_def_connect
@
\subsection{The Template Matrix element writer}
Unlike \oMega, the template matrix element is directly written by the main
\whizard\ program, so there will be no entry in the makefile for
calling an external program. The template matrix element writer is
responsible for writing interfaces and wrappers.
<<Template matrix elements: types>>=
  type, extends (prc_writer_f_module_t) :: template_me_writer_t
     type(model_t), pointer :: model => null ()
     type(string_t) :: model_name
     logical :: unity
     type(string_t), dimension(:), allocatable :: prt_in
     type(string_t), dimension(:), allocatable :: prt_out
     integer :: n_in
     integer :: n_out
     integer :: n_tot
   contains
   <<Template matrix elements: template ME writer: TBP>>
  end type template_me_writer_t

@ %def template_me_writer_t
@ The reported type is the same as for the [[template_me_def_t]] type.
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: type_name => template_me_writer_type_name
<<Template matrix elements: procedures>>=
  function template_me_writer_type_name () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_writer_type_name

@ %def template_me_writer_type_name
@ Taking into account the prefix for template ME module names.
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: get_module_name => template_me_writer_get_module_name
<<Template matrix elements: procedures>>=
  function template_me_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "tpr_" // id
  end function template_me_writer_get_module_name

@ %def template_me_writer_get_module_name
@ Output.  This is called by [[template_me_def_write]].
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write => template_me_writer_write
<<Template matrix elements: procedures>>=
  subroutine template_me_writer_write (object, unit)
    class(template_me_writer_t), intent(in) :: object
    integer, intent(in) :: unit
    integer :: i, j
    write (unit, "(5x,A,I0)") "# incoming part. = ", object%n_in
    write (unit, "(7x,A)", advance="no") &
                              "   Initial state: "  
    do i = 1, object%n_in - 1
       write (unit, "(1x,A)", advance="no") char (object%prt_in(i))
    end do
    write (unit, "(1x,A)") char (object%prt_in(object%n_in))    
    write (unit, "(5x,A,I0)") "# outgoing part. = ", object%n_out    
    write (unit, "(7x,A)", advance="no") &
                              "   Final state:   "      
    do j = 1, object%n_out - 1
       write (unit, "(1x,A)", advance="no") char (object%prt_out(i))
    end do    
    write (unit, "(1x,A)") char (object%prt_out(object%n_out))    
    write (unit, "(5x,A,I0)") "# part. (total) = ", object%n_tot
  end subroutine template_me_writer_write

@ %def template_me_writer_write
@ Initialize with process data.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: init => template_me_writer_init
<<Template matrix elements: procedures>>=
  subroutine template_me_writer_init (writer, model, &
       prt_in, prt_out, unity)
    class(template_me_writer_t), intent(out) :: writer
    type(model_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    writer%model => model
    writer%model_name = model%get_name ()
    writer%n_in = size (prt_in)
    writer%n_out = size (prt_out)
    writer%n_tot = size (prt_in) + size (prt_out)
    allocate (writer%prt_in (size (prt_in)), source = prt_in)
    allocate (writer%prt_out (size (prt_out)), source = prt_out)    
    writer%unity = unity    
  end subroutine template_me_writer_init

@ %def template_me_writer_init
@ The makefile is the driver file for the test matrix elements.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_makefile_code => template_me_write_makefile_code
<<Template matrix elements: procedures>>=
  subroutine template_me_write_makefile_code (writer, unit, id, os_data, testflag)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    write (unit, "(5A)")  "SOURCES += ", char (id), ".f90"
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f tpr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"    
    write (unit, "(5A)")  "CLEAN_OBJECTS += tpr_", char (id), ".mod"       
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
  end subroutine template_me_write_makefile_code

@ %def template_me_write_makefile_code
@ The source is written by this routine.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_source_code => template_me_write_source_code
<<Template matrix elements: procedures>>=
  subroutine template_me_write_source_code (writer, id)
    class(template_me_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    integer, dimension(writer%n_in) :: prt_in, mult_in, col_in
    type(flavor_t), dimension(1:writer%n_in) :: flv_in    
    integer, dimension(writer%n_out) :: prt_out, mult_out
    integer, dimension(writer%n_tot) :: prt, mult
    integer, dimension(:,:), allocatable :: sxxx
    integer :: dummy, status
    type(flavor_t), dimension(1:writer%n_out) :: flv_out    
    type(string_t) :: proc_str, comment_str
    integer :: u, i, j
    integer :: hel, hel_in, hel_out, fac, factor, col_fac
    type(string_t) :: filename
    comment_str = ""
    do i = 1, writer%n_in
       comment_str = comment_str // writer%prt_in(i) // " " 
    end do   
    do j = 1, writer%n_out
       comment_str = comment_str // writer%prt_out(j) // " " 
    end do       
    do i = 1, writer%n_in
       prt_in(i) = writer%model%get_pdg (writer%prt_in(i))
       call flavor_init (flv_in(i), prt_in(i), writer%model)
       mult_in(i) = flavor_get_multiplicity (flv_in(i))
       col_in(i) = abs(flavor_get_color_type (flv_in(i)))
       mult(i) = mult_in(i)
       end do
    do j = 1, writer%n_out
       prt_out(j) = writer%model%get_pdg (writer%prt_out(j))    
       call flavor_init (flv_out(j), prt_out(j), writer%model)       
       mult_out(j) = flavor_get_multiplicity (flv_out(j))       
       mult(writer%n_in + j) = mult_out(j)
       end do
    prt(1:writer%n_in) = prt_in(1:writer%n_in)
    prt(writer%n_in+1:writer%n_tot) = prt_out(1:writer%n_out)
    proc_str = converter (prt)
    hel_in = product (mult_in)
    hel_out = product (mult_out)
    col_fac = product (col_in)
    hel = hel_in * hel_out
    fac = hel
    dummy = 1
    factor = 1
    if (writer%n_out >= 3) then
       do i = 3, writer%n_out
          factor = factor * (i - 2) * (i - 1)
       end do
    end if    
    factor = factor * col_fac
    allocate (sxxx(1:hel,1:writer%n_tot))
    call create_spin_table (dummy,hel,fac,mult,sxxx)
    call msg_message ("Writing test matrix element for process '" &
         // char (id) // "'")
    filename = id // ".f90"
    u = free_unit ()
    open (unit=u, file=char(filename), action="write")
    write (u, "(A)") "! File generated automatically by WHIZARD"   
    write (u, "(A)") "!                                        "
    write (u, "(A)") "! Note that irresp. of what you demanded WHIZARD"
    write (u, "(A)") "! treats this as colorless process       "    
    write (u, "(A)") "!                                        "
    write (u, "(A)") "module tpr_" // char(id)
    write (u, "(A)") "                                         "
    write (u, "(A)") "  use kinds"    
    write (u, "(A)") "  use omega_color, OCF => omega_color_factor"        
    write (u, "(A)") "                                         "
    write (u, "(A)") "  implicit none"        
    write (u, "(A)") "  private"            
    write (u, "(A)") "                                         "    
    write (u, "(A)") "  public :: md5sum"        
    write (u, "(A)") "  public :: number_particles_in, number_particles_out"       
    write (u, "(A)") "  public :: number_spin_states, spin_states"
    write (u, "(A)") "  public :: number_flavor_states, flavor_states"
    write (u, "(A)") "  public :: number_color_flows, color_flows"
    write (u, "(A)") "  public :: number_color_indices, number_color_factors, &"
    write (u, "(A)") "     color_factors, color_sum, openmp_supported"
    write (u, "(A)") "  public :: init, final, update_alpha_s"  
    write (u, "(A)") "                                         "    
    write (u, "(A)") "  public :: new_event, is_allowed, get_amplitude"        
    write (u, "(A)") "       "      
    write (u, "(A)") "  real(default), parameter :: &"
    write (u, "(A)") "       & conv = 0.38937966e12_default"
    write (u, "(A)") "       "
    write (u, "(A)") "  real(default), parameter :: &"
    write (u, "(A)") "       & pi = 3.1415926535897932384626433832795028841972_default"
    write (u, "(A)") "       "
    write (u, "(A)") "  real(default), parameter :: &"
    if (writer%unity) then
       write (u, "(A)") "                   & const = 1"
    else 
       write (u, "(A,1x,I0,A)") "       & const = (16 * pi / conv) * " &
          // "(16 * pi**2)**(", writer%n_out, "-2) " 
    end if
    write (u, "(A)") "       "    
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_prt =  ", &
       writer%n_tot
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_in = ", &
       writer%n_in
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_out = ", &
       writer%n_out
    write (u, "(A)") "  integer, parameter, private :: n_cflow = 1"
    write (u, "(A)") "  integer, parameter, private :: n_cindex = 2"
    write (u, "(A)") "  !!! We ignore tensor products and take only one flavor state."
    write (u, "(A)") "  integer, parameter, private :: n_flv = 1"
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_hel = ", hel
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, parameter, private :: T = .true."
    write (u, "(A)") "  logical, parameter, private :: F = .false."
    write (u, "(A)") "                                           "    
    do i = 1, hel
       write (u, "(A)") "  integer, dimension(n_prt), parameter, private :: &"
       write (u, "(A)") "    " // s_conv(i) // " = [ " // &
            char(converter(sxxx(i,1:writer%n_tot))) // " ]"
    end do 
    write (u, "(A)") "  integer, dimension(n_prt,n_hel), parameter, private :: table_spin_states = &"
    write (u, "(A)") "    reshape ( [ & "
    do i = 1, hel-1
       write (u, "(A)") "                 " // s_conv(i) // ", & " 
    end do 
    write (u, "(A)") "                 " // s_conv(hel) // " & "     
    write (u, "(A)") "              ], [ n_prt, n_hel ] )"
    write (u, "(A)") "                                                 "
    write (u, "(A)") "  integer, dimension(n_prt), parameter, private :: &"
    write (u, "(A)") "    f0001 = [ " // char(proc_str) // " ]   !  " // char(comment_str)
    write (u, "(A)") "  integer, dimension(n_prt,n_flv), parameter, private :: table_flavor_states = &"
    write (u, "(A)") "    reshape ( [ f0001 ], [ n_prt, n_flv ] )"
    write (u, "(A)") "                                                 " 
    write (u, "(A)") "  integer, dimension(n_cindex, n_prt), parameter, private :: &"
    write (u, "(A)") "    c0001 = reshape ( [ " // char (dummy_colorizer (flv_in)) // " " // &
      (repeat ("0,0, ", writer%n_out-1)) // "0,0 ], " // " [ n_cindex, n_prt ] )"
    write (u, "(A)") "  integer, dimension(n_cindex, n_prt, n_cflow), parameter, private :: &"
    write (u, "(A)") "  table_color_flows = reshape ( [ c0001 ], [ n_cindex, n_prt, n_cflow ] )"
    write (u, "(A)") "                                           "   
    write (u, "(A)") "  logical, dimension(n_prt), parameter, private :: & "
    write (u, "(A)") "    g0001 = [ "  // (repeat ("F, ", writer%n_tot-1)) // "F ] "
    write (u, "(A)") "  logical, dimension(n_prt, n_cflow), parameter, private " &
         // ":: table_ghost_flags = &"
    write (u, "(A)") "    reshape ( [ g0001 ], [ n_prt, n_cflow ] )"
    write (u, "(A)") "                                           "   
    write (u, "(A)") "  integer, parameter, private :: n_cfactors = 1"
    write (u, "(A)") "  type(OCF), dimension(n_cfactors), parameter, private :: &"
    write (u, "(A)") "    table_color_factors = [  OCF(1,1,+1._default) ]"
    write (u, "(A)") "                                           "   
    write (u, "(A)") "  logical, dimension(n_flv), parameter, private :: a0001 = [ T ]"   
    write (u, "(A)") "  logical, dimension(n_flv, n_cflow), parameter, private :: &"   
    write (u, "(A)") "    flv_col_is_allowed = reshape ( [ a0001 ], [ n_flv, n_cflow ] )"   
    write (u, "(A)") "                                           "   
    write (u, "(A)") "  complex(default), dimension (n_flv, n_hel, n_cflow), private, save :: amp"    
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, dimension(n_hel), private, save :: hel_is_allowed = T"
    write (u, "(A)") "                                           "
    write (u, "(A)") "contains"          
    write (u, "(A)") "                                           "      
    write (u, "(A)") "  pure function md5sum ()"
    write (u, "(A)") "    character(len=32) :: md5sum"    
    write (u, "(A)") "    ! DON'T EVEN THINK of modifying the following line!"        
    write (u, "(A)") "    md5sum = """ // writer%md5sum // """"
    write (u, "(A)") "  end function md5sum"
    write (u, "(A)") "                                           "          
    write (u, "(A)") "  subroutine init (par)"
    write (u, "(A)") "    real(default), dimension(*), intent(in) :: par"    
    write (u, "(A)") "  end subroutine init"    
    write (u, "(A)") "                                           " 
    write (u, "(A)") "  subroutine final ()" 
    write (u, "(A)") "  end subroutine final" 
    write (u, "(A)") "                                           " 
    write (u, "(A)") "  subroutine update_alpha_s (alpha_s)" 
    write (u, "(A)") "    real(default), intent(in) :: alpha_s"        
    write (u, "(A)") "  end subroutine update_alpha_s" 
    write (u, "(A)") "                                           " 
    write (u, "(A)") "  pure function number_particles_in () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = n_in"
    write (u, "(A)") "  end function number_particles_in"
    write (u, "(A)") "                                           "              
    write (u, "(A)") "  pure function number_particles_out () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = n_out"
    write (u, "(A)") "  end function number_particles_out"
    write (u, "(A)") "                                           "                  
    write (u, "(A)") "  pure function number_spin_states () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = size (table_spin_states, dim=2)"
    write (u, "(A)") "  end function number_spin_states"
    write (u, "(A)") "                                           "                      
    write (u, "(A)") "  pure subroutine spin_states (a)"
    write (u, "(A)") "    integer, dimension(:,:), intent(out) :: a"    
    write (u, "(A)") "    a = table_spin_states"
    write (u, "(A)") "  end subroutine spin_states"    
    write (u, "(A)") "                                           "                          
    write (u, "(A)") "  pure function number_flavor_states () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = 1"
    write (u, "(A)") "  end function number_flavor_states"
    write (u, "(A)") "                                           "                      
    write (u, "(A)") "  pure subroutine flavor_states (a)"
    write (u, "(A)") "    integer, dimension(:,:), intent(out) :: a"    
    write (u, "(A)") "    a = table_flavor_states"
    write (u, "(A)") "  end subroutine flavor_states"
    write (u, "(A)") "                                           "                          
    write (u, "(A)") "  pure function number_color_indices () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = size(table_color_flows, dim=1)"
    write (u, "(A)") "  end function number_color_indices"
    write (u, "(A)") "                                           "                          
    write (u, "(A)") "  pure subroutine color_factors (cf)"
    write (u, "(A)") "    type(OCF), dimension(:), intent(out) :: cf"    
    write (u, "(A)") "    cf = table_color_factors"
    write (u, "(A)") "  end subroutine color_factors"
    write (u, "(A)") "                                           "                              
    !pure unless OpenMP
    !write (u, "(A)") "  pure function color_sum (flv, hel) result (amp2)"
    write (u, "(A)") "  function color_sum (flv, hel) result (amp2)"
    write (u, "(A)") "    integer, intent(in) :: flv, hel"
    write (u, "(A)") "    real(kind=default) :: amp2"
    write (u, "(A)") "    amp2 = real (omega_color_sum (flv, hel, amp, table_color_factors))"
    write (u, "(A)") "  end function color_sum"
    write (u, "(A)") "                                           "       
    write (u, "(A)") "  pure function number_color_flows () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = size (table_color_flows, dim=3)"
    write (u, "(A)") "  end function number_color_flows"
    write (u, "(A)") "                                           "                                  
    write (u, "(A)") "  pure subroutine color_flows (a, g)"
    write (u, "(A)") "    integer, dimension(:,:,:), intent(out) :: a"
    write (u, "(A)") "    logical, dimension(:,:), intent(out) :: g"
    write (u, "(A)") "    a = table_color_flows"
    write (u, "(A)") "    g = table_ghost_flags"
    write (u, "(A)") "  end subroutine color_flows"    
    write (u, "(A)") "                                           "                              
    write (u, "(A)") "  pure function number_color_factors () result (n)"
    write (u, "(A)") "    integer :: n"    
    write (u, "(A)") "    n = size (table_color_factors)"
    write (u, "(A)") "  end function number_color_factors"
    write (u, "(A)") "                                           "                                  
    write (u, "(A)") "  pure function openmp_supported () result (status)"
    write (u, "(A)") "    logical :: status"
    write (u, "(A)") "    status = .false."
    write (u, "(A)") "  end function openmp_supported"
    write (u, "(A)") "                                           "                                  
    write (u, "(A)") "  subroutine new_event (p)"
    write (u, "(A)") "    real(default), dimension(0:3,*), intent(in) :: p"    
    write (u, "(A)") "    call calculate_amplitudes (amp, p)"        
    write (u, "(A)") "  end subroutine new_event"
    write (u, "(A)") "                                           "              
    write (u, "(A)") "  pure function is_allowed (flv, hel, col) result (yorn)"                  
    write (u, "(A)") "    logical :: yorn"                  
    write (u, "(A)") "    integer, intent(in) :: flv, hel, col"                  
    write (u, "(A)") "    yorn = hel_is_allowed(hel) .and. flv_col_is_allowed(flv,col)"                  
    write (u, "(A)") "  end function is_allowed"                     
    write (u, "(A)") "                                           "                  
    write (u, "(A)") "  pure function get_amplitude (flv, hel, col) result (amp_result)"
    write (u, "(A)") "    complex(default) :: amp_result"    
    write (u, "(A)") "    integer, intent(in) :: flv, hel, col"            
    write (u, "(A)") "    amp_result = amp (flv, hel, col)"        
    write (u, "(A)") "  end function get_amplitude"
    write (u, "(A)") "                                           "                  
    write (u, "(A)") "  pure subroutine calculate_amplitudes (amp, k)"
    write (u, "(A)") "    complex(default), dimension(:,:,:), intent(out) :: amp"    
    write (u, "(A)") "    real(default), dimension(0:3,*), intent(in) :: k"    
    write (u, "(A)") "    real(default) :: fac"        
    write (u, "(A)") "    integer :: i"            
    write (u, "(A)") "    ! We give all helicities the same weight!"            
    if (writer%unity) then 
       write (u, "(A,1x,I0,1x,A)") "    fac = ", col_fac
       write (u, "(A)") "    amp = const * sqrt(fac)"
    else
       write (u, "(A,1x,I0,1x,A)") "    fac = ", factor 
       write (u, "(A)") "    amp = sqrt((2 * (k(0,1)*k(0,2) &"
       write (u, "(A,1x,I0,A)") "         - dot_product (k(1:,1), k(1:,2)))) ** (3-", &
                                  writer%n_out, ")) * sqrt(const * fac)"
    end if                                  
    write (u, "(A,1x,I0,A)") "    amp = amp / sqrt(", hel_out, "._default)"
    write (u, "(A)") "  end subroutine calculate_amplitudes"
    write (u, "(A)") "                                           "                  
    write (u, "(A)") "end module tpr_" // char(id)    
    close (u, iostat=status)
    deallocate (sxxx)
  contains
    function s_conv (num) result (chrt)
      integer, intent(in) :: num
      character(len=10) :: chrt
      write (chrt, "(I10)") num
      chrt = trim(adjustl(chrt))
      if (num < 10) then
         chrt = "s000" // chrt
      else if (num < 100) then
         chrt = "s00" // chrt
      else if (num < 1000) then 
         chrt = "s0" // chrt     
      else
         chrt = "s" // chrt            
      end if	 	 
    end function s_conv
    function converter (flv) result (str)
      integer, dimension(:), intent(in) :: flv
      type(string_t) :: str
      character(len=150), dimension(size(flv)) :: chrt
      integer :: i
      str = ""
      do i = 1, size(flv) - 1
         write (chrt(i), "(I10)") flv(i)
         str = str // var_str(trim(adjustl(chrt(i)))) // ", "
      end do    
      write (chrt(size(flv)), "(I10)") flv(size(flv))
      str = str // trim(adjustl(chrt(size(flv))))
    end function converter
    integer function sj (j,m)
      integer, intent(in) :: j, m
      if (((j == 1) .and. (m == 1)) .or. &
          ((j == 2) .and. (m == 2)) .or. &
          ((j == 3) .and. (m == 3)) .or. &
          ((j == 4) .and. (m == 3)) .or. &
          ((j == 5) .and. (m == 4))) then
         sj = 1
      else if (((j == 2) .and. (m == 1)) .or. &
          ((j == 3) .and. (m == 1)) .or. &         
          ((j == 4) .and. (m == 2)) .or. &
          ((j == 5) .and. (m == 2))) then
         sj = -1
      else if (((j == 3) .and. (m == 2)) .or. &
          ((j == 5) .and. (m == 3))) then
         sj = 0
      else if (((j == 4) .and. (m == 1)) .or. &
          ((j == 5) .and. (m == 1))) then         
         sj = -2
      else if (((j == 4) .and. (m == 4)) .or. &
          ((j == 5) .and. (m == 5))) then         
         sj = 2
      else
         call msg_fatal ("template_me_write_source_code: Wrong spin type")
      end if
    end function sj    
    recursive subroutine create_spin_table (index, nhel, fac, mult, inta)
      integer, intent(inout) :: index, fac
      integer, intent(in) :: nhel
      integer, dimension(:), intent(in) :: mult
      integer, dimension(nhel,size(mult)), intent(out) :: inta    
      integer :: j
      if (index > size(mult)) return
      fac = fac / mult(index)
      do j = 1, nhel 
         inta(j,index) = sj (mult(index),mod(((j-1)/fac),mult(index))+1)
      end do   
      index = index + 1
      call create_spin_table (index, nhel, fac, mult, inta)
    end subroutine create_spin_table  
    function dummy_colorizer (flv) result (str)
      type(flavor_t), dimension(:), intent(in) :: flv
      type(string_t) :: str
      integer :: i, k
      str = ""
      k = 0
      do i = 1, size(flv)
         k = k + 1
         select case (flavor_get_color_type (flv(i)))	 
	 case (1,-1)
	    str = str // "0,0, "
	 case (3)
	    str = str // int2string(k) // ",0, "
	 case (-3)
	    str = str // "0," // int2string(-k) // ", "
	 case (8)
	    str = str // int2string(k) // "," // int2string(-k-1) // ", "
	    k = k + 1
	 case default
	    call msg_error ("Color type not supported.")
	 end select
      end do    
      str = adjustl(trim(str))
    end function dummy_colorizer    
  end subroutine template_me_write_source_code    

@ %def template_me_write_source_code
@ Return the name of a procedure that implements a given feature, as
it is provided by the template matrix-element code.  Template ME names
are chosen completely in analogy to the \oMega\ matrix element
conventions. 
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: get_procname => template_me_writer_get_procname
<<Template matrix elements: procedures>>=
  function template_me_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function template_me_writer_get_procname
  
@ %def template_me_writer_get_procname
@ The interfaces for the template-specific features.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_interface => template_me_write_interface
<<Template matrix elements: procedures>>=
  subroutine template_me_write_interface (writer, unit, id, feature)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine template_me_write_interface

@ %def template_me_write_interface
@ The wrappers have to take into account conversion between C and
Fortran data types.

NOTE: The case [[c_default_float]] $\neq$ [[default]] is not yet covered.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_wrapper => template_me_write_wrapper
<<Template matrix elements: procedures>>=
  subroutine template_me_write_wrapper (writer, unit, id, feature)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select
  end subroutine template_me_write_wrapper

@ %def template_me_write_wrapper
@ 
\subsection{Driver}
<<Template matrix elements: types>>=
  type, extends (prc_core_driver_t) :: template_me_driver_t
     procedure(init_t), nopass, pointer :: &
          init => null ()
     procedure(update_alpha_s_t), nopass, pointer :: &
          update_alpha_s => null ()
     procedure(is_allowed_t), nopass, pointer :: &
          is_allowed => null ()
     procedure(new_event_t), nopass, pointer :: &
          new_event => null ()
     procedure(get_amplitude_t), nopass, pointer :: &
          get_amplitude => null ()
   contains
   <<Template matrix elements: template ME driver: TBP>>
  end type template_me_driver_t

@ %def template_me_driver_t
@ The reported type is the same as for the [[template_me_def_t]] type.
<<Template matrix elements: template ME driver: TBP>>=
  procedure, nopass :: type_name => template_me_driver_type_name
<<Template matrix elements: procedures>>=
  function template_me_driver_type_name () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_driver_type_name

@ %def template_me_driver_type_name
@
\subsection{High-level process definition}
This procedure wraps the details filling a process-component
definition entry as appropriate for an template matrix element.

NOTE: For calling the [[import_component]] method, we must explicitly
address the [[process_def_t]] parent object.  The natural way to call
the method of the extended type triggers a bug in gfortran 4.6.  The
string array arguments [[prt_in]] and [[prt_out]] become corrupted and
cause a segfault.
<<Template matrix elements: public>>=
  public :: template_me_make_process_component
<<Template matrix elements: procedures>>=
  subroutine template_me_make_process_component (entry, component_index, &
         model, model_name, prt_in, prt_out, unity)
    class(process_def_entry_t), intent(inout) :: entry
    integer, intent(in) :: component_index
    type(string_t), intent(in) :: model_name
    type(model_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    class(prc_core_def_t), allocatable :: def
    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity)
    end select
    call entry%process_def_t%import_component (component_index, &
         n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method = var_str ("template"), &
         variant = def)
  end subroutine template_me_make_process_component
    
@ %def template_me_make_process_component
@
\subsection{The [[prc_template_me_t]] wrapper}
This is an instance of the generic [[prc_core_t]] object.  It contains a
pointer to the process definition ([[template_me_def_t]]), a data component
([[process_constants_t]]), and the matrix-element driver
([[template_me_driver_t]]).
<<Template matrix elements: public>>=
  public :: prc_template_me_t
<<Template matrix elements: types>>=
  type, extends (prc_core_t) :: prc_template_me_t
     real(default), dimension(:), allocatable :: par
   contains
   <<Template matrix elements: prc template ME: TBP>>
  end type prc_template_me_t
  
@ %def prc_template_me_t
@ The workspace associated to a [[prc_template_me_t]] object contains a single flag.
The flag is used to suppress re-evaluating the matrix element for each
quantum-number combination, after the first amplitude belonging to a given
kinematics has been computed.

We can also store the value of a running coupling once it has been calculated
for an event.  The default value is negative, which indicates an undefined
value in this context.
<<Template matrix elements: types>>=
  type, extends (workspace_t) :: template_me_state_t
     logical :: new_kinematics = .true.
     real(default) :: alpha_qcd = -1
   contains
     procedure :: write => template_me_state_write
     procedure :: reset_new_kinematics => template_me_state_reset_new_kinematics
  end type template_me_state_t
  
@ %def template_me_state_t
<<Template matrix elements: procedures>>=
  subroutine template_me_state_write (object, unit)
    class(template_me_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Template ME state: new kinematics = ", &
         object%new_kinematics
  end subroutine template_me_state_write
  
@ %def template_me_state_write
@
<<Template matrix elements: procedures>>=
  subroutine template_me_state_reset_new_kinematics (object)
    class(template_me_state_t), intent(inout) :: object
  end subroutine template_me_state_reset_new_kinematics

@
@ Allocate the workspace with the above specific type.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: allocate_workspace => prc_template_me_allocate_workspace
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_allocate_workspace (object, tmp)
    class(prc_template_me_t), intent(in) :: object
    class(workspace_t), intent(inout), allocatable :: tmp
    allocate (template_me_state_t :: tmp)
  end subroutine prc_template_me_allocate_workspace
  
@ %def prc_template_me_allocate_workspace
@ The following procedures are inherited from the base type as deferred, thus
must be implemented.  The corresponding unit tests are skipped here; the
procedures are tested when called from the [[processes]] module.

Output: print just the ID of the associated matrix element.  Then display any
stored parameters.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: write => prc_template_me_write
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_write (object, unit)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)", advance="no")  "Template process core:"
    if (object%data_known) then
       write (u, "(1x,A)")  char (object%data%id)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%par)) then
       write (u, "(3x,A)")  "Parameter array:"
       do i = 1, size (object%par)
          write (u, "(5x,I0,1x,ES17.10)")  i, object%par(i)
       end do
    end if
  end subroutine prc_template_me_write
  
@ %def prc_template_me_write
@ Temporarily store the parameter array inside the [[prc_template_me]]
object, so we can use it later during the actual initialization. 
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: set_parameters => prc_template_me_set_parameters
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_set_parameters (prc_template_me, model)
    class(prc_template_me_t), intent(inout) :: prc_template_me
    type(model_t), intent(in), target, optional :: model
    if (present (model)) then
       if (.not. allocated (prc_template_me%par)) &
            allocate (prc_template_me%par (model%get_n_real ()))
       call model%real_parameters_to_c_array (prc_template_me%par)
    end if
  end subroutine prc_template_me_set_parameters
  
@ %def prc_template_me_set_parameters
@ To fully initialize the process core, we perform base
initialization, then initialize the external matrix element code.

This procedure overrides the [[init]] method of the base type, which
we nevertheless can access via its binding [[base_init]].  When done, we
have an allocated driver.  The driver will call the [[init]] procedure
for the external matrix element, and thus transfer the parameter set to
where it finally belongs.

<<Template matrix elements: prc template ME: TBP>>=
  procedure :: init => prc_template_me_init
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_init (object, def, lib, id, i_component)
    class(prc_template_me_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    call object%base_init (def, lib, id, i_component)
    call object%activate_parameters ()
  end subroutine prc_template_me_init
    
@ %def prc_template_me_init
@ Activate the stored parameters by transferring them to the external
matrix element.  
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: activate_parameters => prc_template_me_activate_parameters
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_activate_parameters (object)
    class (prc_template_me_t), intent(inout) :: object
    if (allocated (object%driver)) then
       if (allocated (object%par)) then
          select type (driver => object%driver)
          type is (template_me_driver_t)
             if (associated (driver%init))  call driver%init (object%par)
          end select
       else
          call msg_bug ("prc_template_me_activate: parameter set is not allocated")
       end if
    else
       call msg_bug ("prc_template_me_activate: driver is not allocated")
    end if
  end subroutine prc_template_me_activate_parameters
    
@ %def prc_template_me_activate_parameters
@ The template ME process is an independent process which needs its own Monte
Carlo parameter set for integration.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: needs_mcset => prc_template_me_needs_mcset
<<Template matrix elements: procedures>>=
  function prc_template_me_needs_mcset (object) result (flag)
    class(prc_template_me_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function prc_template_me_needs_mcset
  
@ %def prc_template_me_needs_mcset
@ There is only one term for this tree-level process.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: get_n_terms => prc_template_me_get_n_terms
<<Template matrix elements: procedures>>=
  function prc_template_me_get_n_terms (object) result (n)
    class(prc_template_me_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_template_me_get_n_terms

@ %def prc_template_me_get_n_terms
@ Tell whether a particular combination of flavor, helicity, color is
allowed.  Here we have to consult the matrix-element driver.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: is_allowed => prc_template_me_is_allowed
<<Template matrix elements: procedures>>=
 function prc_template_me_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    type is (template_me_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    end select
  end function prc_template_me_is_allowed
 
@ %def prc_template_me_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.

We reset the [[new_kinematics]] flag, so that the next call to
[[compute_amplitude]] will evaluate the matrix element.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_hard_kinematics => &
       prc_template_me_compute_hard_kinematics
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, tmp)
    class(prc_template_me_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(workspace_t), intent(inout), allocatable :: tmp
    call interaction_set_momenta (int_hard, p_seed)
    if (allocated (tmp)) then
       select type (tmp)
       type is (template_me_state_t);  tmp%new_kinematics = .true.
       end select
    end if
  end subroutine prc_template_me_compute_hard_kinematics
  
@ %def prc_template_me_compute_hard_kinematics
@ This procedure is not called for [[prc_template_me_t]], just a placeholder.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_eff_kinematics => &
       prc_template_me_compute_eff_kinematics
<<Template matrix elements: procedures>>=
  subroutine prc_template_me_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, tmp)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
  end subroutine prc_template_me_compute_eff_kinematics
  
@ %def prc_template_me_compute_eff_kinematics
@ Recover the momenta within the hard interaction.  For tree-level
processes, this is a trivial copy of the incoming seed and outgoing
effective momenta.  The effective interaction is a pointer to the hard
interaction, so the latter is ignored.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: recover_kinematics => prc_template_me_recover_kinematics
<<Template matrix elements: tests>>=
  subroutine prc_template_me_recover_kinematics &
       (object, p_seed, int_hard, int_eff, tmp)
    class(prc_template_me_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
    integer :: n_in
    n_in = interaction_get_n_in (int_eff)
    call interaction_set_momenta (int_eff, p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = interaction_get_momenta (int_eff, outgoing = .true.)
  end subroutine prc_template_me_recover_kinematics
    
@ %def prc_template_me_recover_kinematics
@ Compute the amplitude.  For the tree-level process, we can ignore the scale
settings.  The term index [[j]] is also irrelevant.

We first call [[new_event]] for the given momenta (which we must unpack), then
retrieve the amplitude value for the given quantum numbers.

If the [[tmp]] status flag is present, we can make sure that we call
[[new_event]] only once for a given kinematics.  After the first call, we
unset the [[new_kinematics]] flag.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_amplitude => prc_template_me_compute_amplitude
<<Template matrix elements: procedures>>=
  function prc_template_me_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, tmp) result (amp)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    class(workspace_t), intent(inout), allocatable, optional :: tmp
    complex(default) :: amp
    integer :: n_tot, i
    real(c_default_float), dimension(:,:), allocatable :: parray
    complex(c_default_complex) :: camp
    logical :: new_event
    select type (driver => object%driver)
    type is (template_me_driver_t)
       new_event = .true.
       if (present (tmp)) then
          if (allocated (tmp)) then
             select type (tmp)
             type is (template_me_state_t)
                new_event = tmp%new_kinematics
                tmp%new_kinematics = .false.
             end select
          end if
       end if
       if (new_event) then
          n_tot = object%data%n_in + object%data%n_out
          allocate (parray (0:3, n_tot))
          forall (i = 1:n_tot)  parray(:,i) = vector4_get_components (p(i))
          call driver%new_event (parray)
       end if
       if (object%is_allowed (1, f, h, c)) then
          call driver%get_amplitude &
               (int (f, c_int), int (h, c_int), int (c, c_int), camp)
          amp = camp
       else
          amp = 0
       end if
    end select
  end function prc_template_me_compute_amplitude
    
@ %def prc_template_me_compute_amplitude
@ We do not overwrite the [[prc_core_t]] routine for $\alpha_s$. 

\subsection{Test}
This is the master for calling self-test procedures. There is a
separate test for testing \oMega\ diagram generation as this depends on
a working analysis setup.
<<Template matrix elements: public>>=
  public :: prc_template_me_test
<<Template matrix elements: tests>>=
  subroutine prc_template_me_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Template matrix elements: execute tests>>
end subroutine prc_template_me_test

@ %def prc_template_me_test
@
\subsubsection{Generate, compile and load a simple process matrix element}
The process is $e^+ e^- \to \mu^+\mu^-$ for vanishing masses and
$e=0.3$.  We initialize the process, build the library, and compute a
particular matrix element for momenta of unit energy and right-angle
scattering.  The matrix element, as it happens, is equal to $e^2$.
(Note that are no conversion factors applied, so this result is
exact.)

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Template matrix elements: execute tests>>=
  call test (prc_template_me_1, "prc_template_me_1", &
       "build and load simple template process", &
       u, results)
<<Template matrix elements: tests>>=
  subroutine prc_template_me_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i
    
    write (u, "(A)")  "* Test output: prc_template_me_1"
    write (u, "(A)")  "*   Purpose: create a template matrix element,"
    write (u, "(A)")  "*            normalized to give unit integral,"    
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("template_me1"))
    call os_data_init (os_data)
    call syntax_model_file_init ()

    model => null ()
    call model_list%read_model (var_str ("QED"), var_str ("QED.mdl"), &
         os_data, model)
    model_name = model%get_name ()
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]
    
    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity = .false.)
    end select
    allocate (entry)
    call entry%init (var_str ("template_me1_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("template"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)
    
    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of template_me1_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("template_me1_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for template_me1_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (template_me_driver_t)
       call driver%init (par)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag
       
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_template_me_1"
    
  end subroutine prc_template_me_1
  
@ %def prc_template_me_1
@
<<Template matrix elements: execute tests>>=
  call test (prc_template_me_2, "prc_template_me_2", &
       "build and load simple template_unity process", &
       u, results)
<<Template matrix elements: tests>>=
  subroutine prc_template_me_2 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i
    
    write (u, "(A)")  "* Test output: prc_template_me_1"
    write (u, "(A)")  "*   Purpose: create a template matrix element,"
    write (u, "(A)")  "*            being identical to unity,"    
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("template_me2"))
    call os_data_init (os_data)
    call syntax_model_file_init ()

    model => null ()
    call model_list%read_model (var_str ("QED"), var_str ("QED.mdl"), &
         os_data, model)
    model_name = model%get_name ()
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]
    
    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity = .true.)
    end select
    allocate (entry)
    call entry%init (var_str ("template_me2_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("template_unity"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)
    
    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of template_me2_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("template_me2_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for template_me2_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (template_me_driver_t)
       call driver%init (par)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag
       
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_template_me_2"
    
  end subroutine prc_template_me_2
  
@ %def prc_template_me_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\oMega\ Interface}

The standard method for process computation with \whizard\ is the
\oMega\ matrix element generator.

This section implements the interface to the code generator (via
the makefile) and the driver for the features provided by the \oMega\
matrix element.

There are actually two different methods steered by this interface, the
traditional one which delivers compiled Fortran code, while the \oMega\ 
virtual machine (OVM) produces bytecode with look-up tables.
<<[[prc_omega.f90]]>>=
<<File header>>

module prc_omega
  
  use, intrinsic :: iso_c_binding !NODEP!
  
  use kinds
<<Use strings>>
  use io_units
  use file_utils, only: delete_file
  use unit_tests
  use system_defs, only: TAB
  use diagnostics
  use os_interface
  use lorentz
  use sm_qcd
  use interactions
  use variables
  use models

  use process_constants
  use prclib_interfaces
  use prc_core_def
  use particle_specifiers
  use process_libraries
  use prc_core

<<Standard module head>>

<<Omega interface: public>>

<<Omega interface: types>>

<<Omega interface: interfaces>>

contains
  
<<Omega interface: procedures>>

<<Omega interface: tests>>

end module prc_omega
@ %def prc_omega
@
\subsection{Process definition}
For the process definition we implement an extension of the
[[prc_core_def_t]] abstract type.
<<Omega interface: public>>=
  public :: omega_def_t
<<Omega interface: types>>=
  type, abstract, extends (prc_core_def_t) :: omega_def_t
   contains
   <<Omega interface: omega def: TBP>>
  end type omega_def_t
  
@ %def omega_def_t
@
<<Omega interface: public>>=
  public :: omega_omega_def_t
<<Omega interface: types>>=
  type, extends (omega_def_t) :: omega_omega_def_t
   contains
   <<Omega interface: omega omega def: TBP>>
  end type omega_omega_def_t
  
@ %def omega_omega_def_t  
@
<<Omega interface: public>>=
  public :: omega_ovm_def_t
<<Omega interface: types>>=
  type, extends (omega_def_t) :: omega_ovm_def_t
   contains
   <<Omega interface: omega ovm def: TBP>>
  end type omega_ovm_def_t
  
@ %def omega_ovm_def_t  
@ 
<<Omega interface: omega omega def: TBP>>=
  procedure, nopass :: type_string => omega_omega_def_type_string
<<Omega interface: procedures>>=
  function omega_omega_def_type_string () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_omega_def_type_string

@ %def omega_omega_def_type_string
@ 
<<Omega interface: omega ovm def: TBP>>=
  procedure, nopass :: type_string => omega_ovm_def_type_string
<<Omega interface: procedures>>=
  function omega_ovm_def_type_string () result (string)
    type(string_t) :: string
    string = "ovm"
  end function omega_ovm_def_type_string

@ %def omega_ovm_def_type_string
@ Initialization: allocate the writer for the \oMega\ matrix element.
Also set any data for this process that the writer needs.
<<Omega interface: omega def: TBP>>=
  procedure :: init => omega_def_init
<<Omega interface: procedures>>=
  subroutine omega_def_init (object, model_name, prt_in, prt_out, &
       restrictions, openmp_support, report_progress, extra_options, &
       diags, diags_color)
    class(omega_def_t), intent(out) :: object
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: diags, diags_color
    type(string_t), intent(in), optional :: extra_options
    select type (object)
    type is (omega_omega_def_t)
       allocate (omega_omega_writer_t :: object%writer)
       select type (writer => object%writer)
       type is (omega_omega_writer_t)
          call writer%init (model_name, prt_in, prt_out, &
               restrictions, openmp_support, report_progress, &
               extra_options, diags, diags_color)
       end select
    type is (omega_ovm_def_t)
       allocate (omega_ovm_writer_t :: object%writer)
       select type (writer => object%writer)
       type is (omega_ovm_writer_t)
          call writer%init (model_name, prt_in, prt_out, &
               restrictions, openmp_support, report_progress, &
               extra_options, diags, diags_color)
       end select       
    end select
  end subroutine omega_def_init

@ %def omega_def_init
@ Write/read process- and method-specific data.
<<Omega interface: omega def: TBP>>=
  procedure :: write => omega_def_write
<<Omega interface: procedures>>=
  subroutine omega_def_write (object, unit)
    class(omega_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (omega_omega_writer_t)
       call writer%write (unit)
    type is (omega_ovm_writer_t)
       call writer%write (unit)
    end select
  end subroutine omega_def_write
  
@ %def omega_def_write
@ 
<<Omega interface: omega def: TBP>>=
  procedure :: read => omega_def_read
<<Omega interface: procedures>>=
  subroutine omega_def_read (object, unit)
    class(omega_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug ("O'Mega process definition: input not supported yet")
  end subroutine omega_def_read
  
@ %def omega_def_read
@ Allocate the driver for \oMega matrix elements.
<<Omega interface: omega def: TBP>>=
  procedure :: allocate_driver => omega_def_allocate_driver
<<Omega interface: procedures>>=
  subroutine omega_def_allocate_driver (object, driver, basename)
    class(omega_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    allocate (omega_driver_t :: driver)
  end subroutine omega_def_allocate_driver
  
@ %def omega_def_allocate_driver
@ We need code:
<<Omega interface: omega def: TBP>>=
  procedure, nopass :: needs_code => omega_def_needs_code
<<Omega interface: procedures>>=
  function omega_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function omega_def_needs_code
  
@ %def omega_def_needs_code
@ These are the features that an \oMega\ matrix element provides.
<<Omega interface: omega def: TBP>>=
  procedure, nopass :: get_features => omega_def_get_features
<<Omega interface: procedures>>=
  subroutine omega_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine omega_def_get_features

@ %def omega_def_get_features
@ The interface of the specific features.
<<Omega interface: interfaces>>=
  abstract interface
     subroutine init_t (par) bind(C)
       import
       real(c_default_float), dimension(*), intent(in) :: par
     end subroutine init_t
  end interface
  
  abstract interface
     subroutine update_alpha_s_t (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine update_alpha_s_t
  end interface
  
  abstract interface
     subroutine reset_helicity_selection_t (threshold, cutoff) bind(C)
       import
       real(c_default_float), intent(in) :: threshold
       integer(c_int), intent(in) :: cutoff
     end subroutine reset_helicity_selection_t
  end interface

  abstract interface
     subroutine is_allowed_t (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine is_allowed_t
  end interface

  abstract interface
     subroutine new_event_t (p) bind(C)
       import
       real(c_default_float), dimension(0:3,*), intent(in) :: p
     end subroutine new_event_t
  end interface
  
  abstract interface
     subroutine get_amplitude_t (flv, hel, col, amp) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       complex(c_default_complex), intent(out):: amp
     end subroutine get_amplitude_t
  end interface

@ %def init_t update_alpha_s_t reset_helicity_selection_t  
@ %def is_allowed_t new_event_t get_amplitude_t
@ Connect the \oMega\ features with the process driver.
<<Omega interface: omega def: TBP>>=
  procedure :: connect => omega_def_connect
<<Omega interface: procedures>>=
  subroutine omega_def_connect (def, lib_driver, i, proc_driver)
    class(omega_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    integer(c_int) :: pid, fid
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is  (omega_driver_t)
       pid = i
       fid = 1
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%init)
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 3
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%reset_helicity_selection)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
       fid = 5
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%new_event)
       fid = 6
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%get_amplitude)
    end select
  end subroutine omega_def_connect

@ %def omega_def_connect
@
\subsection{The \oMega\ writer}
The \oMega\ writer is responsible for inserting the appropriate lines
in the makefile that call \oMega, and for writing interfaces and
wrappers.
<<Omega interface: types>>=
  type, extends (prc_writer_f_module_t), abstract :: omega_writer_t
     type(string_t) :: model_name
     type(string_t) :: process_mode
     type(string_t) :: process_string
     type(string_t) :: restrictions
     logical :: openmp_support = .false.
     logical :: report_progress = .false.
     logical :: diags = .false.
     logical :: diags_color = .false.
     type(string_t) :: extra_options
   contains
   <<Omega interface: omega writer: TBP>>
  end type omega_writer_t

@ %def omega_writer_t
@ 
<<Omega interface: types>>=
  type, extends (omega_writer_t) :: omega_omega_writer_t
   contains
   <<Omega interface: omega omega writer: TBP>>
  end type omega_omega_writer_t

@ %def omega_omega_writer_t 
@ 
<<Omega interface: types>>=
  type, extends (omega_writer_t) :: omega_ovm_writer_t
   contains
   <<Omega interface: omega ovm writer: TBP>>
  end type omega_ovm_writer_t

@ %def omega_ovm_writer_t 
<<Omega interface: omega omega writer: TBP>>=
  procedure, nopass :: type_name => omega_omega_writer_type_name
<<Omega interface: procedures>>=
  function omega_omega_writer_type_name () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_omega_writer_type_name

@ %def omega_omega_writer_type_name
@
<<Omega interface: omega ovm writer: TBP>>=
  procedure, nopass :: type_name => omega_ovm_writer_type_name
<<Omega interface: procedures>>=
  function omega_ovm_writer_type_name () result (string)
    type(string_t) :: string
    string = "ovm"
  end function omega_ovm_writer_type_name

@ %def omega_ovm_writer_type_name
@
@ Taking into account the prefix for \oMega\ module names.
<<Omega interface: omega writer: TBP>>=
  procedure, nopass :: get_module_name => omega_writer_get_module_name
<<Omega interface: procedures>>=
  function omega_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function omega_writer_get_module_name

@ %def omega_writer_get_module_name
@ Output.  This is called by [[omega_def_write]].
<<Omega interface: omega writer: TBP>>=
  procedure :: write => omega_writer_write
<<Omega interface: procedures>>=
  subroutine omega_writer_write (object, unit)
    class(omega_writer_t), intent(in) :: object
    integer, intent(in) :: unit
    write (unit, "(5x,A,A)")  "Model name        = ", &
         '"' // char (object%model_name) // '"'
    write (unit, "(5x,A,A)")  "Mode string       = ", &
         '"' // char (object%process_mode) // '"'
    write (unit, "(5x,A,A)")  "Process string    = ", &
         '"' // char (object%process_string) // '"'
    write (unit, "(5x,A,A)")  "Restrictions      = ", &
         '"' // char (object%restrictions) // '"'
    write (unit, "(5x,A,L1)")  "OpenMP support    = ", object%openmp_support
    write (unit, "(5x,A,L1)")  "Report progress   = ", object%report_progress
    write (unit, "(5x,A,A)")  "Extra options     = ", &
         '"' // char (object%extra_options) // '"'
    write (unit, "(5x,A,L1)")  "Write diagrams    = ", object%diags    
    write (unit, "(5x,A,L1)")  "Write color diag. = ", object%diags_color
  end subroutine omega_writer_write

@ %def omega_writer_write
@ Initialize with process data.
<<Omega interface: omega writer: TBP>>=
  procedure :: init => omega_writer_init
<<Omega interface: procedures>>=
  subroutine omega_writer_init (writer, model_name, prt_in, prt_out, &
       restrictions, openmp_support, report_progress, extra_options, &
       diags, diags_color)
    class(omega_writer_t), intent(out) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: diags, diags_color    
    type(string_t), intent(in), optional :: extra_options
    integer :: i
    writer%model_name = model_name
    if (present (restrictions)) then
       writer%restrictions = restrictions
    else
       writer%restrictions = ""
    end if
    if (present (openmp_support))  writer%openmp_support = openmp_support
    if (present (report_progress))  writer%report_progress = report_progress
    if (present (diags))  writer%diags = diags
    if (present (diags_color))  writer%diags_color = diags_color
    if (present (extra_options)) then
       writer%extra_options = " " // extra_options
    else
       writer%extra_options = ""
    end if
    select case (size (prt_in))
    case (1);  writer%process_mode = " -decay"
    case (2);  writer%process_mode = " -scatter"
    end select
    associate (s => writer%process_string)
      s = " '"
      do i = 1, size (prt_in)
         if (i > 1)  s = s // " "
         s = s // prt_in(i)
      end do
      s = s // " ->"
      do i = 1, size (prt_out)
         s = s // " " // prt_out(i)
      end do
      s = s // "'"
    end associate
  end subroutine omega_writer_init

@ %def omega_writer_init
@ The makefile implements the actual \oMega\ call. For old \LaTeX\
distributions, we filter out the hyperref options for \oMega\
diagrams, at least in the testsuite.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_makefile_code => omega_write_makefile_code
<<Omega interface: procedures>>=
  subroutine omega_write_makefile_code (writer, unit, id, os_data, testflag)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    type(string_t) :: restrictions_string
    type(string_t) :: openmp_string
    type(string_t) :: kmatrix_string
    type(string_t) :: progress_string    
    type(string_t) :: diagrams_string
    logical :: escape_hyperref
    escape_hyperref = .false.
    if (present (testflag))  escape_hyperref = testflag
    select type (writer)
    type is (omega_omega_writer_t)       
       omega_binary = "omega_" // writer%model_name // ".opt"
    type is (omega_ovm_writer_t)
       select case (char (writer%model_name))
       case ("SM", "SM_CKM", "SM_Higgs", "2HDM", "2HDM_CKM", &
             "HSExt", "QED", "QCD", "Zprime")
       case default
          call msg_fatal ("The model " // char (writer%model_name) &
               // " is not available for the O'Mega VM.")
       end select
       omega_binary = "omega_" // writer%model_name // "_VM.opt"
    end select
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    if (writer%restrictions /= "") then
       restrictions_string = " -cascade '" // writer%restrictions // "'"
    else
       restrictions_string = ""
    end if
    if (writer%openmp_support) then
       openmp_string = " -target:openmp"
    else
       openmp_string = ""
    end if
    if (writer%report_progress) then
       progress_string = " -fusion:progress"
    else
       progress_string = ""
    end if
    if (writer%diags) then
       if (writer%diags_color) then
          diagrams_string = " -diagrams:C " // char(id) // &
               "_diags -diagrams_LaTeX"
       else
          diagrams_string = " -diagrams " // char(id) // &
               "_diags -diagrams_LaTeX"
       end if
    else 
       if (writer%diags_color) then
          diagrams_string = " -diagrams:c " // char(id) // &
               "_diags -diagrams_LaTeX"        
       else
          diagrams_string = ""
       end if
    end if
    select case (char (writer%model_name))
    case ("SM_rx", "SSC", "NoH_rx", "AltH")
       kmatrix_string = " -target:kmatrix_write"
    case default
       kmatrix_string = ""
    end select
    write (unit, "(5A)")  "SOURCES += ", char (id), ".f90"
    select type (writer)
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  "SOURCES += ", char (id), ".hbc"
    end select
    if (writer%diags .or. writer%diags_color) then
       write (unit, "(5A)")  "TEX_SOURCES += ", char (id), "_diags.tex"    
       if (os_data%event_analysis_pdf) then
          write (unit, "(5A)")  "TEX_OBJECTS += ", char (id), "_diags.pdf"
       else
          write (unit, "(5A)")  "TEX_OBJECTS += ", char (id), "_diags.ps"
       end if
    end if
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"    
    select type (writer)
    type is (omega_omega_writer_t)       
       write (unit, "(5A)")  char (id), ".f90:"       
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".f90", &
            " -target:whizard", &
            " -target:parameter_module parameters_", char (writer%model_name), &
            " -target:module opr_", char (id), &
            " -target:md5sum '", writer%md5sum, "'", &
            char (openmp_string), &
            char (progress_string), &
            char (kmatrix_string), &
            char (writer%process_mode), char (writer%process_string), &
            char (restrictions_string), char (diagrams_string), &
            char (writer%extra_options)
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  char (id), ".hbc:"
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".hbc", &
            char (progress_string), &
            char (writer%process_mode), char (writer%process_string), &
            char (restrictions_string), char (diagrams_string), &
            char (writer%extra_options)
       write (unit, "(5A)")  char (id), ".f90:"
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".f90 -params", &
            " -target:whizard ", &
            " -target:bytecode_file ", char (id), ".hbc", &
            " -target:wrapper_module opr_", char (id), &
            " -target:parameter_module_external parameters_", &           
            char (writer%model_name), &
            " -target:md5sum '", writer%md5sum, "'", &
            char (openmp_string)
    end select
    if (writer%diags .or. writer%diags_color) &
       write (unit, "(5A)")  char (id), "_diags.tex: ", char (id), ".f90"
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"    
    select type (writer)
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".hbc"
    end select
    if (writer%diags .or. writer%diags_color) then
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), "_diags.tex"
    end if
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"       
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    if (writer%diags .or. writer%diags_color) then    
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.aux"  
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.log"         
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.dvi"                
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.toc"                       
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.out"       
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9]"       
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9][0-9]"    
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9][0-9][0-9]"   
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9]"       
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9][0-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.mp"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.log"       
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.dvi"              
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.ps"                     
       if (os_data%event_analysis_pdf) &
            write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.pdf" 
    end if
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
    if (writer%diags .or. writer%diags_color) then
       if (os_data%event_analysis_ps) then
          if (os_data%event_analysis_pdf) then
             write (unit, "(5A)")  char (id), "_diags.pdf: ", char (id), "_diags.tex"
          else
             write (unit, "(5A)")  char (id), "_diags.ps: ", char (id), "_diags.tex"
          end if
          if (escape_hyperref) then
             write (unit, "(5A)")  TAB, "-cat ", char (id), "_diags.tex | \" 
             write (unit, "(5A)")  TAB, "   sed -e" // &
                "'s/\\usepackage\[colorlinks\]{hyperref}.*/%\\usepackage" // &
                "\[colorlinks\]{hyperref}/' > \"
             write (unit, "(5A)")  TAB, "   ", char (id), "_diags.tex.tmp"
             write (unit, "(5A)")  TAB, "mv -f ", char (id), "_diags.tex.tmp \"
             write (unit, "(5A)")  TAB, "   ", char (id), "_diags.tex"
          end if
          write (unit, "(5A)")  TAB, "-TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
               char (id) // "_diags.tex"
          write (unit, "(5A)")  TAB, "MPINPUTS=$(MP_FLAGS) $(MPOST) " // &
               char (id) // "_diags-fmf.mp"
          write (unit, "(5A)")  TAB, "TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
               char (id) // "_diags.tex"  
          write (unit, "(5A)")  TAB, "$(DVIPS) -o " // char (id) // "_diags.ps " // &
               char (id) // "_diags.dvi"
          if (os_data%event_analysis_pdf) then
             write (unit, "(5A)")  TAB, "$(PS2PDF) " // char (id) // "_diags.ps"
          end if
       end if
    end if
  end subroutine omega_write_makefile_code

@ %def omega_write_makefile_code
@ The source is written by the makefile, so nothing to do here.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_source_code => omega_write_source_code
<<Omega interface: procedures>>=
  subroutine omega_write_source_code (writer, id)
    class(omega_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine omega_write_source_code

@ %def omega_write_source_code
@ Return the name of a procedure that implements a given feature, as
it is provided by the external matrix-element code.  \oMega\ names
some procedures differently, therefore we translate here and override
the binding of the base type.
<<Omega interface: omega writer: TBP>>=
  procedure, nopass :: get_procname => omega_writer_get_procname
<<Omega interface: procedures>>=
  function omega_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function omega_writer_get_procname
  
@ %def omega_writer_get_procname
@ The interfaces for the \oMega-specific features.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_interface => omega_write_interface
<<Omega interface: procedures>>=
  subroutine omega_write_interface (writer, unit, id, feature)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine omega_write_interface

@ %def omega_write_interface
@ The wrappers have to take into account conversion between C and
Fortran data types.

NOTE: The case [[c_default_float]] $\neq$ [[default]] is not yet covered.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_wrapper => omega_write_wrapper
<<Omega interface: procedures>>=
  subroutine omega_write_wrapper (writer, unit, id, feature)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select
  end subroutine omega_write_wrapper

@ %def omega_write_wrapper
@ 
\subsection{Driver}
<<Omega interface: types>>=
  type, extends (prc_core_driver_t) :: omega_driver_t
     procedure(init_t), nopass, pointer :: &
          init => null ()
     procedure(update_alpha_s_t), nopass, pointer :: &
          update_alpha_s => null ()
     procedure(reset_helicity_selection_t), nopass, pointer :: &
          reset_helicity_selection => null ()
     procedure(is_allowed_t), nopass, pointer :: &
          is_allowed => null ()
     procedure(new_event_t), nopass, pointer :: &
          new_event => null ()
     procedure(get_amplitude_t), nopass, pointer :: &
          get_amplitude => null ()
   contains
   <<Omega interface: omega driver: TBP>>
  end type omega_driver_t

@ %def omega_driver_t
@ The reported type is the same as for the [[omega_def_t]] type.
<<Omega interface: omega driver: TBP>>=
  procedure, nopass :: type_name => omega_driver_type_name
<<Omega interface: procedures>>=
  function omega_driver_type_name () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_driver_type_name

@ %def omega_driver_type_name
@
\subsection{High-level process definition}
This procedure wraps the details filling a process-component
definition entry as appropriate for an
\oMega\ matrix element.

NOTE: For calling the [[import_component]] method, we must explicitly
address the [[process_def_t]] parent object.  The natural way to call
the method of the extended type triggers a bug in gfortran 4.6.  The
string array arguments [[prt_in]] and [[prt_out]] become corrupted and
cause a segfault.
<<Omega interface: public>>=
  public :: omega_make_process_component
<<Omega interface: procedures>>=
  subroutine omega_make_process_component (entry, component_index, &
         model_name, prt_in, prt_out, restrictions, openmp_support, &
         report_progress, extra_options, diags, diags_color)
    class(process_def_entry_t), intent(inout) :: entry
    integer, intent(in) :: component_index
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: diags, diags_color
    type(string_t), intent(in), optional :: extra_options
    class(prc_core_def_t), allocatable :: def
    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            restrictions, openmp_support, report_progress, &
            extra_options, diags, diags_color)
    end select
    call entry%process_def_t%import_component (component_index, &
         n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method = var_str ("omega"), &
         variant = def)
  end subroutine omega_make_process_component
    
@ %def omega_make_process_component
@
\subsection{The [[prc_omega_t]] wrapper}
This is an instance of the generic [[prc_core_t]] object.  It contains a
pointer to the process definition ([[omega_def_t]]), a data component
([[process_constants_t]]), and the matrix-element driver
([[omega_driver_t]]).
<<Omega interface: public>>=
  public :: prc_omega_t
<<Omega interface: types>>=
  type, extends (prc_core_t) :: prc_omega_t
     real(default), dimension(:), allocatable :: par
     type(helicity_selection_t) :: helicity_selection
     type(qcd_t) :: qcd
   contains
   <<Omega interface: prc omega: TBP>>
  end type prc_omega_t
  
@ %def prc_omega_t
@ The workspace associated to a [[prc_omega_t]] object contains a single flag.
The flag is used to suppress re-evaluating the matrix element for each
quantum-number combination, after the first amplitude belonging to a given
kinematics has been computed.

We can also store the value of a running coupling once it has been calculated
for an event.  The default value is negative, which indicates an undefined
value in this context.
<<Omega interface: types>>=
  type, extends (workspace_t) :: omega_state_t
     logical :: new_kinematics = .true.
     real(default) :: alpha_qcd = -1
   contains
     procedure :: write => omega_state_write
     procedure :: reset_new_kinematics => omega_state_reset_new_kinematics
  end type omega_state_t
  
@ %def omega_state_t
<<Omega interface: procedures>>=
  subroutine omega_state_write (object, unit)
    class(omega_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "O'Mega state: new kinematics = ", &
         object%new_kinematics
  end subroutine omega_state_write
  
@ %def omega_state_write
<<Omega interface: procedures>>=
  subroutine omega_state_reset_new_kinematics (object)
    class(omega_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine omega_state_reset_new_kinematics

@ %def omega_state_reset_new_kinematics
@ Allocate the workspace with the above specific type.
<<Omega interface: prc omega: TBP>>=
  procedure :: allocate_workspace => prc_omega_allocate_workspace
<<Omega interface: procedures>>=
  subroutine prc_omega_allocate_workspace (object, tmp)
    class(prc_omega_t), intent(in) :: object
    class(workspace_t), intent(inout), allocatable :: tmp
    allocate (omega_state_t :: tmp)
  end subroutine prc_omega_allocate_workspace
  
@ %def prc_omega_allocate_workspace
@ The following procedures are inherited from the base type as deferred, thus
must be implemented.  The corresponding unit tests are skipped here; the
procedures are tested when called from the [[processes]] module.

Output: print just the ID of the associated matrix element.  Then display any
stored parameters and the helicity selection data.  (The latter are printed
only if active.)
<<Omega interface: prc omega: TBP>>=
  procedure :: write => prc_omega_write
<<Omega interface: procedures>>=
  subroutine prc_omega_write (object, unit)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)", advance="no")  "O'Mega process core:"
    if (object%data_known) then
       write (u, "(1x,A)")  char (object%data%id)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%par)) then
       write (u, "(3x,A)")  "Parameter array:"
       do i = 1, size (object%par)
          write (u, "(5x,I0,1x,ES17.10)")  i, object%par(i)
       end do
    end if
    call object%helicity_selection%write (u)
    call object%qcd%write (u)
  end subroutine prc_omega_write
  
@ %def prc_omega_write
@ Temporarily store the parameter array inside the [[prc_omega]]
object, so we can use it later during the actual initialization.  Also
store threshold and cutoff for helicity selection.
<<Omega interface: prc omega: TBP>>=
  procedure :: set_parameters => prc_omega_set_parameters
<<Omega interface: procedures>>=
  subroutine prc_omega_set_parameters (prc_omega, model, &
       helicity_selection, qcd, use_color_factors)
    class(prc_omega_t), intent(inout) :: prc_omega
    type(model_t), intent(in), target, optional :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    logical, intent(in), optional :: use_color_factors
    if (present (model)) then
       if (.not. allocated (prc_omega%par)) &
            allocate (prc_omega%par (model%get_n_real ()))
       call model%real_parameters_to_c_array (prc_omega%par)
    end if
    if (present (helicity_selection)) then
       prc_omega%helicity_selection = helicity_selection
    end if
    if (present (qcd)) then
       prc_omega%qcd = qcd
    end if
    if (present (use_color_factors)) then
       prc_omega%use_color_factors = use_color_factors
    end if
  end subroutine prc_omega_set_parameters
  
@ %def prc_omega_set_parameters
@ To fully initialize the process core, we perform base
initialization, then initialize the external matrix element code.

This procedure overrides the [[init]] method of the base type, which
we nevertheless can access via its binding [[base_init]].  When done, we
have an allocated driver.  The driver will call the [[init]] procedure
for the external matrix element, and thus transfer the parameter set to
where it finally belongs.

If requested, we initialize the helicity selction counter.
<<Omega interface: prc omega: TBP>>=
  procedure :: init => prc_omega_init
<<Omega interface: procedures>>=
  subroutine prc_omega_init (object, def, lib, id, i_component)
    class(prc_omega_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    call object%base_init (def, lib, id, i_component)
    call object%activate_parameters ()
  end subroutine prc_omega_init
    
@ %def prc_omega_init
@ Activate the stored parameters by transferring them to the external
matrix element.  Also reset the helicity selection, if requested.
<<Omega interface: prc omega: TBP>>=
  procedure :: activate_parameters => prc_omega_activate_parameters
<<Omega interface: procedures>>=
  subroutine prc_omega_activate_parameters (object)
    class (prc_omega_t), intent(inout) :: object
    if (allocated (object%driver)) then
       if (allocated (object%par)) then
          select type (driver => object%driver)
          type is (omega_driver_t)
             if (associated (driver%init))  call driver%init (object%par)
          end select
       else
          call msg_bug ("prc_omega_activate: parameter set is not allocated")
       end if
       call object%reset_helicity_selection ()
    else
       call msg_bug ("prc_omega_activate: driver is not allocated")
    end if
  end subroutine prc_omega_activate_parameters
    
@ %def prc_omega_activate_parameters
@ The \oMega\ process is an independent process which needs its own Monte
Carlo parameter set for integration.
<<Omega interface: prc omega: TBP>>=
  procedure :: needs_mcset => prc_omega_needs_mcset
<<Omega interface: procedures>>=
  function prc_omega_needs_mcset (object) result (flag)
    class(prc_omega_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function prc_omega_needs_mcset
  
@ %def prc_omega_needs_mcset
@ There is only one term for this tree-level process.
<<Omega interface: prc omega: TBP>>=
  procedure :: get_n_terms => prc_omega_get_n_terms
<<Omega interface: procedures>>=
  function prc_omega_get_n_terms (object) result (n)
    class(prc_omega_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_omega_get_n_terms

@ %def prc_omega_get_n_terms
@ Tell whether a particular combination of flavor, helicity, color is
allowed.  Here we have to consult the matrix-element driver.
<<Omega interface: prc omega: TBP>>=
  procedure :: is_allowed => prc_omega_is_allowed
<<Omega interface: procedures>>=
 function prc_omega_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    type is (omega_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    end select
  end function prc_omega_is_allowed
 
@ %def prc_omega_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.

We reset the [[new_kinematics]] flag, so that the next call to
[[compute_amplitude]] will evaluate the matrix element.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_hard_kinematics => prc_omega_compute_hard_kinematics
<<Omega interface: procedures>>=
  subroutine prc_omega_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, tmp)
    class(prc_omega_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(workspace_t), intent(inout), allocatable :: tmp
    call interaction_set_momenta (int_hard, p_seed)
    if (allocated (tmp)) then
       select type (tmp)
       type is (omega_state_t);  tmp%new_kinematics = .true.
       end select
    end if
  end subroutine prc_omega_compute_hard_kinematics
  
@ %def prc_omega_compute_hard_kinematics
@ This procedure is not called for [[prc_omega_t]], just a placeholder.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_eff_kinematics => prc_omega_compute_eff_kinematics
<<Omega interface: procedures>>=
  subroutine prc_omega_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, tmp)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
  end subroutine prc_omega_compute_eff_kinematics
  
@ %def prc_omega_compute_eff_kinematics
@ Recover the momenta within the hard interaction.  For tree-level
processes, this is a trivial copy of the incoming seed and outgoing
effective momenta.  The effective interaction is a pointer to the hard
interaction, so the latter is ignored.
<<Omega interface: prc omega: TBP>>=
  procedure :: recover_kinematics => prc_omega_recover_kinematics
<<Omega interface: tests>>=
  subroutine prc_omega_recover_kinematics &
       (object, p_seed, int_hard, int_eff, tmp)
    class(prc_omega_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
    integer :: n_in
    n_in = interaction_get_n_in (int_eff)
    call interaction_set_momenta (int_eff, p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = interaction_get_momenta (int_eff, outgoing = .true.)
  end subroutine prc_omega_recover_kinematics
    
@ %def prc_omega_recover_kinematics
@ Reset the helicity selection counters and start counting zero
helicities.  We assume that the [[helicity_selection]] object is allocated.
Otherwise, reset and switch off helicity counting.

In the test routine, the driver is allocated but the driver methods are not.
Therefore, guard against a disassociated method.
<<Omega interface: prc omega: TBP>>=
  procedure :: reset_helicity_selection => prc_omega_reset_helicity_selection
<<Omega interface: procedures>>=
  subroutine prc_omega_reset_helicity_selection (object)
    class(prc_omega_t), intent(inout) :: object
    select type (driver => object%driver)
    type is (omega_driver_t)
       if (associated (driver%reset_helicity_selection)) then
          if (object%helicity_selection%active) then
             call driver%reset_helicity_selection &
                  (real (object%helicity_selection%threshold, &
                  c_default_float), &
                  int (object%helicity_selection%cutoff, c_int))
          else
             call driver%reset_helicity_selection &
                  (0._c_default_float, 0_c_int)
          end if
       end if
    end select
  end subroutine prc_omega_reset_helicity_selection
  
@ %def reset_helicity_selection
@ Compute the amplitude.  For the tree-level process, we can ignore the scale
settings.  The term index [[j]] is also irrelevant.

We first call [[new_event]] for the given momenta (which we must unpack), then
retrieve the amplitude value for the given quantum numbers.

If the [[tmp]] status flag is present, we can make sure that we call
[[new_event]] only once for a given kinematics.  After the first call, we
unset the [[new_kinematics]] flag.

The [[is_allowed]] query is not redundant, since the status may change during
the run if helicities are switched off.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_amplitude => prc_omega_compute_amplitude
<<Omega interface: procedures>>=
  function prc_omega_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, tmp) result (amp)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    class(workspace_t), intent(inout), allocatable, optional :: tmp
    real(default) :: alpha_qcd
    complex(default) :: amp
    integer :: n_tot, i
    real(c_default_float), dimension(:,:), allocatable :: parray
    complex(c_default_complex) :: camp
    logical :: new_event
    select type (driver => object%driver)
    type is (omega_driver_t)
       new_event = .true.
       if (present (tmp)) then
          if (allocated (tmp)) then
             select type (tmp)
             type is (omega_state_t)
                new_event = tmp%new_kinematics
                tmp%new_kinematics = .false.
             end select
          end if
       end if
       if (new_event) then
          if (allocated (object%qcd%alpha)) then
             alpha_qcd = object%qcd%alpha%get (fac_scale)
             call driver%update_alpha_s (alpha_qcd)
             if (present (tmp)) then
                if (allocated (tmp)) then
                   select type (tmp)
                   type is (omega_state_t)
                      tmp%alpha_qcd = alpha_qcd
                   end select
                end if
             end if
          end if
          n_tot = object%data%n_in + object%data%n_out
          allocate (parray (0:3, n_tot))
          do i = 1, n_tot
             parray(:,i) = vector4_get_components (p(i))
          end do
          call driver%new_event (parray)
       end if
       if (object%is_allowed (1, f, h, c)) then
          call driver%get_amplitude &
               (int (f, c_int), int (h, c_int), int (c, c_int), camp)
          amp = camp
       else
          amp = 0
       end if
    end select
  end function prc_omega_compute_amplitude
    
@ %def prc_omega_compute_amplitude
@ After the amplitude has been computed, we may read off the current value of
$\alpha_s$.  This works only if $\alpha_s$ varies, and if the workspace
[[tmp]] is present which stores this value.
<<Omega interface: prc omega: TBP>>=
  procedure :: get_alpha_s => prc_omega_get_alpha_s
<<Omega interface: procedures>>=
  function prc_omega_get_alpha_s (object, tmp) result (alpha)
    class(prc_omega_t), intent(in) :: object
    class(workspace_t), intent(in), allocatable :: tmp
    real(default) :: alpha
    alpha = -1
    if (allocated (object%qcd%alpha) .and. allocated (tmp)) then
       select type (tmp)
       type is (omega_state_t)
          alpha = tmp%alpha_qcd
       end select
    end if
  end function prc_omega_get_alpha_s
  
@ %def prc_omega_get_alpha_s
@
\subsection{Test}
This is the master for calling self-test procedures. There is a
separate test for testing \oMega\ diagram generation as this depends on
a working analysis setup.
<<Omega interface: public>>=
  public :: prc_omega_test
<<Omega interface: tests>>=
  subroutine prc_omega_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Omega interface: execute tests>>
end subroutine prc_omega_test

@ %def prc_omega_test
@
<<Omega interface: public>>=
  public :: prc_omega_diags_test
<<Omega interface: tests>>=
  subroutine prc_omega_diags_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Omega interface: execute diags tests>>
end subroutine prc_omega_diags_test

@ %def prc_omega_diags_test
@
\subsubsection{Generate, compile and load a simple process matrix element}
The process is $e^+ e^- \to \mu^+\mu^-$ for vanishing masses and
$e=0.3$.  We initialize the process, build the library, and compute a
particular matrix element for momenta of unit energy and right-angle
scattering.  The matrix element, as it happens, is equal to $e^2$.
(Note that are no conversion factors applied, so this result is
exact.)

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_1, "prc_omega_1", &
       "build and load simple OMega process", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i
    
    write (u, "(A)")  "* Test output: prc_omega_1"
    write (u, "(A)")  "*   Purpose: create a simple process with OMega"
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("omega1"))
    call os_data_init (os_data)

    model_name = "QED"
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]
    
    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (model_name, prt_in, prt_out)
    end select
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)
    
    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega1_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("omega1_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,L1)") "openmp supported = ", data%openmp_supported
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega1_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (omega_driver_t)
       call driver%init (par)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag
       
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_1"
    
  end subroutine prc_omega_1
  
@ %def prc_omega_1
@
\subsubsection{Check [[prc_omega_t]] wrapper and options}
The process is $e^- e^+ \to e^- e^+$ for vanishing masses and
$e=0.3$.  We build the library using the high-level procedure
[[omega_make_process_component]] and the ``black box''
[[prc_omega_t]] object.  Two variants with different settings for
restrictions and OpenMP.

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_2, "prc_omega_2", &
       "OMega option passing", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_2 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    type(var_list_t), pointer :: var_list => null ()
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: restrictions
    type(process_component_def_t), pointer :: config
    type(prc_omega_t) :: prc1, prc2
    type(process_constants_t) :: data
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(:), allocatable :: par
    real(cdf), dimension(0:3,4) :: p
    complex(c_default_complex) :: amp
    integer :: i
    logical :: exist
    
    write (u, "(A)")  "* Test output: prc_omega_2"
    write (u, "(A)")  "*   Purpose: create simple processes with OMega"
    write (u, "(A)")  "*            use the prc_omega wrapper for this"
    write (u, "(A)")  "*            and check OMega options"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with two entries, &
         &different options."
    write (u, "(A)")  "* (1) e- e+ -> e- e+   &
         &(all diagrams, no OpenMP, report progress)"
    write (u, "(A)")  "* (2) e- e+ -> e- e+   &
         &(s-channel only, with OpenMP, report progress to file)"

    call lib%init (var_str ("omega2"))
    call os_data_init (os_data)
    call syntax_model_file_init ()

    model_name = "QED"
    call model_list%read_model &
         (var_str ("QED"), var_str ("QED.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e-"), var_str ("e+")]
    prt_out = prt_in
    restrictions = "3+4~A"

    allocate (entry)
    call entry%init (var_str ("omega2_a"), &
         model, n_in = 2, n_components = 2)

    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call omega_make_process_component (entry, 2, &
         model_name, prt_in, prt_out, &
         restrictions=restrictions, openmp_support=.true., &
         extra_options=var_str ("-fusion:progress_file omega2.log"))

    call lib%append (entry)
    
    write (u, "(A)")
    write (u, "(A)")  "* Remove left-over file"
    write (u, "(A)")

    call delete_file ("omega2.log")
    inquire (file="omega2.log", exist=exist)
    write (u, "(1x,A,L1)")  "omega2.log exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Build and load library"

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Check extra output of OMega"
    write (u, "(A)")

    inquire (file="omega2.log", exist=exist)
    write (u, "(1x,A,L1)")  "omega2.log exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega2_a and initialize:"
    write (u, "(A)")

    call var_list_set_real (var_list, var_str ("ee"), 0.3_default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("me"), 0._default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("mmu"), 0._default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("mtau"), 0._default, &
         is_known = .true.)
    allocate (par (model%get_n_real ()))
    call model%real_parameters_to_c_array (par)

    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    call prc1%set_parameters (model)
    call prc2%set_parameters (model)

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega2_a_i1:"
    write (u, "(A)")

    config => lib%get_component_def_ptr (var_str ("omega2_a"), 1)
    call prc1%init (config%get_core_def_ptr (), &
         lib, var_str ("omega2_a"), 1)
    call prc1%get_constants (data, 1)

    write (u, "(1x,A,A)")  "component ID     = ", &
         char (data%id)
    write (u, "(1x,A,L1)") "openmp supported = ", &
         data%openmp_supported
    write (u, "(1x,A,A,A)") "model name       = '", &
         char (data%model_name), "'"

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega2_a_i2:"
    write (u, "(A)")

    config => lib%get_component_def_ptr (var_str ("omega2_a"), 2)
    call prc2%init (config%get_core_def_ptr (), &
         lib, var_str ("omega2_a"), 2)
    call prc2%get_constants (data, 1)

    write (u, "(1x,A,A)")  "component ID     = ", &
         char (data%id)
    write (u, "(1x,A,L1)") "openmp supported = ", &
         data%openmp_supported
    write (u, "(1x,A,A,A)") "model name       = '", &
         char (data%model_name), "'"

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute matrix element:"
    write (u, "(A)")

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(1) |amp (1, 6, 1)| =", abs (amp)
    end select

    select type (driver => prc2%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(2) |amp (1, 6, 1)| =", abs (amp)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, sqrt(0.5_cdf), 0.0_cdf, sqrt(0.5_cdf), &
         1.0_cdf,-sqrt(0.5_cdf), 0.0_cdf,-sqrt(0.5_cdf) &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute matrix element:"
    write (u, "(A)")

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(1) |amp (1, 6, 1)| =", abs (amp)
    end select

    select type (driver => prc2%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(2) |amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_2"
    
  end subroutine prc_omega_2
  
@ %def prc_omega_2
@
\subsubsection{Check helicity selection}
The process is $e^- e^+ \to e^- e^+$ for vanishing masses.  We call
the matrix element several times to verify the switching off of
irrelevant helicities.
<<Omega interface: execute tests>>=
  call test (prc_omega_3, "prc_omega_3", &
       "helicity selection", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_3 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    type(var_list_t), pointer :: var_list => null ()
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_component_def_t), pointer :: config
    type(prc_omega_t) :: prc1
    type(process_constants_t) :: data
    integer, parameter :: cdf = c_default_float
    real(cdf), dimension(:), allocatable :: par
    real(cdf), dimension(0:3,4) :: p
    type(helicity_selection_t) :: helicity_selection
    integer :: i, h
    
    write (u, "(A)")  "* Test output: prc_omega_3"
    write (u, "(A)")  "*   Purpose: create simple process with OMega"
    write (u, "(A)")  "*            and check helicity selection"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library."
    write (u, "(A)")  "* (1) e- e+ -> e- e+   (all diagrams, no OpenMP)"

    call lib%init (var_str ("omega3"))
    call os_data_init (os_data)
    call syntax_model_file_init ()

    model_name = "QED"
    call model_list%read_model &
         (var_str ("QED"), var_str ("QED.mdl"), os_data, model)
    var_list => model%get_var_list_ptr ()

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e-"), var_str ("e+")]
    prt_out = prt_in

    allocate (entry)
    call entry%init (var_str ("omega3_a"), &
         model, n_in = 2, n_components = 1)

    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out)
    call lib%append (entry)
    
    write (u, "(A)")
    write (u, "(A)")  "* Build and load library"

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega3_a and initialize:"
    write (u, "(A)")

    call var_list_set_real (var_list, var_str ("ee"), 0.3_default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("me"), 0._default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("mmu"), 0._default, &
         is_known = .true.)
    call var_list_set_real (var_list, var_str ("mtau"), 0._default, &
         is_known = .true.)
    allocate (par (model%get_n_real ()))
    call model%real_parameters_to_c_array (par)

    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    call prc1%set_parameters (model, helicity_selection)

    write (u, "(A)")
    write (u, "(A)")  "* Helicity states of omega3_a_i1:"
    write (u, "(A)")

    config => lib%get_component_def_ptr (var_str ("omega3_a"), 1)
    call prc1%init (config%get_core_def_ptr (), &
         lib, var_str ("omega3_a"), 1)
    call prc1%get_constants (data, 1)

    do i = 1, data%n_hel
       write (u, "(3x,I2,':',4(1x,I2))") i, data%hel_state(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Initially allowed helicities:"
    write (u, "(A)")
    
    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset helicity selection (cutoff = 4)"
    write (u, "(A)")

    helicity_selection%active = .true.
    helicity_selection%threshold = 1e10_default
    helicity_selection%cutoff = 4
    call helicity_selection%write (u)
    
    call prc1%set_parameters (model, helicity_selection)
    call prc1%reset_helicity_selection ()

    write (u, "(A)")
    write (u, "(A)")  "* Allowed helicities:"
    write (u, "(A)")
    
    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute scattering matrix 5 times"
    write (u, "(A)")

    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       do i = 1, 5
          call driver%new_event (p)
          write (u, "(2x,I2)", advance = "no")  i
          do h = 1, data%n_hel
             write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
          end do
          write (u, "(A)")
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Reset helicity selection again"
    write (u, "(A)")

    call prc1%activate_parameters ()

    write (u, "(A)")  "* Allowed helicities:"
    write (u, "(A)")
    
    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")
    
    call lib%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_3"
    
  end subroutine prc_omega_3
  
@ %def prc_omega_3
@
\subsubsection{QCD coupling}
The process is $u\bar u \to d\bar d$ for vanishing masses.  We compute
the amplitude for a fixed configuration once, then reset $\alpha_s$,
then compute again.

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_4, "prc_omega_4", &
       "update QCD alpha", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_4 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(6) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i
    real(cdf) :: alpha_s
    
    write (u, "(A)")  "* Test output: prc_omega_4"
    write (u, "(A)")  "*   Purpose: create a QCD process with OMega"
    write (u, "(A)")  "*            and check alpha_s dependence"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_4_lib"))
    call os_data_init (os_data)

    model_name = "QCD"
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]
    
    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (model_name, prt_in, prt_out)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_4_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters:"
    write (u, "(A)")

    alpha_s = 0.1178_cdf
    
    par = [alpha_s, 0._cdf, 0._cdf, 0._cdf, 173.1_cdf, 1.523_cdf]
    write (u, "(2x,A,F8.4)")  "alpha_s = ", par(1)
    write (u, "(2x,A,F8.4)")  "ms      = ", par(2)
    write (u, "(2x,A,F8.4)")  "mc      = ", par(3)
    write (u, "(2x,A,F8.4)")  "mb      = ", par(4)
    write (u, "(2x,A,F8.4)")  "mtop    = ", par(5)
    write (u, "(2x,A,F8.4)")  "wtop    = ", par(6)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")
    
    p = reshape ([ &
         100.0_cdf, 0.0_cdf, 0.0_cdf, 100.0_cdf, &
         100.0_cdf, 0.0_cdf, 0.0_cdf,-100.0_cdf, &
         100.0_cdf, 100.0_cdf, 0.0_cdf, 0.0_cdf, &
         100.0_cdf,-100.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.1))")  "p", i, " =", p(:,i)
    end do

    call lib%connect_process (var_str ("prc_omega_4_p"), 1, data, driver)

    select type (driver)
    type is (omega_driver_t)
       call driver%init (par)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%new_event (p)

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag
       
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

       write (u, "(A)")
       write (u, "(A)")  "* Double alpha_s and compute matrix element again:"
       write (u, "(A)")

       call driver%update_alpha_s (2 * alpha_s)
       call driver%new_event (p)

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag
       
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_4"
    
  end subroutine prc_omega_4
  
@ %def prc_omega_4
@
\subsubsection{Amplitude and QCD coupling}
The same process as before.  Here, we initialize with a running $\alpha_s$
coupling and compute twice with different scales.  We use the high-level
method [[compute_amplitude]].
<<Omega interface: execute tests>>=
  call test (prc_omega_5, "prc_omega_5", &
       "running QCD alpha", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_5 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_component_def_t), pointer :: cdef_ptr
    class(prc_core_def_t), pointer :: def_ptr
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(qcd_t) :: qcd
    class(prc_core_t), allocatable :: core
    class(workspace_t), allocatable :: tmp
    type(vector4_t), dimension(4) :: p
    complex(default) :: amp
    real(default) :: fac_scale
    integer :: i
    
    write (u, "(A)")  "* Test output: prc_omega_5"
    write (u, "(A)")  "*   Purpose: create a QCD process with OMega"
    write (u, "(A)")  "*            and check alpha_s dependence"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_5_lib"))
    call os_data_init (os_data)

    call syntax_model_file_init ()
    call model_list%read_model (var_str ("QCD"), var_str ("QCD.mdl"), &
         os_data, model)
    model_name = "QCD"

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]
    
    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (model_name, prt_in, prt_out)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_5_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    write (u, "(A)")  "* Probe library API"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics"
    write (u, "(A)")
    
    p(1) = vector4_moving (100._default, 100._default, 3)
    p(2) = vector4_moving (100._default,-100._default, 3)
    p(3) = vector4_moving (100._default, 100._default, 1)
    p(4) = vector4_moving (100._default,-100._default, 1)
    do i = 1, 4
       call vector4_write (p(i), u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup QCD data"
    write (u, "(A)")
    
    allocate (alpha_qcd_from_scale_t :: qcd%alpha)
    
    write (u, "(A)")  "* Setup process core"
    write (u, "(A)")
    
    allocate (prc_omega_t :: core)
    cdef_ptr => lib%get_component_def_ptr (var_str ("prc_omega_5_p"), 1)
    def_ptr => cdef_ptr%get_core_def_ptr ()

    select type (core)
    type is (prc_omega_t)
       call core%allocate_workspace (tmp)
       call core%set_parameters (model, qcd = qcd)
       call core%init (def_ptr, lib, var_str ("prc_omega_5_p"), 1)
       call core%write (u)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element"
       write (u, "(A)")

       fac_scale = 100
       write (u, "(1x,A,F4.0)")  "factorization scale = ", fac_scale

       amp = core%compute_amplitude &
            (1, p, 1, 6, 1, fac_scale, 100._default)

       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

       write (u, "(A)")
       write (u, "(A)")  "* Modify factorization scale and &
            &compute matrix element again"
       write (u, "(A)")

       fac_scale = 200
       write (u, "(1x,A,F4.0)")  "factorization scale = ", fac_scale

       amp = core%compute_amplitude &
            (1, p, 1, 6, 1, fac_scale, 100._default)

       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

    end select

    call lib%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_5"
    
  end subroutine prc_omega_5
  
@ %def prc_omega_5
@
\subsubsection{Generate matrix element diagrams}
The same process as before. No amplitude is computed here, instead we just
generate Feynman (and color flow) diagrams, and check whether PS and PDF
files have been generated. This test is only run if event analysis is 
possible.
<<Omega interface: execute diags tests>>=
  call test (prc_omega_diags_1, "prc_omega_diags_1", &
       "generate Feynman diagrams", &
       u, results)
<<Omega interface: tests>>=
  subroutine prc_omega_diags_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: diags_file, pdf_file, ps_file
    logical :: exist, exist_pdf, exist_ps
    integer :: iostat, u_diags
    character(128) :: buffer    
    
    write (u, "(A)")  "* Test output: prc_omega_diags_1"
    write (u, "(A)")  "*   Purpose: generate Feynman diagrams"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_diags_1_lib"))
    call os_data_init (os_data)

    call syntax_model_file_init ()
    call model_list%read_model (var_str ("SM"), var_str ("SM.mdl"), &
         os_data, model)
    model_name = "SM"

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]
    
    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            diags = .true., diags_color = .true.)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_diags_1_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)
    
    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")  "    and generate diagrams"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., testflag = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    write (u, "(A)")  "* Probe library API"
    write (u, "(A)")
       
    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")  "* Check produced diagram files"
    write (u, "(A)")        

    diags_file = "prc_omega_diags_1_p_i1_diags.tex"
    ps_file  = "prc_omega_diags_1_p_i1_diags.ps"
    pdf_file = "prc_omega_diags_1_p_i1_diags.pdf"    
    inquire (file = char (diags_file), exist = exist)
    if (exist) then
       u_diags = free_unit ()
       open (u_diags, file = char (diags_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_diags, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_diags)
    else
       write (u, "(A)")  "[Feynman diagrams LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[Feynman diagrams Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[Feynman diagrams Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[Feynman diagrams PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[Feynman diagrams PDF file is missing/non-regular]"
    end if               
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")    
    
    call lib%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_diags_1"
    
  end subroutine prc_omega_diags_1
  
@ %def prc_omega_diags_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gosam Interface}
<<[[prc_gosam.f90]]>>=
<<File header>>

module prc_gosam
  
  use, intrinsic :: iso_c_binding !NODEP!

  use kinds, only: default, double
<<Use strings>>  
  use io_units
  use constants
  use system_defs, only: TAB
  use system_dependencies
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use interactions
  use pdg_arrays
  use sm_qcd
  use flavors
  use models
  use md5
  
  use process_constants
  use prclib_interfaces
  use prc_core_def
  use prc_core

  use blha_config
  use loop_archive

<<Standard module head>>

<<prc gosam: constants>>

<<prc gosam: public>>

<<prc gosam: types>>

<<prc gosam: interfaces>>

contains

<<prc gosam: procedures>>

end module prc_gosam

@ 
@ %def module prc_gosam

<<prc gosam: constants>>=
  character(10), dimension(5), parameter ::  &
             lib_suffix = [character(10) :: &
             '.a', '.la', '.so', '.so.0', '.so.0.0.0']

@ The GoSam interface requires the momentum and result array to be of a fixed length.
<<prc gosam: constants>>=
  integer, parameter :: GOSAM_PARAMETER_LIMIT = 10
  integer, parameter :: GOSAM_MOMENTUM_LIMIT = 50
  integer, parameter :: GOSAM_RESULTS_LIMIT = 60

@ 
<<prc gosam: public>>=
  public :: gosam_writer_t
<<prc gosam: types>>=
  type, extends (prc_writer_f_module_t) :: gosam_writer_t
    type(string_t) :: gosam_dir
    type(string_t) :: golem_dir
    type(string_t) :: samurai_dir
    type(string_t) :: ninja_dir
    type(string_t) :: form_dir
    type(string_t) :: qgraf_dir
    type(blha_configuration_t) :: blha_cfg
  contains
  <<prc gosam: gosam writer: TBP>>
  end type gosam_writer_t

@ 
@ %def gosam_writer_t

<<prc gosam: public>>=
  public :: gosam_def_t
<<prc gosam: types>>=
  type, extends (prc_core_def_t) :: gosam_def_t
    type(string_t) :: basename
    logical :: execute_olp = .true.
  contains
  <<prc gosam: gosam def: TBP>>
  end type gosam_def_t

@ 
@ %def gosam_def_t
<<prc gosam: types>>=
  type, extends (prc_core_driver_t) :: gosam_driver_t 
    type(string_t) :: gosam_dir
    type(string_t) :: olp_file
    type(string_t) :: olc_file
    type(string_t) :: olp_dir
    type(loop_archive_t) :: loop_archive
    procedure(olp_start),nopass,  pointer :: &
              gosam_olp_start => null ()
    procedure(olp_eval), nopass, pointer :: &
              gosam_olp_eval => null()
    procedure(olp_info), nopass, pointer :: &
              gosam_olp_info => null ()
    procedure(olp_set_parameter), nopass, pointer :: &
              gosam_olp_set_parameter => null ()
    procedure(olp_eval2), nopass, pointer :: &
              gosam_olp_eval2 => null ()
    procedure(olp_option), nopass, pointer :: &
              gosam_olp_option => null ()
    procedure(olp_polvec), nopass, pointer :: &
              gosam_olp_polvec => null ()
    procedure(olp_finalize), nopass, pointer :: &
              gosam_olp_finalize => null ()
    procedure(olp_print_parameter), nopass, pointer :: &
              gosam_olp_print_parameter => null ()
  contains
  <<prc gosam: gosam driver: TBP>>
  end type gosam_driver_t

@ 
@ %def gosam_driver_t
<<prc gosam: public>>=
  public :: prc_gosam_t
<<prc gosam: types>>=
  type, extends (prc_core_t) :: prc_gosam_t
    type(qcd_t) :: qcd
    integer :: n_proc
    real(default) :: maximum_accuracy = 10000.0
    logical :: initialized = .false.
    integer :: i_born, i_cc, i_sc, i_virt
  contains
  <<prc gosam: prc gosam: TBP>>
  end type prc_gosam_t

@ 
@ %def prc_gosam_t
<<prc gosam: types>>=
  type, extends (workspace_t) :: gosam_state_t
    logical :: new_kinematics = .true.
    real(default) :: alpha_qcd = -1
  contains
  <<prc gosam: gosam state: TBP>>
  end type gosam_state_t

@ %def gosam_state_t
@
<<prc gosam: interfaces>>=
  interface 
    subroutine olp_start (contract_file_name, ierr) bind (C,name="OLP_Start")
      import
      character(kind=c_char, len=1), intent(in) :: contract_file_name
      integer(kind=c_int), intent(out) :: ierr
    end subroutine olp_start
  end interface

@ %def olp_start_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_eval (label, momenta, mu, parameters, res) &
         bind (C,name="OLP_EvalSubProcess")
      import
      integer(kind=c_int), value, intent(in) :: label
      real(kind=c_double), value, intent(in) :: mu
      real(kind=c_double), dimension(GOSAM_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(GOSAM_PARAMETER_LIMIT), intent(in) :: parameters
      real(kind=c_double), dimension(GOSAM_RESULTS_LIMIT), intent(out) :: res
    end subroutine olp_eval
  end interface

@ %def olp_eval interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_info (olp_file, olp_version, message) &
         bind(C,name="OLP_Info")
      import
      character(kind=c_char), intent(inout), dimension(15) :: olp_file
      character(kind=c_char), intent(inout), dimension(15) :: olp_version
      character(kind=c_char), intent(inout), dimension(255) :: message
    end subroutine olp_info
  end interface

@ %def olp_info interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_set_parameter &
         (variable_name, real_part, complex_part, success) &
            bind(C,name="OLP_SetParameter")
      import
      character(kind=c_char,len=1), intent(in) :: variable_name
      real(kind=c_double), intent(in) :: real_part, complex_part
      integer(kind=c_int), intent(out) :: success
    end subroutine olp_set_parameter
  end interface

@ %def olp_set_parameter_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_eval2 (label, momenta, mu, res, acc) &
         bind(C,name="OLP_EvalSubProcess2")
      import
      integer(kind=c_int), intent(in) :: label
      real(kind=c_double), intent(in) :: mu
      real(kind=c_double), dimension(GOSAM_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(GOSAM_RESULTS_LIMIT), intent(out) :: res
      real(kind=c_double), intent(out) :: acc
    end subroutine olp_eval2
  end interface

@ %def olp_eval2_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_option (line, stat) bind(C,name="OLP_Option")
      import
      character(kind=c_char, len=1), intent(in) :: line
      integer(kind=c_int), intent(out) :: stat
    end subroutine
  end interface

@ %def olp_option_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_polvec (p, q, eps) bind(C,name="OLP_Polvec")
      import
      real(kind=c_double), dimension(0:3), intent(in) :: p, q
      real(kind=c_double), dimension(0:7), intent(out) :: eps
    end subroutine
  end interface

@ %def olp_polvec_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_finalize () bind(C,name="OLP_Finalize")
      import
    end subroutine olp_finalize
  end interface

@ %def olp_finalize_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_print_parameter (filename) bind(C,name="OLP_PrintParameter")
      import
      character(kind=c_char, len=1), intent(in) :: filename
    end subroutine olp_print_parameter
  end interface

@ %def olp_print_parameter_interface
@
<<prc gosam: gosam def: TBP>>=
  procedure :: init => gosam_def_init
<<prc gosam: procedures>>=
  subroutine gosam_def_init (object, basename)
    class(gosam_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename
    object%basename = basename
    allocate (gosam_writer_t :: object%writer)
  end subroutine gosam_def_init

@ %def gosam_def_init
@
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: type_string => gosam_def_type_string
<<prc gosam: procedures>>=
  function gosam_def_type_string () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_def_type_string

@ 
@ %def gosam_def_type_string
<<prc gosam: gosam def: TBP>>=
  procedure :: write => gosam_def_write
<<prc gosam: procedures>>=
  subroutine gosam_def_write (object, unit)
    class(gosam_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (gosam_writer_t)
      call writer%write (unit)
    end select
  end subroutine gosam_def_write

@ 
@ %def gosam_def_write
<<prc gosam: gosam def: TBP>>=
  procedure :: read => gosam_def_read
<<prc gosam: procedures>>=
  subroutine gosam_def_read (object, unit)
    class(gosam_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug ("GoSam process definition: input not supported yet")
  end subroutine gosam_def_read


@ %def gosam_def_read
@
<<prc gosam: gosam def: TBP>>=
  procedure :: allocate_driver => gosam_def_allocate_driver
<<prc gosam: procedures>>=
  subroutine gosam_def_allocate_driver (object, driver, basename)
    class(gosam_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (gosam_driver_t :: driver)
  end subroutine gosam_def_allocate_driver

@
@ %def gosam_def_allocate_driver
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: get_features => gosam_def_get_features
<<prc gosam: procedures>>=
  subroutine gosam_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine gosam_def_get_features 

@
@ %def gosam_def_get_features
<<prc gosam: gosam def: TBP>>=
  procedure :: connect => gosam_def_connect
<<prc gosam: procedures>>=
  subroutine gosam_def_connect (def, lib_driver, i, proc_driver)   
    class(gosam_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    call msg_bug ("No implementation for gosam_def_connect")
  end subroutine gosam_def_connect

@ 
@ %def gosam_def_connect
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_wrapper => gosam_write_wrapper
<<prc gosam: procedures>>=
  subroutine gosam_write_wrapper (writer, unit, id, feature)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    call msg_bug ("Gosam write wrapper: Do not know what to do!")
  end subroutine gosam_write_wrapper

@
@ %def gosam_write_wrapper
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_interface => gosam_write_interface
<<prc gosam: procedures>>= 
  subroutine gosam_write_interface (writer, unit, id, feature)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
  end subroutine gosam_write_interface 

@
@ %def gosam_write_interface
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_source_code => gosam_write_source_code
<<prc gosam: procedures>>=
  subroutine gosam_write_source_code (writer, id)
    class(gosam_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    call msg_bug ("Gosam does not have to be " // &
         "supported with Whizard-generated code")
  end subroutine gosam_write_source_code

@ 
@ %def gosam_write_source_code
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_makefile_code => gosam_write_makefile_code
<<prc gosam: procedures>>=
  subroutine gosam_write_makefile_code (writer, unit, id, os_data, testflag)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    call msg_bug ("Gosam does not have to be " // &
         "supported with a Whizard-generated Makefile")
  end subroutine gosam_write_makefile_code

@
@ %def gosam_write_makefile_code
<<prc gosam: gosam writer: TBP>>=
  procedure, nopass :: type_name => gosam_writer_type_name
<<prc gosam: procedures>>=
  function gosam_writer_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_writer_type_name

@
@ %def gosam_writer_type_name
<<prc gosam: gosam writer: TBP>>=
  procedure :: write => gosam_writer_write
<<prc gosam: procedures>>=
  subroutine gosam_writer_write (writer, unit)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit    
    write (unit, "(1x,A)")  char (writer%get_process_string ())
  end subroutine gosam_writer_write

@
@ %def gosam_writer_write
<<prc gosam: gosam writer: TBP>>=
  procedure :: init => gosam_writer_init
<<prc gosam: procedures>>=
  subroutine gosam_writer_init (writer, basename, flv_states, amp_type, & 
                                alpha_power, alphas_power, &
                                os_data, model, ex_olp)
    class(gosam_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: basename
    integer, intent(in), dimension(:,:) :: flv_states
    integer, intent(in), dimension(:), optional :: amp_type
    integer, intent(in) :: alpha_power, alphas_power
    type(os_data_t), intent(in) :: os_data
    type(model_t), intent(in), pointer :: model
    logical, intent(out) :: ex_olp
    ex_olp = .false.

    writer%gosam_dir = GOSAM_DIR
    writer%golem_dir = GOLEM_DIR 
    writer%samurai_dir = SAMURAI_DIR
    writer%ninja_dir = NINJA_DIR
    writer%form_dir = FORM_DIR
    writer%qgraf_dir = QGRAF_DIR

    call check_file_change (var_str ('golem.in'), 'config')
  contains
    subroutine check_file_change (filename, file_type)
      type(string_t), intent(in) :: filename
      character(*), intent(in) :: file_type
      logical :: exist
      integer :: unit
      character(len=32) :: md5sum1, md5sum2
      inquire (file = char (filename), exist = exist)
      if (exist) then
        unit = free_unit ()
        open (unit, file = char (filename), status = 'old', action = 'read')
        md5sum1 = md5sum (unit)
        close (unit)
        open (unit, file = char (filename // '_tmp'), status = 'replace',&
              action = 'readwrite')
        call generate_file (unit, file_type)
        rewind (unit)
        md5sum2 = md5sum (unit)
        close (unit)
        if (md5sum1 == md5sum2) then
          call os_system_call ('rm ' // filename // '_tmp')
          ex_olp = ex_olp .or. .false.
        else
          call os_system_call ('mv ' // filename // '_tmp' &
                  // ' ' // filename)
          ex_olp = ex_olp .or. .true.
        end if
      else
        unit = free_unit ()
        open (unit, file = char (filename), status = 'new', action = 'write')
        call generate_file (unit, file_type)
        close(unit)
        ex_olp = ex_olp .or..true.
      end if
    end subroutine check_file_change

    subroutine generate_file (unit, file_type)
      integer, intent(in) :: unit
      character(*), intent(in) :: file_type
      select case (file_type)
      case ('config')
        call writer%generate_configuration_file (unit, os_data)
      case ('olp')
        call writer%generate_olp_file (unit, os_data)
      case default
        call msg_fatal &
          ('Gosam writer: can only create configuration- and olp-files')
      end select
    end subroutine generate_file
  end subroutine gosam_writer_init  

@ %def gosam_writer_init
@
<<prc gosam: gosam driver: TBP>>=
  procedure, nopass :: type_name => gosam_driver_type_name
<<prc gosam: procedures>>=
  function gosam_driver_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_driver_type_name

@ 
@ %def gosam_driver_type_name
<<prc gosam: gosam driver: TBP>>=
  procedure :: init => gosam_driver_init
<<prc gosam: procedures>>=
  subroutine gosam_driver_init (object, os_data, olp_file, &
                                olc_file, olp_dir)
    class(gosam_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: olp_file, olc_file, olp_dir
    object%gosam_dir = GOSAM_DIR
    object%olp_file = olp_file
    object%olc_file = olc_file
    object%olp_dir = olp_dir
    call object%loop_archive%activate (var_str ('Generated_Loops'))
  end subroutine gosam_driver_init

@ %def gosam_driver_init
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: generate_configuration_file => &
            gosam_writer_generate_configuration_file
<<prc gosam: procedures>>=
  subroutine gosam_writer_generate_configuration_file &
          (object, unit, os_data)
      class(gosam_writer_t), intent(in) :: object
      integer, intent(in) :: unit
      type(os_data_t), intent(in) :: os_data
      type(string_t) :: fc_bin
      type(string_t) :: form_bin, qgraf_bin, haggies_bin
      type(string_t) :: fcflags_golem, ldflags_golem
      type(string_t) :: fcflags_samurai, ldflags_samurai
      type(string_t) :: fcflags_ninja, ldflags_ninja
      type(string_t) :: ldflags_avh_olo, ldflags_qcdloop
      fc_bin = DEFAULT_FC
      form_bin = object%form_dir // '/bin/tform'
      qgraf_bin = object%qgraf_dir // '/bin/qgraf'
      if (object%gosam_dir /= "") then
        haggies_bin = '/usr/bin/java -jar ' // object%gosam_dir // &
                       '/share/golem/haggies/haggies.jar'
      else
        call msg_fatal ("generate_configuration_file: At least " // &
             "the GoSam Directory has to be specified!")
      end if
      if (object%golem_dir /= "") then
        fcflags_golem = "-I" // object%golem_dir // "/include/golem95"
        ldflags_golem = "-L" // object%golem_dir // "/lib -lgolem"
      end if
      if (object%samurai_dir /= "") then
        fcflags_samurai = "-I" // object%samurai_dir // "/include/samurai"
        ldflags_samurai = "-L" // object%samurai_dir // "/lib -lsamurai"
        ldflags_avh_olo = "-L" // object%samurai_dir // "/lib -lavh_olo"
        ldflags_qcdloop = "-L" // object%samurai_dir // "/lib -lqcdloop"
      end if
      if (object%ninja_dir /= "") then
        fcflags_ninja = "-I" // object%ninja_dir // "/include/ninja " &
                        // "-I" // object%ninja_dir // "/include"
        ldflags_ninja = "-L" // object%ninja_dir // "/lib -lninja"
      end if
      write (unit, "(A)") "+avh_olo.ldflags=" &
            // char (ldflags_avh_olo) 
      write (unit, "(A)") "reduction_programs=golem95, samurai, ninja"
      write (unit, "(A)") "extensions=autotools"
      write (unit, "(A)") "+qcdloop.ldflags=" &
            // char (ldflags_qcdloop)
      write (unit, "(A)") "+zzz.extensions=qcdloop, avh_olo"
      write (unit, "(A)") "fc.bin=" // char (os_data%fc)
      write (unit, "(A)") "form.bin=" // char (form_bin)
      write (unit, "(A)") "qgraf.bin=" // char (qgraf_bin)
      write (unit, "(A)") "golem95.fcflags=" // char (fcflags_golem)
      write (unit, "(A)") "golem95.ldflags=" // char (ldflags_golem)
      write (unit, "(A)") "haggies.bin=" // char (haggies_bin)
      write (unit, "(A)") "samurai.fcflags=" // char (fcflags_samurai)
      write (unit, "(A)") "samurai.ldflags=" // char (ldflags_samurai)
      write (unit, "(A)") "ninja.fcflags=" // char (fcflags_ninja)
      write (unit, "(A)") "ninja.ldflags=" // char (ldflags_ninja)
      write (unit, "(A)") "zero=mU,mD,mC,mS,mB"
      write (unit, "(A)") "PSP_check=False"
      write (unit, "(A)") "filter.lo=lambda d: d.iprop(H) == 0 and d.iprop(chi) == 0"
      write (unit, "(A)") "filter.nlo=lambda d: d.iprop(H) == 0 and d.iprop(chi) == 0"
  end subroutine gosam_writer_generate_configuration_file

@ %def gosam_writer_generate_configuration_file
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: generate_olp_file => gosam_writer_generate_olp_file
<<prc gosam: procedures>>=
  subroutine gosam_writer_generate_olp_file (object, unit, os_data)
    class(gosam_writer_t), intent(in) :: object
    integer, intent(in) :: unit
    type(os_data_t), intent(in) :: os_data
    call blha_configuration_write (object%blha_cfg, unit)
  end subroutine gosam_writer_generate_olp_file

@ %def gosam_writer_generate_olp_file
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: get_process_string => gosam_writer_get_process_string
<<prc gosam: procedures>>=
  function gosam_writer_get_process_string (writer) result (s_proc)
    class(gosam_writer_t), intent(in) :: writer
    type(string_t) :: s_proc
    character (3) :: c 
    integer :: i
    ! write (c, '(I3)') writer%pdg_in (1)
    ! s_proc = var_str (c) // " "
    ! write (c, '(I3)') writer%pdg_in (2)
    ! s_proc = s_proc // var_str (c) // " -> "
    ! do i = 1, size (writer%pdg_out)
    !   write (c, '(I3)') writer%pdg_out (i) 
    !   s_proc = s_proc // var_str (c) // " "
    ! end do
  end function gosam_writer_get_process_string

@ %def gosam_writer_get_process_string
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: get_n_proc => gosam_writer_get_n_proc
<<prc gosam: procedures>>=
  function gosam_writer_get_n_proc (writer) result (n_proc)
    class(gosam_writer_t), intent(in) :: writer
    integer :: n_proc
    n_proc = blha_configuration_get_n_proc (writer%blha_cfg)
  end function gosam_writer_get_n_proc

@ %def gosam_writer_get_n_proc
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: execute_olp_file => gosam_driver_execute_olp_file
<<prc gosam: procedures>>=
  subroutine gosam_driver_execute_olp_file (object, os_data)
    class(gosam_driver_t), intent(in) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: command
    integer :: unit
    command = object%gosam_dir // "/bin" // &
              '/gosam.py --olp ' // object%olp_file // &
              ' --destination=' // object%olp_dir // &
              ' -f -z'
    call os_system_call (command, verbose = .true.)
    call msg_message ("Configure olp_modules")
    command = "cd " // object%olp_dir // "; ./autogen.sh --prefix=$(pwd)"
    call os_system_call (command, verbose = .true.)
    call msg_message ("Installing olp_modules")
    command = "cd " // object%olp_dir // ";  make install"
    call os_system_call (command, verbose = .true.)
  end subroutine gosam_driver_execute_olp_file

@ %def gosam_driver_execute_olp_file
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: load => gosam_driver_load
<<prc gosam: procedures>>=
  subroutine gosam_driver_load (object, os_data, store, success)
    class(gosam_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: store
    logical, intent(out) :: success
    type(dlaccess_t) :: dlaccess
    type(string_t) ::  path
    type(c_funptr) :: c_fptr

    path = object%olp_dir // '/.libs'
    call dlaccess_init &
          (dlaccess, var_str ("."), path // '/libgolem_olp.so', os_data)
    if (os_file_exist (path // '/libgolem_olp.so')) then
      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Start"))
      call c_f_procpointer (c_fptr, object%gosam_olp_start)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess"))
      call c_f_procpointer (c_fptr, object%gosam_olp_eval)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Info"))
      call c_f_procpointer (c_fptr, object%gosam_olp_info)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_SetParameter"))
      call c_f_procpointer (c_fptr, object%gosam_olp_set_parameter)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess2"))
      call c_f_procpointer (c_fptr, object%gosam_olp_eval2)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Option"))
      call c_f_procpointer (c_fptr, object%gosam_olp_option)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Polvec"))
      call c_f_procpointer (c_fptr, object%gosam_olp_polvec)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Finalize"))
      call c_f_procpointer (c_fptr, object%gosam_olp_finalize)

      c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_PrintParameter"))
      call c_f_procpointer (c_fptr, object%gosam_olp_print_parameter)

      success = .not. dlaccess_has_error (dlaccess)
      if (store .and. success) call object%loop_archive%record (object%olp_file, &
                                  var_str ('golem.in'), path // '/libgolem_olp.so')
    else
      success = .false.
    end if
  end subroutine gosam_driver_load

@ %def gosam_driver_load
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: write => prc_gosam_write
<<prc gosam: procedures>>=
  subroutine prc_gosam_write (object, unit)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message ("GOSAM")
  end subroutine prc_gosam_write

@
@ %def prc_gosam_write
<<prc gosam: prc gosam: TBP>>=
  procedure :: needs_mcset => prc_gosam_needs_mcset
<<prc gosam: procedures>>=
  function prc_gosam_needs_mcset (object) result (flag)
    class(prc_gosam_t), intent(in) :: object
    logical :: flag
    !!! Is this really the same for Gosam as for Omega?
    flag = .true.
  end function prc_gosam_needs_mcset

@
@ %def prc_gosam_write
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_n_terms => prc_gosam_get_n_terms
<<prc gosam: procedures>>=
  function prc_gosam_get_n_terms (object) result (n)
    class(prc_gosam_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_gosam_get_n_terms

@  
@ %def prc_gosam_get_n_terms
<<prc gosam: prc gosam: TBP>>=
  procedure :: is_allowed => prc_gosam_is_allowed
<<prc gosam: procedures>>=
  function prc_gosam_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    flag = .true.
  end function prc_gosam_is_allowed

@
@ %def prc_gosam_is_allowed
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_hard_kinematics => prc_gosam_compute_hard_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, tmp)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(workspace_t), intent(inout), allocatable :: tmp 
    call interaction_set_momenta (int_hard, p_seed)
    if (allocated (tmp)) then
      select type (tmp)
      type is (gosam_state_t); tmp%new_kinematics = .true.
      end select
    end if
  end subroutine prc_gosam_compute_hard_kinematics

@ 
@ %def prc_gosam_compute_hard_kinematics
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_eff_kinematics => prc_gosam_compute_eff_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, tmp)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
  end subroutine prc_gosam_compute_eff_kinematics

@
@ %def prc_gosam_compute_eff_kinematics
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_amplitude => prc_gosam_compute_amplitude
<<prc gosam: procedures>>=
  function prc_gosam_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, tmp) result (amp)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    class(workspace_t), intent(inout), allocatable, optional :: tmp
    complex(default) :: amp
    select type (tmp)
    type is (gosam_state_t)
      tmp%alpha_qcd = object%qcd%alpha%get (fac_scale)
    end select
    amp = 0.0
  end function prc_gosam_compute_amplitude

@
@ %def prc_gosam_compute_amplitude
<<prc gosam: prc gosam: TBP>>=
  procedure :: recover_kinematics => prc_gosam_recover_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_recover_kinematics &
       (object, p_seed, int_hard, int_eff, tmp)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard, int_eff
    class(workspace_t), intent(inout), allocatable :: tmp
    integer :: n_in
    n_in = interaction_get_n_in (int_eff)
    call interaction_set_momenta (int_eff, p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = interaction_get_momenta (int_eff, outgoing = .true.)
  end subroutine prc_gosam_recover_kinematics

@ 
@ %def prc_gosam_recover_kinematics
<<prc gosam: prc gosam: TBP>>=
   procedure :: init_writer => prc_gosam_init_writer
<<prc gosam: procedures>>=
  subroutine prc_gosam_init_writer (object, gosam_template, os_data, model)
    class(prc_gosam_t), intent(inout) :: object
    type(gosam_writer_template_t), intent(inout) :: gosam_template
    type(os_data_t), intent(in) :: os_data
    type(model_t), intent(in), pointer :: model
    integer,  dimension(:), allocatable :: amp_type
    integer, dimension(:,:), allocatable :: flv_states
    integer :: i, n_proc
    
    n_proc = 0
    if (gosam_template%compute_loops) n_proc = n_proc+1
    if (gosam_template%compute_correlations) n_proc = n_proc+3

    associate (data => gosam_template%data)
      allocate (amp_type (n_proc))
      allocate (flv_states (data%n_in + data%n_out, n_proc))
      do i = 1, n_proc
         flv_states (:,i:i) = data%get_flv_state ()
      end do
      i = 1
      if (gosam_template%compute_loops) then
         amp_type (i) = BLHA_AMP_LOOP
         object%i_virt = i-1
         i = i+1
      end if
      if (gosam_template%compute_correlations) then
         amp_type (i) = BLHA_AMP_TREE
         object%i_born = i-1
         i = i+1
         amp_type (i) = BLHA_AMP_CC
         object%i_cc = i-1
         i = i+1
         amp_type (i) = BLHA_AMP_SC
         object%i_sc = i-1
      end if  
     
      select type (def => object%def) 
        type is (gosam_def_t)
        select type (writer => def%writer)
        type is (gosam_writer_t)
          call writer%init (def%basename, flv_states, amp_type, &
                            gosam_template%alpha_power, &
                            gosam_template%alphas_power, &
                            os_data, model, def%execute_olp)
        end select
      end select
    end associate
  end subroutine prc_gosam_init_writer

@ %def prc_gosam_init_writer
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: init_driver => prc_gosam_init_driver
<<prc gosam: procedures>>=
  subroutine prc_gosam_init_driver (object, os_data)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical :: dl_success
    type(string_t) :: olp_file, olc_file, olp_dir
    integer(c_int) :: success
    logical :: found = .false.

    select type (def => object%def)
    type is (gosam_def_t)
      olp_file = def%basename // '.olp'
      olc_file = def%basename // '.olc'
      olp_dir = def%basename // '_olp_modules'
    class default
      call msg_bug ("prc_gosam_init_driver: core_def should be of gosam-type")
    end select

    call object%def%allocate_driver (object%driver, var_str ("Test_Gosam"))
    associate (driver=>object%driver)
    select type(driver)
    type is (gosam_driver_t)

      call driver%init (os_data, olp_file, olc_file, olp_dir)
      call driver%loop_archive%search ([olp_file, var_str ('golem.in'), olp_dir // &
                                        '/.libs/libgolem_olp_.so'], found)
      if (found) then
         call driver%loop_archive%restore (olp_file, olp_dir)
      else
        select type (def => object%def)
        type is (gosam_def_t)
           call driver%execute_olp_file (os_data)
        end select  
      end if
      call driver%load (os_data, .not.found, dl_success)
      if (.not. dl_success) &
        call msg_fatal ("Error in linking gosam libraries")
      call driver%gosam_olp_start (char (driver%olc_file), success)
    end select
    end associate
  end subroutine prc_gosam_init_driver

@ %def prc_gosam_init_driver
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_initialized => prc_gosam_set_initialized
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_initialized (prc_gosam)
    class(prc_gosam_t), intent(inout) :: prc_gosam
    prc_gosam%initialized = .true.
  end subroutine prc_gosam_set_initialized 

@ %def prc_gosam_set_initialized
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_parameters => prc_gosam_set_parameters
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_parameters (object, qcd)
    class(prc_gosam_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    object%qcd = qcd
  end subroutine prc_gosam_set_parameters

@ %def prc_gosam_set_parameters
@
<<prc gosam: procedures>>=
  function create_blha_momentum_array (p) result (mom)
    type(vector4_t), intent(in), dimension(:) :: p
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    integer :: n, i, k

    n = size (p)
    if (n > 10) call msg_fatal ("Number of external particles exceeeds" &
                                 // "size of GoSam-internal momentum array")
    k = 1
    do i = 1, n
       mom(k:k+3) = vector4_get_components (p(i))
       mom(k+4) = invariant_mass (p(i))
       k = k+5
    end do
    mom (k:50) = 0.0
  end function create_blha_momentum_array

@ %def create_blha_momentum_array
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_virt => prc_gosam_compute_sqme_virt
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_virt &
       (object, p, ren_scale, alpha_s, sqme, bad_point)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(in) :: alpha_s
    logical, intent(out) :: bad_point
    real(default), dimension(4), intent(out) :: sqme
    real(double) :: mu
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    integer :: i, comp
    real(double) :: acc_dble
    real(default) :: acc
    integer :: ierr

    mom = create_blha_momentum_array (p)
    if (ren_scale == 0.0) then
      mu = sqrt (2* (p(1)*p(2)))
    else
      mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
      call driver%gosam_olp_set_parameter &
           (c_char_'alphaS'//c_null_char, &
            dble (twopi), 0._double, ierr)
      call driver%gosam_olp_eval2 (object%i_virt, mom, mu, r, acc_dble) 
    end select
    acc = acc_dble
    sqme = r(1:4)
    if (acc > object%maximum_accuracy) then
       bad_point = .true.
    else
       bad_point = .false.
    end if
  end subroutine prc_gosam_compute_sqme_virt

@ %def prc_gosam_compute_sqme_virt
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_cc => prc_gosam_compute_sqme_cc
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_cc &
         (object, p, ren_scale, born_out, born_cc, bad_point)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(out), optional :: born_out
    real(default), intent(inout), dimension(:,:) :: born_cc
    logical, intent(out) :: bad_point
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: mu
    integer :: i, j, pos
    integer :: im1, jm1
    real(double) :: acc_dble1, acc_dble2
    real(default) :: acc1, acc2
    real(default) :: born
    integer :: ierr

    mom = create_blha_momentum_array (p)
    if (ren_scale == 0.0) then
       mu = sqrt (2*p(1)*p(2))
    else
       mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%gosam_olp_eval2 (object%i_born, mom, mu, r, acc_dble1)
       born = r(4)
       if (present (born_out)) born_out = born
       call driver%gosam_olp_eval2 (object%i_cc, mom, mu, r, acc_dble2)
    end select
    do j = 1, size (p)
      do i = 1, j
        if (i <= 2 .or. j <= 2) then
          born_cc (i,j) = 0._default
        else if (i == j) then
          born_cc (i,j) = -cf*born
        else
          im1 = i-1; jm1 = j-1
          pos = im1 + jm1*(jm1-1)/2 + 1
          born_cc (i,j) = -r(pos)
        end if
        born_cc (j,i) = born_cc (i,j)
      end do
    end do
    acc1 = acc_dble1; acc2 = acc_dble2
    if (acc1 > object%maximum_accuracy .or. &
        acc2 > object%maximum_accuracy) then
      bad_point = .true.
    end if
  end subroutine prc_gosam_compute_sqme_cc

@ %def prc_gosam_compute_sqme_cc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_sc => prc_gosam_compute_sqme_sc
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_sc &
           (object, em, p, ren_scale_in, born_sc, bad_point)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: em
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale_in
    real(default), intent(inout), dimension(:,:) :: born_sc
    logical, intent(out) :: bad_point
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: ren_scale
    real(double), dimension(0:3) :: p_gluon, q_ref
    real(double), dimension(0:7) :: eps
    integer :: i, igm1, n
    integer :: pos
    integer :: mu, nu
    real(default) :: sum_born
    real(double) :: acc_dble
    real(default) :: acc
    integer :: ierr

    sum_born = 0.0
    mom = create_blha_momentum_array (p)
@ Dummy vector as reference momentum
<<prc gosam: procedures>>=
    q_ref = 0.5*[1,1,1,1]
    p_gluon = vector4_get_components (p(em))
    if (ren_scale_in == 0.0) then
      ren_scale = sqrt (2*p(1)*p(2))
    else
      ren_scale = ren_scale_in
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%gosam_olp_eval2 (object%i_sc, mom, ren_scale, r, acc_dble)
       call driver%gosam_olp_polvec (p_gluon, q_ref, eps)
    end select

    igm1 = em-1
    n = size(p)
    do i = 0, n-1
      pos = 2*igm1 + 2*n*i + 1
      sum_born = sum_born + r(pos)
    end do

    do mu = 0, 3
      do nu = 0, 3
        born_sc (mu,nu) = sum_born * eps(2*mu) * eps(2*nu)
      end do
    end do
  
    acc = acc_dble
    if (acc > object%maximum_accuracy) bad_point = .true.
  end subroutine prc_gosam_compute_sqme_sc

@ %def prc_gosam_compute_sqme_sc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: fill_constants => prc_gosam_fill_constants
<<prc gosam: procedures>>=
  subroutine prc_gosam_fill_constants (object, data_born)
    class(prc_gosam_t), intent(inout) :: object
    type(process_constants_t), intent(in) :: data_born
    associate (data => object%data)
      data%id = 'eeuu'
      print *, 'Model name: ', char (data_born%model_name)
      data%model_name = data_born%model_name
      data%md5sum = data_born%md5sum
      data%openmp_supported = .false.
      data%n_in = data_born%n_in
      data%n_out = data_born%n_out
      data%n_flv = data_born%n_flv
      data%n_hel = data_born%n_hel
      data%n_col = data_born%n_col
      data%n_cin = data_born%n_cin
      data%n_cf = data_born%n_cf
      data%flv_state = data_born%flv_state
      data%hel_state = data_born%hel_state
      data%col_state = data_born%col_state
      data%color_factors = data_born%color_factors
      data%cf_index = data_born%cf_index
      data%ghost_flag = data_born%ghost_flag
    end associate
  end subroutine prc_gosam_fill_constants

@ %def prc_gosam_fill_constants
@ 
<<prc gosam: prc gosam: TBP>>=
  procedure :: allocate_workspace => prc_gosam_allocate_workspace
<<prc gosam: procedures>>=
  subroutine prc_gosam_allocate_workspace (object, tmp)
    class(prc_gosam_t), intent(in) :: object
    class(workspace_t), intent(inout), allocatable :: tmp
    allocate (gosam_state_t :: tmp)
  end subroutine prc_gosam_allocate_workspace

@ %def prc_gosam_allocate_workspace
@ 
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_alpha_s => prc_gosam_get_alpha_s
<<prc gosam: procedures>>=
  function prc_gosam_get_alpha_s (object, tmp) result (alpha)
    class(prc_gosam_t), intent(in) :: object
    class(workspace_t), intent(in), allocatable :: tmp
    real(default) :: alpha
    if (allocated (tmp)) then
      select type (tmp)
      type is (gosam_state_t)
        alpha = tmp%alpha_qcd
      end select
    end if
  end function prc_gosam_get_alpha_s

@ %def prc_gosam_get_alpha_s
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_n_proc => prc_gosam_set_n_proc
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_n_proc (object)
    class(prc_gosam_t), intent(inout) :: object
    select type (writer => object%def%writer)
    type is (gosam_writer_t)
      object%n_proc = writer%get_n_proc ()
    end select
  end subroutine prc_gosam_set_n_proc

@ %def prc_gosam_set_n_proc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_n_proc => prc_gosam_get_n_proc
<<prc gosam: procedures>>=
  function prc_gosam_get_n_proc (object) result (n_proc)
    class(prc_gosam_t), intent(in) :: object
    integer :: n_proc
    n_proc = object%n_proc
  end function prc_gosam_get_n_proc

@ %def prc_gosam_get_n_proc
@
<<prc gosam: gosam state: TBP>>=
  procedure :: write => gosam_state_write
<<prc gosam: procedures>>=
  subroutine gosam_state_write (object, unit)
    class(gosam_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_bug ("gosam_state_write: What to write?")
  end subroutine gosam_state_write

@ %def prc_gosam_state_write
@
<<prc gosam: gosam state: TBP>>=
  procedure :: reset_new_kinematics => gosam_state_reset_new_kinematics
<<prc gosam: procedures>>=
  subroutine gosam_state_reset_new_kinematics (object)
    class(gosam_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine gosam_state_reset_new_kinematics

@ 
@ %def gosam_state_reset_new_kinematics
<<prc gosam: procedures>>=
  function check_golem_installation (os_data) result (res)
     type(os_data_t), intent(in) :: os_data
     logical :: res
     type(string_t) :: libavh_olo, libgolem
     integer :: i
     res = .true.
     do i = 1, size (lib_suffix)
       libavh_olo = os_data%prefix // '/lib/libavh_olo' // &
            trim (lib_suffix (i))
       libgolem = os_data%prefix // '/lib/libgolem' // trim (lib_suffix (i))
       res = res .and. (os_file_exist (libavh_olo) .and. &
            os_file_exist (libgolem))
       if (.not. res) exit
     end do
   end function check_golem_installation

@ %def check_golem_installation
@
<<prc gosam: procedures>>=
  function check_samurai_installation (os_data) result (res)
    type(os_data_t), intent(in) :: os_data
    logical :: res
    type(string_t) :: libsamurai
    integer :: i
    res = .true.
    do i = 1, size (lib_suffix)
      libsamurai = os_data%prefix // '/lib/libsamurai' // trim (lib_suffix(i))
      res = os_file_exist (libsamurai)
      if (.not. res) exit
    end do
  end function check_samurai_installation 

@ %def check_samurai_installation
@
<<prc gosam: procedures>>=
  function check_ninja_installation (os_data) result (res)
    type(os_data_t), intent(in) :: os_data
    logical :: res
    type(string_t) :: libninja
    integer :: i
    res = .true.
    do i = 1, size (lib_suffix)
      libninja = os_data%prefix // '/lib/libninja' // trim (lib_suffix(i))
      res = os_file_exist (libninja)
      if (.not. res) exit
    end do
  end function check_ninja_installation

@ %def check_ninja_installation
@
<<prc gosam: public>>=
  public :: gosam_writer_template_t
<<prc gosam: types>>=
  type :: gosam_writer_template_t
    type(process_constants_t) :: data
    logical :: compute_loops = .true.
    logical :: compute_correlations = .false.
    integer :: alpha_power, alphas_power
    logical :: new
  end type gosam_writer_template_t

@ %def gosam_writer_template_t
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Save previously generated loop libraries}
<<[[loop_archive.f90]]>>=
<<File header>>

module loop_archive

  use io_units
<<Use strings>>
  use diagnostics
  use os_interface
  use md5

<<Loop archive: public>>

<<Loop archive: types>>

contains

<<Loop archive: procedures>>

end module loop_archive
@ %def loop_archive
@ 
<<Loop archive: public>>=
  public :: loop_archive_t
<<Loop archive: types>>=
  type :: loop_archive_t
    logical :: active = .false.
    type(string_t) :: name
    type(string_t) :: current_prefix
  contains
  <<Loop archive: loop archive: TBP>>
  end type loop_archive_t

@ %def loop_archive_t
@
<<Loop archive: loop archive: TBP>>=
  procedure :: activate => loop_archive_activate
<<Loop archive: procedures>>=
  subroutine loop_archive_activate (archive, name)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: name
    integer :: status, success
    type(string_t) :: prefix
    archive%name = name
    call os_system_call ('test -d "' // name // &
                         '"', status = status, verbose = .true.)
    if (status /= 0) then
      call os_system_call ('mkdir ' // name, &
                            status = success, verbose = .true.)
      if (success /= 0) call msg_fatal ("Creation of loop archive failed!")
    end if
    archive%active = .true.
  end subroutine loop_archive_activate

@ %def loop_archive_activate
@
<<Loop archive: loop archive: TBP>>=
  procedure :: record => loop_archive_record
<<Loop archive: procedures>>=
  subroutine loop_archive_record (archive, olp_file, config_file, lib)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_file, config_file, lib
    type(string_t) :: current_prefix
    type(string_t) :: filename
    
! Copy, rename and move olp-file
    filename = archive%current_prefix // '.olp'
    call os_system_call ('cp ' // olp_file // ' ' // &
                         filename)
    call os_system_call ('mv ' // filename // ' ' // &
                         archive%name)
! Do the same with the loop-library and the config file
    filename = archive%current_prefix // '_libgolem_olp.so'
    call os_system_call ('cp ' // lib // ' ' // filename)
    call os_system_call ('mv ' // filename // ' ' // &
                         archive%name)
    filename = archive%current_prefix // '_golem.in'
    call os_system_call ('cp ' // config_file // ' ' // &
                         filename)
    call os_system_call ('mv ' // filename // ' ' // &
                         archive%name)

  end subroutine loop_archive_record

@ %def loop_archive_record
@
<<Loop archive: loop archive: TBP>>=
  procedure :: search => loop_archive_search
<<Loop archive: procedures>>=
  subroutine loop_archive_search (archive, files, found)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), dimension(3), intent(in) :: files
    logical, intent(out) :: found
    type(string_t) :: current_olp, current_config, current_lib
    character(len=3) :: prefix
    integer :: counter
    logical, dimension(2) :: exist
    integer, dimension(2) :: identical
    integer :: i

    counter = 1
    do
       write(prefix,"(A,I2.2)") 'V', counter
       current_olp = archive%name // '/' // var_str (prefix) // '.olp'
       current_config = archive%name // '/' // var_str (prefix) // '_golem.in'
       current_lib = archive%name // '/' // var_str (prefix) // '_libgolem_olp.so'
       inquire (file = char (current_olp), exist = exist(1))
       inquire (file = char (current_config), exist = exist(2))
       if (all (exist)) then
          call os_system_call ('diff ' // current_olp // ' ' // files(1) // &
                               ' > /dev/null', status=identical(1))
          call os_system_call ('diff ' // current_config // ' ' // files(2) // &
                               ' > /dev/null', status=identical(2))
            if (all (identical == 0)) then
               found = .true.
               exit
            else
               counter = counter+1
            end if
       else
          found = .false.
          exit
       end if
       if (counter >= 100) call msg_fatal ("Maximum number of loop-libraries exceeded!")
    end do
    write(prefix,"(A,I2.2)") 'V', counter
    archive%current_prefix = var_str (prefix)    
  end subroutine loop_archive_search

@ %def loop_archive_searc
@
<<Loop archive: loop archive: TBP>>=
  procedure :: restore => loop_archive_restore
<<Loop archive: procedures>>=
  subroutine loop_archive_restore (archive, olp_orig, path)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_orig, path
    type(string_t) :: olp_file, config_file, lib
    
    olp_file = archive%current_prefix // '.olp'
    config_file = archive%current_prefix // '_golem.in'
    lib = archive%current_prefix // '_libgolem_olp.so'

    call os_system_call ('cp ' // archive%name // '/' // olp_file // ' .')
    call os_system_call ('mv ' // olp_file // ' ' // olp_orig)
    
    call os_system_call ('cp ' // archive%name // '/' // config_file // ' .')
    call os_system_call ('mv ' // config_file // ' golem.in')

    call os_system_call ('cp ' // archive%name // '/' // lib // ' .')
    call os_system_call ('mv ' // lib // ' libgolem_olp.so')
    call os_system_call ('cp libgolem_olp.so ' // path)
    
  end subroutine loop_archive_restore

@ %def loop_archive_restore
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Event I/O}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this chapter we provide a generic handler for event I/O and the
various implementations: raw, HepMC, Les Houches, etc.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Sample Data}
We define a simple and transparent container for (meta)data that are
associated with an event sample.
<<[[eio_data.f90]]>>=
<<File header>>

module eio_data
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use events

<<EIO data: public>>

<<EIO data: types>>

contains
  
<<EIO data: procedures>>

<<EIO data: tests>>

end module eio_data
@ %def eio_data
@
\subsection{Event Sample Data}
These are data that apply to an event sample as a whole.  They are
given in an easily portable form (no fancy structure) and are used for
initializing event formats.

There are two MD5 sums here.  [[md5sum_proc]] depends only on the
definition of the contributing processes.  A sample with matching
checksum can be rescanned with modified model parameters, beam
structure etc, to recalculate observables.  [[md5sum_config]] includes
all relevant data.  Rescanning a sample with matching checksum will
produce identical observables.  (A third checksum might be added which
depends on the event sample itself.  This is not needed, so far.)

If alternate weights are part of the event sample ([[n_alt]] nonzero),
there is a configuration MD5 sum for each of them.
<<EIO data: public>>=
  public :: event_sample_data_t
<<EIO data: types>>=
  type :: event_sample_data_t
     character(32) :: md5sum_prc = ""
     character(32) :: md5sum_cfg = ""
     logical :: unweighted = .true.
     logical :: negative_weights = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: n_beam = 0
     integer, dimension(2) :: pdg_beam = 0
     real(default), dimension(2) :: energy_beam = 0
     integer :: n_proc = 0
     integer :: n_evt = 0
     integer :: split_n_evt = 0
     integer :: split_index = 0
     real(default) :: total_cross_section = 0
     integer, dimension(:), allocatable :: proc_num_id
     integer :: n_alt = 0
     character(32), dimension(:), allocatable :: md5sum_alt
     real(default), dimension(:), allocatable :: cross_section
     real(default), dimension(:), allocatable :: error
   contains
   <<EIO data: event sample data: TBP>>
  end type event_sample_data_t
  
@ %def event_sample_data_t
@ Initialize: allocate for the number of processes
<<EIO data: event sample data: TBP>>=
  procedure :: init => event_sample_data_init
<<EIO data: procedures>>=
  subroutine event_sample_data_init (data, n_proc, n_alt)
    class(event_sample_data_t), intent(out) :: data
    integer, intent(in) :: n_proc
    integer, intent(in), optional :: n_alt
    data%n_proc = n_proc
    allocate (data%proc_num_id (n_proc), source = 0)
    allocate (data%cross_section (n_proc), source = 0._default)
    allocate (data%error (n_proc), source = 0._default)
    if (present (n_alt)) then
       data%n_alt = n_alt
       allocate (data%md5sum_alt (n_alt))
       data%md5sum_alt = ""
    end if
  end subroutine event_sample_data_init
  
@ %def event_sample_data_init
@ Output.
<<EIO data: event sample data: TBP>>=
  procedure :: write => event_sample_data_write
<<EIO data: procedures>>=
  subroutine event_sample_data_write (data, unit)
    class(event_sample_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event sample properties:"
    write (u, "(3x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(3x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    write (u, "(3x,A,L1)")  "unweighted       = ", data%unweighted
    write (u, "(3x,A,L1)")  "negative weights = ", data%negative_weights
    write (u, "(3x,A,A)")   "normalization    = ", &
         char (event_normalization_string (data%norm_mode))
    write (u, "(3x,A,I0)")  "number of beams  = ", data%n_beam
    write (u, "(5x,A,2(1x,I19))")  "PDG    = ", &
         data%pdg_beam(:data%n_beam)
    write (u, "(5x,A,2(1x,ES19.12))")  "Energy = ", &
         data%energy_beam(:data%n_beam)
    if (data%n_evt > 0) then
       write (u, "(3x,A,I0)")  "number of events = ", data%n_evt
    end if
    if (data%total_cross_section /= 0) then
       write (u, "(3x,A,ES19.12)")  "total cross sec. = ", &
            data%total_cross_section
    end if
    write (u, "(3x,A,I0)")  "num of processes = ", data%n_proc
    do i = 1, data%n_proc
       write (u, "(3x,A,I0)")  "Process #", data%proc_num_id (i)
       select case (data%n_beam)
       case (1)
          write (u, "(5x,A,ES19.12)")  "Width = ", data%cross_section(i)
       case (2)
          write (u, "(5x,A,ES19.12)")  "CSec  = ", data%cross_section(i)
       end select
       write (u, "(5x,A,ES19.12)")  "Error = ", data%error(i)
    end do
    if (data%n_alt > 0) then
       write (u, "(3x,A,I0)")  "num of alt wgt   = ", data%n_alt
       do i = 1, data%n_alt
          write (u, "(5x,A,A,A,1x,I0)")  "MD5 sum (cfg)  = '", &
               data%md5sum_alt(i), "'", i
       end do
    end if
  end subroutine event_sample_data_write
    
@ %def event_sample_data_write
@
\subsection{Unit tests}
<<EIO data: public>>=
  public :: eio_data_test
<<EIO data: tests>>=
  subroutine eio_data_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO data: execute tests>>
  end subroutine eio_data_test
  
@ %def eio_data_test 
@
\subsubsection{Event Sample Data}
Print the contents of a sample data block.
<<EIO data: execute tests>>=
  call test (eio_data_1, "eio_data_1", &
       "event sample data", &
       u, results)
<<EIO data: tests>>=
  subroutine eio_data_1 (u)
    integer, intent(in) :: u
    type(event_sample_data_t) :: data

    write (u, "(A)")  "* Test output: eio_data_1"
    write (u, "(A)")  "*   Purpose:  display event sample data"
    write (u, "(A)")

    write (u, "(A)")  "* Decay process, one component"
    write (u, "(A)")
 
    call data%init (1, 1)
    data%n_beam = 1
    data%pdg_beam(1) = 25
    data%energy_beam(1) = 125

    data%norm_mode = NORM_UNIT
    
    data%proc_num_id = [42]
    data%cross_section = [1.23e-4_default]
    data%error = 5e-6_default
    
    data%md5sum_prc = "abcdefghijklmnopabcdefghijklmnop"
    data%md5sum_cfg = "12345678901234561234567890123456"
    data%md5sum_alt(1) = "uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu"
    
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Scattering process, two components"
    write (u, "(A)")
    
    call data%init (2)
    data%n_beam = 2
    data%pdg_beam = [2212, -2212]
    data%energy_beam = [8._default, 10._default]
    
    data%norm_mode = NORM_SIGMA
    
    data%proc_num_id = [12, 34]
    data%cross_section = [100._default, 88._default]
    data%error = [1._default, 0.1_default]
    
    call data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_data_1"
    
  end subroutine eio_data_1
  
@ %def eio_data_1
@
\subsubsection{Event Normalization}
Check the functions for translating modes and updating weights.
<<EIO data: execute tests>>=
  call test (eio_data_2, "eio_data_2", &
       "event normalization", &
       u, results)
<<EIO data: tests>>=
  subroutine eio_data_2 (u)
    integer, intent(in) :: u
    type(string_t) :: s
    logical :: unweighted
    real(default) :: w, sigma
    integer :: n

    write (u, "(A)")  "* Test output: eio_data_2"
    write (u, "(A)")  "*   Purpose:  handle event normalization"
    write (u, "(A)")

    write (u, "(A)")  "* Normalization strings"
    write (u, "(A)")

    s = "auto"
    unweighted = .true.
    write (u, "(1x,A,1x,L1,1x,A)")  char (s), unweighted, &
         char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "AUTO"
    unweighted = .false.
    write (u, "(1x,A,1x,L1,1x,A)")  char (s), unweighted, &
         char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))

    unweighted = .true.
    
    s = "1"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "1/n"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "Sigma"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "sigma/N"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))

    write (u, "(A)")
    write (u, "(A)")  "* Normalization update"
    write (u, "(A)")
    
    sigma = 5
    n = 2

    w0 = 1

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w

    write (u, *)
    
    w0 = 0.5

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, *)
    
    w0 = 5.0

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, *)
    
    w0 = 2.5

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_data_2"
    
  end subroutine eio_data_2
  
@ %def eio_data_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract I/O Handler}

This module defines an abstract object for event I/O and the
associated methods.  

There are [[output]] and [[input]] methods which
write or read a single event from/to the I/O stream, respectively.
The I/O stream itself may be a file, a common block, or an externally
linked structure, depending on the concrete implementation.

A [[write]] method prints the current content of the
implementation-dependent event record in human-readable form.

The [[init_in]]/[[init_out]] and [[final]] prepare
and finalize the I/O stream, respectively.  There is also a
[[switch_inout]] method which turns an input stream into an output
stream where events can be appended.

Optionally, output files can be split in chunks of well-defined size.  The
[[split_out]] method takes care of this.
<<[[eio_base.f90]]>>=
<<File header>>

module eio_base
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data

<<Standard module head>>

<<EIO base: public>>

<<EIO base: types>>

<<EIO base: interfaces>>

<<EIO base: test types>>

contains
  
<<EIO base: procedures>>

<<EIO base: tests>>

end module eio_base
@ %def eio_base
@
\subsection{Process pointer}
For handling multiple processes, we need an array of process pointers.  This
requires a wrapper:
<<EIO base: public>>=
  public :: process_ptr_t
<<EIO base: types>>=
  type :: process_ptr_t
     type(process_t), pointer :: ptr => null ()
  end type process_ptr_t
  
@ %def process_ptr_t
@
\subsection{Type}
We can assume that most implementations will need the file extension as a
fixed string and, if they support file splitting, the current file index.

The fallback model is useful for implementations that are able to read
unknown files which may contain hadrons etc., not in the current
hard-interaction model.
<<EIO base: public>>=
  public :: eio_t
<<EIO base: types>>=
  type, abstract :: eio_t
     type(string_t) :: sample
     type(string_t) :: extension
     type(string_t) :: filename
     logical :: split = .false.
     integer :: split_n_evt = 0
     integer :: split_index = 0
     type(model_t), pointer :: fallback_model => null ()
   contains
   <<EIO base: eio: TBP>>
  end type eio_t
  
@ %def eio_t
@ Write to screen.  If possible, this should display the contents of the
current event, i.e., the last one that was written or read.
<<EIO base: eio: TBP>>=
  procedure (eio_write), deferred :: write
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_write (object, unit)
       import
       class(eio_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine eio_write
  end interface
  
@ %def eio_write
@ Finalize.  This should write/read footer data and close input/output
channels.
<<EIO base: eio: TBP>>=
  procedure (eio_final), deferred :: final
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_final (object)
       import
       class(eio_t), intent(inout) :: object
     end subroutine eio_final
  end interface
  
@ %def eio_final
@ Determine splitting parameters from the event sample data.
<<EIO base: eio: TBP>>=
  procedure :: set_splitting => eio_set_splitting
<<EIO base: procedures>>=
  subroutine eio_set_splitting (eio, data)
    class(eio_t), intent(inout) :: eio
    type(event_sample_data_t), intent(in) :: data
    eio%split = data%split_n_evt > 0
    if (eio%split) then
       eio%split_n_evt = data%split_n_evt
       eio%split_index = data%split_index
    end if
  end subroutine eio_set_splitting
    
@ %def eio_set_splitting
@ Generate a filename, taking a possible split index into account.
<<EIO base: eio: TBP>>=
  procedure :: set_filename => eio_set_filename
<<EIO base: procedures>>=
  subroutine eio_set_filename (eio)
    class(eio_t), intent(inout) :: eio
    character(32) :: buffer
    if (eio%split) then
       write (buffer, "(I0,'.')")  eio%split_index
       eio%filename = eio%sample // "." // trim (buffer) // eio%extension
    else
       eio%filename = eio%sample // "." // eio%extension
    end if
  end subroutine eio_set_filename

@ %def eio_set_filename
@ Set the fallback model.
<<EIO base: eio: TBP>>=
  procedure :: set_fallback_model => eio_set_fallback_model
<<EIO base: procedures>>=
  subroutine eio_set_fallback_model (eio, model)
    class(eio_t), intent(inout) :: eio
    type(model_t), intent(in), target :: model
    eio%fallback_model => model
  end subroutine eio_set_fallback_model
  
@ %def eio_set_fallback_model
@ Initialize for output.  We provide process pointers.  This should
open an event file if appropriate and write header data.  Some methods
may require event sample data.
<<EIO base: eio: TBP>>=
  procedure (eio_init_out), deferred :: init_out
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_init_out &
          (eio, sample, process_ptr, data, success, extension)
       import
       class(eio_t), intent(inout) :: eio
       type(string_t), intent(in) :: sample
       type(string_t), intent(in), optional :: extension       
       type(process_ptr_t), dimension(:), intent(in) :: process_ptr
       type(event_sample_data_t), intent(in), optional :: data
       logical, intent(out), optional :: success
     end subroutine eio_init_out
  end interface

@ %def eio_init_out
@ Initialize for input.  We provide process names.  This should open an event
file if appropriate and read header data.  The [[md5sum]] can be used to check
the integrity of the configuration, it it provides a checksum to compare with.
In case the extension has changed the extension is also given as an argument.

The [[data]] argument is [[intent(inout)]]: we may read part of it and
keep other parts and/or check them against the data in the file.
<<EIO base: eio: TBP>>=
  procedure (eio_init_in), deferred :: init_in
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_init_in &
          (eio, sample, process_ptr, data, success, extension)
       import
       class(eio_t), intent(inout) :: eio
       type(string_t), intent(in) :: sample
       type(string_t), intent(in), optional :: extension
       type(process_ptr_t), dimension(:), intent(in) :: process_ptr
       type(event_sample_data_t), intent(inout), optional :: data
       logical, intent(out), optional :: success
     end subroutine eio_init_in
  end interface

@ %def eio_init_in
@ Re-initialize for output.  This should change the status of any event file
from input to output and position it for appending new events.
<<EIO base: eio: TBP>>=
  procedure (eio_switch_inout), deferred :: switch_inout
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_switch_inout (eio, success)
       import
       class(eio_t), intent(inout) :: eio
       logical, intent(out), optional :: success
     end subroutine eio_switch_inout
  end interface

@ %def eio_switch_inout
@ This is similar: split the output, i.e., close the current file and open a
new one.  The default implementation does nothing.  For the feature to work,
an implementation must override this.
<<EIO base: eio: TBP>>=
  procedure :: split_out => eio_split_out
<<EIO base: procedures>>=
  subroutine eio_split_out (eio)
    class(eio_t), intent(inout) :: eio
  end subroutine eio_split_out

@ %def eio_split_out
@ 
@ Output an event.  All data can be taken from the [[event]] record.
The index [[i_prc]] identifies the process among the processes that
are contained in the current sample.  The [[reading]] flag, if present,
indicates that the event was read from file, not generated.
<<EIO base: eio: TBP>>=
  procedure (eio_output), deferred :: output
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_output (eio, event, i_prc, reading)
       import
       class(eio_t), intent(inout) :: eio
       type(event_t), intent(in), target :: event
       integer, intent(in) :: i_prc
       logical, intent(in), optional :: reading
     end subroutine eio_output
  end interface
  
@ %def eio_output
@ Input an event.  This should fill all event data that cannot be inferred
from the associated process.

The input is broken down into two parts.  First we read the [[i_prc]]
index.  So we know which process to expect in the subsequent event.
If we have reached end of file, we also will know.
Then, we read the event itself.

The parameter [[iostat]] is supposed to be set as the Fortran standard
requires, negative for EOF and positive for error.
<<EIO base: eio: TBP>>=
  procedure (eio_input_i_prc), deferred :: input_i_prc
  procedure (eio_input_event), deferred :: input_event
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_input_i_prc (eio, i_prc, iostat)
       import
       class(eio_t), intent(inout) :: eio
       integer, intent(out) :: i_prc
       integer, intent(out) :: iostat
     end subroutine eio_input_i_prc
  end interface
  
  abstract interface
     subroutine eio_input_event (eio, event, iostat)
       import
       class(eio_t), intent(inout) :: eio
       type(event_t), intent(inout), target :: event
       integer, intent(out) :: iostat
     end subroutine eio_input_event
  end interface
  
@ %def eio_input
@
\subsection{Unit tests}
<<EIO base: public>>=
  public :: eio_base_test
<<EIO base: tests>>=
  subroutine eio_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO base: execute tests>>
  end subroutine eio_base_test
  
@ %def eio_base_test 
@ 
\subsubsection{Test type for event I/O}
The contents simulate the contents of an external file.  We have the
[[sample]] string as the file name, [[sqrts]] and the array of [[process_id]]s
as metadata, and the array of momenta [[event_p]] as the list of events.  The
second index is the event index.  The [[event_i]] component is the pointer
to the current event, [[event_n]] is the total number of stored events.
<<EIO base: test types>>=
  type, extends (eio_t) :: eio_test_t
     real(default) :: sqrts
     type(string_t) :: process_id
     integer :: event_n = 0
     integer :: event_i = 0
     integer :: i_prc = 0
     type(vector4_t), dimension(:,:), allocatable :: event_p
   contains
   <<EIO base: eio test: TBP>>
  end type eio_test_t

@ %def eio_test_t
@ Write to screen.  Pretend that this is an actual event format.
<<EIO base: eio test: TBP>>=
  procedure :: write => eio_test_write
<<EIO base: procedures>>=
  subroutine eio_test_write (object, unit)
    class(eio_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Test event stream"
    write (u, "(3x,A,A,A)")  "Process ID  = '", char (object%process_id), "'"
    write (u, "(3x,A,ES19.12)")  "sqrts       = ", object%sqrts
    if (object%event_i /= 0) then
       write (u, "(1x,A,I0,A)")  "Event #", object%event_i, ":"
       do i = 1, size (object%event_p, 1)
          call vector4_write (object%event_p(i, object%event_i), u)
       end do
    end if
  end subroutine eio_test_write
    
@ %def eio_test_write
@ Finalizer.  For the test case, we just reset the event count,
but keep the stored ``events''.  For the real implementations, the events
would be stored on an external medium, so we would delete the object
contents.
<<EIO base: eio test: TBP>>=
  procedure :: final => eio_test_final
<<EIO base: procedures>>=
  subroutine eio_test_final (object)
    class(eio_test_t), intent(inout) :: object
    object%event_i = 0
  end subroutine eio_test_final
    
@ %def eio_test_final
@ Initialization: We store the process IDs and the energy from the beam-data
object.  We also allocate the momenta (i.e., the simulated event record) for a
fixed maximum size of 10 events, 2 momenta each.  There is only a single
process.
<<EIO base: eio test: TBP>>=
  procedure :: init_out => eio_test_init_out
<<EIO base: procedures>>=
  subroutine eio_test_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_test_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    type(beam_data_t), pointer :: beam_data
    eio%sample = sample
    eio%process_id = process_ptr(1)%ptr%get_id ()
    beam_data => process_ptr(1)%ptr%get_beam_data_ptr ()
    eio%sqrts = beam_data_get_sqrts (beam_data)
    eio%event_n = 0
    eio%event_i = 0
    allocate (eio%event_p (2, 10))
    if (present (success))  success = .true.
  end subroutine eio_test_init_out
  
@ %def eio_test_init_out
@ Initialization for input.  Nothing to do for the test type.
<<EIO base: eio test: TBP>>=
  procedure :: init_in => eio_test_init_in
<<EIO base: procedures>>=
  subroutine eio_test_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_test_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    if (present (success))  success = .true.
  end subroutine eio_test_init_in
  
@ %def eio_test_init_in
@ Switch from output to input.  Again, nothing to do for the test type.
<<EIO base: eio test: TBP>>=
  procedure :: switch_inout => eio_test_switch_inout
<<EIO base: procedures>>=
  subroutine eio_test_switch_inout (eio, success)
    class(eio_test_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    if (present (success))  success = .true.
  end subroutine eio_test_switch_inout
  
@ %def eio_test_switch_inout
@ Output.  Increment the event counter and store the momenta of the current
event.
<<EIO base: eio test: TBP>>=
  procedure :: output => eio_test_output
<<EIO base: procedures>>=
  subroutine eio_test_output (eio, event, i_prc, reading)
    class(eio_test_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    logical, intent(in), optional :: reading
    integer, intent(in) :: i_prc
    type(particle_set_t), pointer :: pset
    type(particle_t) :: prt
    eio%event_n = eio%event_n + 1
    eio%event_i = eio%event_n
    eio%i_prc = i_prc
    pset => event%get_particle_set_ptr ()
    prt = particle_set_get_particle (pset, 3)
    eio%event_p(1, eio%event_i) = particle_get_momentum (prt)
    prt = particle_set_get_particle (pset, 4)
    eio%event_p(2, eio%event_i) = particle_get_momentum (prt)
  end subroutine eio_test_output

@ %def eio_test_output
@ Input.  Increment the event counter and retrieve the momenta of the current
event.  For the test case, we do not actually modify the current event.
<<EIO base: eio test: TBP>>=
  procedure :: input_i_prc => eio_test_input_i_prc
  procedure :: input_event => eio_test_input_event
<<EIO base: procedures>>=
  subroutine eio_test_input_i_prc (eio, i_prc, iostat)
    class(eio_test_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    i_prc = eio%i_prc
    iostat = 0
  end subroutine eio_test_input_i_prc

  subroutine eio_test_input_event (eio, event, iostat)
    class(eio_test_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    eio%event_i = eio%event_i + 1
    iostat = 0
  end subroutine eio_test_input_event

@ %def eio_test_input_i_prc
@ %def eio_test_input_event
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods using the [[eio_test_t]] type.
<<EIO base: execute tests>>=
  call test (eio_base_1, "eio_base_1", &
       "read and write event contents", &
       u, results)
<<EIO base: tests>>=
  subroutine eio_base_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    integer :: i_prc,  iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_base_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_test1"
 
    allocate (eio_test_t :: eio)
    
    call eio%init_out (sample, [process_ptr])
    call event%generate (1, [0._default, 0._default])
    call eio%output (event, 42)
    call eio%write (u)
    call eio%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample, [process_ptr])
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%write (u)
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i = ", i_prc
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")
    
    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call eio%output (event, 5)
    call eio%write (u)
    call eio%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")
    
    call eio%init_in (sample, [process_ptr])
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%write (u)
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i = ", i_prc
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_base_1"
    
  end subroutine eio_base_1
  
@ %def eio_base_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Raw Event I/O}
The raw format is for internal use only.  All data are stored
unformatted, so they can be efficiently be re-read on the same
machine, but not necessarily on another machine.
<<[[eio_raw.f90]]>>=
<<File header>>

module eio_raw
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use variables
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO raw: public>>

<<EIO raw: types>>

contains
  
<<EIO raw: procedures>>

<<EIO raw: tests>>

end module eio_raw
@ %def eio_raw
@
\subsection{Type}
<<EIO raw: public>>=
  public :: eio_raw_t
<<EIO raw: types>>=
  type, extends (eio_t) :: eio_raw_t
     logical :: reading = .false.
     logical :: writing = .false.
     integer :: unit = 0
     integer :: norm_mode = NORM_UNDEFINED
     real(default) :: sigma = 1
     integer :: n = 1
     integer :: n_alt = 0
     logical :: check = .false.
   contains
   <<EIO raw: eio raw: TBP>>
  end type eio_raw_t
  
@ %def eio_raw_t
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO raw: eio raw: TBP>>=
  procedure :: write => eio_raw_write
<<EIO raw: procedures>>=
  subroutine eio_raw_write (object, unit)
    class(eio_raw_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Raw event stream:"
    write (u, "(3x,A,L1)")  "Check MD5 sum     = ", object%check
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alternate weights = ", object%n_alt
    end if
    if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_raw_write
  
@ %def eio_raw_write
@ Finalizer: close any open file.
<<EIO raw: eio raw: TBP>>=
  procedure :: final => eio_raw_final
<<EIO raw: procedures>>=
  subroutine eio_raw_final (object)
    class(eio_raw_t), intent(inout) :: object
    if (object%reading .or. object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing raw file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%reading = .false.
       object%writing = .false.
    end if
  end subroutine eio_raw_final
  
@ %def eio_raw_final
@ Set the [[check]] flag which determines whether we compare checksums on input.
<<EIO raw: eio raw: TBP>>=
  procedure :: set_parameters => eio_raw_set_parameters
<<EIO raw: procedures>>=
  subroutine eio_raw_set_parameters (eio, check, extension)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(in) :: check
    type(string_t), intent(in), optional :: extension 
    eio%check = check
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
  end subroutine eio_raw_set_parameters
    
@ %def eio_raw_set_parameters
@ Initialize event writing.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_out => eio_raw_init_out
<<EIO raw: procedures>>=
  subroutine eio_raw_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i
    if (present (extension)) then
       eio%extension  = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    if (present (data)) then
       md5sum_prc = data%md5sum_prc
       md5sum_cfg = data%md5sum_cfg
       eio%norm_mode = data%norm_mode
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
       eio%n_alt = data%n_alt
       if (eio%n_alt > 0) then
          allocate (md5sum_alt (data%n_alt), source = data%md5sum_alt)
       end if
    else
       md5sum_prc = ""
       md5sum_cfg = ""
    end if
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", status = "replace")
    write (eio%unit)  md5sum_prc
    write (eio%unit)  md5sum_cfg
    write (eio%unit)  eio%norm_mode
    write (eio%unit)  eio%n_alt
    do i = 1, eio%n_alt
       write (eio%unit)  md5sum_alt(i)
    end do
    if (present (success))  success = .true.
  end subroutine eio_raw_init_out
    
@ %def eio_raw_init_out
@ Initialize event reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_in => eio_raw_init_in
<<EIO raw: procedures>>=
  subroutine eio_raw_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i
    if (present (success))  success = .true.
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    if (present (data)) then
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
    end if
    write (msg_buffer, "(A,A,A)")  "Events: reading from raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%reading = .true.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "read", status = "old")
    read (eio%unit)  md5sum_prc
    read (eio%unit)  md5sum_cfg
    read (eio%unit)  eio%norm_mode
    read (eio%unit)  eio%n_alt
    if (present (data)) then
       if (eio%n_alt /= data%n_alt) then
          if (present (success))  success = .false. !
          return
       end if
    end if
    allocate (md5sum_alt (eio%n_alt))
    do i = 1, eio%n_alt
       read (eio%unit)  md5sum_alt(i)
    end do
    if (present (success)) then
       if (present (data)) then
          if (eio%check) then
             if (data%md5sum_prc /= "") then
                success = success .and. md5sum_prc == data%md5sum_prc
             end if
             if (data%md5sum_cfg /= "") then
                success = success .and. md5sum_cfg == data%md5sum_cfg
             end if
             do i = 1, eio%n_alt
                if (data%md5sum_alt(i) /= "") then
                   success = success .and. md5sum_alt(i) == data%md5sum_alt(i)
                end if
             end do
          else
             call msg_warning ("Reading event file: MD5 sum check disabled")
          end if
       end if
    end if
  end subroutine eio_raw_init_in
    
@ %def eio_raw_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: switch_inout => eio_raw_switch_inout
<<EIO raw: procedures>>=
  subroutine eio_raw_switch_inout (eio, success)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    write (msg_buffer, "(A,A,A)")  "Events: appending to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    close (eio%unit, status = "keep")
    eio%reading = .false.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", position = "append", status = "old")
    eio%writing = .true.
    if (present (success))  success = .true.
  end subroutine eio_raw_switch_inout
  
@ %def eio_raw_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.

We always write the particle set of the hard process.  (Note: this
should be reconsidered.)  We do make a physical copy.

On output, we write the [[prc]] values for weight and sqme, since
these are the values just computed.  On input, we store the values as
[[ref]] values.  The caller can then decide whether to recompute
values and thus obtain distinct [[prc]] values, or just accept them.
<<EIO raw: eio raw: TBP>>=
  procedure :: output => eio_raw_output
<<EIO raw: procedures>>=
  subroutine eio_raw_output (eio, event, i_prc, reading)
    class(eio_raw_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    logical, intent(in), optional :: reading
    integer, intent(in) :: i_prc
    type(particle_set_t) :: pset
    integer :: i
    if (eio%writing) then
       if (event%has_particle_set ()) then
          write (eio%unit)  i_prc
          write (eio%unit)  event%get_i_mci ()
          write (eio%unit)  event%get_i_term ()
          write (eio%unit)  event%get_channel ()
          write (eio%unit)  event%expr%weight_prc
          write (eio%unit)  event%expr%excess_prc
          write (eio%unit)  event%expr%sqme_prc
          do i = 1, eio%n_alt
             write (eio%unit)  event%expr%weight_alt(i)
             write (eio%unit)  event%expr%sqme_alt(i)
          end do
          call event%get_particle_set_hard_proc (pset)
          call particle_set_write_raw (pset, eio%unit)
          call particle_set_final (pset)
       else
          call msg_bug ("Event: write raw: particle set is undefined")
       end if
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for writing")
    end if
  end subroutine eio_raw_output

@ %def eio_raw_output
@ Input an event.

Note: the particle set is physically copied.  If there is a
performance issue, we might choose to pointer-assign it instead, with
a different version of [[event%set_particle_set_hard_proc]].
<<EIO raw: eio raw: TBP>>=
  procedure :: input_i_prc => eio_raw_input_i_prc
  procedure :: input_event => eio_raw_input_event
<<EIO raw: procedures>>=
  subroutine eio_raw_input_i_prc (eio, i_prc, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)  i_prc
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_i_prc

  subroutine eio_raw_input_event (eio, event, iostat)
    class(eio_raw_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    integer :: i_mci, i_term, channel, i
    real(default) :: weight, excess, sqme
    real(default), dimension(:), allocatable :: weight_alt, sqme_alt
    type(particle_set_t) :: pset
    if (eio%reading) then
       read (eio%unit, iostat = iostat)  i_mci
       if (iostat /= 0)  return
       read (eio%unit, iostat = iostat)  i_term
       if (iostat /= 0)  return
       read (eio%unit, iostat = iostat)  channel
       if (iostat /= 0)  return
       read (eio%unit, iostat = iostat)  weight
       if (iostat /= 0)  return
       read (eio%unit, iostat = iostat)  excess
       if (iostat /= 0)  return
       read (eio%unit, iostat = iostat)  sqme
       if (iostat /= 0)  return
       call event%reset ()
       call event%select (i_mci, i_term, channel)
       if (eio%norm_mode /= NORM_UNDEFINED) then
          call event_normalization_update (weight, &
               eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
          call event_normalization_update (excess, &
               eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
       end if
       call event%set (sqme_ref = sqme, weight_ref = weight, &
            excess_prc = excess)
       if (eio%n_alt /= 0) then
          allocate (sqme_alt (eio%n_alt), weight_alt (eio%n_alt))
          do i = 1, eio%n_alt
             read (eio%unit, iostat = iostat)  weight_alt(i)
             if (iostat /= 0)  return
             read (eio%unit, iostat = iostat)  sqme_alt(i)
             if (iostat /= 0)  return
          end do
          call event%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
       end if
       call particle_set_read_raw (pset, eio%unit, iostat)
       if (iostat /= 0)  return
       if (associated (event%process)) then
          call particle_set_set_model (pset, event%process%get_model_ptr ())
       end if
       call event%set_particle_set_hard_proc (pset)
       call particle_set_final (pset)
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_event

@ %def eio_raw_input_i_prc
@ %def eio_raw_input_event
@
\subsection{Unit tests}
<<EIO raw: public>>=
  public :: eio_raw_test
<<EIO raw: tests>>=
  subroutine eio_raw_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO raw: execute tests>>
  end subroutine eio_raw_test
  
@ %def eio_raw_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_1, "eio_raw_1", &
       "read and write event contents", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_1"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample, [process_ptr])
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample, [process_ptr])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")
    
    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 5)
    call eio%write (u)
    call eio%final ()
    
    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")
    
    call eio%init_in (sample, [process_ptr])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/1):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/1):", iostat
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/2):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/2):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_1"
    
  end subroutine eio_raw_1
  
@ %def eio_raw_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_2, "eio_raw_2", &
       "handle multiple weights", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(var_list_t) :: var_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_2"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")  "*            with multiple weights"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    call data%init (n_proc = 1, n_alt = 2)

    call var_list_append_log (var_list, var_str ("?unweighted"), .false., &
         intrinsic = .true.)
    call var_list_append_string (var_list, var_str ("$sample_normalization"), &
         var_str ("auto"), intrinsic = .true.)
    call var_list_append_real (var_list, var_str ("safety_factor"), &
         1._default, intrinsic = .true.)

    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_2"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = [2 * event%weight_ref, 3 * event%weight_ref])
    call event%store_alt_values ()
    call event%check ()

    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample, [process_ptr], data)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_2"
    
  end subroutine eio_raw_2
  
@ %def eio_raw_2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Event Generation Checkpoints}
This is an output-only format.  Its only use is to write screen
messages every $n$ events, to inform the user about progress.
<<[[eio_checkpoints.f90]]>>=
<<File header>>

module eio_checkpoints
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use cputime
  use models
  use processes
  use events
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO checkpoints: public>>

<<EIO checkpoints: parameters>>

<<EIO checkpoints: types>>

contains
  
<<EIO checkpoints: procedures>>

<<EIO checkpoints: tests>>

end module eio_checkpoints
@ %def eio_checkpoints
@
\subsection{Type}
<<EIO checkpoints: public>>=
  public :: eio_checkpoints_t
<<EIO checkpoints: types>>=
  type, extends (eio_t) :: eio_checkpoints_t
     logical :: active = .false.
     logical :: running = .false.
     integer :: val = 0
     integer :: n_events = 0
     integer :: n_read = 0
     integer :: i_evt = 0
     logical :: blank = .false.
     type(timer_t) :: timer
   contains
   <<EIO checkpoints: eio checkpoints: TBP>>
  end type eio_checkpoints_t
  
@ %def eio_checkpoints_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LHEF.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: set_parameters => eio_checkpoints_set_parameters
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_set_parameters (eio, checkpoint, blank)
    class(eio_checkpoints_t), intent(inout) :: eio
    integer, intent(in) :: checkpoint
    logical, intent(in), optional :: blank
    eio%val = checkpoint
    if (present (blank))  eio%blank = blank
  end subroutine eio_checkpoints_set_parameters
  
@ %def eio_checkpoints_set_parameters
@ 
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current status.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: write => eio_checkpoints_write
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_write (object, unit)
    class(eio_checkpoints_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%active) then
       write (u, "(1x,A)")  "Event-sample checkpoints:  active"
       write (u, "(3x,A,I0)")  "interval  = ", object%val
       write (u, "(3x,A,I0)")  "n_events  = ", object%n_events
       write (u, "(3x,A,I0)")  "n_read    = ", object%n_read
       write (u, "(3x,A,I0)")  "n_current = ", object%i_evt
       write (u, "(3x,A,L1)")  "blanking  = ", object%blank
       call object%timer%write (u)
    else
       write (u, "(1x,A)")  "Event-sample checkpoints:  off"
    end if
  end subroutine eio_checkpoints_write
  
@ %def eio_checkpoints_write
@ Finalizer: trivial.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: final => eio_checkpoints_final
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_final (object)
    class(eio_checkpoints_t), intent(inout) :: object
    object%active = .false.
  end subroutine eio_checkpoints_final
  
@ %def eio_checkpoints_final
@ Activate checkpointing for event generation or writing.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: init_out => eio_checkpoints_init_out
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    if (present (data)) then
       if (eio%val > 0) then
          eio%active = .true.
          eio%i_evt = 0
          eio%n_read = 0
          eio%n_events = data%n_evt
       end if
    end if
    if (present (success))  success = .true.
  end subroutine eio_checkpoints_init_out
    
@ %def eio_checkpoints_init_out
@ No checkpointing for event reading.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: init_in => eio_checkpoints_init_in
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("Event checkpoints: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_checkpoints_init_in
    
@ %def eio_checkpoints_init_in
@ Switch from input to output: also not supported.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: switch_inout => eio_checkpoints_switch_inout
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_switch_inout (eio, success)
    class(eio_checkpoints_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("Event checkpoints: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_checkpoints_switch_inout
  
@ %def eio_checkpoints_switch_inout
@ Checkpoints: display progress for the current event, if applicable.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: output => eio_checkpoints_output
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_output (eio, event, i_prc, reading)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    logical :: rd
    rd = .false.;  if (present (reading))  rd = reading
    if (eio%active) then
       if (.not. eio%running)  call eio%startup ()
       if (eio%running) then
          eio%i_evt = eio%i_evt + 1
          if (rd) then
             eio%n_read = eio%n_read + 1
          else if (mod (eio%i_evt, eio%val) == 0) then
             call eio%message (eio%blank)
          end if
          if (eio%i_evt == eio%n_events)  call eio%shutdown ()
       end if
    end if
  end subroutine eio_checkpoints_output

@ %def eio_checkpoints_output
@ When the first event is called, we have to initialize the screen output.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: startup => eio_checkpoints_startup
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_startup (eio)
    class(eio_checkpoints_t), intent(inout) :: eio
    if (eio%active .and. eio%i_evt < eio%n_events) then
       call msg_message ("")
       call msg_message (checkpoint_bar)
       call msg_message (checkpoint_head)
       call msg_message (checkpoint_bar)
       write (msg_buffer, checkpoint_fmt) 0., 0, eio%n_events - eio%i_evt, "???"
       call msg_message ()
       eio%running = .true.
       call eio%timer%start ()
    end if
  end subroutine eio_checkpoints_startup
  
@ %def eio_checkpoints_startup
@ This message is printed at every checkpoint.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: message => eio_checkpoints_message
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_message (eio, testflag)
    class(eio_checkpoints_t), intent(inout) :: eio
    logical, intent(in), optional :: testflag
    real :: t
    type(time_t) :: time_remaining
    type(string_t) :: time_string
    call eio%timer%stop ()
    t = eio%timer
    call eio%timer%restart ()
    time_remaining = &
         nint (t / (eio%i_evt - eio%n_read) * (eio%n_events - eio%i_evt))
    time_string = time_remaining%to_string_ms (blank = testflag)
    write (msg_buffer, checkpoint_fmt) &
         100 * (eio%i_evt - eio%n_read) / real (eio%n_events - eio%n_read), &
         eio%i_evt - eio%n_read, &
         eio%n_events - eio%i_evt, &
         char (time_string)
    call msg_message ()
  end subroutine eio_checkpoints_message

@ %def eio_checkpoints_message
@ When the last event is called, wrap up.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: shutdown => eio_checkpoints_shutdown
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_shutdown (eio)
    class(eio_checkpoints_t), intent(inout) :: eio
    if (mod (eio%i_evt, eio%val) /= 0) then
       write (msg_buffer, checkpoint_fmt) &
            100., eio%i_evt - eio%n_read, 0, "0m:00s"
       call msg_message ()
    end if
    call msg_message (checkpoint_bar)
    call msg_message ("")
    eio%running = .false.
  end subroutine eio_checkpoints_shutdown

@ %def eio_checkpoints_shutdown
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: input_i_prc => eio_checkpoints_input_i_prc
  procedure :: input_event => eio_checkpoints_input_event
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_input_i_prc (eio, i_prc, iostat)
    class(eio_checkpoints_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("Event checkpoints: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_checkpoints_input_i_prc

  subroutine eio_checkpoints_input_event (eio, event, iostat)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("Event checkpoints: event input not supported")
    iostat = 1
  end subroutine eio_checkpoints_input_event

@ %def eio_checkpoints_input_i_prc
@ %def eio_checkpoints_input_event
@
\subsection{Message header}
<<EIO checkpoints: parameters>>=
  character(*), parameter :: &
     checkpoint_head = "| % complete | events generated | events remaining &
     &| time remaining"
  character(*), parameter :: &
     checkpoint_bar  = "|==================================================&
     &=================|"
  character(*), parameter :: &
     checkpoint_fmt  = "('   ',F5.1,T16,I9,T35,I9,T58,A)"
@ %def checkpoint_head
@ %def checkpoint_bar
@ %def checkpoint_fmt
@ %def checkpointing_t
@
\subsection{Unit tests}
<<EIO checkpoints: public>>=
  public :: eio_checkpoints_test
<<EIO checkpoints: tests>>=
  subroutine eio_checkpoints_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO checkpoints: execute tests>>
  end subroutine eio_checkpoints_test
  
@ %def eio_checkpoints_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO checkpoints: execute tests>>=
  call test (eio_checkpoints_1, "eio_checkpoints_1", &
       "read and write event contents", &
       u, results)
<<EIO checkpoints: tests>>=
  subroutine eio_checkpoints_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    type(event_sample_data_t) :: data
    type(string_t) :: sample
    integer :: i, n_events

    write (u, "(A)")  "* Test output: eio_checkpoints_1"
    write (u, "(A)")  "*   Purpose: generate a number of events &
         &with screen output"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate events"
    write (u, "(A)")
 
    sample = "eio_checkpoints_1"
 
    allocate (eio_checkpoints_t :: eio)

    n_events = 10
    call data%init (1, 0)
    data%n_evt = n_events

    select type (eio)
    type is (eio_checkpoints_t)
       call eio%set_parameters (checkpoint = 4)
    end select

    call eio%init_out (sample, [process_ptr], data)

    do i = 1, n_events
       call event%generate (1, [0._default, 0._default])
       call eio%output (event, i_prc = 0)
    end do
    
    write (u, "(A)")  "* Checkpointing status"
    write (u, "(A)")

    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_checkpoints_1"
    
  end subroutine eio_checkpoints_1
  
@ %def eio_checkpoints_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HEP Common Blocks}

Long ago, to transfer data between programs one had to set up a common
block and link both programs as libraries to the main executable.  The
HEP community standardizes several of those common blocks.

The modern way of data exchange uses data files with standard
formats.  However, the LHEF standard data format derives from a common
block (actually, two).

\whizard\ used to support those common blocks, and LHEF was
implemented via writing/reading blocks.  We still keep this
convention, but intend to eliminate common blocks (or any other static
storage) from the workflow in the future.  This will gain flexibility
towards concurrent running of program images.

We encapsulate everything here in a module.  The module holds the
variables which are part of the common block.

Note: This code is taken essentially unchanged from \whizard\ 2.1 and
does not (yet) provide unit tests.
<<[[hep_common.f90]]>>=
<<File header>>

module hep_common
  
  use kinds
  use io_units
<<Use strings>>
  use diagnostics
  use physics_defs, only: HADRON_REMNANT
  use physics_defs, only: HADRON_REMNANT_SINGLET
  use physics_defs, only: HADRON_REMNANT_TRIPLET
  use physics_defs, only: HADRON_REMNANT_OCTET
  use lorentz
  use flavors
  use colors
  use polarizations
  use models
  use particles
  use subevents
  use processes

<<Standard module head>>

<<HEP common: public>>

<<HEP common: interfaces>>

<<HEP common: parameters>>

<<HEP common: variables>>

<<HEP common: common blocks>>

contains
  
<<HEP common: procedures>>

end module hep_common
@ %def hep_common
@
\subsection{Event characteristics}
The maximal number of particles in an event record.
<<HEP common: parameters>>=
  integer, parameter :: MAXNUP = 500
@ %def MAXNUP
@ The number of particles in this event.
<<HEP common: variables>>=
  integer :: NUP
@ %def NUP
@ The process ID for this event.
<<HEP common: variables>>=
  integer :: IDPRUP
@ %def IDPRUP
@ The weight of this event ($\pm 1$ for unweighted events).
<<HEP common: variables>>=
  double precision :: XWGTUP
@ %def XWGTUP
@ The factorization scale that is used for PDF calculation ($-1$ if
undefined).
<<HEP common: variables>>=
  double precision :: SCALUP
@ %def SCALUP
@ The QED and QCD couplings $\alpha$ used for this event ($-1$ if
undefined).
<<HEP common: variables>>=
  double precision :: AQEDUP
  double precision :: AQCDUP
@ %def AQEDUP AQCDUP
@ 

\subsection{Particle characteristics}
The PDG code:
<<HEP common: variables>>=
  integer, dimension(MAXNUP) :: IDUP
@ %def IDUP
@ The status code.  Incoming: $-1$, outgoing: $+1$.  Intermediate
t-channel propagator: $-2$ (currently not used by WHIZARD).
Intermediate resonance whose mass should be preserved: $2$.
Intermediate resonance for documentation: $3$ (currently not used).
Beam particles: $-9$.
<<HEP common: variables>>=
  integer, dimension(MAXNUP) :: ISTUP
@ %def ISTUP
@ Index of first and last mother.
<<HEP common: variables>>=
  integer, dimension(2,MAXNUP) :: MOTHUP
@ %def MOTHUP
@ Color line index of the color and anticolor entry for the particle.
The standard recommends using large numbers; we start from MAXNUP+1. 
<<HEP common: variables>>=
  integer, dimension(2,MAXNUP) :: ICOLUP
@ %def ICOLUP
@ Momentum, energy, and invariant mass: $(p_x,p_y,p_z,E,M)$.  For
space-like particles, $M$ is the negative square root of the absolute
value of the invariant mass.
<<HEP common: variables>>=
  double precision, dimension(5,MAXNUP) :: PUP
@ %def PUP
@ Invariant lifetime (distance) from production to decay in mm.
<<HEP common: variables>>=
  double precision, dimension(MAXNUP) :: VTIMUP
@ %def VTIMUP
@ Cosine of the angle between the spin-vector and a particle and the
3-momentum of its mother, given in the lab frame.  If
undefined/unpolarized: $9$.
<<HEP common: variables>>=
  double precision, dimension(MAXNUP) :: SPINUP
@ %def SPINUP
@ 
\subsection{The HEPRUP common block}
This common block is filled once per run.

\subsubsection{Run characteristics}
The maximal number of different processes.
<<HEP common: parameters>>=
  integer, parameter :: MAXPUP = 100
@ %def MAXPUP
@ The beam PDG codes.
<<HEP common: variables>>=
  integer, dimension(2) :: IDBMUP
@ %def IDBMUP
@ The beam energies in GeV.
<<HEP common: variables>>=
  double precision, dimension(2) :: EBMUP
@ %def EBMUP
@ The PDF group and set for the two beams.  (Undefined: use $-1$;
LHAPDF: use group = $0$).
<<HEP common: variables>>=
  integer, dimension(2) :: PDFGUP
  integer, dimension(2) :: PDFSUP
@ %def PDFGUP PDFSUP
@ The (re)weighting model.  1: events are weighted, the shower
generator (SHG) selects processes according to the maximum weight (in
pb) and unweights events.  2: events are weighted, the SHG selects
processes according to their cross section (in pb) and unweights
events.  3: events are unweighted and simply run through the SHG.  4:
events are weighted, and the SHG keeps the weight.  Negative numbers:
negative weights are allowed (and are reweighted to $\pm 1$ by the
SHG, if allowed).

\whizard\ only supports modes 3 and 4, as the SHG is not given control
over process selection.  This is consistent with writing events to
file, for offline showering.
<<HEP common: variables>>=
  integer :: IDWTUP
@ %def IDWTUP
@ The number of different processes.
<<HEP common: variables>>=
  integer :: NPRUP
@ %def NPRUP
@
\subsubsection{Process characteristics}
Cross section and error in pb.  (Cross section is needed only for
$[[IDWTUP]] = 2$, so here both values are given for informational
purposes only.)
<<HEP common: variables>>=
  double precision, dimension(MAXPUP) :: XSECUP
  double precision, dimension(MAXPUP) :: XERRUP
@ %def XSECUP XERRUP
@ Maximum weight, i.e., the maximum value that [[XWGTUP]] can take.
Also unused for the supported weighting models. It is $\pm 1$ for
unweighted events.
<<HEP common: variables>>=
  double precision, dimension(MAXPUP) :: XMAXUP
@ %def XMAXUP
@ Internal ID of the selected process, matches [[IDPRUP]] below.
<<HEP common: variables>>=
  integer, dimension(MAXPUP) :: LPRUP
@ %def LPRUP
@
\subsubsection{The common block}
<<HEP common: common blocks>>=
  common /HEPRUP/ &
       IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP, &
       XSECUP, XERRUP, XMAXUP, LPRUP
  save /HEPRUP/

@ %def HEPRUP
@ Fill the run characteristics of the common block.  The
initialization sets the beam properties, number of processes, and
weighting model.
<<HEP common: public>>=
  public :: heprup_init
<<HEP common: procedures>>=
  subroutine heprup_init &
       (beam_pdg, beam_energy, n_processes, unweighted, negative_weights)
    integer, dimension(2), intent(in) :: beam_pdg
    real(default), dimension(2), intent(in) :: beam_energy
    integer, intent(in) :: n_processes
    logical, intent(in) :: unweighted
    logical, intent(in) :: negative_weights
    IDBMUP = beam_pdg
    EBMUP = beam_energy
    PDFGUP = -1
    PDFSUP = -1
    if (unweighted) then
       IDWTUP = 3
    else
       IDWTUP = 4
    end if
    if (negative_weights)  IDWTUP = - IDWTUP
    NPRUP = n_processes
  end subroutine heprup_init

@ %def heprup_init
@ Extract parameters from the common block.  We leave it to the caller
to specify which parameters it actually needs.

[[PDFGUP]] and [[PDFSUP]] are not extracted.  [[IDWTUP=1,2]] are not
supported by \whizard, but correspond to weighted events.
<<HEP common: public>>=
  public :: heprup_get_run_parameters
<<HEP common: procedures>>=
  subroutine heprup_get_run_parameters &
       (beam_pdg, beam_energy, n_processes, unweighted, negative_weights)
    integer, dimension(2), intent(out), optional :: beam_pdg
    real(default), dimension(2), intent(out), optional :: beam_energy
    integer, intent(out), optional :: n_processes
    logical, intent(out), optional :: unweighted
    logical, intent(out), optional :: negative_weights
    if (present (beam_pdg))  beam_pdg = IDBMUP
    if (present (beam_energy))  beam_energy = EBMUP
    if (present (n_processes))  n_processes = NPRUP
    if (present (unweighted)) then
       select case (abs (IDWTUP))
       case (3)
          unweighted = .true.
       case (4)
          unweighted = .false.
       case (1,2)  ! not supported by WHIZARD
          unweighted = .false.
       case default
          call msg_fatal ("HEPRUP: unsupported IDWTUP value")
       end select
    end if
    if (present (negative_weights)) then
       negative_weights = IDWTUP < 0
    end if
  end subroutine heprup_get_run_parameters

@ %def heprup_get_run_parameters
@ Specify PDF set info.  Since we support only LHAPDF, the group entry
is zero.
<<HEP common: public>>=
  public :: heprup_set_lhapdf_id
<<HEP common: procedures>>=
  subroutine heprup_set_lhapdf_id (i_beam, pdf_id)
    integer, intent(in) :: i_beam, pdf_id
    PDFGUP(i_beam) = 0
    PDFSUP(i_beam) = pdf_id
  end subroutine heprup_set_lhapdf_id

@ %def heprup_set_lhapdf_id
@ Fill the characteristics for a particular process.  Only the process
ID is mandatory.  Note that \whizard\ computes cross sections in fb,
so we have to rescale to pb.  The maximum weight is meaningless for
unweighted events.
<<HEP common: public>>=
  public :: heprup_set_process_parameters
<<HEP common: procedures>>=
  subroutine heprup_set_process_parameters &
       (i, process_id, cross_section, error, max_weight)
    integer, intent(in) :: i, process_id
    real(default), intent(in), optional :: cross_section, error, max_weight
    real(default), parameter :: pb_per_fb = 1.e-3_default
    LPRUP(i) = process_id
    if (present (cross_section)) then
       XSECUP(i) = cross_section * pb_per_fb
    else
       XSECUP(i) = 0
    end if
    if (present (error)) then
       XERRUP(i) = error * pb_per_fb
    else
       XERRUP(i) = 0
    end if
    select case (IDWTUP)
    case (3);  XMAXUP(i) = 1
    case (4)
       if (present (max_weight)) then
          XMAXUP(i) = max_weight * pb_per_fb
       else
          XMAXUP(i) = 0
       end if
    end select
  end subroutine heprup_set_process_parameters

@ %def heprup_set_process_parameters
@ Extract the process parameters, as far as needed.
<<HEP common: public>>=
  public :: heprup_get_process_parameters
<<HEP common: procedures>>=
  subroutine heprup_get_process_parameters  &
       (i, process_id, cross_section, error, max_weight)
    integer, intent(in) :: i
    integer, intent(out), optional :: process_id
    real(default), intent(out), optional :: cross_section, error, max_weight
    real(default), parameter :: pb_per_fb = 1.e-3_default
    if (present (process_id))  process_id = LPRUP(i)
    if (present (cross_section)) then
       cross_section = XSECUP(i) / pb_per_fb
    end if
    if (present (error)) then
       error = XERRUP(i) / pb_per_fb
    end if
    if (present (max_weight)) then
       select case (IDWTUP)
       case (3)
          max_weight = 1
       case (4)
          max_weight = XMAXUP(i) / pb_per_fb
       case (1,2)   ! not supported by WHIZARD
          max_weight = 0
       case default
          call msg_fatal ("HEPRUP: unsupported IDWTUP value")
       end select
    end if
  end subroutine heprup_get_process_parameters

@ %def heprup_get_process_parameters
@
\subsection{Run parameter output (verbose)}
This is a verbose output of the HEPRUP block.
<<HEP common: public>>=
  public :: heprup_write_verbose
<<HEP common: procedures>>=
  subroutine heprup_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPRUP Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "IDBMUP", IDBMUP, &
         "PDG code of beams"
    write (u, "(3x,A6,' = ',G12.5,1x,G12.5,8x,A)")  "EBMUP ", EBMUP, &
         "Energy of beams in GeV"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "PDFGUP", PDFGUP, &
         "PDF author group [-1 = undefined]"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "PDFSUP", PDFSUP, &
         "PDF set ID       [-1 = undefined]"
    write (u, "(3x,A6,' = ',I9,3x,1x,9x,3x,8x,A)")  "IDWTUP", IDWTUP, &
         "LHA code for event weight mode"
    write (u, "(3x,A6,' = ',I9,3x,1x,9x,3x,8x,A)")  "NPRUP ", NPRUP, &
         "Number of user subprocesses"
    do i = 1, NPRUP
       write (u, "(1x,A,I0)")  "Subprocess #", i
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XSECUP", XSECUP(i), &
            "Cross section in pb"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XERRUP", XERRUP(i), &
            "Cross section error in pb"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XMAXUP", XMAXUP(i), &
            "Maximum event weight (cf. IDWTUP)"
       write (u, "(3x,A6,' = ',I9,3x,1x,12x,8x,A)")  "LPRUP ", LPRUP(i), &
            "Subprocess ID"
    end do
  end subroutine heprup_write_verbose

@ %def heprup_write_verbose
@
\subsection{Run parameter output (other formats)}
This routine writes the initialization block according to the LHEF
standard.  It uses the current contents of the HEPRUP block.
<<HEP common: public>>=
  public :: heprup_write_lhef
<<HEP common: procedures>>=
  subroutine heprup_write_lhef (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),2(1x,ES17.10),6(1x,I0))") &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       write (u, "(3(1x,ES17.10),1x,I0)") &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_write_lhef
  
@ %def heprup_write_lhef
@
This routine is a complete dummy at the moment. It uses the current
contents of the HEPRUP block. At the end, it should depend on certain
input flags for the different ASCII event formats.
<<HEP common: public>>=
  public :: heprup_write_ascii
<<HEP common: procedures>>=
  subroutine heprup_write_ascii (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),2(1x,ES17.10),6(1x,I0))") &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       write (u, "(3(1x,ES17.10),1x,I0)") &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_write_ascii
  
@ %def heprup_write_ascii
@
\subsubsection{Run parameter input (LHEF)}
In a LHEF file, the parameters are written in correct order on
separate lines, but we should not count on the precise format.
List-directed input should just work.
<<HEP common: public>>=
  public :: heprup_read_lhef
<<HEP common: procedures>>=
  subroutine heprup_read_lhef (u)
    integer, intent(in) :: u
    integer :: i
    read (u, *) &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       read (u, *) &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_read_lhef
    
@ %def heprup_read_lhef
@
\subsection{The HEPEUP common block}
<<HEP common: common blocks>>=
  common /HEPEUP/ &
       NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP, &
       IDUP, ISTUP, MOTHUP, ICOLUP, PUP, VTIMUP, SPINUP
  save /HEPEUP/

@ %def HEPEUP
@ 
\subsubsection{Initialization}
Fill the event characteristics of the common block.  The
initialization sets only the number of particles and initializes the
rest with default values.  The other routine sets the optional
parameters.
<<HEP common: public>>=
  public :: hepeup_init
  public :: hepeup_set_event_parameters
<<HEP common: procedures>>=
  subroutine hepeup_init (n_tot)
    integer, intent(in) :: n_tot
    NUP = n_tot
    IDPRUP = 0
    XWGTUP = 1
    SCALUP = -1
    AQEDUP = -1
    AQCDUP = -1
  end subroutine hepeup_init

  subroutine hepeup_set_event_parameters &
       (proc_id, weight, scale, alpha_qed, alpha_qcd)
    integer, intent(in), optional :: proc_id
    real(default), intent(in), optional :: weight, scale, alpha_qed, alpha_qcd
    if (present (proc_id))   IDPRUP = proc_id
    if (present (weight))    XWGTUP = weight
    if (present (scale))     SCALUP = scale
    if (present (alpha_qed)) AQEDUP = alpha_qed
    if (present (alpha_qcd)) AQCDUP = alpha_qcd
  end subroutine hepeup_set_event_parameters

@ %def hepeup_init hepeup_set_event_parameters
@ 
Extract event information.  The caller determines the parameters.
<<HEP common: public>>=
  public :: hepeup_get_event_parameters
<<HEP common: procedures>>=
  subroutine hepeup_get_event_parameters &
       (proc_id, weight, scale, alpha_qed, alpha_qcd)
    integer, intent(out), optional :: proc_id
    real(default), intent(out), optional :: weight, scale, alpha_qed, alpha_qcd
    if (present (proc_id))   proc_id   = IDPRUP
    if (present (weight))    weight    = XWGTUP
    if (present (scale))     scale     = SCALUP
    if (present (alpha_qed)) alpha_qed = AQEDUP
    if (present (alpha_qcd)) alpha_qcd = AQCDUP
  end subroutine hepeup_get_event_parameters

@ %def hepeup_get_event_parameters
@ 
\subsubsection{Particle data}
Below we need the particle status codes which are actually defined
in the [[subevents]] module.

Set the entry for a specific particle.  All parameters are set with
the exception of lifetime and spin, where default values are stored.
<<HEP common: public>>=
  public :: hepeup_set_particle
<<HEP common: procedures>>=
  subroutine hepeup_set_particle (i, pdg, status, parent, col, p, m2)
    integer, intent(in) :: i
    integer, intent(in) :: pdg, status
    integer, dimension(:), intent(in) :: parent
    type(vector4_t), intent(in) :: p
    integer, dimension(2), intent(in) :: col
    real(default), intent(in) :: m2
    if (i > MAXNUP) then
       call msg_error (arr=[ &
            var_str ("Too many particles in HEPEUP common block. " // &
                            "If this happened "), &
            var_str ("during event output, your events will be " // &
                            "invalid; please consider "), &
            var_str ("switching to a modern event format like HEPMC. " // &
                            "If you are not "), &
            var_str ("using an old, HEPEUP based format and " // &
                            "nevertheless get this error,"), &
            var_str ("please notify the WHIZARD developers,") ])
       return
    end if
    IDUP(i) = pdg
    select case (status)
    case (PRT_BEAM);         ISTUP(i) = -9
    case (PRT_INCOMING);     ISTUP(i) = -1
    case (PRT_BEAM_REMNANT); ISTUP(i) =  3
    case (PRT_OUTGOING);     ISTUP(i) =  1
    case (PRT_RESONANT);     ISTUP(i) =  2
    case (PRT_VIRTUAL);      ISTUP(i) =  3
    case default;            ISTUP(i) =  0
    end select
    select case (size (parent))
    case (0);      MOTHUP(:,i) = 0
    case (1);      MOTHUP(1,i) = parent(1); MOTHUP(2,i) = 0
    case default;  MOTHUP(:,i) = [ parent(1), parent(size (parent)) ]
    end select
    if (col(1) > 0) then
       ICOLUP(1,i) = 500 + col(1)
    else
       ICOLUP(1,i) = 0
    end if
    if (col(2) > 0) then
       ICOLUP(2,i) = 500 + col(2)
    else
       ICOLUP(2,i) = 0
    end if
    PUP(1:3,i) = vector3_get_components (space_part (p))
    PUP(4,i) = energy (p)
    PUP(5,i) = sign (sqrt (abs (m2)), m2)
    VTIMUP(i) = 0
    SPINUP(i) = 9
  end subroutine hepeup_set_particle

@ %def hepeup_set_particle
@ Set the lifetime, actually $c\tau$ measured im mm, where $\tau$ is
the invariant lifetime.
<<HEP common: public>>=
  public :: hepeup_set_particle_lifetime
<<HEP common: procedures>>=
  subroutine hepeup_set_particle_lifetime (i, lifetime)
    integer, intent(in) :: i
    real(default), intent(in) :: lifetime
    VTIMUP(i) = lifetime
  end subroutine hepeup_set_particle_lifetime

@ %def hepeup_set_particle_lifetime
@ Set the particle spin entry.  We need the cosine of the angle of the
spin axis with respect to the three-momentum of the parent particle.

If the particle has a full polarization density matrix given, we need
the particle momentum and polarization as well as the mother-particle
momentum.  The polarization is transformed into a spin vector (which
is sensible only for spin-1/2 or massless particles), which then is
transformed into the lab frame (by a rotation of the 3-axis to the
particle momentum axis).  Finally, we compute the scalar product of
this vector with the mother-particle three-momentum.

This puts severe restrictions on the applicability of this definition,
and Lorentz invariance is lost.  Unfortunately, the Les Houches Accord
requires this computation.
<<HEP common: public>>=
  public :: hepeup_set_particle_spin
<<HEP common: interfaces>>=
  interface hepeup_set_particle_spin
     module procedure hepeup_set_particle_spin_pol
  end interface
<<HEP common: procedures>>=
  subroutine hepeup_set_particle_spin_pol (i, p, pol, p_mother)
    integer, intent(in) :: i
    type(vector4_t), intent(in) :: p
    type(polarization_t), intent(in) :: pol
    type(vector4_t), intent(in) :: p_mother
    type(vector3_t) :: s3, p3
    type(vector4_t) :: s4
    s3 = vector3_moving (polarization_get_axis (pol))
    p3 = space_part (p)
    s4 = rotation_to_2nd (3, p3) * vector4_moving (0._default, s3)
    SPINUP(i) = enclosed_angle_ct (s4, p_mother)
  end subroutine hepeup_set_particle_spin_pol
    
@ %def hepeup_set_particle_spin
@
Extract particle data.  The caller decides which ones to retrieve.

Status codes: beam remnants share the status code with virtual particles.
However, for the purpose of WHIZARD we should identify them.  We
use the PDG code for this.
<<HEP common: public>>=
  public :: hepeup_get_particle
<<HEP common: procedures>>=
  subroutine hepeup_get_particle (i, pdg, status, parent, col, p, m2)
    integer, intent(in) :: i
    integer, intent(out), optional :: pdg, status
    integer, dimension(:), intent(out), optional :: parent
    type(vector4_t), intent(out), optional :: p
    integer, dimension(2), intent(out), optional :: col
    real(default), dimension(5,MAXNUP) :: pup_def
    real(default), intent(out), optional :: m2
    if (present (pdg))  pdg = IDUP(i)
    if (present (status)) then
       select case (ISTUP(i))
       case (-9);  status = PRT_BEAM
       case (-1);  status = PRT_INCOMING
       case (1);   status = PRT_OUTGOING
       case (2);   status = PRT_RESONANT
       case (3);
          select case (abs (IDUP(i)))
          case (HADRON_REMNANT, HADRON_REMNANT_SINGLET, &
               HADRON_REMNANT_TRIPLET, HADRON_REMNANT_OCTET)
             status = PRT_BEAM_REMNANT
          case default
             status = PRT_VIRTUAL
          end select
       case default
          status = PRT_UNDEFINED
       end select
    end if
    if (present (parent)) then
       select case (size (parent))
       case (0)
       case (1);    parent(1) = MOTHUP(1,i)
       case (2);    parent = MOTHUP(:,i)
       end select
    end if
    if (present (col)) then
       col = ICOLUP(:,i)
    end if
    if (present (p)) then
       pup_def = PUP
       p = vector4_moving (pup_def(4,i), vector3_moving (pup_def(1:3,i)))
    end if
    if (present (m2)) then
       m2 = sign (PUP(5,i) ** 2, PUP(5,i))
    end if
  end subroutine hepeup_get_particle

@ %def hepeup_get_particle
@
\subsection{The HEPEVT common block}

For the LEP Monte Carlos, a standard common block has been proposed
in AKV89.  We strongly recommend its use.  (The description is an
abbreviated transcription of AKV89, Vol. 3, pp. 327-330).

[[NMXHEP]] is the maximum number of entries:
<<HEP common: variables>>=
  integer, parameter :: NMXHEP = 4000

@ %def NMXHEP 
@ [[NEVHEP]] is normally the event number, but may take special
values as follows:

   0   the program does not keep track of event numbers.
  -1   a special initialization record.
  -2   a special final record.
<<HEP common: variables>>=
  integer :: NEVHEP

@ %def NEVHEP
@  [[NHEP]] holds the number of entries for this event.
<<HEP common: variables>>=
  integer :: NHEP

@ %def NHEP
@ The entry [[ISTHEP(N)]] gives the status code for the [[N]]th entry,
with the following semantics:
   0       a null entry.
   1       an existing entry, which has not decayed or fragmented.
   2       a decayed or fragmented entry, which is retained for
           event history information.
   3       documentation line.
   4- 10   reserved for future standards.
  11-200   at the disposal of each model builder.
 201-      at the disposal of users.
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: ISTHEP

@ %def ISTHEP 
@ 
The Particle Data Group has proposed standard particle codes,
which are to be stored in [[IDHEP(N)]].
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: IDHEP

@ %def IDHEP
@ [[JMOHEP(1,N)]] points to the mother of the [[N]]th entry, if any.
It is set to zero for initial entries.
[[JMOHEP(2,N)]] points to the second mother, if any.
<<HEP common: variables>>=
  integer, dimension(2, NMXHEP) :: JMOHEP

@ %def JMOHEP
@ [[JDAHEP(1,N)]] and [[JDAHEP(2,N)]] point to the first and last daughter 
of the [[N]]th entry, if any.  These are zero for entries which have not
yet decayed.  The other daughters are stored in between these two.
<<HEP common: variables>>=
  integer, dimension(2, NMXHEP) :: JDAHEP

@ %def JDAHEP
@ In [[PHEP]] we store the momentum of the particle, more specifically
this means that [[PHEP(1,N)]], [[PHEP(2,N)]], and [[PHEP(3,N)]] contain the
momentum in the $x$, $y$, and $z$ direction (as defined by the machine
people), measured in GeV/c.  [[PHEP(4,N)]] contains the energy in GeV
and [[PHEP(5,N)]] the mass in GeV$/c^2$.  The latter may be negative for
spacelike partons.
<<HEP common: variables>>=
  double precision, dimension(5, NMXHEP) :: PHEP
  
@ %def PHEP
@ Finally [[VHEP]] is the place to store the position of the production
vertex.  [[VHEP(1,N)]], [[VHEP(2,N)]], and [[VHEP(3,N)]] contain the $x$, $y$,
and $z$ coordinate (as defined by the machine people), measured in mm.
[[VHEP(4,N)]] contains the production time in mm/c.
<<HEP common: variables>>=
  double precision, dimension(4, NMXHEP) :: VHEP
  
@ %def VHEP 
@ As an amendment to the proposed standard common block HEPEVT, we
also have a polarisation common block HEPSPN, as described in
AKV89.  [[SHEP(1,N)]], [[SHEP(2,N)]], and [[SHEP(3,N)]] give the $x$, $y$, and $z$
component of the spinvector $s$ of a fermion in the fermions restframe.

Furthermore, we add the polarization of the corresponding outgoing
particles:
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: hepevt_pol

@ %def hepevt_pol  
@
By convention, [[SHEP(4,N)]] is always 1. All this is taken from StdHep
4.06 manual and written using Fortran90 conventions.
<<HEP common: common blocks>>=
  common /HEPEVT/ &
       NEVHEP, NHEP, ISTHEP, IDHEP, &
       JMOHEP, JDAHEP, PHEP, VHEP
  save /HEPEVT/
  
@ %def HEPEVT
@ Here we store HEPEVT parameters of the WHIZARD 1 realization which
are not part of the HEPEVT common block. 
<<HEP common: variables>>=
  integer :: hepevt_n_out, hepevt_n_remnants

@ %def hepevt_n_out, hepevt_n_remnants
@  
<<HEP common: variables>>=
  double precision :: hepevt_weight, hepevt_function_value
  double precision :: hepevt_function_ratio
  
@ %def hepevt_weight hepevt_function_value
@ Filling HEPEVT: If the event count is not provided, set [[NEVHEP]]
to zero.  If the event count is [[-1]] or [[-2]], the record
corresponds to initialization and finalization, and the event is
irrelevant.

Note that the event count may be larger than $2^{31}$ (2 GEvents).  In
that case, cut off the upper bits since [[NEVHEP]] is probably limited
to default integer. 
<<HEP common: public>>=
  public :: hepevt_init
  public :: hepevt_set_event_parameters
<<HEP common: procedures>>=
  subroutine hepevt_init (n_tot, n_out)
    integer, intent(in) :: n_tot, n_out
    NHEP              = n_tot
    NEVHEP            = 0
    hepevt_n_out      = n_out
    hepevt_n_remnants = 0
    hepevt_weight     = 1
    hepevt_function_value = 0
    hepevt_function_ratio = 1
  end subroutine hepevt_init
  
  subroutine hepevt_set_event_parameters &
       (weight, function_value, function_ratio, i_evt)
    integer, intent(in), optional :: i_evt
    real(default), intent(in), optional :: weight, function_value, &
       function_ratio
    if (present (i_evt)) NEVHEP = i_evt
    if (present (weight)) hepevt_weight = weight
    if (present (function_value)) hepevt_function_value = &
         function_value
    if (present (function_ratio)) hepevt_function_ratio = &
         function_ratio
  end subroutine hepevt_set_event_parameters

@ %def hepevt_init hepevt_set_event_parameters
@ Set the entry for a specific particle.  All parameters are set with
the exception of lifetime and spin, where default values are stored.
<<HEP common: public>>=
  public :: hepevt_set_particle
<<HEP common: procedures>>=
  subroutine hepevt_set_particle (i, pdg, status, parent, child, p, m2, hel)
    integer, intent(in) :: i
    integer, intent(in) :: pdg, status
    integer, dimension(:), intent(in) :: parent
    integer, dimension(:), intent(in) :: child
    type(vector4_t), intent(in) :: p
    real(default), intent(in) :: m2
    integer, intent(in) :: hel
    IDHEP(i) = pdg
    select case (status)
      case (PRT_BEAM);      ISTHEP(i) = 2
      case (PRT_INCOMING);  ISTHEP(i) = 2
      case (PRT_OUTGOING);  ISTHEP(i) = 1
      case (PRT_VIRTUAL);   ISTHEP(i) = 2
      case (PRT_RESONANT);  ISTHEP(i) = 2
      case default;         ISTHEP(i) = 0
    end select
    select case (size (parent))
    case (0);      JMOHEP(:,i) = 0
    case (1);      JMOHEP(1,i) = parent(1); JMOHEP(2,i) = 0
    case default;  JMOHEP(:,i) = [ parent(1), parent(size (parent)) ]
    end select
    select case (size (child))
    case (0);      JDAHEP(:,i) = 0
    case (1);      JDAHEP(:,i) = child(1)
    case default;  JDAHEP(:,i) = [ child(1), child(size (child)) ]
    end select
    PHEP(1:3,i) = vector3_get_components (space_part (p))
    PHEP(4,i) = energy (p)
    PHEP(5,i) = sign (sqrt (abs (m2)), m2)
    VHEP(1:4,i) = 0
    hepevt_pol(i) = hel
  end subroutine hepevt_set_particle

@ %def hepevt_set_particle
@
\subsection{Event output}
This is a verbose output of the HEPEVT block.
<<HEP common: public>>=
  public :: hepevt_write_verbose
<<HEP common: procedures>>=
  subroutine hepevt_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPEVT Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NEVHEP", NEVHEP, &
         "Event number"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NHEP  ", NHEP, &
         "Number of particles in event"
    do i = 1, NHEP
       write (u, "(1x,A,I0)")  "Particle #", i
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)", advance="no") &
            "ISTHEP", ISTHEP(i), "Status code: "
       select case (ISTHEP(i))
       case ( 0);  write (u, "(A)")  "null entry"
       case ( 1);  write (u, "(A)")  "outgoing"
       case ( 2);  write (u, "(A)")  "decayed"
       case ( 3);  write (u, "(A)")  "documentation"
       case (4:10);  write (u, "(A)")  "[unspecified]"
       case (11:200);  write (u, "(A)")  "[model-specific]"
       case (201:);  write (u, "(A)")  "[user-defined]"
       case default;  write (u, "(A)")  "[undefined]"
       end select
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDHEP ", IDHEP(i), &
            "PDG code of particle"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "JMOHEP", JMOHEP(:,i), &
            "Index of first/second mother"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "JDAHEP", JDAHEP(:,i), &
            "Index of first/last daughter"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "PHEP12", &
            PHEP(1:2,i), "Transversal momentum (x/y) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP3 ", PHEP(3,i), &
            "Longitudinal momentum (z) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP4 ", PHEP(4,i), &
            "Energy in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP5 ", PHEP(5,i), &
            "Invariant mass in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "VHEP12", VHEP(1:2,i), &
            "Transversal displacement (xy) in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VHEP3 ", VHEP(3,i), &
            "Longitudinal displacement (z) in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VHEP4 ", VHEP(4,i), &
            "Production time in mm"
    end do
  end subroutine hepevt_write_verbose

@ %def hepevt_write_verbose
@
This is a verbose output of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_write_verbose
<<HEP common: procedures>>=
  subroutine hepeup_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPEUP Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NUP   ", NUP, &
         "Number of particles in event"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDPRUP", IDPRUP, &
         "Subprocess ID"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "XWGTUP", XWGTUP, &
         "Event weight"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "SCALUP", SCALUP, &
         "Event energy scale in GeV"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "AQEDUP", AQEDUP, &
         "QED coupling [-1 = undefined]"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "AQCDUP", AQCDUP, &
         "QCD coupling [-1 = undefined]"
    do i = 1, NUP
       write (u, "(1x,A,I0)")  "Particle #", i
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDUP  ", IDUP(i), &
            "PDG code of particle"
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)", advance="no") &
            "ISTUP ", ISTUP(i), "Status code: "
       select case (ISTUP(i))
       case (-1);  write (u, "(A)")  "incoming"
       case ( 1);  write (u, "(A)")  "outgoing"
       case (-2);  write (u, "(A)")  "spacelike"
       case ( 2);  write (u, "(A)")  "resonance"
       case ( 3);  write (u, "(A)")  "resonance (doc)"
       case (-9);  write (u, "(A)")  "beam"
       case default;  write (u, "(A)")  "[undefined]"
       end select
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "MOTHUP", MOTHUP(:,i), &
            "Index of first/last mother"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "ICOLUP", ICOLUP(:,i), &
            "Color/anticolor flow index"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "PUP1/2", PUP(1:2,i), &
            "Transversal momentum (x/y) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP3  ", PUP(3,i), &
            "Longitudinal momentum (z) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP4  ", PUP(4,i), &
            "Energy in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP5  ", PUP(5,i), &
            "Invariant mass in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VTIMUP", VTIMUP(i), &
            "Invariant lifetime in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "SPINUP", SPINUP(i), &
            "cos(spin angle) [9 = undefined]"
    end do
  end subroutine hepeup_write_verbose

@ %def hepeup_write_verbose
@
\subsection{Event output in various formats}
This routine writes event output according to the LHEF standard.  It
uses the current contents of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_write_lhef
  public :: hepeup_write_lha
<<HEP common: procedures>>=
  subroutine hepeup_write_lhef (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),4(1x,ES17.10))") &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    do i = 1, NUP
       write (u, "(6(1x,I0),7(1x,ES17.10))") &
            IDUP(i), ISTUP(i), MOTHUP(:,i), ICOLUP(:,i), &
            PUP(:,i), VTIMUP(i), SPINUP(i)
    end do
  end subroutine hepeup_write_lhef

  subroutine hepeup_write_lha (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    integer, dimension(MAXNUP) :: spin_up
    spin_up = SPINUP
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I5),1x,ES17.10,3(1x,ES13.6))") &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    write (u, "(500(1x,I5))") IDUP(:NUP)
    write (u, "(500(1x,I5))") MOTHUP(1,:NUP)
    write (u, "(500(1x,I5))") MOTHUP(2,:NUP)
    write (u, "(500(1x,I5))") ICOLUP(1,:NUP)
    write (u, "(500(1x,I5))") ICOLUP(2,:NUP)
    write (u, "(500(1x,I5))") ISTUP(:NUP)
    write (u, "(500(1x,I5))") spin_up(:NUP)
    do i = 1, NUP
            write (u, "(1x,I5,4(1x,ES17.10))") i, PUP([ 4,1,2,3 ], i)
    end do

  end subroutine hepeup_write_lha  

@ %def hepeup_write_lhef hepeup_write_lha 
@ This routine writes event output according to the HEPEVT standard.  It
uses the current contents of the HEPEVT block and some additional
parameters according to the standard in WHIZARD 1. For the long ASCII
format, the value of the sample function (i.e. the product of squared
matrix element, structure functions and phase space factor is printed out).
The option of reweighting matrix elements with respect to some
reference cross section is not implemented in WHIZARD 2 for this event
format, therefore the second entry in the long ASCII format (the
function ratio) is always one. The ATHENA format is an implementation
of the HEPEVT format that is readable by the ATLAS ATHENA software
framework. It is very similar to the WHIZARD 1 HEPEVT format, except
that it contains an event counter, a particle counter inside the
event, and has the HEPEVT [[ISTHEP]] status before the PDG code. The
MOKKA format is a special ASCII format  that contains the information
to be parsed to the MOKKA LC fast simulation software.
<<HEP common: public>>=
  public :: hepevt_write_hepevt
  public :: hepevt_write_ascii
  public :: hepevt_write_athena
  public :: hepevt_write_mokka  
<<HEP common: procedures>>=
  subroutine hepevt_write_hepevt (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       write (u, "(7(1x,I0))") &
            ISTHEP(i), IDHEP(i), JMOHEP(:,i), JDAHEP(:,i), hepevt_pol(i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
       write (u, "(5(1x,ES17.10))") VHEP(:,i), 0.d0
    end do
  end subroutine hepevt_write_hepevt
  
  subroutine hepevt_write_ascii (unit, long)
    integer, intent(in), optional :: unit
    logical, intent(in) :: long   
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       if (ISTHEP(i) /= 1)  cycle
       write (u, "(2(1x,I0))") IDHEP(i), hepevt_pol(i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
    end do
    if (long) then 
       write (u, "(2(1x,ES17.10))") &
            hepevt_function_value, hepevt_function_ratio
    end if
  end subroutine hepevt_write_ascii
  
  subroutine hepevt_write_athena (unit, i_evt)
    integer, intent(in), optional :: unit, i_evt
    integer :: u, i, num_event
    num_event = 0
    if (present (i_evt)) num_event = i_evt
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0))") num_event, NHEP
    do i = 1, NHEP
       write (u, "(7(1x,I0))") &
            i, ISTHEP(i), IDHEP(i), JMOHEP(:,i), JDAHEP(:,i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
       write (u, "(5(1x,ES17.10))") VHEP(1:4,i)
    end do
  end subroutine hepevt_write_athena
  
  subroutine hepevt_write_mokka (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       write (u, "(4(1x,I0),4(1x,ES17.10))") &
            ISTHEP(i), IDHEP(i), JDAHEP(1,i), JDAHEP(2,i), &
            PHEP(1:3,i), PHEP(5,i)
    end do
  end subroutine hepevt_write_mokka
  
@ %def hepevt_write_hepevt hepevt_write_ascii
@ %def hepevt_write_athena 
@
\subsection{Event input in various formats}
This routine writes event output according to the LHEF standard.  It
uses the current contents of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_read_lhef
<<HEP common: procedures>>=
  subroutine hepeup_read_lhef (u)
    integer, intent(in) :: u
    integer :: i
    read (u, *) &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    do i = 1, NUP
       read (u, *) &
            IDUP(i), ISTUP(i), MOTHUP(:,i), ICOLUP(:,i), &
            PUP(:,i), VTIMUP(i), SPINUP(i)
    end do
  end subroutine hepeup_read_lhef

@ %def hepeup_read_lhef
@ 
\subsection{Data Transfer: particle sets}
The \whizard\ format for handling particle data in events is
[[particle_set_t]].  We have to interface this to the common blocks.

We first create a new particle set that contains only the particles
that are supported by the LHEF format.  These are: beam, incoming,
resonant, outgoing.  We drop particles with unknown, virtual or
beam-remnant status.

From this set we fill the common block.  Event information such as
process ID and weight is not transferred here; this has to be done by
the caller.  The spin information is set only if the particle has a
unique mother, and if its polarization is fully defined.
<<HEP common: public>>=
  public :: hepeup_from_particle_set
<<HEP common: procedures>>=
  subroutine hepeup_from_particle_set (particle_set, keep_beams)
    type(particle_set_t), intent(in), target :: particle_set
    logical, intent(in), optional :: keep_beams  
    type(particle_t), pointer :: prt
    type(particle_set_t), target :: pset_hepevt
    integer :: i, n_parents
    integer, dimension(1) :: i_mother
    call particle_set_to_hepevt_form (particle_set, pset_hepevt, keep_beams)
    call hepeup_init (pset_hepevt%n_tot)
    do i = 1, pset_hepevt%n_tot
       prt => pset_hepevt%prt(i)
       call hepeup_set_particle (i, &
            particle_get_pdg (prt), &
            particle_get_status (prt), &
            particle_get_parents (prt), &
	    particle_get_color (prt), &
            particle_get_momentum (prt), &
            particle_get_p2 (prt))
       n_parents = particle_get_n_parents (prt)
       if (n_parents == 1) then
          i_mother = particle_get_parents (prt)
          select case (particle_get_polarization_status (prt))
          case (PRT_GENERIC_POLARIZATION)
             call hepeup_set_particle_spin (i, &
                  particle_get_momentum (prt), &
                  particle_get_polarization (prt), &
                  particle_get_momentum (pset_hepevt%prt(i_mother(1))))
          end select
       end if
    end do
    call particle_set_final (pset_hepevt)
  end subroutine hepeup_from_particle_set

@ %def hepeup_from_particle_set
@ Input.  The particle set should be allocated properly, but we
replace the particle contents.

If there are no beam particles in the event, we try to reconstruct beam
particles and beam remnants.  We assume for simplicity that the beam
particles, if any, are the first two particles.  If they are absent, the first
two particles should be the incoming partons.
<<HEP common: public>>=
  public :: hepeup_to_particle_set
<<HEP common: procedures>>=
  subroutine hepeup_to_particle_set &
       (particle_set, recover_beams, model, alt_model)
    type(particle_set_t), intent(inout), target :: particle_set
    logical, intent(in), optional :: recover_beams
    type(model_t), intent(in), target :: model, alt_model
    type(particle_t), dimension(:), allocatable :: prt
    integer, dimension(2) :: parent
    integer, dimension(:), allocatable :: child
    integer :: i, j, k, pdg, status
    type(flavor_t) :: flv
    type(color_t) :: col
    integer, dimension(2) :: c
    type(vector4_t) :: p
    real(default) :: p2
    logical :: reconstruct
    integer :: off
    if (present (recover_beams)) then
       reconstruct = recover_beams .and. .not. all (ISTUP(1:2) == PRT_BEAM)
    else
       reconstruct = .false.
    end if
    if (reconstruct) then
       off = 4
    else
       off = 0
    end if
    allocate (prt (NUP + off), child (NUP + off))
    do i = 1, NUP
       k = i + off
       call hepeup_get_particle (i, pdg, status, col = c, p = p, m2 = p2)
       call flavor_init (flv, pdg, model, alt_model)
       call particle_set_flavor (prt(k), flv)
       call particle_reset_status (prt(k), status)
       call color_init (col, c)
       call particle_set_color (prt(k), col)
       call particle_set_momentum (prt(k), p, p2)
       where (MOTHUP(:,i) /= 0)
          parent = MOTHUP(:,i) + off
       elsewhere
          parent = 0
       end where
       call particle_set_parents (prt(k), parent)
       child = [(j, j = 1 + off, NUP + off)]
       where (MOTHUP(1,:NUP) /= i .and. MOTHUP(2,:NUP) /= i)  child = 0
       call particle_set_children (prt(k), child)
    end do
    if (reconstruct) then
       do k = 1, 2
          call particle_reset_status (prt(k), PRT_BEAM)
          call particle_set_children (prt(k), [k+2,k+4])
       end do
       do k = 3, 4
          call particle_reset_status (prt(k), PRT_BEAM_REMNANT)
          call particle_set_parents (prt(k), [k-2])
       end do
       do k = 5, 6
          call particle_set_parents (prt(k), [k-4])
       end do
    else
       call handle_beams (prt)
    end if
    call particle_set_replace (particle_set, prt)
  end subroutine hepeup_to_particle_set
  
@ %def hepeup_to_particle_set
@ Beams and beam remnants require a special handling.  \whizard's interactions
are set up such that in the list of children of beam particles, the remnant
comes before the interacting parton.  To enforce this, we may have to reorder
things.

The beam particles will always be the first two particles.
<<HEP common: procedures>>=
  subroutine handle_beams (prt)
    type(particle_t), dimension(:), intent(inout) :: prt
    integer :: i
    integer, dimension(2) :: child
    do i = 1, 2
       select case (particle_get_status (prt(i)))
       case (PRT_BEAM)
          child = particle_get_children (prt(i))
          if (particle_get_status (prt(child(2))) == PRT_BEAM_REMNANT) then
             call particle_set_children (prt(i), child([2,1]))
          end if
       end select
    end do
  end subroutine handle_beams
    
@ %def handle_beams
@ 
The HEPEVT common block is quite similar, but does contain less
information, e.g. no color flows (it was LEP time). The spin
information is set only if the particle has a unique mother, and if
its polarization is fully defined. 
<<HEP common: public>>=
  public :: hepevt_from_particle_set
<<HEP common: procedures>>=
  subroutine hepevt_from_particle_set (particle_set, keep_beams)
    type(particle_set_t), intent(in), target :: particle_set
    type(particle_t), pointer :: prt
    type(particle_set_t), target :: pset_hepevt
    logical, intent(in), optional :: keep_beams
    integer :: i
    call particle_set_to_hepevt_form (particle_set, pset_hepevt, keep_beams)
    call hepevt_init (pset_hepevt%n_tot, pset_hepevt%n_out)    
    do i = 1, pset_hepevt%n_tot
       prt => pset_hepevt%prt(i)
       call hepevt_set_particle (i, &
            particle_get_pdg (prt), &
            particle_get_status (prt), &
            particle_get_parents (prt), &
            particle_get_children (prt), &
            particle_get_momentum (prt), &
            particle_get_p2 (prt), &
	    particle_get_helicity (prt))
    end do
    call particle_set_final (pset_hepevt)
  end subroutine hepevt_from_particle_set

@ %def hepevt_from_particle_set
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HEP Common and Events}

This is a separate module that manages data exchange between the common blocks
and [[event_t]] objects.  We separate this from the previous module in order
to avoid a circular module dependency. It also contains the functions
necessary for communication between [[hepmc_event_t]] and
[[event_t]] objects.
<<[[hep_events.f90]]>>=
<<File header>>

module hep_events
  
  use kinds
  use io_units
  use diagnostics

  use models
  use particles
  use processes
  use hep_common
  use hepmc_interface
  use events

<<Standard module head>>

<<HEP events: public>>

contains
  
<<HEP events: procedures>>

end module hep_events
@ %def hep_events
@
\subsection{Data Transfer: events}
Fill the HEPEUP block, given a \whizard\ event object.
<<HEP events: public>>=
  public :: hepeup_from_event
<<HEP events: procedures>>=
  subroutine hepeup_from_event (event, keep_beams, process_index)
    type(event_t), intent(in), target :: event
    logical, intent(in), optional :: keep_beams
    integer, intent(in), optional :: process_index
    type(particle_set_t), pointer :: particle_set
    real(default) :: scale, alpha_qcd
    if (event%has_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call hepeup_from_particle_set (particle_set, keep_beams)
       if (present (process_index)) &
            call hepeup_set_event_parameters (proc_id = process_index)
       scale = event%get_fac_scale ()
       if (scale /= 0) &
            call hepeup_set_event_parameters (scale = scale)
       alpha_qcd = event%get_alpha_s ()       
       if (alpha_qcd /= 0) &
            call hepeup_set_event_parameters (alpha_qcd = alpha_qcd)
       if (event%weight_prc_is_known) then
          call hepeup_set_event_parameters (weight = event%weight_prc)
       else
          call msg_bug ("HEPEUP: process weight is unknown")
       end if
    else
       call msg_bug ("HEPEUP: event incomplete")
    end if
  end subroutine hepeup_from_event

@ %def hepeup_from_event
@ Reverse.  

Note: The current implementation sets the particle set of the hard
process and is therefore not useful if the event on file is dressed.
This should be reconsidered.

Note: setting of scale or alpha is not yet supported by the
[[event_t]] object.  Ticket \#628.
<<HEP events: public>>=
  public :: hepeup_to_event
<<HEP events: procedures>>=
  subroutine hepeup_to_event &
       (event, fallback_model, process_index, recover_beams)
    type(event_t), intent(inout), target :: event
    type(model_t), intent(in), target :: fallback_model
    integer, intent(out), optional :: process_index
    logical, intent(in), optional :: recover_beams
    type(process_t), pointer :: process
    type(model_t), pointer :: model
    real(default) :: weight, scale, alpha_qcd
    type(particle_set_t) :: particle_set
    process => event%get_process_ptr ()
    model => process%get_model_ptr ()
    call hepeup_to_particle_set &
         (particle_set, recover_beams, model, fallback_model)
    call event%set_particle_set_hard_proc (particle_set)
    call particle_set_final (particle_set)
    if (present (process_index)) then
       call hepeup_get_event_parameters (proc_id = process_index)
    end if
    call hepeup_get_event_parameters (weight = weight, &
         scale = scale, alpha_qcd = alpha_qcd)
    call event%set (weight_ref = weight)
!!! Not implemented yet:
!     if (scale > 0)  call event%set_scales (scale)
!     if (alpha_qcd > 0)  call event%set_alpha_qcd (alpha_qcd)
  end subroutine hepeup_to_event

@ %def hepeup_to_event
@ Fill the HEPEVT (event) common block:
<<HEP events: public>>=
  public :: hepevt_from_event
<<HEP events: procedures>>=
  subroutine hepevt_from_event (event, i_evt, keep_beams)
    type(event_t), intent(in), target :: event
    integer, intent(in), optional :: i_evt
    logical, intent(in), optional :: keep_beams  
    type(particle_set_t), pointer :: particle_set
    if (event%has_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call hepevt_from_particle_set (particle_set, keep_beams)
       if (event%weight_prc_is_known .and. event%sqme_prc_is_known) then
          call hepevt_set_event_parameters ( &
               weight = event%weight_prc, &
               function_value = event%sqme_prc)
       else
          call msg_bug ("HEPEVT: event weight and/or sqme unknown")
       end if
       if (present (i_evt)) &
            call hepevt_set_event_parameters (i_evt = i_evt)
    else
       call msg_bug ("HEPEVT: event incomplete")
    end if
  end subroutine hepevt_from_event

@ %def hepevt_from_event
@
<<HEP events: public>>=
  public :: hepmc_to_event
<<HEP events: procedures>>=
  subroutine hepmc_to_event &
       (event, hepmc_event, fallback_model, process_index, recover_beams)
    type(event_t), intent(inout), target :: event
    type(hepmc_event_t), intent(inout) :: hepmc_event
    type(model_t), intent(in), target :: fallback_model
    integer, intent(out), optional :: process_index
    logical, intent(in), optional :: recover_beams
    type(process_t), pointer :: process
    type(model_t), pointer :: model
    real(default) :: weight, scale, alpha_qcd
    type(particle_set_t) :: particle_set
    process => event%get_process_ptr ()
    model => process%get_model_ptr ()
    call particle_set_init &
         (particle_set, hepmc_event, model, fallback_model, PRT_DEFINITE_HELICITY)
    call event%set_particle_set_hard_proc (particle_set)
    call particle_set_final (particle_set)
    call event%set ()
!!! Not implemented yet:
!     if (scale > 0)  call event%set_scales (scale)
!     if (alpha_qcd > 0)  call event%set_alpha_qcd (alpha_qcd)
  end subroutine hepmc_to_event
  
@ %def hepmc_to_event
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LHEF Input/Output}
The LHEF event record is standardized.  It is an ASCII format.  We try
our best at using it for both input and output.
<<[[eio_lhef.f90]]>>=
<<File header>>

module eio_lhef
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics
  use os_interface

  use xml
  use lorentz
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data
  use eio_base
  use hep_common
  use hep_events

<<Standard module head>>

<<EIO LHEF: public>>

<<EIO LHEF: types>>

<<EIO LHEF: interfaces>>

contains
  
<<EIO LHEF: procedures>>

<<EIO LHEF: tests>>

end module eio_lhef
@ %def eio_lhef
@
\subsection{Type}
With sufficient confidence that it will always be three characters, we
can store the version string with a default value.
<<EIO LHEF: public>>=
  public :: eio_lhef_t
<<EIO LHEF: types>>=
  type, extends (eio_t) :: eio_lhef_t
     logical :: writing = .false.
     logical :: reading = .false.
     integer :: unit = 0
     type(event_sample_data_t) :: data
     type(cstream_t) :: cstream
     character(3) :: version = "1.0"
     logical :: keep_beams = .false.
     logical :: recover_beams = .true.
     logical :: unweighted = .true.
     logical :: write_sqme_ref = .false.
     logical :: write_sqme_prc = .false.
     logical :: write_sqme_alt = .false.
     integer :: n_alt = 0
     integer, dimension(:), allocatable :: proc_num_id
     integer :: i_weight_sqme = 0
     type(xml_tag_t) :: tag_lhef, tag_head, tag_init, tag_event
     type(xml_tag_t), allocatable :: tag_gen_n, tag_gen_v
     type(xml_tag_t), allocatable :: tag_generator, tag_xsecinfo
     type(xml_tag_t), allocatable :: tag_sqme_ref, tag_sqme_prc
     type(xml_tag_t), dimension(:), allocatable :: tag_sqme_alt, tag_wgts_alt
     type(xml_tag_t), allocatable :: tag_weight, tag_weightinfo, tag_weights
   contains
   <<EIO LHEF: eio lhef: TBP>>
  end type eio_lhef_t
  
@ %def eio_lhef_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LHEF.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: set_parameters => eio_lhef_set_parameters
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_set_parameters (eio, keep_beams, recover_beams, &
       version, extension, write_sqme_ref, write_sqme_prc, write_sqme_alt)
    class(eio_lhef_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams
    character(*), intent(in), optional :: version
    type(string_t), intent(in), optional :: extension
    logical, intent(in), optional :: write_sqme_ref
    logical, intent(in), optional :: write_sqme_prc
    logical, intent(in), optional :: write_sqme_alt
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (version)) then
       select case (version)
       case ("1.0", "2.0", "3.0")
          eio%version = version
       case default
          call msg_error ("LHEF version " // version &
               // " is not supported.  Inserting 2.0")
          eio%version = "2.0"
       end select
    end if
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "lhe"
    end if
    if (present (write_sqme_ref))  eio%write_sqme_ref = write_sqme_ref
    if (present (write_sqme_prc))  eio%write_sqme_prc = write_sqme_prc
    if (present (write_sqme_alt))  eio%write_sqme_alt = write_sqme_alt
  end subroutine eio_lhef_set_parameters
  
@ %def eio_lhef_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write => eio_lhef_write
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write (object, unit)
    class(eio_lhef_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "LHEF event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A)")     "Version           = ", object%version
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if
  end subroutine eio_lhef_write
  
@ %def eio_lhef_write
@ Finalizer: close any open file.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: final => eio_lhef_final
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_final (object)
    class(eio_lhef_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LHEF file '", &
            char (object%filename), "'"
       call msg_message ()
       call object%write_footer ()
       close (object%unit)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LHEF file '", &
            char (object%filename), "'"
       call msg_message ()
       call object%cstream%final ()
       object%reading = .false.
    end if
  end subroutine eio_lhef_final
  
@ %def eio_lhef_final
@ Common initialization for input and output.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: common_init => eio_lhef_common_init
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_common_init (eio, sample, data, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("LHEF initialization: missing data")
    eio%data = data
    if (data%n_beam /= 2) &
         call msg_fatal ("LHEF: defined for scattering processes only")
    eio%unweighted = data%unweighted
    if (eio%unweighted) then
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default;  call msg_fatal &
            ("LHEF: normalization for unweighted events must be '1'")
       end select
    else
       select case (data%norm_mode)
       case (NORM_SIGMA)
       case default;  call msg_fatal &
            ("LHEF: normalization for weighted events must be 'sigma'")
       end select
    end if
    eio%n_alt = data%n_alt
    eio%sample = sample
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    eio%unit = free_unit ()
    call eio%init_tags (data)
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_lhef_common_init
  
@ %def eio_lhef_common_init
@ Initialize the tag objects.  Some tags depend on the LHEF
version.  In particular, the tags that in LHEF 2.0 identify
individual weights by name in each event block, in LHEF 3.0 are
replaced by info tags in the init block and a single \texttt{weights}
tag in the event block.  The name attributes of those tags
are specific for \whizard.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_tags => eio_lhef_init_tags
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_tags (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(in) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    integer :: i
    call eio%tag_lhef%init ( &
         var_str ("LesHouchesEvents"), &
         [xml_attribute (var_str ("version"), var_str (eio%version))], &
         .true.)
    call eio%tag_head%init ( &
         var_str ("header"), &
         .true.)
    call eio%tag_init%init ( &
         var_str ("init"), &
         .true.)
    call eio%tag_event%init (var_str ("event"), &
         .true.)
    select case (eio%version)
    case ("1.0")
       allocate (eio%tag_gen_n)
       call eio%tag_gen_n%init ( &
            var_str ("generator_name"), &
            .true.)
       allocate (eio%tag_gen_v)
       call eio%tag_gen_v%init ( &
            var_str ("generator_version"), &
            .true.)
    end select
    select case (eio%version)
    case ("2.0", "3.0")
       allocate (eio%tag_generator)
       call eio%tag_generator%init ( &
            var_str ("generator"), &
            [xml_attribute (var_str ("version"), var_str ("<<Version>>"))], &
            .true.)
       allocate (eio%tag_xsecinfo)
       call eio%tag_xsecinfo%init ( &
            var_str ("xsecinfo"), &
            [xml_attribute (var_str ("neve"), str (data%n_evt)), &
             xml_attribute (var_str ("totxsec"), &
                            str (data%total_cross_section * pb_per_fb))])
    end select
    select case (eio%version)
    case ("2.0")
       allocate (eio%tag_weight)
       call eio%tag_weight%init (var_str ("weight"), &
            [xml_attribute (var_str ("name"))])
       if (eio%write_sqme_ref) then
          allocate (eio%tag_sqme_ref)
          call eio%tag_sqme_ref%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_ref"))], &
               .true.)
       end if
       if (eio%write_sqme_prc) then
          allocate (eio%tag_sqme_prc)
          call eio%tag_sqme_prc%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_prc"))], &
               .true.)
       end if
       if (eio%n_alt > 0) then
          if (eio%write_sqme_alt) then
             allocate (eio%tag_sqme_alt (1))
             call eio%tag_sqme_alt(1)%init (var_str ("weight"), &
                  [xml_attribute (var_str ("name"), var_str ("sqme_alt"))], &
                  .true.)
          end if
          allocate (eio%tag_wgts_alt (1))
          call eio%tag_wgts_alt(1)%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("wgts_alt"))], &
               .true.)
       end if
    case ("3.0")
       if (eio%write_sqme_ref) then
          allocate (eio%tag_sqme_ref)
          call eio%tag_sqme_ref%init (var_str ("weightinfo"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_ref"))])
       end if
       if (eio%write_sqme_prc) then
          allocate (eio%tag_sqme_prc)
          call eio%tag_sqme_prc%init (var_str ("weightinfo"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_prc"))])
       end if
       if (eio%n_alt > 0) then
          if (eio%write_sqme_alt) then
             allocate (eio%tag_sqme_alt (eio%n_alt))
             do i = 1, eio%n_alt
                call eio%tag_sqme_alt(i)%init (var_str ("weightinfo"), &
                     [xml_attribute (var_str ("name"), &
                                     var_str ("sqme_alt") // str (i))])
             end do
          end if
          allocate (eio%tag_wgts_alt (eio%n_alt))
          do i = 1, eio%n_alt
             call eio%tag_wgts_alt(i)%init (var_str ("weightinfo"), &
                  [xml_attribute (var_str ("name"), &
                                  var_str ("wgts_alt") // str (i))])
          end do
       end if
       allocate (eio%tag_weightinfo)
       call eio%tag_weightinfo%init (var_str ("weightinfo"), &
            [xml_attribute (var_str ("name"))])
       allocate (eio%tag_weights)
       call eio%tag_weights%init (var_str ("weights"), .true.)
    end select
  end subroutine eio_lhef_init_tags
  
@ %def eio_lhef_init_tags
@ Initialize event writing.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_out => eio_lhef_init_out
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: u, i
    call eio%set_splitting (data)
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to LHEF file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    u = eio%unit
    open (u, file = char (eio%filename), &
         action = "write", status = "replace")
    call eio%write_header ()
    call heprup_init &
         (data%pdg_beam, &
          data%energy_beam, &
          n_processes = data%n_proc, &
          unweighted = data%unweighted, &
          negative_weights = data%negative_weights)	  	
    do i = 1, data%n_proc
       call heprup_set_process_parameters (i = i, &
            process_id = data%proc_num_id(i), &
            cross_section = data%cross_section(i), &
            error = data%error(i))
    end do
    call eio%tag_init%write (u);  write (u, *)
    call heprup_write_lhef (u)
    select case (eio%version)
    case ("2.0");  call eio%write_init_20 (data)
    case ("3.0");  call eio%write_init_30 (data)
    end select
    call eio%tag_init%close (u);  write (u, *)
    if (present (success))  success = .true.
  end subroutine eio_lhef_init_out
    
@ %def eio_lhef_init_out
@ Initialize event reading.  First read the LHEF tag and version, then
read the header and skip over its contents, then read the init block.
(We require the opening and closing tags of the init block to be placed
on separate lines without extra stuff.)

For input, we do not (yet?) support split event files.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_in => eio_lhef_init_in
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist, ok, closing
    type(event_sample_data_t) :: data_file
    type(string_t) :: string
    integer :: u
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from LHEF file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: LHEF file not found.")
    eio%reading = .true.
    u = eio%unit
    open (u, file = char (eio%filename), &
         action = "read", status = "old")
    call eio%cstream%init (u)
    call eio%read_header ()
    call eio%tag_init%read (eio%cstream, ok)
    if (.not. ok)  call err_init
    select case (eio%version)
    case ("1.0");  call eio%read_init_10 (data_file)
       call eio%tag_init%read_content (eio%cstream, string, closing)
       if (string /= "" .or. .not. closing)  call err_init
    case ("2.0");  call eio%read_init_20 (data_file)
    case ("3.0");  call eio%read_init_30 (data_file)
    end select
    call eio%merge_data (data, data_file)
    if (present (success))  success = .true.

  contains
    
    subroutine err_init
      call msg_fatal ("LHEF: syntax error in init tag")
    end subroutine err_init
      
  end subroutine eio_lhef_init_in
    
@ %def eio_lhef_init_in
@ Merge event sample data: we can check the data in the file against
our assumptions and set or reset parameters.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: merge_data => eio_merge_data
<<EIO LHEF: procedures>>=
  subroutine eio_merge_data (eio, data, data_file)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(inout) :: data
    type(event_sample_data_t), intent(in) :: data_file
    real, parameter :: tolerance = 1000 * epsilon (1._default)
    if (data%unweighted .neqv. data_file%unweighted)  call err_weights
    if (data%negative_weights .neqv. data_file%negative_weights) &
         call err_weights
    if (data%norm_mode /= data_file%norm_mode)  call err_norm
    if (data%n_beam /= data_file%n_beam)  call err_beams
    if (any (data%pdg_beam /= data_file%pdg_beam))  call err_beams
    if (any (abs ((data%energy_beam - data_file%energy_beam)) &
         > (data%energy_beam + data_file%energy_beam) * tolerance)) &
         call err_beams
    if (data%n_proc /= data_file%n_proc)  call err_proc
    if (any (data%proc_num_id /= data_file%proc_num_id))  call err_proc
    where (data%cross_section == 0)
       data%cross_section = data_file%cross_section
       data%error = data_file%error
    end where
    data%total_cross_section = sum (data%cross_section)
    if (data_file%n_evt > 0) then
       if (data%n_evt > 0 .and. data_file%n_evt /= data%n_evt)  call err_n_evt
       data%n_evt = data_file%n_evt
    end if
  contains
    subroutine err_weights
      call msg_fatal ("LHEF: mismatch in event weight properties")
    end subroutine err_weights
    subroutine err_norm
      call msg_fatal ("LHEF: mismatch in event normalization")
    end subroutine err_norm
    subroutine err_beams
      call msg_fatal ("LHEF: mismatch in beam properties")
    end subroutine err_beams
    subroutine err_proc
      call msg_fatal ("LHEF: mismatch in process definitions")
    end subroutine err_proc
    subroutine err_n_evt
      call msg_error ("LHEF: mismatch in specified number of events (ignored)")
    end subroutine err_n_evt
  end subroutine eio_merge_data
    
@ %def eio_merge_data
@ Switch from input to output: reopen the file for reading.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: switch_inout => eio_lhef_switch_inout
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_switch_inout (eio, success)
    class(eio_lhef_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("LHEF: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_lhef_switch_inout
  
@ %def eio_lhef_switch_inout
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: split_out => eio_lhef_split_out
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_split_out (eio)
    class(eio_lhef_t), intent(inout) :: eio
    integer :: u
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to LHEF file '", &
            char (eio%filename), "'"
       call msg_message ()
       call eio%write_footer ()
       u = eio%unit
       close (u)
       open (u, file = char (eio%filename), &
            action = "write", status = "replace")
       call eio%write_header ()
       call eio%tag_init%write (u);  write (u, *)
       call heprup_write_lhef (u)
       select case (eio%version)
       case ("2.0");  call eio%write_init_20 (eio%data)
       case ("3.0");  call eio%write_init_30 (eio%data)
       end select
       call eio%tag_init%close (u);  write (u, *)
    end if
  end subroutine eio_lhef_split_out
  
@ %def eio_lhef_split_out
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: output => eio_lhef_output
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_output (eio, event, i_prc, reading)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    if (eio%writing) then
       call hepeup_from_event (event, &
            process_index = eio%proc_num_id (i_prc), &
            keep_beams = eio%keep_beams)
       write (u, '(A)') "<event>"
       call hepeup_write_lhef (eio%unit)
       select case (eio%version)
       case ("2.0");  call eio%write_event_20 (event)
       case ("3.0");  call eio%write_event_30 (event)
       end select
       write (u, '(A)') "</event>"
    else
       call eio%write ()
       call msg_fatal ("LHEF file is not open for writing")
    end if
  end subroutine eio_lhef_output

@ %def eio_lhef_output
@ Input an event.  Upon input of [[i_prc]], we can just read in the
whole HEPEUP common block.  These data are known to come first.  The
[[i_prc]] value can be deduced from the IDPRUP value by a table
lookup.

Reading the common block bypasses the [[cstream]] which accesses the
input unit.  This is consistent with the LHEF specification.  After
the common-block data have been swallowed, we can resume reading from
stream.

We don't catch actual I/O errors.  However, we return a negative value in
[[iostat]] if we reached the terminating [[</LesHouchesEvents>]] tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: input_i_prc => eio_lhef_input_i_prc
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_input_i_prc (eio, i_prc, iostat)
    class(eio_lhef_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    integer :: i, proc_num_id
    type(string_t) :: s
    logical :: ok
    iostat = 0
    call eio%tag_lhef%read_content (eio%cstream, s, ok)
    if (ok) then
       if (s == "") then
          iostat = -1
       else
          call err_close
       end if
       return
    else
       call eio%cstream%revert_record (s)
    end if
    call eio%tag_event%read (eio%cstream, ok)
    if (.not. ok) then
       call err_evt1
       return
    end if
    call hepeup_read_lhef (eio%unit)
    call hepeup_get_event_parameters (proc_id = proc_num_id)
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_close
      call msg_error ("LHEF: reading events: syntax error in closing tag")
      iostat = 1
    end subroutine
    subroutine err_evt1
      call msg_error ("LHEF: reading events: invalid event tag, &
           &aborting read")
      iostat = 2
    end subroutine err_evt1
    subroutine err_index
      call msg_error ("LHEF: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 3
    end subroutine err_index
  end subroutine eio_lhef_input_i_prc

@ %def eio_lhef_input_i_prc
@ Since we have already read the event information from file, this
input routine can transfer the common-block contents to the event
record.  Also, we read any further information in the event record.

Since LHEF doesn't give this information, we must assume that the MCI
group, term, and channel can all be safely set to 1.  This works if
there is only one MCI group and term.  The channel doesn't matter for
the matrix element.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: input_event => eio_lhef_input_event
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_input_event (eio, event, iostat)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    type(string_t) :: s
    logical :: closing
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    call hepeup_to_event (event, eio%fallback_model, &
         recover_beams = eio%recover_beams)
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if
    select case (eio%version)
    case ("1.0")
       call eio%tag_event%read_content (eio%cstream, s, closing = closing)
       if (s /= "" .or. .not. closing)  call err_evt2
    case ("2.0");  call eio%read_event_20 (event)
    case ("3.0");  call eio%read_event_30 (event)
    end select
  contains
    subroutine err_evt2
      call msg_error ("LHEF: reading events: syntax error in event record, &
           &aborting read")
      iostat = 2
    end subroutine err_evt2

  end subroutine eio_lhef_input_event

@ %def eio_lhef_input_event
@ 
\subsection{Les Houches Event File: header/footer}
These two routines write the header and footer for the Les Houches
Event File format (LHEF).

The current version writes no information except for the generator
name and version (v.1.0 only).
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_header => eio_lhef_write_header
  procedure :: write_footer => eio_lhef_write_footer
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_header (eio)
    class(eio_lhef_t), intent(in) :: eio
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    call eio%tag_lhef%write (u);  write (u, *)
    call eio%tag_head%write (u);  write (u, *)
    select case (eio%version)
    case ("1.0")
       write (u, "(2x)", advance = "no")
       call eio%tag_gen_n%write (var_str ("WHIZARD"), u)
       write (u, *)
       write (u, "(2x)", advance = "no")
       call eio%tag_gen_v%write (var_str ("<<Version>>"), u)
       write (u, *)
    end select
    call eio%tag_head%close (u);  write (u, *)
  end subroutine eio_lhef_write_header

  subroutine eio_lhef_write_footer (eio)
    class(eio_lhef_t), intent(in) :: eio
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    call eio%tag_lhef%close (u)
  end subroutine eio_lhef_write_footer

@ %def eio_lhef_write_header eio_lhef_write_footer
@ Reading the header just means finding the tags and ignoring any
contents.  When done, we should stand just after the header tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_header => eio_lhef_read_header
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_header (eio)
    class(eio_lhef_t), intent(inout) :: eio
    logical :: success, closing
    type(string_t) :: content
    call eio%tag_lhef%read (eio%cstream, success)
    if (.not. success .or. .not. eio%tag_lhef%has_content)  call err_lhef
    if (eio%tag_lhef%get_attribute (1) /= eio%version)  call err_version
    call eio%tag_head%read (eio%cstream, success)
    if (.not. success)  call err_header
    if (eio%tag_head%has_content) then
       SKIP_HEADER_CONTENT: do
          call eio%tag_head%read_content (eio%cstream, content, closing)
          if (closing)  exit SKIP_HEADER_CONTENT
       end do SKIP_HEADER_CONTENT
    end if
  contains
    subroutine err_lhef
      call msg_fatal ("LHEF: LesHouchesEvents tag absent or corrupted")
    end subroutine err_lhef
    subroutine err_header
      call msg_fatal ("LHEF: header tag absent or corrupted")
    end subroutine err_header
    subroutine err_version
       call msg_error ("LHEF: version mismatch: expected " &
            // eio%version // ", found " &
            // char (eio%tag_lhef%get_attribute (1)))
    end subroutine err_version
  end subroutine eio_lhef_read_header

@ %def eio_lhef_read_header
@
\subsection{Version-Specific Code: 1.0}
In version 1.0, the init tag contains just HEPRUP data.  While a
[[cstream]] is connected to the input unit, we bypass it temporarily
for the purpose of reading the HEPRUP contents.  This is consistent
with the LHEF standard.

This routine does not read the closing tag of the init block.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_10 => eio_lhef_read_init_10
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_10 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(out) :: data
    integer :: n_proc, i
    call heprup_read_lhef (eio%unit)
    call heprup_get_run_parameters (n_processes = n_proc)
    call data%init (n_proc)
    data%n_beam = 2
    call heprup_get_run_parameters ( &
         unweighted = data%unweighted, &
         negative_weights = data%negative_weights, &
         beam_pdg = data%pdg_beam, &
         beam_energy = data%energy_beam)
    if (data%unweighted) then
       data%norm_mode = NORM_UNIT
    else
       data%norm_mode = NORM_SIGMA
    end if
    do i = 1, n_proc
       call heprup_get_process_parameters (i, &
            process_id = data%proc_num_id(i), &
            cross_section = data%cross_section(i), &
            error = data%error(i))
    end do
  end subroutine eio_lhef_read_init_10
  
@ %def eio_lhef_read_init_10
@
\subsection{Version-Specific Code: 2.0}
This is the init information for the 2.0 format, after the HEPRUP
data.  We have the following tags:
\begin{itemize}
\item \texttt{generator}  Generator name and version.
\item \texttt{xsecinfo}  Cross section and weights data.  We have the
  total cross section and number of events (assuming that the event
  file is intact), but information on minimum and maximum weights is
  not available before the file is complete.  We just write the
  mandatory tags.  (Note that the default values of the other tags
  describe a uniform unit weight, but we can determine most values
  only after the sample is complete.)
\item \texttt{cutsinfo}  This optional tag is too specific to represent the
  possibilities of WHIZARD, so we skip it.
\item \texttt{procinfo}  This optional tag is useful for giving
  details of NLO calculations.  Skipped.
\item \texttt{mergetype}  Optional, also not applicable.
\end{itemize}
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_init_20 => eio_lhef_write_init_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_init_20 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    integer :: u
    u = eio%unit
    call eio%tag_generator%write (u)
    write (u, "(A)", advance="no")  "WHIZARD"
    call eio%tag_generator%close (u);  write (u, *)
    call eio%tag_xsecinfo%write (u);  write (u, *)
  end subroutine eio_lhef_write_init_20
    
@ %def eio_lhef_write_init_20
@ When reading the init block, we first call the 1.0 routine that
fills HEPRUP.  Then we consider the possible tags.  Only the
\texttt{generator} and \texttt{xsecinfo} tags are of interest.  We
skip everything else except for the closing tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_20 => eio_lhef_read_init_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_20 (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(out) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    type(string_t) :: content
    logical :: found, closing
    call eio_lhef_read_init_10 (eio, data)
    SCAN_INIT_TAGS: do
       call eio%tag_generator%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_generator%has_content)  call err_generator
          call eio%tag_generator%read_content (eio%cstream, content, closing)
          call msg_message ("LHEF: Event file has been generated by " &
               // char (content) // " " &
               // char (eio%tag_generator%get_attribute (1)))
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_xsecinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_xsecinfo%has_content)  call err_xsecinfo
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_init%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_init
          exit SCAN_INIT_TAGS
       end if
    end do SCAN_INIT_TAGS
    data%n_evt = &
         read_ival (eio%tag_xsecinfo%get_attribute (1))
    data%total_cross_section = &
         read_rval (eio%tag_xsecinfo%get_attribute (2)) / pb_per_fb
  contains
    subroutine err_generator
      call msg_fatal ("LHEF: invalid generator tag")
    end subroutine err_generator
    subroutine err_xsecinfo
      call msg_fatal ("LHEF: invalid xsecinfo tag")
    end subroutine err_xsecinfo
    subroutine err_init
      call msg_fatal ("LHEF: syntax error after init tag")
    end subroutine err_init
  end subroutine eio_lhef_read_init_20
  
@ %def eio_lhef_read_init_20
@ This is additional event-specific information for the 2.0 format,
after the HEPEUP data.  We can specify weights, starting from the
master weight and adding alternative weights.  The alternative weights
are collected in a common tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_event_20 => eio_lhef_write_event_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_event_20 (eio, event)
    class(eio_lhef_t), intent(in) :: eio
    type(event_t), intent(in) :: event
    type(string_t) :: s
    integer :: i, u
    u = eio%unit
    if (eio%write_sqme_ref) then
       s = str (event%sqme_ref)
       call eio%tag_sqme_ref%write (s, u);  write (u, *)
    end if
    if (eio%write_sqme_prc) then
       s = str (event%sqme_prc)
       call eio%tag_sqme_prc%write (s, u);  write (u, *)
    end if
    if (eio%n_alt > 0) then
       if (eio%write_sqme_alt) then
          s = str (event%sqme_alt(1))
          do i = 2, eio%n_alt
             s = s // " " // str (event%sqme_alt(i));  write (u, *)
          end do
          call eio%tag_sqme_alt(1)%write (s, u)
       end if
       s = str (event%weight_alt(1))
       do i = 2, eio%n_alt
          s = s // " " // str (event%weight_alt(i));  write (u, *)
       end do
       call eio%tag_wgts_alt(1)%write (s, u)
    end if
  end subroutine eio_lhef_write_event_20
    
@ %def eio_lhef_write_event_20
@ Read extra event data.  If there is a weight entry labeled [[sqme_prc]], we
take this as the squared matrix-element value (the new
\emph{reference} value [[sqme_ref]]). Other tags, including
tags written by the above writer, are skipped.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_event_20 => eio_lhef_read_event_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_event_20 (eio, event)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_t), intent(inout) :: event
    type(string_t) :: content
    logical :: found, closing
    SCAN_EVENT_TAGS: do
       call eio%tag_weight%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_weight%has_content)  call err_weight
          call eio%tag_weight%read_content (eio%cstream, content, closing)
          if (.not. closing)  call err_weight
          if (eio%tag_weight%get_attribute (1) == "sqme_prc") then
             call event%set (sqme_ref = read_rval (content))
          end if
          cycle SCAN_EVENT_TAGS
       end if
       call eio%tag_event%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_event
          exit SCAN_EVENT_TAGS
       end if
    end do SCAN_EVENT_TAGS
  contains
    subroutine err_weight
      call msg_fatal ("LHEF: invalid weight tag in event record")
    end subroutine err_weight
    subroutine err_event
      call msg_fatal ("LHEF: syntax error after event tag")
    end subroutine err_event
  end subroutine eio_lhef_read_event_20
    
@ %def eio_lhef_read_event_20
@
\subsection{Version-Specific Code: 3.0}
This is the init information for the 3.0 format, after the HEPRUP
data.  We have the following tags:
\begin{itemize}
\item \texttt{generator}  Generator name and version.
\item \texttt{xsecinfo}  Cross section and weights data.  We have the
  total cross section and number of events (assuming that the event
  file is intact), but information on minimum and maximum weights is
  not available before the file is complete.  We just write the
  mandatory tags.  (Note that the default values of the other tags
  describe a uniform unit weight, but we can determine most values
  only after the sample is complete.)
\item \texttt{cutsinfo}  This optional tag is too specific to represent the
  possibilities of WHIZARD, so we skip it.
\item \texttt{procinfo}  This optional tag is useful for giving
  details of NLO calculations.  Skipped.
\item \texttt{weightinfo}  Determine the meaning of optional weights, whose
  values are given in the event record.
\end{itemize}
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_init_30 => eio_lhef_write_init_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_init_30 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    integer :: u, i
    u = given_output_unit (eio%unit)
    call eio%tag_generator%write (u)
    write (u, "(A)", advance="no")  "WHIZARD"
    call eiO%tag_generator%close (u);  write (u, *)
    call eio%tag_xsecinfo%write (u);  write (u, *)
    if (eio%write_sqme_ref) then
       call eio%tag_sqme_ref%write (u);  write (u, *)
    end if
    if (eio%write_sqme_prc) then
       call eio%tag_sqme_prc%write (u);  write (u, *)
    end if
    if (eio%write_sqme_alt) then
       do i = 1, eio%n_alt
          call eio%tag_sqme_alt(i)%write (u);  write (u, *)
       end do
    end if
    do i = 1, eio%n_alt
       call eio%tag_wgts_alt(i)%write (u);  write (u, *)
    end do
  end subroutine eio_lhef_write_init_30
    
@ %def eio_lhef_write_init_30
@ When reading the init block, we first call the 1.0 routine that
fills HEPRUP.  Then we consider the possible tags.  Only the
\texttt{generator} and \texttt{xsecinfo} tags are of interest.  We
skip everything else except for the closing tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_30 => eio_lhef_read_init_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_30 (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(out) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    type(string_t) :: content
    logical :: found, closing
    integer :: n_weightinfo
    call eio_lhef_read_init_10 (eio, data)
    n_weightinfo = 0
    eio%i_weight_sqme = 0
    SCAN_INIT_TAGS: do
       call eio%tag_generator%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_generator%has_content)  call err_generator
          call eio%tag_generator%read_content (eio%cstream, content, closing)
          call msg_message ("LHEF: Event file has been generated by " &
               // char (content) // " " &
               // char (eio%tag_generator%get_attribute (1)))
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_xsecinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_xsecinfo%has_content)  call err_xsecinfo
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_weightinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_weightinfo%has_content)  call err_xsecinfo
          n_weightinfo = n_weightinfo + 1
          if (eio%tag_weightinfo%get_attribute (1) == "sqme_prc") then
             eio%i_weight_sqme = n_weightinfo
          end if
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_init%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_init
          exit SCAN_INIT_TAGS
       end if
    end do SCAN_INIT_TAGS
    data%n_evt = &
         read_ival (eio%tag_xsecinfo%get_attribute (1))
    data%total_cross_section = &
         read_rval (eio%tag_xsecinfo%get_attribute (2)) / pb_per_fb
  contains
    subroutine err_generator
      call msg_fatal ("LHEF: invalid generator tag")
    end subroutine err_generator
    subroutine err_xsecinfo
      call msg_fatal ("LHEF: invalid xsecinfo tag")
    end subroutine err_xsecinfo
    subroutine err_init
      call msg_fatal ("LHEF: syntax error after init tag")
    end subroutine err_init
  end subroutine eio_lhef_read_init_30
  
@ %def eio_lhef_read_init_30
@ This is additional event-specific information for the 3.0 format,
after the HEPEUP data.  We can specify weights, starting from the
master weight and adding alternative weights.  The weight tags are
already allocated, so we just have to transfer the weight values to
strings, assemble them and write them to file.  All weights are
collected in a single tag.

Note: If efficiency turns out to be an issue, we may revert to
traditional character buffer writing.  However, we need to know the
maximum length.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_event_30 => eio_lhef_write_event_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_event_30 (eio, event)
    class(eio_lhef_t), intent(in) :: eio
    type(event_t), intent(in) :: event
    type(string_t) :: s
    integer :: u, i
    u = eio%unit
    s = ""
    if (eio%write_sqme_ref) then
       s = s // str (event%sqme_ref) // " "
    end if
    if (eio%write_sqme_prc) then
       s = s // str (event%sqme_prc) // " "
    end if
    if (eio%n_alt > 0) then
       if (eio%write_sqme_alt) then
          s = s // str (event%sqme_alt(1)) // " "
          do i = 2, eio%n_alt
             s = s // str (event%sqme_alt(i)) // " "
          end do
       end if
       s = s // str (event%weight_alt(1)) // " "
       do i = 2, eio%n_alt
          s = s // str (event%weight_alt(i)) // " "
       end do
    end if
    if (len_trim (s) > 0) then
       call eio%tag_weights%write (trim (s), u);  write (u, *)
    end if
  end subroutine eio_lhef_write_event_30
    
@ %def eio_lhef_write_event_30
@ Read extra event data.  If there is a [[weights]] tag and if there
was a [[weightinfo]] entry labeled [[sqme_prc]], we extract the
corresponding entry from the weights string and store this as the
event's  squared matrix-element value.  Other tags, including
tags written by the above writer, are skipped.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_event_30 => eio_lhef_read_event_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_event_30 (eio, event)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_t), intent(inout) :: event
    type(string_t) :: content, string
    logical :: found, closing
    integer :: i
    SCAN_EVENT_TAGS: do
       call eio%tag_weights%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_weights%has_content)  call err_weights
          call eio%tag_weights%read_content (eio%cstream, content, closing)
          if (.not. closing)  call err_weights
          if (eio%i_weight_sqme > 0) then
             SCAN_WEIGHTS: do i = 1, eio%i_weight_sqme
                call split (content, string, " ")
                content = adjustl (content)
                if (i == eio%i_weight_sqme) then
                   call event%set (sqme_ref = read_rval (string))
                   exit SCAN_WEIGHTS
                end if
             end do SCAN_WEIGHTS
          end if
          cycle SCAN_EVENT_TAGS
       end if
       call eio%tag_event%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_event
          exit SCAN_EVENT_TAGS
       end if
    end do SCAN_EVENT_TAGS
  contains
    subroutine err_weights
      call msg_fatal ("LHEF: invalid weights tag in event record")
    end subroutine err_weights
    subroutine err_event
      call msg_fatal ("LHEF: syntax error after event tag")
    end subroutine err_event
  end subroutine eio_lhef_read_event_30
    
@ %def eio_lhef_read_event_30
@
\subsection{Auxiliary}
Create a string from a number.  We use fixed format for the reals
and variable format for integers.
<<EIO LHEF: interfaces>>=
  interface str
     module procedure str_int, str_real
  end interface
<<EIO LHEF: procedures>>=
  function str_int (i) result (s)
    integer, intent(in) :: i
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(I0)")  i
    s = var_str (trim (buffer))
  end function str_int
  
  function str_real (x) result (s)
    real(default), intent(in) :: x
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(ES17.10)")  x
    s = var_str (trim (adjustl (buffer)))
  end function str_real
  
@ %def str
@ Auxiliary: Read real, integer, string value.
<<EIO LHEF: procedures>>=
  function read_rval (s) result (rval)
    type(string_t), intent(in) :: s
    real(default) :: rval
    character(80) :: buffer
    buffer = s
    read (buffer, *)  rval
  end function read_rval
    
  function read_ival (s) result (ival)
    type(string_t), intent(in) :: s
    integer :: ival
    character(80) :: buffer
    buffer = s
    read (buffer, *)  ival
  end function read_ival
    
@ %def read_rval read_ival
@
\subsection{Unit tests}
<<EIO LHEF: public>>=
  public :: eio_lhef_test
<<EIO LHEF: tests>>=
  subroutine eio_lhef_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO LHEF: execute tests>>
  end subroutine eio_lhef_test
  
@ %def eio_lhef_test 
@
\subsubsection{Version 1.0 Output}
We test the implementation of all I/O methods.  We start with output
according to version 1.0.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_1, "eio_lhef_1", &
       "write version 1.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_1"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_1"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // "." // eio%extension), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters ()
    end select
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_1"
    
  end subroutine eio_lhef_1
  
@ %def eio_lhef_1
@
\subsubsection{Version 2.0 Output}
Version 2.0 has added a lot of options to the LHEF format.  We
implement some of them.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_2, "eio_lhef_2", &
       "write version 2.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_2"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_2"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "2.0", write_sqme_prc = .true.)
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])


    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // "." // eio%extension), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:10) == "<generator")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_2"
    
  end subroutine eio_lhef_2
  
@ %def eio_lhef_2
@
\subsubsection{Version 3.0 Output}
Version 3.0 is an update which removes some tags (which we didn't use anyway)
and suggests a new treatment of weights.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_3, "eio_lhef_3", &
       "write version 3.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_3 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_3"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_3"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "3.0", write_sqme_prc = .true.)
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])


    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lhe"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:10) == "<generator")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_3"
    
  end subroutine eio_lhef_3
  
@ %def eio_lhef_3
@
\subsubsection{Version 1.0 Input}
Check input of a version-1.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_4, "eio_lhef_4", &
       "read version 1.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_4 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(model_t), pointer :: fallback_model
    type(os_data_t) :: os_data
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_4"
    write (u, "(A)")  "*   Purpose: read a LHEF 1.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_4"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="1.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '  <arbitrary_tag opt="foo">content</arbitrary_tag>'
    write (u_file, "(A)")  '  Text'
    write (u_file, "(A)")  '  <another_tag />'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         & -1 -1 -1 -1 3 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 1.0000000000E+00 42'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         & -1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00  0.0000000000E+00 &
         & 4.8412291828E+02  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00  0.0000000000E+00 &
         &-4.8412291828E+02  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 -4.6042825611E+02 &
         & 0.0000000000E+00  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02  4.6042825611E+02 &
         & 0.0000000000E+00  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)
    

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, fallback_model)
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, [process_ptr], data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_4"
    
  end subroutine eio_lhef_4
  
@ %def eio_lhef_4
@
\subsubsection{Version 2.0 Input}
Check input of a version-2.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_5, "eio_lhef_5", &
       "read version 2.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_5 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(model_t), pointer :: fallback_model
    type(os_data_t) :: os_data
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_5"
    write (u, "(A)")  "*   Purpose: read a LHEF 2.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_5"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="2.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         &-1 -1 -1 -1 4 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 0.0000000000E+00 42'
    write (u_file, "(A)")  '<generator version="2.2.3">WHIZARD&
         &</generator>'
    write (u_file, "(A)")  '<xsecinfo neve="1" totxsec="1.0000000000E-01" />'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         &-1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00  4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00 -4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 &
         &-4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02 &
         & 4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '<weight name="sqme_prc">1.0000000000E+00</weight>'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, fallback_model)
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "2.0", recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, [process_ptr], data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_5"
    
  end subroutine eio_lhef_5
  
@ %def eio_lhef_5
@
\subsubsection{Version 3.0 Input}
Check input of a version-3.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_6, "eio_lhef_6", &
       "read version 3.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_6 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(model_t), pointer :: fallback_model
    type(os_data_t) :: os_data
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_6"
    write (u, "(A)")  "*   Purpose: read a LHEF 3.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_6"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="3.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         &-1 -1 -1 -1 4 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 0.0000000000E+00 42'
    write (u_file, "(A)")  '<generator version="2.2.3">WHIZARD&
         &</generator>'
    write (u_file, "(A)")  '<xsecinfo neve="1" totxsec="1.0000000000E-01" />'
    write (u_file, "(A)")  '<weightinfo name="sqme_prc" />'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         &-1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00  4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00 -4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 &
         &-4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02 &
         & 4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '<weights>1.0000000000E+00</weights>'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, fallback_model)
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "3.0", recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, [process_ptr], data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_6"
    
  end subroutine eio_lhef_6
  
@ %def eio_lhef_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HepMC Output}
The HepMC event record is standardized.  It is an ASCII format.  We try
our best at using it for both input and output.
<<[[eio_hepmc.f90]]>>=
<<File header>>

module eio_hepmc
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use models
  use particles
  use subevents
  use beams
  use processes
  use events
  use hep_events
  use eio_data
  use eio_base
  use hepmc_interface

<<Standard module head>>

<<EIO HepMC: public>>

<<EIO HepMC: types>>

<<EIO HepMC: interfaces>>

contains
  
<<EIO HepMC: procedures>>

<<EIO HepMC: tests>>

end module eio_hepmc
@ %def eio_hepmc
@
\subsection{Type}
A type [[hepmc_event]] is introduced as container to store HepMC event
data, particularly for splitting the reading into read out of the process
index and the proper event data.
<<EIO HepMC: public>>=
  public :: eio_hepmc_t
<<EIO HepMC: types>>=
  type, extends (eio_t) :: eio_hepmc_t
     logical :: writing = .false.
     logical :: reading = .false.
     logical :: keep_beams = .false.
     logical :: recover_beams = .false.
     type(hepmc_iostream_t) :: iostream
     type(hepmc_event_t) :: hepmc_event
     integer, dimension(:), allocatable :: proc_num_id
   contains
   <<EIO HepMC: eio hepmc: TBP>>
  end type eio_hepmc_t
  
@ %def eio_hepmc_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with HepMC.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: set_parameters => eio_hepmc_set_parameters
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_set_parameters (eio, keep_beams, &
       recover_beams, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams 
    type(string_t), intent(in), optional :: extension    
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "hepmc"
    end if
  end subroutine eio_hepmc_set_parameters
  
@ %def eio_hepmc_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: write => eio_hepmc_write
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_write (object, unit)
    class(eio_hepmc_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "HepMC event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if    
  end subroutine eio_hepmc_write
  
@ %def eio_hepmc_write
@ Finalizer: close any open file.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: final => eio_hepmc_final
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_final (object)
    class(eio_hepmc_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing HepMC file '", &
            char (object%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (object%iostream)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing HepMC file '", &
            char (object%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (object%iostream)
       object%reading = .false.
    end if
  end subroutine eio_hepmc_final
  
@ %def eio_hepmc_final
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: split_out => eio_hepmc_split_out
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_split_out (eio)
    class(eio_hepmc_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to HepMC file '", &
            char (eio%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (eio%iostream)
       call hepmc_iostream_open_out (eio%iostream, eio%filename)
    end if
  end subroutine eio_hepmc_split_out
  
@ %def eio_hepmc_split_out
@ Common initialization for input and output.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: common_init => eio_hepmc_common_init
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_common_init (eio, sample, data, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("HepMC initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("HepMC: defined for scattering processes only")    
    if (data%unweighted) then
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default; call msg_fatal &
            ("HepMC: normalization for unweighted events must be '1'")
       end select
    else
       call msg_fatal ("HepMC: events must be unweighted")    
    end if
    eio%sample = sample    
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_hepmc_common_init
  
@ %def eio_hepmc_common_init
@ Initialize event writing.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: init_out => eio_hepmc_init_out
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to HepMC file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    call hepmc_iostream_open_out (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_hepmc_init_out
    
@ %def eio_hepmc_init_out
@ Initialize event reading. For input, we do not (yet) support split
event files. 
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: init_in => eio_hepmc_init_in
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_init_in & 
       (eio, sample, process_ptr, data, success, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from HepMC file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: HepMC file not found.")
    eio%reading = .true.
    call hepmc_iostream_open_in (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_hepmc_init_in
    
@ %def eio_hepmc_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: switch_inout => eio_hepmc_switch_inout
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_switch_inout (eio, success)
    class(eio_hepmc_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("HepMC: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_hepmc_switch_inout
  
@ %def eio_hepmc_switch_inout
@ Output an event to the allocated HepMC output stream.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: output => eio_hepmc_output
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_output (eio, event, i_prc, reading)
    class(eio_hepmc_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    type(particle_set_t), pointer :: pset_ptr
    if (eio%writing) then
       pset_ptr => event%get_particle_set_ptr ()
       call hepmc_event_init (eio%hepmc_event, &
            proc_id = eio%proc_num_id (i_prc), &
            event_id = event%expr%index)
       call hepmc_event_from_particle_set (eio%hepmc_event, pset_ptr)
       call hepmc_event_set_scale (eio%hepmc_event, event%get_fac_scale ())
       call hepmc_event_set_alpha_qcd (eio%hepmc_event, event%get_alpha_s ())
       call hepmc_iostream_write_event (eio%iostream, eio%hepmc_event)
       call hepmc_event_final (eio%hepmc_event)
    else
       call eio%write ()
       call msg_fatal ("HepMC file is not open for writing")
    end if
  end subroutine eio_hepmc_output

@ %def eio_hepmc_output
@ Input an event.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: input_i_prc => eio_hepmc_input_i_prc
  procedure :: input_event => eio_hepmc_input_event
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_input_i_prc (eio, i_prc, iostat)
    class(eio_hepmc_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    logical :: ok
    integer :: i, proc_num_id
    iostat = 0
    call hepmc_event_init (eio%hepmc_event)
    call hepmc_iostream_read_event (eio%iostream, eio%hepmc_event, ok)
    proc_num_id = hepmc_event_get_process_id (eio%hepmc_event)
    if (.not. ok) then 
       iostat = -1 
       return
    end if
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_index
      call msg_error ("HepMC: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 1
    end subroutine err_index
  end subroutine eio_hepmc_input_i_prc

  subroutine eio_hepmc_input_event (eio, event, iostat)
    class(eio_hepmc_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    logical :: ok    
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    call hepmc_to_event (event, eio%hepmc_event, eio%fallback_model, &
         recover_beams = eio%recover_beams) 
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if    
    call hepmc_event_final (eio%hepmc_event)
  end subroutine eio_hepmc_input_event

@ %def eio_hepmc_input_i_prc
@ %def eio_hepmc_input_event
@
\subsection{Auxiliary}
Create a string from a number.  We use fixed format for the reals
and variable format for integers.
<<EIO HepMC: interfaces>>=
  interface str
     module procedure str_int, str_real
  end interface
<<EIO HepMC: procedures>>=
  function str_int (i) result (s)
    integer, intent(in) :: i
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(I0)")  i
    s = var_str (trim (buffer))
  end function str_int
  
  function str_real (x) result (s)
    real(default), intent(in) :: x
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(ES17.10)")  x
    s = var_str (trim (adjustl (buffer)))
  end function str_real
  
@ %def str
@
\subsection{Unit tests}
<<EIO HepMC: public>>=
  public :: eio_hepmc_test
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO HepMC: execute tests>>
  end subroutine eio_hepmc_test
  
@ %def eio_hepmc_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO HepMC: execute tests>>=
  call test (eio_hepmc_1, "eio_hepmc_1", &
       "write event contents", &
       u, results)
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(116) :: buffer

    write (u, "(A)")  "* Test output: eio_hepmc_1"
    write (u, "(A)")  "*   Purpose: write a HepMC file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)        
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
    
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_hepmc_1"
 
    allocate (eio_hepmc_t :: eio)
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents (blanking out last two digits):"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepmc"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       if (trim (buffer) == "")  cycle
       if (buffer(1:14) == "HepMC::Version")  cycle
       if (buffer(1:10) == "P 10001 25") &
            call buffer_blanker (buffer, 32, 55, 78)
       if (buffer(1:10) == "P 10002 25") &
            call buffer_blanker (buffer, 33, 56, 79)
       if (buffer(1:10) == "P 10003 25") &
            call buffer_blanker (buffer, 29, 53, 78, 101)
       if (buffer(1:10) == "P 10004 25") &
            call buffer_blanker (buffer, 28, 51, 76, 99)       
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_hepmc_t :: eio)
    
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_hepmc_1"
    
  contains
    
    subroutine buffer_blanker (buf, pos1, pos2, pos3, pos4)
      character(len=*), intent(inout) :: buf
      integer, intent(in) :: pos1, pos2, pos3
      integer, intent(in), optional :: pos4
      type(string_t) :: line
      line = var_str (trim (buf))
      line = replace (line, pos1, "XX")
      line = replace (line, pos2, "XX")
      line = replace (line, pos3, "XX")
      if (present (pos4)) then
         line = replace (line, pos4, "XX")
      end if
      line = replace (line, "4999999999999", "5000000000000")
      buf = char (line)
    end subroutine buffer_blanker
    
  end subroutine eio_hepmc_1
  
@ %def eio_hepmc_1
@ Test also the reading of HepMC events.
<<EIO HepMC: execute tests>>=
  call test (eio_hepmc_2, "eio_hepmc_2", &
       "read event contents", &
       u, results)
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(model_t), pointer :: fallback_model
    type(os_data_t) :: os_data
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_hepmc_2"
    write (u, "(A)")  "*   Purpose: read a HepMC event"
    write (u, "(A)")

    write (u, "(A)")  "* Write a HepMC data file"
    write (u, "(A)")
    
    u_file = free_unit ()
    sample = "eio_hepmc_2"
    open (u_file, file = char (sample // ".hepmc"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  "HepMC::Version 2.06.09"
    write (u_file, "(A)")  "HepMC::IO_GenEvent-START_EVENT_LISTING"
    write (u_file, "(A)")  "E 0 -1 -1.0000000000000000e+00 &
         &-1.0000000000000000e+00 &
         &-1.0000000000000000e+00 42 0 1 10001 10002 0 0"
    write (u_file, "(A)")  "U GEV MM"
    write (u_file, "(A)")  "V -1 0 0 0 0 0 2 2 0"
    write (u_file, "(A)")  "P 10001 25 0 0 4.8412291827592713e+02 &
         &5.0000000000000000e+02 &
         &1.2499999999999989e+02 3 0 0 -1 0"
    write (u_file, "(A)")  "P 10002 25 0 0 -4.8412291827592713e+02 &
         &5.0000000000000000e+02 &
         &1.2499999999999989e+02 3 0 0 -1 0"
    write (u_file, "(A)")  "P 10003 25 -1.4960220911365536e+02 &
         &-4.6042825611414656e+02 &
         &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    write (u_file, "(A)")  "P 10004 25 1.4960220911365536e+02 &
         &4.6042825611414656e+02 &
         &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    write (u_file, "(A)")  "HepMC::IO_GenEvent-END_EVENT_LISTING"
    close (u_file)

    
    write (u, "(A)")  "* Initialize test process" 
    write (u, "(A)")
    
    call syntax_model_file_init ()    
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), &
         var_str ("SM_hadrons.mdl"), os_data, fallback_model)

    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
    
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
 
    allocate (eio_hepmc_t :: eio)
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters (recover_beams = .false.)
    end select            
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)

    write (u, "(A)")    
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")
             
    call eio%init_in (sample, [process_ptr], data)
    call eio%write (u)    
    
    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")
 
    call eio%input_i_prc (i_prc, iostat)

    select type (eio)
    type is (eio_hepmc_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
    
    call eio%input_event (event, iostat)
    
    call event%write (u)
        
    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")
    
    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_hepmc_2"
    
  end subroutine eio_hepmc_2
  
@ %def eio_hepmc_2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LCIO Output}
The LCIO event record is standardized for the use with Linear $e^+e^-$
colliders. It is a binary event format.  We try our best at using it
for both input and output. 
<<[[eio_lcio.f90]]>>=
<<File header>>

module eio_lcio
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use models
  use particles
  use subevents
  use beams
  use processes
  use events
  use hep_events
  use eio_data
  use eio_base
  use lcio_interface

<<Standard module head>>

<<EIO LCIO: public>>

<<EIO LCIO: types>>

<<EIO LCIO: interfaces>>

contains
  
<<EIO LCIO: procedures>>

<<EIO LCIO: tests>>

end module eio_lcio
@ %def eio_lcio
@
\subsection{Type}
A type [[lcio_event]] is introduced as container to store LCIO event
data, particularly for splitting the reading into read out of the process
index and the proper event data.
<<EIO LCIO: public>>=
  public :: eio_lcio_t
<<EIO LCIO: types>>=
  type, extends (eio_t) :: eio_lcio_t
     logical :: writing = .false.
     logical :: reading = .false.
     logical :: keep_beams = .false.
     logical :: recover_beams = .false.
     type(lcio_event_t) :: lcio_event
     integer, dimension(:), allocatable :: proc_num_id
   contains
   <<EIO LCIO: eio lcio: TBP>>
  end type eio_lcio_t
  
@ %def eio_lcio_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LCIO.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: set_parameters => eio_lcio_set_parameters
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_set_parameters (eio, keep_beams, &
       recover_beams, extension)
    class(eio_lcio_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams 
    type(string_t), intent(in), optional :: extension    
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "slcio"
    end if
  end subroutine eio_lcio_set_parameters
  
@ %def eio_lcio_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: write => eio_lcio_write
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_write (object, unit)
    class(eio_lcio_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "LCIO event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if    
  end subroutine eio_lcio_write
  
@ %def eio_lcio_write
@ Finalizer: close any open file.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: final => eio_lcio_final
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_final (object)
    class(eio_lcio_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LCIO file '", &
            char (object%filename), "'"
       call msg_message ()
       !! call hepmc_iostream_close (object%iostream)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LCIO file '", &
            char (object%filename), "'"
       call msg_message ()
       !! call hepmc_iostream_close (object%iostream)
       object%reading = .false.
    end if
  end subroutine eio_lcio_final
  
@ %def eio_lcio_final
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: split_out => eio_lcio_split_out
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_split_out (eio)
    class(eio_lcio_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to LCIO file '", &
            char (eio%filename), "'"
       call msg_message ()
       !! call hepmc_iostream_close (eio%iostream)
       !! call hepmc_iostream_open_out (eio%iostream, eio%filename)
    end if
  end subroutine eio_lcio_split_out
  
@ %def eio_lcio_split_out
@ Common initialization for input and output.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: common_init => eio_lcio_common_init
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_common_init (eio, sample, data, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("LCIO initialization: missing data")
    !!! Is this really true?
    if (data%n_beam /= 2) &
         call msg_fatal ("LCIO: defined for scattering processes only")    
    if (data%unweighted) then
       !!! Check for this !
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default; call msg_fatal &
            ("LCIO: normalization for unweighted events must be '1'")
       end select
    else
       !!! Check for this
       call msg_fatal ("LCIO: events must be unweighted")    
    end if
    eio%sample = sample    
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_lcio_common_init
  
@ %def eio_lcio_common_init
@ Initialize event writing.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: init_out => eio_lcio_init_out
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to LCIO file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    !!! call hepmc_iostream_open_out (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_lcio_init_out
    
@ %def eio_lcio_init_out
@ Initialize event reading. For input, we do not (yet) support split
event files. 
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: init_in => eio_lcio_init_in
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_init_in & 
       (eio, sample, process_ptr, data, success, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from LCIO file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: LCIO file not found.")
    eio%reading = .true.
    !!! call hepmc_iostream_open_in (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_lcio_init_in
    
@ %def eio_lcio_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: switch_inout => eio_lcio_switch_inout
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_switch_inout (eio, success)
    class(eio_lcio_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("LCIO: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_lcio_switch_inout
  
@ %def eio_lcio_switch_inout
@ Output an event to the allocated HepMC output stream.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: output => eio_lcio_output
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_output (eio, event, i_prc, reading)
    class(eio_lcio_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    type(particle_set_t), pointer :: pset_ptr
    if (eio%writing) then
       pset_ptr => event%get_particle_set_ptr ()
       call lcio_event_init (eio%lcio_event, &
             proc_id = eio%proc_num_id (i_prc), &
             event_id = event%expr%index)
       !!! call hepmc_event_from_particle_set (eio%hepmc_event, pset_ptr)
       !!! call hepmc_event_set_scale (eio%hepmc_event, event%get_fac_scale ())
       !!! call hepmc_event_set_alpha_qcd (eio%hepmc_event, event%get_alpha_s ())
       !!! call hepmc_iostream_write_event (eio%iostream, eio%hepmc_event)
       call lcio_event_final (eio%lcio_event)
    else
       call eio%write ()
       call msg_fatal ("LCIO file is not open for writing")
    end if
  end subroutine eio_lcio_output

@ %def eio_lcio_output
@ Input an event.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: input_i_prc => eio_lcio_input_i_prc
  procedure :: input_event => eio_lcio_input_event
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_input_i_prc (eio, i_prc, iostat)
    class(eio_lcio_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    logical :: ok
    integer :: i, proc_num_id
    iostat = 0
    call lcio_event_init (eio%lcio_event)
    !!! call hepmc_iostream_read_event (eio%iostream, eio%hepmc_event, ok)
    !!! proc_num_id = hepmc_event_get_process_id (eio%hepmc_event)
    if (.not. ok) then 
       iostat = -1 
       return
    end if
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_index
      call msg_error ("LCIO: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 1
    end subroutine err_index
  end subroutine eio_lcio_input_i_prc

  subroutine eio_lcio_input_event (eio, event, iostat)
    class(eio_lcio_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    logical :: ok    
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    !!! call hepmc_to_event (event, eio%hepmc_event, eio%fallback_model, &
    !!!     recover_beams = eio%recover_beams) 
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if    
    call lcio_event_final (eio%lcio_event)
  end subroutine eio_lcio_input_event

@ %def eio_lcio_input_i_prc
@ %def eio_lcio_input_event
@
@
\subsection{Auxiliary}
Create a string from a number.  We use fixed format for the reals
and variable format for integers.
<<EIO LCIO: interfaces>>=
  interface str
     module procedure str_int, str_real
  end interface
<<EIO LCIO: procedures>>=
  function str_int (i) result (s)
    integer, intent(in) :: i
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(I0)")  i
    s = var_str (trim (buffer))
  end function str_int
  
  function str_real (x) result (s)
    real(default), intent(in) :: x
    type(string_t) :: s
    character(32) :: buffer
    write (buffer, "(ES17.10)")  x
    s = var_str (trim (adjustl (buffer)))
  end function str_real
  
@ %def str
@
\subsection{Unit tests}
<<EIO LCIO: public>>=
  public :: eio_lcio_test
<<EIO LCIO: tests>>=
  subroutine eio_lcio_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO LCIO: execute tests>>
  end subroutine eio_lcio_test
  
@ %def eio_lcio_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO LCIO: execute tests>>=
  call test (eio_lcio_1, "eio_lcio_1", &
       "write event contents", &
       u, results)
<<EIO LCIO: tests>>=
  subroutine eio_lcio_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(116) :: buffer

    write (u, "(A)")  "* Test output: eio_lcio_1"
    write (u, "(A)")  "*   Purpose: write a LCIO file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)        
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
    
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lcio_1"
 
    allocate (eio_lcio_t :: eio)
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    !!! write (u, "(A)")
    !!! write (u, "(A)")  "* File contents (blanking out last two digits):"
    !!! write (u, "(A)")
    !!! 
    !!! u_file = free_unit ()
    !!! open (u_file, file = char (sample // ".hepmc"), &
    !!!      action = "read", status = "old")
    !!! do
    !!!    read (u_file, "(A)", iostat = iostat)  buffer
    !!!    if (iostat /= 0)  exit
    !!!    if (trim (buffer) == "")  cycle
    !!!    if (buffer(1:14) == "HepMC::Version")  cycle
    !!!    if (buffer(1:10) == "P 10001 25") &
    !!!         call buffer_blanker (buffer, 32, 55, 78)
    !!!    if (buffer(1:10) == "P 10002 25") &
    !!!         call buffer_blanker (buffer, 33, 56, 79)
    !!!    if (buffer(1:10) == "P 10003 25") &
    !!!         call buffer_blanker (buffer, 29, 53, 78, 101)
    !!!    if (buffer(1:10) == "P 10004 25") &
    !!!         call buffer_blanker (buffer, 28, 51, 76, 99)       
    !!!    write (u, "(A)") trim (buffer)
    !!! end do
    !!! close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_lcio_t :: eio)
    
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lcio_1"

  end subroutine eio_lcio_1
  
@ %def eio_lcio_1
@ Test also the reading of LCIO events.
<<EIO LCIO: execute tests>>=
  call test (eio_lcio_2, "eio_lcio_2", &
       "read event contents", &
       u, results)
<<EIO LCIO: tests>>=
  subroutine eio_lcio_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(model_t), pointer :: fallback_model
    type(os_data_t) :: os_data
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lcio_2"
    write (u, "(A)")  "*   Purpose: read a LCIO event"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LCIO data file"
    write (u, "(A)")
    
    u_file = free_unit ()
    sample = "eio_lcio_2"
    open (u_file, file = char (sample // ".slcio"), &
         status = "replace", action = "readwrite")
    
    !!! write (u_file, "(A)")  "HepMC::Version 2.06.09"
    !!! write (u_file, "(A)")  "HepMC::IO_GenEvent-START_EVENT_LISTING"
    !!! write (u_file, "(A)")  "E 0 -1 -1.0000000000000000e+00 &
    !!!      &-1.0000000000000000e+00 &
    !!!      &-1.0000000000000000e+00 42 0 1 10001 10002 0 0"
    !!! write (u_file, "(A)")  "U GEV MM"
    !!! write (u_file, "(A)")  "V -1 0 0 0 0 0 2 2 0"
    !!! write (u_file, "(A)")  "P 10001 25 0 0 4.8412291827592713e+02 &
    !!!      &5.0000000000000000e+02 &
    !!!      &1.2499999999999989e+02 3 0 0 -1 0"
    !!! write (u_file, "(A)")  "P 10002 25 0 0 -4.8412291827592713e+02 &
    !!!      &5.0000000000000000e+02 &
    !!!      &1.2499999999999989e+02 3 0 0 -1 0"
    !!! write (u_file, "(A)")  "P 10003 25 -1.4960220911365536e+02 &
    !!!      &-4.6042825611414656e+02 &
    !!!      &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    !!! write (u_file, "(A)")  "P 10004 25 1.4960220911365536e+02 &
    !!!      &4.6042825611414656e+02 &
    !!!      &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    !!! write (u_file, "(A)")  "HepMC::IO_GenEvent-END_EVENT_LISTING"
    !!! close (u_file)

    
    write (u, "(A)")  "* Initialize test process" 
    write (u, "(A)")
    
    call syntax_model_file_init ()    
    call os_data_init (os_data)
    call model_list%read_model (var_str ("SM_hadrons"), &
         var_str ("SM_hadrons.mdl"), os_data, fallback_model)

    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
    
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
 
    allocate (eio_lcio_t :: eio)
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters (recover_beams = .false.)
    end select            
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)

    write (u, "(A)")    
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")
             
    call eio%init_in (sample, [process_ptr], data)
    call eio%write (u)    
    
    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")
 
    call eio%input_i_prc (i_prc, iostat)

    select type (eio)
    type is (eio_lcio_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
    
    call eio%input_event (event, iostat)
    
    call event%write (u)
        
    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")
    
    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lcio_2"
    
  end subroutine eio_lcio_2
  
@ %def eio_lcio_2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ASCII File Formats}
Here, we implement several ASCII file formats. It is possible to
switch between them using flags.
<<[[eio_ascii.f90]]>>=
<<File header>>

module eio_ascii
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data
  use eio_base
  use hep_common
  use hep_events

<<Standard module head>>

<<EIO ascii: public>>

<<EIO ascii: types>>

contains
  
<<EIO ascii: procedures>>

<<EIO ascii: tests>>

end module eio_ascii
@ %def eio_ascii
@
\subsection{Type}
<<EIO ascii: public>>=
  public :: eio_ascii_t
<<EIO ascii: types>>=
  type, abstract, extends (eio_t) :: eio_ascii_t
     logical :: writing = .false.
     integer :: unit = 0
     logical :: keep_beams = .false.     
   contains
   <<EIO ascii: eio ascii: TBP>>
  end type eio_ascii_t
  
@ %def eio_ascii_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_ascii_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_ascii_t
  end type eio_ascii_ascii_t
  
@ %def eio_ascii_ascii_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_athena_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_athena_t
  end type eio_ascii_athena_t
  
@ %def eio_ascii_athena_t
@ The debug format has a few options that can be controlled by
Sindarin variables.
<<EIO ascii: public>>=
  public :: eio_ascii_debug_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_debug_t
     logical :: show_process = .true.
     logical :: show_transforms = .true.
     logical :: show_decay = .true.
     logical :: verbose = .true.
  end type eio_ascii_debug_t
  
@ %def eio_ascii_debug_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_hepevt_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_hepevt_t
  end type eio_ascii_hepevt_t
  
@ %def eio_ascii_hepevt_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_hepevt_verb_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_hepevt_verb_t
  end type eio_ascii_hepevt_verb_t
  
@ %def eio_ascii_hepevt_verb_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_lha_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_lha_t
  end type eio_ascii_lha_t
  
@ %def eio_ascii_lha_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_lha_verb_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_lha_verb_t
  end type eio_ascii_lha_verb_t
   
@ %def eio_ascii_lha_verb_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_long_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_long_t
  end type eio_ascii_long_t
  
@ %def eio_ascii_long_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_mokka_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_mokka_t
  end type eio_ascii_mokka_t
  
@ %def eio_ascii_mokka_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_short_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_short_t
  end type eio_ascii_short_t
  
@ %def eio_ascii_short_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with ASCII file formats.  In
particular, this is the file extension.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: set_parameters => eio_ascii_set_parameters
<<EIO ascii: procedures>>=
  subroutine eio_ascii_set_parameters (eio, keep_beams, extension, &
       show_process, show_transforms, show_decay, verbose)
    class(eio_ascii_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    type(string_t), intent(in), optional :: extension
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (extension)) then
       eio%extension = extension
    else
       select type (eio)
       type is (eio_ascii_ascii_t)
          eio%extension = "evt"
       type is (eio_ascii_athena_t)
          eio%extension = "athena.evt"
       type is (eio_ascii_debug_t)
          eio%extension = "debug"
       type is (eio_ascii_hepevt_t)
          eio%extension = "hepevt"
       type is (eio_ascii_hepevt_verb_t)
          eio%extension = "hepevt.verb"          
       type is (eio_ascii_lha_t)
          eio%extension = "lha"
       type is (eio_ascii_lha_verb_t)
          eio%extension = "lha.verb"          
       type is (eio_ascii_long_t)
          eio%extension = "long.evt"
       type is (eio_ascii_mokka_t)
          eio%extension = "mokka.evt"
       type is (eio_ascii_short_t)
          eio%extension = "short.evt"
       end select
    end if
    select type (eio)
    type is (eio_ascii_debug_t)
       if (present (show_process))  eio%show_process = show_process
       if (present (show_transforms))  eio%show_transforms = show_transforms
       if (present (show_decay))  eio%show_decay = show_decay
       if (present (verbose))  eio%verbose = verbose
    end select
  end subroutine eio_ascii_set_parameters
  
@ %def eio_ascii_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: write => eio_ascii_write
<<EIO ascii: procedures>>=
  subroutine eio_ascii_write (object, unit)
    class(eio_ascii_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    select type (object)
    type is (eio_ascii_ascii_t)
       write (u, "(1x,A)")  "ASCII event stream (default format):"
    type is (eio_ascii_athena_t)
       write (u, "(1x,A)")  "ASCII event stream (ATHENA format):"
    type is (eio_ascii_debug_t)
       write (u, "(1x,A)")  "ASCII event stream (Debugging format):"
    type is (eio_ascii_hepevt_t)
       write (u, "(1x,A)")  "ASCII event stream (HEPEVT format):"
    type is (eio_ascii_hepevt_verb_t)
       write (u, "(1x,A)")  "ASCII event stream (verbose HEPEVT format):"
    type is (eio_ascii_lha_t)
       write (u, "(1x,A)")  "ASCII event stream (LHA format):"
    type is (eio_ascii_lha_verb_t)
       write (u, "(1x,A)")  "ASCII event stream (verbose LHA format):"
    type is (eio_ascii_long_t)
       write (u, "(1x,A)")  "ASCII event stream (long format):"
    type is (eio_ascii_mokka_t)
       write (u, "(1x,A)")  "ASCII event stream (MOKKA format):"
    type is (eio_ascii_short_t)
       write (u, "(1x,A)")  "ASCII event stream (short format):"
    end select
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    select type (object)
    type is (eio_ascii_debug_t)
       write (u, "(3x,A,L1)")    "Show process      = ", object%show_process
       write (u, "(3x,A,L1)")    "Show transforms   = ", object%show_transforms
       write (u, "(3x,A,L1)")    "Show decay tree   = ", object%show_decay
       write (u, "(3x,A,L1)")    "Verbose output    = ", object%verbose
    end select
  end subroutine eio_ascii_write
  
@ %def eio_ascii_write
@ Finalizer: close any open file.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: final => eio_ascii_final
<<EIO ascii: procedures>>=
  subroutine eio_ascii_final (object)
    class(eio_ascii_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing ASCII file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%writing = .false.
    end if
  end subroutine eio_ascii_final
  
@ %def eio_ascii_final
@ Initialize event writing.

Check weight normalization.  This applies to all ASCII-type files that
use the HEPRUP common block.  We can't allow normalization conventions
that are not covered by the HEPRUP definition.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: init_out => eio_ascii_init_out
<<EIO ascii: procedures>>=
  subroutine eio_ascii_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_ascii_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: i
    if (.not. present (data)) &
         call msg_bug ("ASCII initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("ASCII: defined for scattering processes only")
    eio%sample = sample
    call eio%check_normalization (data)
    call eio%set_splitting (data)
    call eio%set_filename ()
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to ASCII file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    open (eio%unit, file = char (eio%filename), &
         action = "write", status = "replace")
    select type (eio)
    type is (eio_ascii_lha_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))
       end do
       call heprup_write_ascii (eio%unit)    
    type is (eio_ascii_lha_verb_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))
       end do
       call heprup_write_verbose (eio%unit)        
    end select
    if (present (success))  success = .true.
  end subroutine eio_ascii_init_out
    
@ %def eio_ascii_init_out
@ Some event properties do not go well with some output formats.  In
particular, many formats require unweighted events.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: check_normalization => eio_ascii_check_normalization
<<EIO ascii: procedures>>=
  subroutine eio_ascii_check_normalization (eio, data)
    class(eio_ascii_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    if (data%unweighted) then
    else
       select type (eio)
       type is (eio_ascii_athena_t);  call msg_fatal &
            ("Event output (Athena format): events must be unweighted.")
       type is (eio_ascii_hepevt_t);  call msg_fatal &
            ("Event output (HEPEVT format): events must be unweighted.")
       type is (eio_ascii_hepevt_verb_t);  call msg_fatal &
            ("Event output (HEPEVT format): events must be unweighted.")
       end select
       select case (data%norm_mode)
       case (NORM_SIGMA)
       case default
          select type (eio)
          type is (eio_ascii_lha_t)
             call msg_fatal &
                  ("Event output (LHA): normalization for weighted events &
                  &must be 'sigma'")
          type is (eio_ascii_lha_verb_t)
             call msg_fatal &
                  ("Event output (LHA): normalization for weighted events &
                  &must be 'sigma'")
          end select
       end select
    end if
  end subroutine eio_ascii_check_normalization
  
@ %def check_normalization
@ Initialize event reading.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: init_in => eio_ascii_init_in
<<EIO ascii: procedures>>=
  subroutine eio_ascii_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_ascii_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("ASCII: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_ascii_init_in
    
@ %def eio_ascii_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: switch_inout => eio_ascii_switch_inout
<<EIO ascii: procedures>>=
  subroutine eio_ascii_switch_inout (eio, success)
    class(eio_ascii_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("ASCII: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_ascii_switch_inout
  
@ %def eio_ascii_switch_inout
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO ascii: eio ascii: TBP>>=
  procedure :: split_out => eio_ascii_split_out
<<EIO ascii: procedures>>=
  subroutine eio_ascii_split_out (eio)
    class(eio_ascii_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to ASCII file '", &
            char (eio%filename), "'"
       call msg_message ()
       close (eio%unit)
       open (eio%unit, file = char (eio%filename), &
            action = "write", status = "replace")
       select type (eio)
       type is (eio_ascii_lha_t)
          call heprup_write_ascii (eio%unit)    
       type is (eio_ascii_lha_verb_t)
          call heprup_write_verbose (eio%unit)        
       end select
    end if
  end subroutine eio_ascii_split_out
  
@ %def eio_ascii_split_out
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: output => eio_ascii_output
<<EIO ascii: procedures>>=
  subroutine eio_ascii_output (eio, event, i_prc, reading)
    class(eio_ascii_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    if (eio%writing) then
       select type (eio)
       type is (eio_ascii_lha_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call hepeup_write_lha (eio%unit)
       type is (eio_ascii_lha_verb_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call hepeup_write_verbose (eio%unit)          
       type is (eio_ascii_ascii_t)
          call event%write (eio%unit, &
               show_process = .false., &
               show_transforms = .false., &
               show_decay = .false., &
               verbose = .false.)
       type is (eio_ascii_athena_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &          
               keep_beams = eio%keep_beams)
          call hepevt_write_athena (eio%unit)                    
       type is (eio_ascii_debug_t)
          call event%write (eio%unit, &
               show_process = eio%show_process, &
               show_transforms = eio%show_transforms, &
               show_decay = eio%show_decay, &
               verbose = eio%verbose)
       type is (eio_ascii_hepevt_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_hepevt (eio%unit)                              
       type is (eio_ascii_hepevt_verb_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_verbose (eio%unit)
       type is (eio_ascii_long_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, & 
               keep_beams = eio%keep_beams)
          call hepevt_write_ascii (eio%unit, .true.)                           
       type is (eio_ascii_mokka_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_mokka (eio%unit)                              
       type is (eio_ascii_short_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &  
               keep_beams = eio%keep_beams)
          call hepevt_write_ascii (eio%unit, .false.)                    
       end select       
    else
       call eio%write ()
       call msg_fatal ("ASCII file is not open for writing")
    end if
  end subroutine eio_ascii_output

@ %def eio_ascii_output
@ Input an event.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: input_i_prc => eio_ascii_input_i_prc
  procedure :: input_event => eio_ascii_input_event
<<EIO ascii: procedures>>=
  subroutine eio_ascii_input_i_prc (eio, i_prc, iostat)
    class(eio_ascii_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("ASCII: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_ascii_input_i_prc

  subroutine eio_ascii_input_event (eio, event, iostat)
    class(eio_ascii_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("ASCII: event input not supported")
    iostat = 1
  end subroutine eio_ascii_input_event

@ %def eio_ascii_input_i_prc
@ %def eio_ascii_input_event
@
\subsection{Unit tests}
<<EIO ascii: public>>=
  public :: eio_ascii_test
<<EIO ascii: tests>>=
  subroutine eio_ascii_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO ascii: execute tests>>
  end subroutine eio_ascii_test
  
@ %def eio_ascii_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods, method [[ascii]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_1, "eio_ascii_1", &
       "read and write event contents, format [ascii]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_1"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII ascii format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_1"
 
    allocate (eio_ascii_ascii_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_ascii_t :: eio)
    
    select type (eio)
    type is (eio_ascii_ascii_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_1"
    
  end subroutine eio_ascii_1
  
@ %def eio_ascii_1
@ 
We test the implementation of all I/O methods, method [[athena]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_2, "eio_ascii_2", &
       "read and write event contents, format [athena]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_2"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII athena format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_2"
 
    allocate (eio_ascii_athena_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char(sample // ".athena.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_athena_t :: eio)
    
    select type (eio)
    type is (eio_ascii_athena_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_2"
    
  end subroutine eio_ascii_2
  
@ %def eio_ascii_2
@ 
We test the implementation of all I/O methods, method [[debug]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_3, "eio_ascii_3", &
       "read and write event contents, format [debug]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_3 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_3"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII debug format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_3"
 
    allocate (eio_ascii_debug_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".debug"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_debug_t :: eio)
    
    select type (eio)
    type is (eio_ascii_debug_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_3"
    
  end subroutine eio_ascii_3
  
@ %def eio_ascii_3
@ 
We test the implementation of all I/O methods, method [[hepevt]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_4, "eio_ascii_4", &
       "read and write event contents, format [hepevt]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_4 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_4"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII hepevt format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_4"
 
    allocate (eio_ascii_hepevt_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepevt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_hepevt_t :: eio)
    
    select type (eio)
    type is (eio_ascii_hepevt_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_4"
    
  end subroutine eio_ascii_4
  
@ %def eio_ascii_4
@ 
We test the implementation of all I/O methods, method [[lha]] (old LHA):
<<EIO ascii: execute tests>>=
  call test (eio_ascii_5, "eio_ascii_5", &
       "read and write event contents, format [lha]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_5 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_5"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII LHA format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_5"
 
    allocate (eio_ascii_lha_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lha"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_lha_t :: eio)
    
    select type (eio)
    type is (eio_ascii_lha_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_5"
    
  end subroutine eio_ascii_5
  
@ %def eio_ascii_5
@ 
We test the implementation of all I/O methods, method [[long]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_6, "eio_ascii_6", &
       "read and write event contents, format [long]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_6 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_6"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII long format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_6"
 
    allocate (eio_ascii_long_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".long.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_long_t :: eio)
    
    select type (eio)
    type is (eio_ascii_long_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_6"
    
  end subroutine eio_ascii_6
  
@ %def eio_ascii_6
@ 
We test the implementation of all I/O methods, method [[mokka]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_7, "eio_ascii_7", &
       "read and write event contents, format [mokka]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_7 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_7"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII mokka format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_7"
 
    allocate (eio_ascii_mokka_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".mokka.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_mokka_t :: eio)
    
    select type (eio)
    type is (eio_ascii_mokka_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_7"
    
  end subroutine eio_ascii_7
  
@ %def eio_ascii_7
@ 
We test the implementation of all I/O methods, method [[short]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_8, "eio_ascii_8", &
       "read and write event contents, format [short]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_8 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_8"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII short format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_8"
 
    allocate (eio_ascii_short_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".short.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_short_t :: eio)
    
    select type (eio)
    type is (eio_ascii_short_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_8"
    
  end subroutine eio_ascii_8
  
@ %def eio_ascii_8
@ 
We test the implementation of all I/O methods, method [[lha]]  (old
LHA) in verbose version:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_9, "eio_ascii_9", &
       "read and write event contents, format [lha_verb]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_9 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_9"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII LHA verbose format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_9"
 
    allocate (eio_ascii_lha_verb_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lha.verb"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_lha_verb_t :: eio)
    
    select type (eio)
    type is (eio_ascii_lha_verb_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_9"
    
  end subroutine eio_ascii_9
  
@ %def eio_ascii_9 
@ 
We test the implementation of all I/O methods, method [[hepevt_verb]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_10, "eio_ascii_10", &
       "read and write event contents, format [hepevt_verb]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_10 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_10"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII hepevt verbose format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_10"
 
    allocate (eio_ascii_hepevt_verb_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepevt.verb"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_hepevt_verb_t :: eio)
    
    select type (eio)
    type is (eio_ascii_hepevt_verb_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_10"
    
  end subroutine eio_ascii_10
  
@ %def eio_ascii_10
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{STDHEP File Formats}
Here, we implement the two existing STDHEP file formats, one based on the
HEPRUP/HEPEUP common blocks, the other based on the HEPEVT common block.
The second one is actually the standard STDHEP format.
<<[[eio_stdhep.f90]]>>=
<<File header>>

module eio_stdhep
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data
  use eio_base
  use hep_common
  use hep_events

<<Standard module head>>

<<EIO stdhep: public>>

<<EIO stdhep: types>>

<<EIO stdhep: variables>>

contains
  
<<EIO stdhep: procedures>>

<<EIO stdhep: tests>>

end module eio_stdhep
@ %def eio_stdhep
@
\subsection{Type}
<<EIO stdhep: public>>=
  public :: eio_stdhep_t
<<EIO stdhep: types>>=
  type, abstract, extends (eio_t) :: eio_stdhep_t
     logical :: writing = .false.
     logical :: reading = .false.
     integer :: unit = 0
     logical :: keep_beams = .false.     
     integer(i64) :: n_events_expected = 0
   contains
   <<EIO stdhep: eio stdhep: TBP>>
  end type eio_stdhep_t
  
@ %def eio_stdhep_t
@
<<EIO stdhep: public>>=
  public :: eio_stdhep_hepevt_t
<<EIO stdhep: types>>=
  type, extends (eio_stdhep_t) :: eio_stdhep_hepevt_t
  end type eio_stdhep_hepevt_t
  
@ %def eio_stdhep_hepevt_t
@
<<EIO stdhep: public>>=
  public :: eio_stdhep_hepeup_t
<<EIO stdhep: types>>=
  type, extends (eio_stdhep_t) :: eio_stdhep_hepeup_t
  end type eio_stdhep_hepeup_t
  
@ %def eio_stdhep_hepeup_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with STDHEP file formats.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: set_parameters => eio_stdhep_set_parameters
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_set_parameters (eio, keep_beams, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    type(string_t), intent(in), optional :: extension
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (extension)) then
       eio%extension = extension
    else
       select type (eio)
       type is (eio_stdhep_hepevt_t)
          eio%extension = "hep"
       type is (eio_stdhep_hepeup_t)
          eio%extension = "up.hep"
       end select
    end if
  end subroutine eio_stdhep_set_parameters
  
@ %def eio_ascii_stdhep_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: write => eio_stdhep_write
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_write (object, unit)
    class(eio_stdhep_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "STDHEP event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
  end subroutine eio_stdhep_write
  
@ %def eio_stdhep_write
@ Finalizer: close any open file.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: final => eio_stdhep_final
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_final (object)
    class(eio_stdhep_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing STDHEP file '", &
            char (object%filename), "'"
       call msg_message ()
       call stdhep_end
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing STDHEP file '", &
            char (object%filename), "'"
       call msg_message ()
       object%reading = .false.
    end if
  end subroutine eio_stdhep_final
  
@ %def eio_stdhep_final
@ Common initialization for input and output.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: common_init => eio_stdhep_common_init
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_common_init (eio, sample, data, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("STDHEP initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("STDHEP: defined for scattering processes only")
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()    
    eio%unit = free_unit ()    
  end subroutine eio_stdhep_common_init

@ %def eio_stdhep_common_init
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: split_out => eio_stdhep_split_out
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_split_out (eio)
    class(eio_stdhep_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to STDHEP file '", &
            char (eio%filename), "'"
       call msg_message ()
       call stdhep_end
       select type (eio)
       type is (eio_stdhep_hepeup_t)
          call stdhep_init_out (char (eio%filename), &
               "WHIZARD event sample", eio%n_events_expected)
          call stdhep_write (STDHEP_HEPRUP)
       type is (eio_stdhep_hepevt_t)
          call stdhep_init_out (char (eio%filename), &
               "WHIZARD event sample", eio%n_events_expected) 
       end select
    end if
  end subroutine eio_stdhep_split_out
  
@ %def eio_stdhep_split_out
@ Initialize event writing.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: init_out => eio_stdhep_init_out
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: i
    if (.not. present (data)) &
         call msg_bug ("STDHEP initialization: missing data")        
    eio%sample = sample
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    eio%n_events_expected = data%n_evt
    write (msg_buffer, "(A,A,A)")  "Events: writing to STDHEP file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))          
       end do
       call stdhep_init_out (char (eio%filename), &
            "WHIZARD event sample", eio%n_events_expected)
       call stdhep_write (STDHEP_HEPRUP)
    type is (eio_stdhep_hepevt_t)
       call stdhep_init_out (char (eio%filename), &
            "WHIZARD event sample", eio%n_events_expected) 
    end select
    if (present (success))  success = .true.
  end subroutine eio_stdhep_init_out
    
@ %def eio_stdhep_init_out
@ Initialize event reading.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: init_in => eio_stdhep_init_in
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    
    call msg_bug ("STDHEP: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_stdhep_init_in
    
@ %def eio_stdhep_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: switch_inout => eio_stdhep_switch_inout
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_switch_inout (eio, success)
    class(eio_stdhep_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("STDHEP: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_stdhep_switch_inout
  
@ %def eio_stdhep_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: output => eio_stdhep_output
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_output (eio, event, i_prc, reading)
    class(eio_stdhep_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    if (eio%writing) then
       select type (eio)
       type is (eio_stdhep_hepeup_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call stdhep_write (STDHEP_HEPEUP)
       type is (eio_stdhep_hepevt_t)
          call hepevt_from_event (event, &
               i_evt = event%expr%index, &                         
               keep_beams = eio%keep_beams)
          call stdhep_write (STDHEP_HEPEVT)                              
       end select       
    else
       call eio%write ()
       call msg_fatal ("STDHEP file is not open for writing")
    end if
  end subroutine eio_stdhep_output

@ %def eio_stdhep_output
@ Input an event.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: input_i_prc => eio_stdhep_input_i_prc
  procedure :: input_event => eio_stdhep_input_event
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_input_i_prc (eio, i_prc, iostat)
    class(eio_stdhep_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("STDHEP: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_stdhep_input_i_prc

  subroutine eio_stdhep_input_event (eio, event, iostat)
    class(eio_stdhep_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("STDHEP: event input not supported")
    iostat = 1
  end subroutine eio_stdhep_input_event

@ %def eio_stdhep_input_i_prc
@ %def eio_stdhep_input_event
@ STDHEP speficic routines.
<<EIO stdhep: public>>=
  public :: stdhep_init_out
  public :: stdhep_init_in
  public :: stdhep_write 
  public :: stdhep_end  
<<EIO stdhep: procedures>>=
  subroutine stdhep_init_out (file, title, nevt)
    character(len=*), intent(in) :: file, title
    integer(i64), intent(in) :: nevt
    integer(i32) :: nevt32
    external stdxwinit, stdxwrt
    nevt32 = min (nevt, int (huge (1_i32), i64))
    call stdxwinit (file, title, nevt32, istr, lok)
    call stdxwrt (100, istr, lok)
  end subroutine stdhep_init_out

  subroutine stdhep_init_in (file, nevt)
    character(len=*), intent(in) :: file
    integer(i64), intent(in) :: nevt
    integer(i32) :: nevt32
    external stdx
  end subroutine stdhep_init_in
  
  subroutine stdhep_write (ilbl)
    integer, intent(in) :: ilbl
    external stdxwrt
    call stdxwrt (ilbl, istr, lok)
  end subroutine stdhep_write

  subroutine stdhep_read (ilbl, lok)
    integer, intent(out) :: ilbl
    logical, intent(out) :: lok
    external stdxrd
    call stdxrd (ilbl, istr, lok)
  end subroutine stdhep_read
  
  subroutine stdhep_end
    external stdxend, stdxwrt
    call stdxwrt (200, istr, lok)
    call stdxend (istr)
  end subroutine stdhep_end  
  
@  %def stdhep_init stdhep_read stdhep_write stdhep_end
@ 
\subsection{Variables}
<<EIO stdhep: variables>>=
  integer, save :: istr, lok
  integer, parameter :: &
       STDHEP_HEPEVT = 1, STDHEP_HEPEUP = 11, STDHEP_HEPRUP = 12
@ 
\subsection{Unit tests}
<<EIO stdhep: public>>=
  public :: eio_stdhep_test
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO stdhep: execute tests>>
  end subroutine eio_stdhep_test
  
@ %def eio_stdhep_test 
@
\subsubsection{Test I/O methods}
We test the implementation of the STDHEP HEPEVT I/O method:
<<EIO stdhep: execute tests>>=
  call test (eio_stdhep_1, "eio_stdhep_1", &
       "read and write event contents, format [stdhep]", &
       u, results)
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_stdhep_1"
    write (u, "(A)")  "*   Purpose: generate an event in STDHEP HEPEVT format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_stdhep_1"
 
    allocate (eio_stdhep_hepevt_t :: eio)
    select type (eio)
    type is (eio_stdhep_hepevt_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hep"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
    end do
    !!! JRR: WK please check: should be replaced by a XDR reader? (#530)
    !  write (u, "(A)") trim (buffer) 
    !  The number of lines is system-dependent!
    write (u, "(A)") "     Successfully read STDHEP HEPEVT file"    
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_stdhep_hepevt_t :: eio)
    
    select type (eio)
    type is (eio_stdhep_hepevt_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_stdhep_1"
    
  end subroutine eio_stdhep_1
  
@ %def eio_stdhep_1
@ 
We test the implementation of the STDHEP HEPEUP I/O method:
<<EIO stdhep: execute tests>>=
  call test (eio_stdhep_2, "eio_stdhep_2", &
       "read and write event contents, format [stdhep]", &
       u, results)
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_stdhep_2"
    write (u, "(A)")  "*   Purpose: generate an event in STDHEP HEPEUP format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_stdhep_2"
 
    allocate (eio_stdhep_hepeup_t :: eio)
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call eio%set_parameters ()
    end select    
    
    call eio%init_out (sample, [process_ptr], data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char(sample // ".up.hep"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
    end do
    !!! JRR: WK please check: should be replaced by a XDR reader? (#530)
    !  write (u, "(A)") trim (buffer)
    !  The number of lines is system-dependent!    
    write (u, "(A)") "     Successfully read STDHEP HEPEUP file"    
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_stdhep_hepeup_t :: eio)
    
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_stdhep_2"
    
  end subroutine eio_stdhep_2
  
@ %def eio_stdhep_2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Event Weight Output}
This is an output-only format.  For each event, we print the indices
that identify process, process part (MCI group), and term.  As
numerical information we print the squared matrix element (trace) and
the event weight.
<<[[eio_weights.f90]]>>=
<<File header>>

module eio_weights
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use variables
  use models
  use particles
  use beams
  use processes
  use events
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO weights: public>>

<<EIO weights: types>>

contains
  
<<EIO weights: procedures>>

<<EIO weights: tests>>

end module eio_weights
@ %def eio_weights
@
\subsection{Type}
<<EIO weights: public>>=
  public :: eio_weights_t
<<EIO weights: types>>=
  type, extends (eio_t) :: eio_weights_t
     logical :: writing = .false.
     integer :: unit = 0
     logical :: pacify = .false.
   contains
   <<EIO weights: eio weights: TBP>>
  end type eio_weights_t
  
@ %def eio_weights_t
@
\subsection{Specific Methods}
Set pacify flags.
<<EIO weights: eio weights: TBP>>=
  procedure :: set_parameters => eio_weights_set_parameters
<<EIO weights: procedures>>=
  subroutine eio_weights_set_parameters (eio, pacify)
    class(eio_weights_t), intent(inout) :: eio
    logical, intent(in), optional :: pacify
    if (present (pacify))  eio%pacify = pacify    
    eio%extension = "weights.dat"
  end subroutine eio_weights_set_parameters
  
@ %def eio_weights_set_parameters
@ 
\subsection{Common Methods}
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO weights: eio weights: TBP>>=
  procedure :: write => eio_weights_write
<<EIO weights: procedures>>=
  subroutine eio_weights_write (object, unit)
    class(eio_weights_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Weight stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
       write (u, "(3x,A,L1)") "Reduced I/O prec. = ", object%pacify 
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_weights_write
  
@ %def eio_weights_write
@ Finalizer: close any open file.
<<EIO weights: eio weights: TBP>>=
  procedure :: final => eio_weights_final
<<EIO weights: procedures>>=
  subroutine eio_weights_final (object)
    class(eio_weights_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing weight stream file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%writing = .false.
    end if
  end subroutine eio_weights_final
  
@ %def eio_weights_final
@ Initialize event writing.
<<EIO weights: eio weights: TBP>>=
  procedure :: init_out => eio_weights_init_out
<<EIO weights: procedures>>=
  subroutine eio_weights_init_out &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_weights_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    if (present(extension)) then
       eio%extension = extension
    else 
       eio%extension = "weights.dat"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to weight stream file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    open (eio%unit, file = char (eio%filename), &
         action = "write", status = "replace")
    if (present (success))  success = .true.
  end subroutine eio_weights_init_out
    
@ %def eio_weights_init_out
@ Initialize event reading.
<<EIO weights: eio weights: TBP>>=
  procedure :: init_in => eio_weights_init_in
<<EIO weights: procedures>>=
  subroutine eio_weights_init_in &
       (eio, sample, process_ptr, data, success, extension)
    class(eio_weights_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("Weight stream: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_weights_init_in
    
@ %def eio_weights_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO weights: eio weights: TBP>>=
  procedure :: switch_inout => eio_weights_switch_inout
<<EIO weights: procedures>>=
  subroutine eio_weights_switch_inout (eio, success)
    class(eio_weights_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("Weight stream: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_weights_switch_inout
  
@ %def eio_weights_switch_inout
@ Output an event.  Write first the event indices, then weight and two
values of the squared matrix element: [[sqme_ref]] is the value stored
in the event record, and [[sqme_prc]] is the one stored in the process
instance.  (They can differ: when recalculating, the former is read
from file and the latter is the result of the new calculation.)

For the alternative entries, the [[sqme]] value is always obtained by
a new calculation, and thus qualifies as [[sqme_prc]].
<<EIO weights: eio weights: TBP>>=
  procedure :: output => eio_weights_output
<<EIO weights: procedures>>=
  subroutine eio_weights_output (eio, event, i_prc, reading)
    class(eio_weights_t), intent(inout) :: eio
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading
    integer :: i_mci, i_term, n_alt, i
    real(default) :: weight, sqme_ref, sqme_prc
    if (eio%writing) then
       i_mci = event%get_i_mci ()
       i_term = event%get_i_term ()
       weight = event%weight_prc
       sqme_ref = event%sqme_ref
       sqme_prc = event%sqme_prc
       n_alt = event%n_alt
1      format (I0,3(1x,ES17.10),3(1x,I0))
2      format (I0,3(1x,ES15.8),3(1x,I0))       
       if (eio%pacify) then
          write (eio%unit, 2)  0, weight, sqme_prc, sqme_ref, &
               i_prc, i_mci, i_term
       else
          write (eio%unit, 1)  0, weight, sqme_prc, sqme_ref, &
               i_prc, i_mci, i_term
       end if
       do i = 1, n_alt
          weight = event%weight_alt(i)
          sqme_prc = event%sqme_alt(i)
          if (eio%pacify) then
             write (eio%unit, 2)  i, weight, sqme_prc
          else
             write (eio%unit, 1)  i, weight, sqme_prc          
          end if
       end do
    else
       call eio%write ()
       call msg_fatal ("Weight stream file is not open for writing")
    end if
  end subroutine eio_weights_output

@ %def eio_weights_output
@ Input an event.
<<EIO weights: eio weights: TBP>>=
  procedure :: input_i_prc => eio_weights_input_i_prc
  procedure :: input_event => eio_weights_input_event
<<EIO weights: procedures>>=
  subroutine eio_weights_input_i_prc (eio, i_prc, iostat)
    class(eio_weights_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("Weight stream: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_weights_input_i_prc

  subroutine eio_weights_input_event (eio, event, iostat)
    class(eio_weights_t), intent(inout) :: eio
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("Weight stream: event input not supported")
    iostat = 1
  end subroutine eio_weights_input_event

@ %def eio_weights_input_i_prc
@ %def eio_weights_input_event
@
\subsection{Unit tests}
<<EIO weights: public>>=
  public :: eio_weights_test
<<EIO weights: tests>>=
  subroutine eio_weights_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO weights: execute tests>>
  end subroutine eio_weights_test
  
@ %def eio_weights_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO weights: execute tests>>=
  call test (eio_weights_1, "eio_weights_1", &
       "read and write event contents", &
       u, results)
<<EIO weights: tests>>=
  subroutine eio_weights_1 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_weights_1"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_weights_1"
 
    allocate (eio_weights_t :: eio)
    
    call eio%init_out (sample, [process_ptr])
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents: &
         &(weight, sqme(evt), sqme(prc), i_prc, i_mci, i_term)"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "eio_weights_1.weights.dat", &
         action = "read", status = "old")
    read (u_file, "(A)")  buffer
    write (u, "(A)") trim (buffer)
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_weights_1"
    
  end subroutine eio_weights_1
  
@ %def eio_weights_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO weights: execute tests>>=
  call test (eio_weights_2, "eio_weights_2", &
       "multiple weights", &
       u, results)
<<EIO weights: tests>>=
  subroutine eio_weights_2 (u)
    integer, intent(in) :: u
    type(model_list_t) :: model_list
    type(var_list_t) :: var_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, i
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_weights_2"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    call process_instance%setup_event_data ()

    call var_list_append_log (var_list, var_str ("?unweighted"), .false., &
         intrinsic = .true.)
    call var_list_append_string (var_list, var_str ("$sample_normalization"), &
         var_str ("auto"), intrinsic = .true.)

    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_weights_2"
 
    allocate (eio_weights_t :: eio)
    
    call eio%init_out (sample, [process_ptr])
    select type (eio)
    type is (eio_weights_t)
       call eio%set_parameters (pacify = .true.)
    end select
    call event%generate (1, [0._default, 0._default])
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = [2 * event%weight_prc, 3 * event%weight_prc])

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)") 
    write (u, "(A)")  "* File contents: &
         &(weight, sqme(evt), sqme(prc), i_prc, i_mci, i_term)"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "eio_weights_2.weights.dat", &
         action = "read", status = "old")
    do i = 1, 3
       read (u_file, "(A)")  buffer
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_weights_2"
    
  end subroutine eio_weights_2
  
@ %def eio_weights_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The SUSY Les Houches Accord}
The SUSY Les Houches Accord defines a standard interfaces for storing
the physics data of SUSY models.  Here, we provide the means
for reading, storing, and writing such data.
<<[[slha_interface.f90]]>>=
<<File header>>

module slha_interface

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use string_utils, only: upper_case
  use unit_tests
  use system_defs, only: VERSION_STRING
  use system_defs, only: EOF
  use diagnostics
  use os_interface
  use ifiles
  use lexers
  use syntax_rules
  use parser
  use variables
  use eval_trees
  use models

<<Standard module head>>

<<SLHA: public>>

<<SLHA: parameters>>

<<SLHA: variables>>

  save

contains

<<SLHA: procedures>>

<<SLHA: tests>>

end module slha_interface
@ %def slha_interface
@ 
\subsection{Preprocessor}
SLHA is a mixed-format standard.  It should be read in assuming free
format (but line-oriented), but it has some fixed-format elements.

To overcome this difficulty, we implement a preprocessing step which
transforms the SLHA into a format that can be swallowed by our generic
free-format lexer and parser.  Each line with a blank first character
is assumed to be a data line.  We prepend a 'DATA' keyword to these lines.
Furthermore, to enforce line-orientation, each line is appended a '\$'
key which is recognized by the parser.  To do this properly, we first
remove trailing comments, and skip lines consisting only of comments.

The preprocessor reads from a stream and puts out an [[ifile]].
Blocks that are not recognized are skipped.  For some blocks, data
items are quoted, so they can be read as strings if necessary.
<<SLHA: parameters>>=
  integer, parameter :: MODE_SKIP = 0, MODE_DATA = 1, MODE_INFO = 2

@ %def MODE_SKIP = 0, MODE_DATA = 1, MODE_INFO = 2
<<SLHA: procedures>>=
  subroutine slha_preprocess (stream, ifile)
    type(stream_t), intent(inout), target :: stream
    type(ifile_t), intent(out) :: ifile
    type(string_t) :: buffer, line, item
    integer :: iostat
    integer :: mode
    mode = MODE
    SCAN_FILE: do
       call stream_get_record (stream, buffer, iostat)
       select case (iostat)
       case (0)
          call split (buffer, line, "#")
          if (len_trim (line) == 0)  cycle SCAN_FILE
          select case (char (extract (line, 1, 1)))
          case ("B", "b")
             mode = check_block_handling (line)
             call ifile_append (ifile, line // "$")
          case ("D", "d")
             mode = MODE_DATA
             call ifile_append (ifile, line // "$")
          case (" ")
             select case (mode)
             case (MODE_DATA)
                call ifile_append (ifile, "DATA" // line // "$")
             case (MODE_INFO)
                line = adjustl (line)
                call split (line, item, " ")
                call ifile_append (ifile, "INFO" // " " // item // " " &
                     // '"' // trim (adjustl (line)) // '" $')
             end select
          case default
             call msg_message (char (line))
             call msg_fatal ("SLHA: Incomprehensible line")
          end select
       case (EOF)
          exit SCAN_FILE
       case default
          call msg_fatal ("SLHA: I/O error occured while reading SLHA input")
       end select
    end do SCAN_FILE
  end subroutine slha_preprocess

@ %def slha_preprocess
@ Return the mode that we should treat this block with.  We need
to recognize only those blocks that we actually use.
<<SLHA: procedures>>=
  function check_block_handling (line) result (mode)
    integer :: mode
    type(string_t), intent(in) :: line
    type(string_t) :: buffer, key, block_name
    buffer = trim (line)
    call split (buffer, key, " ")
    buffer = adjustl (buffer)
    call split (buffer, block_name, " ")
    block_name = trim (adjustl (upper_case (block_name)))
    select case (char (block_name))
    case ("MODSEL", "MINPAR", "SMINPUTS")
       mode = MODE_DATA
    case ("MASS")
       mode = MODE_DATA
    case ("NMIX", "UMIX", "VMIX", "STOPMIX", "SBOTMIX", "STAUMIX")
       mode = MODE_DATA
    case ("NMHMIX", "NMAMIX", "NMNMIX", "NMSSMRUN")
       mode = MODE_DATA
    case ("ALPHA", "HMIX")
       mode = MODE_DATA
    case ("AU", "AD", "AE")
       mode = MODE_DATA
    case ("SPINFO", "DCINFO")
       mode = MODE_INFO
    case default
       mode = MODE_SKIP
    end select
  end function check_block_handling

@ %def check_block_handling
@
\subsection{Lexer and syntax}
<<SLHA: variables>>=
  type(syntax_t), target :: syntax_slha

@ %def syntax_slha
<<SLHA: public>>=
  public :: syntax_slha_init
<<SLHA: procedures>>=
  subroutine syntax_slha_init ()
    type(ifile_t) :: ifile
    call define_slha_syntax (ifile)
    call syntax_init (syntax_slha, ifile)
    call ifile_final (ifile)
  end subroutine syntax_slha_init

@ %def syntax_slha_init
<<SLHA: public>>=
  public :: syntax_slha_final
<<SLHA: procedures>>=
  subroutine syntax_slha_final ()
    call syntax_final (syntax_slha)
  end subroutine syntax_slha_final

@ %def syntax_slha_final
<<SLHA: public>>=
  public :: syntax_slha_write
<<SLHA: procedures>>=
  subroutine syntax_slha_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_slha, unit)
  end subroutine syntax_slha_write

@ %def syntax_slha_write
<<SLHA: procedures>>=
  subroutine define_slha_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ slha = chunk*")
    call ifile_append (ifile, "ALT chunk = block_def | decay_def")
    call ifile_append (ifile, "SEQ block_def = " &
         // "BLOCK block_spec '$' block_line*")
    call ifile_append (ifile, "KEY BLOCK")
    call ifile_append (ifile, "SEQ block_spec = block_name qvalue?")
    call ifile_append (ifile, "IDE block_name")
    call ifile_append (ifile, "SEQ qvalue = qname '=' real")
    call ifile_append (ifile, "IDE qname")
    call ifile_append (ifile, "KEY '='")
    call ifile_append (ifile, "REA real")
    call ifile_append (ifile, "KEY '$'")
    call ifile_append (ifile, "ALT block_line = block_data | block_info")
    call ifile_append (ifile, "SEQ block_data = DATA data_line '$'")
    call ifile_append (ifile, "KEY DATA")
    call ifile_append (ifile, "SEQ data_line = data_item+")
    call ifile_append (ifile, "ALT data_item = signed_number | number")
    call ifile_append (ifile, "SEQ signed_number = sign number")
    call ifile_append (ifile, "ALT sign = '+' | '-'")
    call ifile_append (ifile, "ALT number = integer | real")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "KEY '-'")
    call ifile_append (ifile, "KEY '+'")
    call ifile_append (ifile, "SEQ block_info = INFO info_line '$'")
    call ifile_append (ifile, "KEY INFO")
    call ifile_append (ifile, "SEQ info_line = integer string_literal")
    call ifile_append (ifile, "QUO string_literal = '""'...'""'")
    call ifile_append (ifile, "SEQ decay_def = " &
         // "DECAY decay_spec '$' decay_data*")
    call ifile_append (ifile, "KEY DECAY")
    call ifile_append (ifile, "SEQ decay_spec = pdg_code data_item")
    call ifile_append (ifile, "ALT pdg_code = signed_integer | integer")
    call ifile_append (ifile, "SEQ signed_integer = sign integer")
    call ifile_append (ifile, "SEQ decay_data = DATA decay_line '$'")
    call ifile_append (ifile, "SEQ decay_line = data_item integer pdg_code+")
  end subroutine define_slha_syntax

@ %def define_slha_syntax
@ The SLHA specification allows for string data items in certain
places.  Currently, we do not interpret them, but the strings, which
are not quoted, must be parsed somehow.  The hack for this problem is
to allow essentially all characters as special characters, so the
string can be read before it is discarded.
<<SLHA: public>>=
  public :: lexer_init_slha 
<<SLHA: procedures>>=
  subroutine lexer_init_slha (lexer)
    type(lexer_t), intent(out) :: lexer
    call lexer_init (lexer, &
         comment_chars = "#", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "+-=$", &
         special_class = [ "" ], &
         keyword_list = syntax_get_keyword_list_ptr (syntax_slha), &
         upper_case_keywords = .true.)  ! $
  end subroutine lexer_init_slha

@ %def lexer_init_slha
@ 
\subsection{Interpreter}
\subsubsection{Find blocks}
From the parse tree, find the node that represents a particular
block.  If [[required]] is true, issue an error if not found.
Since [[block_name]] is always invoked with capital letters, we 
have to capitalize [[pn_block_name]]. 
<<SLHA: procedures>>=
  function slha_get_block_ptr &
       (parse_tree, block_name, required) result (pn_block)
    type(parse_node_t), pointer :: pn_block
    type(parse_tree_t), intent(in) :: parse_tree
    type(string_t), intent(in) :: block_name
    logical, intent(in) :: required
    type(parse_node_t), pointer :: pn_root, pn_block_spec, pn_block_name
    pn_root => parse_tree_get_root_ptr (parse_tree)
    pn_block => parse_node_get_sub_ptr (pn_root)
    do while (associated (pn_block))
       select case (char (parse_node_get_rule_key (pn_block)))
       case ("block_def")
          pn_block_spec => parse_node_get_sub_ptr (pn_block, 2)
          pn_block_name => parse_node_get_sub_ptr (pn_block_spec)
          if (trim (adjustl (upper_case (parse_node_get_string &
	           (pn_block_name)))) == block_name) then
             return
          end if
       end select
       pn_block => parse_node_get_next_ptr (pn_block)
    end do
    if (required) then
       call msg_fatal ("SLHA: block '" // char (block_name) // "' not found")
    end if
  end function slha_get_block_ptr

@ %def slha_get_blck_ptr
@ Scan the file for the first/next DECAY block.
<<SLHA: procedures>>=
  function slha_get_first_decay_ptr (parse_tree) result (pn_decay)
    type(parse_node_t), pointer :: pn_decay
    type(parse_tree_t), intent(in) :: parse_tree
    type(parse_node_t), pointer :: pn_root
    pn_root => parse_tree_get_root_ptr (parse_tree)
    pn_decay => parse_node_get_sub_ptr (pn_root)
    do while (associated (pn_decay))
       select case (char (parse_node_get_rule_key (pn_decay)))
       case ("decay_def")
          return
       end select
       pn_decay => parse_node_get_next_ptr (pn_decay)
    end do
  end function slha_get_first_decay_ptr

  function slha_get_next_decay_ptr (pn_block) result (pn_decay)
    type(parse_node_t), pointer :: pn_decay
    type(parse_node_t), intent(in), target :: pn_block
    pn_decay => parse_node_get_next_ptr (pn_block)
    do while (associated (pn_decay))
       select case (char (parse_node_get_rule_key (pn_decay)))
       case ("decay_def")
          return
       end select
       pn_decay => parse_node_get_next_ptr (pn_decay)
    end do
  end function slha_get_next_decay_ptr

@ %def slha_get_next_decay_ptr
@ 
\subsubsection{Extract and transfer data from blocks}
Given the parse node of a block, find the parse node of a particular
switch or data line.  Return this node and the node of the data item
following the integer code.
<<SLHA: procedures>>=
  subroutine slha_find_index_ptr (pn_block, pn_data, pn_item, code)
    type(parse_node_t), intent(in), target :: pn_block
    type(parse_node_t), intent(out), pointer :: pn_data
    type(parse_node_t), intent(out), pointer :: pn_item
    integer, intent(in) :: code
    pn_data => parse_node_get_sub_ptr (pn_block, 4)
    call slha_next_index_ptr (pn_data, pn_item, code)
  end subroutine slha_find_index_ptr

  subroutine slha_find_index_pair_ptr (pn_block, pn_data, pn_item, code1, code2)
    type(parse_node_t), intent(in), target :: pn_block
    type(parse_node_t), intent(out), pointer :: pn_data
    type(parse_node_t), intent(out), pointer :: pn_item
    integer, intent(in) :: code1, code2
    pn_data => parse_node_get_sub_ptr (pn_block, 4)
    call slha_next_index_pair_ptr (pn_data, pn_item, code1, code2)
  end subroutine slha_find_index_pair_ptr

@ %def slha_find_index_ptr slha_find_index_pair_ptr
@ Starting from the pointer to a data line, find a data line with the
given integer code.
<<SLHA: procedures>>=
  subroutine slha_next_index_ptr (pn_data, pn_item, code)
    type(parse_node_t), intent(inout), pointer :: pn_data
    integer, intent(in) :: code
    type(parse_node_t), intent(out), pointer :: pn_item
    type(parse_node_t), pointer :: pn_line, pn_code
    do while (associated (pn_data))
       pn_line => parse_node_get_sub_ptr (pn_data, 2)
       pn_code => parse_node_get_sub_ptr (pn_line)
       select case (char (parse_node_get_rule_key (pn_code)))
       case ("integer")
          if (parse_node_get_integer (pn_code) == code) then
             pn_item => parse_node_get_next_ptr (pn_code)
             return
          end if
       end select
       pn_data => parse_node_get_next_ptr (pn_data)
    end do
    pn_item => null ()
  end subroutine slha_next_index_ptr

@ %def slha_next_index_ptr
@ Starting from the pointer to a data line, find a data line with the
given integer code pair.
<<SLHA: procedures>>=
  subroutine slha_next_index_pair_ptr (pn_data, pn_item, code1, code2)
    type(parse_node_t), intent(inout), pointer :: pn_data
    integer, intent(in) :: code1, code2
    type(parse_node_t), intent(out), pointer :: pn_item
    type(parse_node_t), pointer :: pn_line, pn_code1, pn_code2
    do while (associated (pn_data))
       pn_line => parse_node_get_sub_ptr (pn_data, 2)
       pn_code1 => parse_node_get_sub_ptr (pn_line)
       select case (char (parse_node_get_rule_key (pn_code1)))
       case ("integer")
          if (parse_node_get_integer (pn_code1) == code1) then
             pn_code2 => parse_node_get_next_ptr (pn_code1)
             if (associated (pn_code2)) then
                select case (char (parse_node_get_rule_key (pn_code2)))
                case ("integer")
                   if (parse_node_get_integer (pn_code2) == code2) then
                      pn_item => parse_node_get_next_ptr (pn_code2)
                      return
                   end if
                end select
             end if
          end if
       end select
       pn_data => parse_node_get_next_ptr (pn_data)
    end do
    pn_item => null ()
  end subroutine slha_next_index_pair_ptr

@ %def slha_next_index_pair_ptr
@ 
\subsubsection{Handle info data}
Return all strings with index [[i]].  The result is an allocated
string array.  Since we do not know the number of matching entries in
advance, we build an intermediate list which is transferred to the
final array and deleted before exiting.
<<SLHA: procedures>>=
  subroutine retrieve_strings_in_block (pn_block, code, str_array)
    type(parse_node_t), intent(in), target :: pn_block
    integer, intent(in) :: code
    type(string_t), dimension(:), allocatable, intent(out) :: str_array
    type(parse_node_t), pointer :: pn_data, pn_item
    type :: str_entry_t
       type(string_t) :: str
       type(str_entry_t), pointer :: next => null ()
    end type str_entry_t
    type(str_entry_t), pointer :: first => null ()
    type(str_entry_t), pointer :: current => null ()
    integer :: n
    n = 0
    call slha_find_index_ptr (pn_block, pn_data, pn_item, code)
    if (associated (pn_item)) then
       n = n + 1
       allocate (first)
       first%str = parse_node_get_string (pn_item)
       current => first
       do while (associated (pn_data))
          pn_data => parse_node_get_next_ptr (pn_data)
          call slha_next_index_ptr (pn_data, pn_item, code)
          if (associated (pn_item)) then
             n = n + 1
             allocate (current%next)
             current => current%next
             current%str = parse_node_get_string (pn_item)
          end if
       end do
       allocate (str_array (n))
       n = 0
       do while (associated (first))
          n = n + 1
          current => first
          str_array(n) = current%str
          first => first%next
          deallocate (current)
       end do
    else
       allocate (str_array (0))
    end if
  end subroutine retrieve_strings_in_block

@ %def retrieve_strings_in_block
@ 
\subsubsection{Transfer data from SLHA to variables}
Extract real parameter with index [[i]].  If it does not
exist, retrieve it from the variable list, using the given name.
<<SLHA: procedures>>=
  function get_parameter_in_block (pn_block, code, name, var_list) result (var)
    real(default) :: var
    type(parse_node_t), intent(in), target :: pn_block
    integer, intent(in) :: code
    type(string_t), intent(in) :: name
    type(var_list_t), intent(in), target :: var_list
    type(parse_node_t), pointer :: pn_data, pn_item
    call slha_find_index_ptr (pn_block, pn_data, pn_item, code)
    if (associated (pn_item)) then
       var = get_real_parameter (pn_item)
    else
       var = var_list_get_rval (var_list, name)
    end if
  end function get_parameter_in_block

@ %def get_parameter_in_block
@ Extract a real data item with index [[i]].  If it
does exist, set it in the variable list, using the given name.  If
the variable is not present in the variable list, ignore it.
<<SLHA: procedures>>=
  subroutine set_data_item (pn_block, code, name, var_list)
    type(parse_node_t), intent(in), target :: pn_block
    integer, intent(in) :: code
    type(string_t), intent(in) :: name
    type(var_list_t), intent(inout), target :: var_list
    type(parse_node_t), pointer :: pn_data, pn_item
    call slha_find_index_ptr (pn_block, pn_data, pn_item, code)
    if (associated (pn_item)) then
       call var_list_set_real &
            (var_list, name,  get_real_parameter (pn_item), &
             is_known=.true., ignore=.true.)
    end if
  end subroutine set_data_item

@ %def set_data_item
@ Extract a real matrix element with index [[i,j]].  If it
does exists, set it in the variable list, using the given name.  If
the variable is not present in the variable list, ignore it.
<<SLHA: procedures>>=
  subroutine set_matrix_element (pn_block, code1, code2, name, var_list)
    type(parse_node_t), intent(in), target :: pn_block
    integer, intent(in) :: code1, code2
    type(string_t), intent(in) :: name
    type(var_list_t), intent(inout), target :: var_list
    type(parse_node_t), pointer :: pn_data, pn_item
    call slha_find_index_pair_ptr (pn_block, pn_data, pn_item, code1, code2)
    if (associated (pn_item)) then
       call var_list_set_real &
            (var_list, name,  get_real_parameter (pn_item), &
             is_known=.true., ignore=.true.)
    end if
  end subroutine set_matrix_element

@ %def set_matrix_element
@ 
\subsubsection{Transfer data from variables to SLHA}
Get a real/integer parameter with index [[i]] from the variable list and write
it to the current output file.  In the integer case, we account for
the fact that the variable is type real.  If it does not exist, do nothing.
<<SLHA: procedures>>=
  subroutine write_integer_data_item (u, code, name, var_list, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code
    type(string_t), intent(in) :: name
    type(var_list_t), intent(in) :: var_list
    character(*), intent(in) :: comment
    integer :: item
    if (var_list_exists (var_list, name)) then
       item = nint (var_list_get_rval (var_list, name))
       call write_integer_parameter (u, code, item, comment)
    end if
  end subroutine write_integer_data_item

  subroutine write_real_data_item (u, code, name, var_list, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code
    type(string_t), intent(in) :: name
    type(var_list_t), intent(in) :: var_list
    character(*), intent(in) :: comment
    real(default) :: item
    if (var_list_exists (var_list, name)) then
       item = var_list_get_rval (var_list, name)
       call write_real_parameter (u, code, item, comment)
    end if
  end subroutine write_real_data_item

@ %def write_real_data_item
@ Get a real data item with two integer indices from the variable list
and write it to the current output file.  If it does not exist, do
nothing.
<<SLHA: procedures>>=
  subroutine write_matrix_element (u, code1, code2, name, var_list, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code1, code2
    type(string_t), intent(in) :: name
    type(var_list_t), intent(in) :: var_list
    character(*), intent(in) :: comment
    real(default) :: item
    if (var_list_exists (var_list, name)) then
       item = var_list_get_rval (var_list, name)
       call write_real_matrix_element (u, code1, code2, item, comment)
    end if
  end subroutine write_matrix_element

@ %def write_matrix_element
@ 
\subsection{Auxiliary function}
Write a block header.
<<SLHA: procedures>>=
  subroutine write_block_header (u, name, comment)
    integer, intent(in) :: u
    character(*), intent(in) :: name, comment
    write (u, "(A,1x,A,3x,'#',1x,A)")  "BLOCK", name, comment
  end subroutine write_block_header

@ %def write_block_header
@ Extract a real parameter that may be defined real or
integer, signed or unsigned.
<<SLHA: procedures>>=
  function get_real_parameter (pn_item) result (var)
    real(default) :: var
    type(parse_node_t), intent(in), target :: pn_item
    type(parse_node_t), pointer :: pn_sign, pn_var
    integer :: sign
    select case (char (parse_node_get_rule_key (pn_item)))
    case ("signed_number")
       pn_sign => parse_node_get_sub_ptr (pn_item)
       pn_var  => parse_node_get_next_ptr (pn_sign)
       select case (char (parse_node_get_key (pn_sign)))
       case ("+");  sign = +1
       case ("-");  sign = -1
       end select
    case default
       sign = +1
       pn_var => pn_item
    end select
    select case (char (parse_node_get_rule_key (pn_var)))
    case ("integer");  var = sign * parse_node_get_integer (pn_var)
    case ("real");     var = sign * parse_node_get_real (pn_var)
    end select
  end function get_real_parameter

@ %def get_real_parameter
@ Auxiliary: Extract an integer parameter that may be defined signed
or unsigned.  A real value is an error.
<<SLHA: procedures>>=
  function get_integer_parameter (pn_item) result (var)
    integer :: var
    type(parse_node_t), intent(in), target :: pn_item
    type(parse_node_t), pointer :: pn_sign, pn_var
    integer :: sign
    select case (char (parse_node_get_rule_key (pn_item)))
    case ("signed_integer")
       pn_sign => parse_node_get_sub_ptr (pn_item)
       pn_var  => parse_node_get_next_ptr (pn_sign)
       select case (char (parse_node_get_key (pn_sign)))
       case ("+");  sign = +1
       case ("-");  sign = -1
       end select
    case ("integer")
       sign = +1
       pn_var => pn_item
    case default
       call parse_node_write (pn_var)
       call msg_error ("SLHA: Integer parameter expected")
       var = 0
       return
    end select
    var = sign * parse_node_get_integer (pn_var)
  end function get_integer_parameter

@ %def get_real_parameter
@ Write an integer parameter with a single index directly to file,
using the required output format.
<<SLHA: procedures>>=
  subroutine write_integer_parameter (u, code, item, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code
    integer, intent(in) :: item
    character(*), intent(in) :: comment
1   format (1x, I9, 3x, 3x, I9, 4x, 3x, '#', 1x, A)
    write (u, 1)  code, item, comment
  end subroutine write_integer_parameter

@ %def write_integer_parameter
@ Write a real parameter with two indices directly to file,
using the required output format.
<<SLHA: procedures>>=
  subroutine write_real_parameter (u, code, item, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code
    real(default), intent(in) :: item
    character(*), intent(in) :: comment
1   format (1x, I9, 3x, 1P, E16.8, 0P, 3x, '#', 1x, A)
    write (u, 1)  code, item, comment
  end subroutine write_real_parameter

@ %def write_real_parameter
@ Write a real parameter with a single index directly to file,
using the required output format.
<<SLHA: procedures>>=
  subroutine write_real_matrix_element (u, code1, code2, item, comment)
    integer, intent(in) :: u
    integer, intent(in) :: code1, code2
    real(default), intent(in) :: item
    character(*), intent(in) :: comment
1   format (1x, I2, 1x, I2, 3x, 1P, E16.8, 0P, 3x, '#', 1x, A)
    write (u, 1)  code1, code2, item, comment
  end subroutine write_real_matrix_element

@ %def write_real_matrix_element
@ 
\subsubsection{The concrete SLHA interpreter}
SLHA codes for particular physics models
<<SLHA: parameters>>=
  integer, parameter :: MDL_MSSM = 0
  integer, parameter :: MDL_NMSSM = 1
@ %def MDL_MSSM MDL_NMSSM
@ Take the parse tree and extract relevant data.  Select the correct
model and store all data that is present in the appropriate variable
list.  Finally, update the variable record.
<<SLHA: procedures>>=
  subroutine slha_interpret_parse_tree &
       (parse_tree, os_data, model_list, model, input, spectrum, decays)
    type(parse_tree_t), intent(in) :: parse_tree
    type(os_data_t), intent(in) :: os_data
    type(model_list_t), intent(inout) :: model_list
    type(model_t), pointer, intent(inout) :: model
    logical, intent(in) :: input, spectrum, decays
    logical :: errors
    integer :: mssm_type
    call slha_handle_MODSEL (parse_tree, os_data, model_list, model, mssm_type)
    if (associated (model)) then
       if (input) then
          call slha_handle_SMINPUTS (parse_tree, model)
          call slha_handle_MINPAR (parse_tree, model, mssm_type)
       end if
       if (spectrum) then
          call slha_handle_info_block (parse_tree, "SPINFO", errors)
          if (errors)  return
          call slha_handle_MASS (parse_tree, model)
          call slha_handle_matrix_block (parse_tree, "NMIX", "mn_", 4, 4, model)
	  call slha_handle_matrix_block (parse_tree, "NMNMIX", "mixn_", 5, 5, model)
          call slha_handle_matrix_block (parse_tree, "UMIX", "mu_", 2, 2, model)
          call slha_handle_matrix_block (parse_tree, "VMIX", "mv_", 2, 2, model)
          call slha_handle_matrix_block (parse_tree, "STOPMIX", "mt_", 2, 2, model)
          call slha_handle_matrix_block (parse_tree, "SBOTMIX", "mb_", 2, 2, model)
          call slha_handle_matrix_block (parse_tree, "STAUMIX", "ml_", 2, 2, model)
	  call slha_handle_matrix_block (parse_tree, "NMHMIX", "mixh0_", 3, 3, model)
	  call slha_handle_matrix_block (parse_tree, "NMAMIX", "mixa0_", 2, 3, model)
          call slha_handle_ALPHA (parse_tree, model)
          call slha_handle_HMIX (parse_tree, model)
	  call slha_handle_NMSSMRUN (parse_tree, model)
          call slha_handle_matrix_block (parse_tree, "AU", "Au_", 3, 3, model)
          call slha_handle_matrix_block (parse_tree, "AD", "Ad_", 3, 3, model)
          call slha_handle_matrix_block (parse_tree, "AE", "Ae_", 3, 3, model)
       end if
       if (decays) then
          call slha_handle_info_block (parse_tree, "DCINFO", errors)
          if (errors)  return
          call slha_handle_decays (parse_tree, model)
       end if
    end if
  end subroutine slha_interpret_parse_tree

@ %def slha_interpret_parse_tree
@ 
\subsubsection{Info blocks}
Handle the informational blocks SPINFO and DCINFO.  The first two
items are program name and version.  Items with index 3 are warnings.
Items with index 4 are errors.  We reproduce these as WHIZARD warnings
and errors.
<<SLHA: procedures>>=
  subroutine slha_handle_info_block (parse_tree, block_name, errors)
    type(parse_tree_t), intent(in) :: parse_tree
    character(*), intent(in) :: block_name
    logical, intent(out) :: errors
    type(parse_node_t), pointer :: pn_block
    type(string_t), dimension(:), allocatable :: msg
    integer :: i
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str (block_name), required=.true.)
    if (.not. associated (pn_block)) then
       call msg_error ("SLHA: Missing info block '" &
            // trim (block_name) // "'; ignored.")
       errors = .true.
       return
    end if
    select case (block_name)
    case ("SPINFO")
       call msg_message ("SLHA: SUSY spectrum program info:")
    case ("DCINFO")
       call msg_message ("SLHA: SUSY decay program info:")
    end select
    call retrieve_strings_in_block (pn_block, 1, msg)
    do i = 1, size (msg)
       call msg_message ("SLHA: " // char (msg(i)))
    end do
    call retrieve_strings_in_block (pn_block, 2, msg)
    do i = 1, size (msg)
       call msg_message ("SLHA: " // char (msg(i)))
    end do
    call retrieve_strings_in_block (pn_block, 3, msg)
    do i = 1, size (msg)
       call msg_warning ("SLHA: " // char (msg(i)))
    end do
    call retrieve_strings_in_block (pn_block, 4, msg)
    do i = 1, size (msg)
       call msg_error ("SLHA: " // char (msg(i)))
    end do
    errors = size (msg) > 0
  end subroutine slha_handle_info_block

@ %def slha_handle_info_block
@ 
\subsubsection{MODSEL}
Handle the overall model definition.  Only certain models are
recognized.  The soft-breaking model templates that determine the set
of input parameters:
<<SLHA: parameters>>=
  integer, parameter :: MSSM_GENERIC = 0
  integer, parameter :: MSSM_SUGRA = 1
  integer, parameter :: MSSM_GMSB = 2
  integer, parameter :: MSSM_AMSB = 3

@ %def MSSM_GENERIC MSSM_MSUGRA MSSM_GMSB MSSM_AMSB
<<SLHA: procedures>>=
  subroutine slha_handle_MODSEL &
       (parse_tree, os_data, model_list, model, mssm_type)
    type(parse_tree_t), intent(in) :: parse_tree
    type(os_data_t), intent(in) :: os_data
    type(model_list_t), intent(inout) :: model_list
    type(model_t), pointer, intent(inout) :: model
    integer, intent(out) :: mssm_type
    type(parse_node_t), pointer :: pn_block, pn_data, pn_item
    type(string_t) :: model_name
    type(string_t) :: filename
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("MODSEL"), required=.true.)
    call slha_find_index_ptr (pn_block, pn_data, pn_item, 1)
    if (associated (pn_item)) then
       mssm_type = get_integer_parameter (pn_item)
    else
       mssm_type = MSSM_GENERIC
    end if
    call slha_find_index_ptr (pn_block, pn_data, pn_item, 3)
    if (associated (pn_item)) then
       select case (parse_node_get_integer (pn_item))
       case (MDL_MSSM);  model_name = "MSSM"
       case (MDL_NMSSM); model_name = "NMSSM"
       case default
          call msg_fatal ("SLHA: unknown model code in MODSEL")
          return
       end select
    else
       model_name = "MSSM"
    end if
    call slha_find_index_ptr (pn_block, pn_data, pn_item, 4)
    if (associated (pn_item)) then
      call msg_fatal (" R-parity violation is currently not supported by WHIZARD.")	
    end	if
    call slha_find_index_ptr (pn_block, pn_data, pn_item, 5)
    if (associated (pn_item)) then
      call msg_fatal (" CP violation is currently not supported by WHIZARD.")	
    end	if
    select case (char (model_name))
      case ("MSSM")
         select case (char (model%get_name ()))
           case ("MSSM","MSSM_CKM","MSSM_Grav","MSSM_Hgg")
	      model_name = model%get_name ()
	   case default
              call msg_fatal (" User-defined model and model in SLHA input file do not match.")	
         end select 
      case ("NMSSM") 	 
         select case (char (model%get_name ()))
           case ("NMSSM","NMSSM_CKM","NMSSM_Hgg")
	      model_name = model%get_name ()
	   case default
              call msg_fatal (" User-defined model and model in SLHA input file do not match.")	
         end select 
      case default
         call msg_fatal (" SLHA model selection failure.")
    end select     
    filename = model_name // ".mdl"
    model => null ()
    call model_list%read_model (model_name, filename, os_data, model)
    if (associated (model)) then
       call msg_message ("SLHA: Initializing model '" &
            // char (model_name) // "'")
    else
       call msg_fatal ("SLHA: Initialization failed for model '" &
            // char (model_name) // "'")
    end if
  end subroutine slha_handle_MODSEL

@ %def slha_handle_MODSEL
@ Write a MODSEL block, based on the contents of the current model.
<<SLHA: procedures>>=
  subroutine slha_write_MODSEL (u, model, mssm_type)
    integer, intent(in) :: u
    type(model_t), intent(in), target :: model
    integer, intent(out) :: mssm_type
    type(var_list_t), pointer :: var_list
    integer :: model_id
    type(string_t) :: mtype_string
    var_list => model%get_var_list_ptr ()
    if (var_list_exists (var_list, var_str ("mtype"))) then
       mssm_type = nint (var_list_get_rval (var_list, var_str ("mtype")))
    else
       call msg_error ("SLHA: parameter 'mtype' (SUSY breaking scheme) " &
            // "is unknown in current model, no SLHA output possible")
       mssm_type = -1
       return
    end if
    call write_block_header (u, "MODSEL", "SUSY model selection")
    select case (mssm_type)
    case (0);  mtype_string = "Generic MSSM"
    case (1);  mtype_string = "SUGRA"
    case (2);  mtype_string = "GMSB"
    case (3);  mtype_string = "AMSB"
    case default
       mtype_string = "unknown"
    end select
    call write_integer_parameter (u, 1, mssm_type, &
         "SUSY-breaking scheme: " // char (mtype_string))
    select case (char (model%get_name ()))
    case ("MSSM");  model_id = MDL_MSSM
    case ("NMSSM"); model_id = MDL_NMSSM
    case default
       model_id = 0
    end select
    call write_integer_parameter (u, 3, model_id, &
         "SUSY model type: " // char (model%get_name ()))
  end subroutine slha_write_MODSEL
    
@ %def slha_write_MODSEL
@ 
\subsubsection{SMINPUTS}
Read SM parameters and update the variable list accordingly.  If a
parameter is not defined in the block, we use the previous value from
the model variable list.  For the basic parameters we have to do a
small recalculation, since SLHA uses the $G_F$-$\alpha$-$m_Z$ scheme,
while \whizard\ derives them from $G_F$, $m_W$, and $m_Z$.
<<SLHA: procedures>>=
  subroutine slha_handle_SMINPUTS (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block
    real(default) :: alpha_em_i, GF, alphas, mZ
    real(default) :: ee, vv, cw_sw, cw2, mW
    real(default) :: mb, mtop, mtau
    type(var_list_t), pointer :: var_list
    var_list => model%get_var_list_ptr ()
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("SMINPUTS"), required=.true.)
    if (.not. (associated (pn_block)))  return
    alpha_em_i = &
         get_parameter_in_block (pn_block, 1, var_str ("alpha_em_i"), var_list)
    GF = get_parameter_in_block (pn_block, 2, var_str ("GF"), var_list)
    alphas = &
         get_parameter_in_block (pn_block, 3, var_str ("alphas"), var_list)
    mZ   = get_parameter_in_block (pn_block, 4, var_str ("mZ"), var_list)
    mb   = get_parameter_in_block (pn_block, 5, var_str ("mb"), var_list)
    mtop = get_parameter_in_block (pn_block, 6, var_str ("mtop"), var_list)
    mtau = get_parameter_in_block (pn_block, 7, var_str ("mtau"), var_list)
    ee = sqrt (4 * pi / alpha_em_i)
    vv = 1 / sqrt (sqrt (2._default) * GF)
    cw_sw = ee * vv / (2 * mZ)
    if (2*cw_sw <= 1) then
       cw2 = (1 + sqrt (1 - 4 * cw_sw**2)) / 2
       mW = mZ * sqrt (cw2)
       call var_list_set_real (var_list, var_str ("GF"), GF, .true.)
       call var_list_set_real (var_list, var_str ("mZ"), mZ, .true.)
       call var_list_set_real (var_list, var_str ("mW"), mW, .true.)
       call var_list_set_real (var_list, var_str ("mtau"), mtau, .true.)
       call var_list_set_real (var_list, var_str ("mb"), mb, .true.)
       call var_list_set_real (var_list, var_str ("mtop"), mtop, .true.)
       call var_list_set_real (var_list, var_str ("alphas"), alphas, .true.)
    else
       call msg_fatal ("SLHA: Unphysical SM parameter values")
       return
    end if
  end subroutine slha_handle_SMINPUTS

@ %def slha_handle_SMINPUTS
@ Write a SMINPUTS block.
<<SLHA: procedures>>=
  subroutine slha_write_SMINPUTS (u, model)
    integer, intent(in) :: u
    type(model_t), intent(in), target :: model
    type(var_list_t), pointer :: var_list
    var_list => model%get_var_list_ptr ()
    call write_block_header (u, "SMINPUTS", "SM input parameters")
    call write_real_data_item (u, 1, var_str ("alpha_em_i"), var_list, &
         "Inverse electromagnetic coupling alpha (Z pole)")
    call write_real_data_item (u, 2, var_str ("GF"), var_list, &
         "Fermi constant")
    call write_real_data_item (u, 3, var_str ("alphas"), var_list, &
         "Strong coupling alpha_s (Z pole)")
    call write_real_data_item (u, 4, var_str ("mZ"), var_list, &
         "Z mass")
    call write_real_data_item (u, 5, var_str ("mb"), var_list, &
         "b running mass (at mb)")
    call write_real_data_item (u, 6, var_str ("mtop"), var_list, &
         "top mass")
    call write_real_data_item (u, 7, var_str ("mtau"), var_list, &
         "tau mass")
  end subroutine slha_write_SMINPUTS

@ %def slha_write_SMINPUTS
@ 
\subsubsection{MINPAR}
The block of SUSY input parameters.  They are accessible to WHIZARD,
but they only get used when an external spectrum generator is
invoked.  The precise set of parameters depends on the type of SUSY
breaking, which by itself is one of the parameters.
<<SLHA: procedures>>=
  subroutine slha_handle_MINPAR (parse_tree, model, mssm_type)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    integer, intent(in) :: mssm_type
    type(var_list_t), pointer :: var_list
    type(parse_node_t), pointer :: pn_block
    var_list => model%get_var_list_ptr ()
    call var_list_set_real (var_list, &
         var_str ("mtype"),  real(mssm_type, default), is_known=.true.)
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("MINPAR"), required=.true.)
    select case (mssm_type)
    case (MSSM_SUGRA)
       call set_data_item (pn_block, 1, var_str ("m_zero"), var_list)
       call set_data_item (pn_block, 2, var_str ("m_half"), var_list)
       call set_data_item (pn_block, 3, var_str ("tanb"), var_list)
       call set_data_item (pn_block, 4, var_str ("sgn_mu"), var_list)
       call set_data_item (pn_block, 5, var_str ("A0"), var_list)
    case (MSSM_GMSB)
       call set_data_item (pn_block, 1, var_str ("Lambda"), var_list)
       call set_data_item (pn_block, 2, var_str ("M_mes"), var_list)
       call set_data_item (pn_block, 3, var_str ("tanb"), var_list)
       call set_data_item (pn_block, 4, var_str ("sgn_mu"), var_list)
       call set_data_item (pn_block, 5, var_str ("N_5"), var_list)
       call set_data_item (pn_block, 6, var_str ("c_grav"), var_list)
    case (MSSM_AMSB)
       call set_data_item (pn_block, 1, var_str ("m_zero"), var_list)
       call set_data_item (pn_block, 2, var_str ("m_grav"), var_list)
       call set_data_item (pn_block, 3, var_str ("tanb"), var_list)
       call set_data_item (pn_block, 4, var_str ("sgn_mu"), var_list)
    case default
       call set_data_item (pn_block, 3, var_str ("tanb"), var_list)
    end select
  end subroutine slha_handle_MINPAR

@ %def slha_handle_MINPAR
@ Write a MINPAR block as appropriate for the current model type.
<<SLHA: procedures>>=
  subroutine slha_write_MINPAR (u, model, mssm_type)
    integer, intent(in) :: u
    type(model_t), intent(in), target :: model
    integer, intent(in) :: mssm_type
    type(var_list_t), pointer :: var_list
    var_list => model%get_var_list_ptr ()
    call write_block_header (u, "MINPAR", "Basic SUSY input parameters")
    select case (mssm_type)
    case (MSSM_SUGRA)
       call write_real_data_item (u, 1, var_str ("m_zero"), var_list, &
            "Common scalar mass")
       call write_real_data_item (u, 2, var_str ("m_half"), var_list, &
            "Common gaugino mass")
       call write_real_data_item (u, 3, var_str ("tanb"), var_list, &
            "tan(beta)")
       call write_integer_data_item (u, 4, &
            var_str ("sgn_mu"), var_list, &
            "Sign of mu")
       call write_real_data_item (u, 5, var_str ("A0"), var_list, &
            "Common trilinear coupling")
    case (MSSM_GMSB)
       call write_real_data_item (u, 1, var_str ("Lambda"), var_list, &
            "Soft-breaking scale")
       call write_real_data_item (u, 2, var_str ("M_mes"), var_list, &
            "Messenger scale")
       call write_real_data_item (u, 3, var_str ("tanb"), var_list, &
            "tan(beta)")
       call write_integer_data_item (u, 4, &
            var_str ("sgn_mu"), var_list, &
            "Sign of mu")
       call write_integer_data_item (u, 5, var_str ("N_5"), var_list, &
            "Messenger index")
       call write_real_data_item (u, 6, var_str ("c_grav"), var_list, &
            "Gravitino mass factor")
    case (MSSM_AMSB)
       call write_real_data_item (u, 1, var_str ("m_zero"), var_list, &
            "Common scalar mass")
       call write_real_data_item (u, 2, var_str ("m_grav"), var_list, &
            "Gravitino mass")
       call write_real_data_item (u, 3, var_str ("tanb"), var_list, &
            "tan(beta)")
       call write_integer_data_item (u, 4, &
            var_str ("sgn_mu"), var_list, &
            "Sign of mu")
    case default
       call write_real_data_item (u, 3, var_str ("tanb"), var_list, &
            "tan(beta)")
    end select
  end subroutine slha_write_MINPAR
    
@ %def slha_write_MINPAR
@
\subsubsection{Mass spectrum}
Set masses.  Since the particles are identified by PDG code, read
the line and try to set the appropriate particle mass in the current
model.  At the end, update parameters, just in case the $W$ or $Z$
mass was included.
<<SLHA: procedures>>=
  subroutine slha_handle_MASS (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block, pn_data, pn_line, pn_code
    type(parse_node_t), pointer :: pn_mass
    integer :: pdg
    real(default) :: mass
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("MASS"), required=.true.)
    if (.not. (associated (pn_block)))  return
    pn_data => parse_node_get_sub_ptr (pn_block, 4)
    do while (associated (pn_data))
       pn_line => parse_node_get_sub_ptr (pn_data, 2)
       pn_code => parse_node_get_sub_ptr (pn_line)
       if (associated (pn_code)) then
          pdg = get_integer_parameter (pn_code)
          pn_mass => parse_node_get_next_ptr (pn_code)
          if (associated (pn_mass)) then
             mass = get_real_parameter (pn_mass)
             call model%set_field_mass (pdg, mass)
          else
             call msg_error ("SLHA: Block MASS: Missing mass value")
          end if
       else
          call msg_error ("SLHA: Block MASS: Missing PDG code")
       end if
       pn_data => parse_node_get_next_ptr (pn_data)
    end do
  end subroutine slha_handle_MASS

@ %def slha_handle_MASS
@ 
\subsubsection{Widths}
Set widths.  For each DECAY block, extract the header, read the PDG
code and width, and try to set the appropriate particle width in the
current model.
<<SLHA: procedures>>=
  subroutine slha_handle_decays (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_decay, pn_decay_spec, pn_code, pn_width
    integer :: pdg
    real(default) :: width
    pn_decay => slha_get_first_decay_ptr (parse_tree)
    do while (associated (pn_decay))
       pn_decay_spec => parse_node_get_sub_ptr (pn_decay, 2)
       pn_code => parse_node_get_sub_ptr (pn_decay_spec)
       pdg = get_integer_parameter (pn_code)
       pn_width => parse_node_get_next_ptr (pn_code)
       width = get_real_parameter (pn_width)
       call model%set_field_width (pdg, width)
       pn_decay => slha_get_next_decay_ptr (pn_decay)
    end do
  end subroutine slha_handle_decays

@ %def slha_handle_decays
@ 
\subsubsection{Mixing matrices}
Read mixing matrices.  We can treat all matrices by a single
procedure if we just know the block name, variable prefix, and matrix
dimension.  The matrix dimension must be less than 10. 
For the pseudoscalar Higgses in NMSSM-type models we need off-diagonal 
matrices, so we generalize the definition.
<<SLHA: procedures>>=
  subroutine slha_handle_matrix_block &
       (parse_tree, block_name, var_prefix, dim1, dim2, model)
    type(parse_tree_t), intent(in) :: parse_tree
    character(*), intent(in) :: block_name, var_prefix
    integer, intent(in) :: dim1, dim2
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block
    type(var_list_t), pointer :: var_list
    integer :: i, j
    character(len=len(var_prefix)+2) :: var_name
    var_list => model%get_var_list_ptr ()
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str (block_name), required=.false.)
    if (.not. (associated (pn_block)))  return
    do i = 1, dim1
       do j = 1, dim2
          write (var_name, "(A,I1,I1)")  var_prefix, i, j
          call set_matrix_element (pn_block, i, j, var_str (var_name), var_list)
       end do
    end do
  end subroutine slha_handle_matrix_block

@ %def slha_handle_matrix_block
@ 
\subsubsection{Higgs data}
Read the block ALPHA which holds just the Higgs mixing angle.
<<SLHA: procedures>>=
  subroutine slha_handle_ALPHA (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block, pn_line, pn_data, pn_item
    type(var_list_t), pointer :: var_list
    real(default) :: al_h
    var_list => model%get_var_list_ptr ()
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("ALPHA"), required=.false.)
    if (.not. (associated (pn_block)))  return
    pn_data => parse_node_get_sub_ptr (pn_block, 4)
    pn_line => parse_node_get_sub_ptr (pn_data, 2)
    pn_item => parse_node_get_sub_ptr (pn_line)
    if (associated (pn_item)) then
       al_h = get_real_parameter (pn_item)
       call var_list_set_real (var_list, var_str ("al_h"), al_h, &
            is_known=.true., ignore=.true.)
    end if
  end subroutine slha_handle_ALPHA

@ %def slha_handle_matrix_block
@ Read the block HMIX for the Higgs mixing parameters
<<SLHA: procedures>>=
  subroutine slha_handle_HMIX (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block
    type(var_list_t), pointer :: var_list
    var_list => model%get_var_list_ptr ()
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("HMIX"), required=.false.)
    if (.not. (associated (pn_block)))  return
    call set_data_item (pn_block, 1, var_str ("mu_h"), var_list)
    call set_data_item (pn_block, 2, var_str ("tanb_h"), var_list)
  end subroutine slha_handle_HMIX

@ %def slha_handle_HMIX
@ Read the block NMSSMRUN for the specific NMSSM parameters
<<SLHA: procedures>>=
  subroutine slha_handle_NMSSMRUN (parse_tree, model)
    type(parse_tree_t), intent(in) :: parse_tree
    type(model_t), intent(inout), target :: model
    type(parse_node_t), pointer :: pn_block
    type(var_list_t), pointer :: var_list
    var_list => model%get_var_list_ptr ()
    pn_block => slha_get_block_ptr &
         (parse_tree, var_str ("NMSSMRUN"), required=.false.)
    if (.not. (associated (pn_block)))  return
    call set_data_item (pn_block, 1, var_str ("ls"), var_list)
    call set_data_item (pn_block, 2, var_str ("ks"), var_list)
    call set_data_item (pn_block, 3, var_str ("a_ls"), var_list)    
    call set_data_item (pn_block, 4, var_str ("a_ks"), var_list)        
    call set_data_item (pn_block, 5, var_str ("nmu"), var_list)    
    end subroutine slha_handle_NMSSMRUN

@ %def slha_handle_NMSSMRUN
@ 
\subsection{Parser}
Read a SLHA file from stream, including preprocessing, and make up a
parse tree.
<<SLHA: procedures>>=
  subroutine slha_parse_stream (stream, parse_tree)
    type(stream_t), intent(inout), target :: stream
    type(parse_tree_t), intent(out) :: parse_tree
    type(ifile_t) :: ifile
    type(lexer_t) :: lexer
    type(stream_t), target :: stream_tmp
    call slha_preprocess (stream, ifile)
    call stream_init (stream_tmp, ifile)
    call lexer_init_slha (lexer)
    call lexer_assign_stream (lexer, stream_tmp)
    call parse_tree_init (parse_tree, syntax_slha, lexer)
    call lexer_final (lexer)
    call stream_final (stream_tmp)
    call ifile_final (ifile)
  end subroutine slha_parse_stream

@ %def slha_parse_stream
@ Read a SLHA file chosen by name.  Check first the current directory,
then the directory where SUSY input files should be located.
<<SLHA: procedures>>=
  subroutine slha_parse_file (file, os_data, parse_tree)
    type(string_t), intent(in) :: file
    type(os_data_t), intent(in) :: os_data
    type(parse_tree_t), intent(out) :: parse_tree
    logical :: exist
    type(string_t) :: filename
    type(stream_t), target :: stream
    call msg_message ("Reading SLHA input file '" // char (file) // "'")
    filename = file
    inquire (file=char(filename), exist=exist)
    if (.not. exist) then
       filename = os_data%whizard_susypath // "/" // file
       inquire (file=char(filename), exist=exist)
       if (.not. exist) then
          call msg_fatal ("SLHA input file '" // char (file) // "' not found")
          return
       end if
    end if
    call stream_init (stream, char (filename))
    call slha_parse_stream (stream, parse_tree)
    call stream_final (stream)
  end subroutine slha_parse_file

@ %def slha_parse_file
@ 
\subsection{API}
Read the SLHA file, parse it, and interpret the parse tree.  The model
parameters retrieved from the file will be inserted into the
appropriate model, which is loaded and modified in the background.
The pointer to this model is returned as the last argument.
<<SLHA: public>>=
  public :: slha_read_file
<<SLHA: procedures>>=
  subroutine slha_read_file &
       (file, os_data, model_list, model, input, spectrum, decays)
    type(string_t), intent(in) :: file
    type(os_data_t), intent(in) :: os_data
    type(model_list_t), intent(inout) :: model_list
    type(model_t), pointer, intent(inout) :: model
    logical, intent(in) :: input, spectrum, decays
    type(parse_tree_t) :: parse_tree
    call slha_parse_file (file, os_data, parse_tree)
    if (associated (parse_tree_get_root_ptr (parse_tree))) then
       call slha_interpret_parse_tree &
            (parse_tree, os_data, model_list, model, input, spectrum, decays)
       call parse_tree_final (parse_tree)
       call model%update_parameters ()
    end if
  end subroutine slha_read_file

@ %def slha_read_file
@ Write the SLHA contents, as far as possible, to external file.
<<SLHA: public>>=
  public :: slha_write_file
<<SLHA: procedures>>=
  subroutine slha_write_file (file, model, input, spectrum, decays)
    type(string_t), intent(in) :: file
    type(model_t), target, intent(in) :: model
    logical, intent(in) :: input, spectrum, decays
    integer :: mssm_type
    integer :: u
    u = free_unit ()
    call msg_message ("Writing SLHA output file '" // char (file) // "'")
    open (unit=u, file=char(file), action="write", status="replace")
    write (u, "(A)")  "# SUSY Les Houches Accord"
    write (u, "(A)")  "# Output generated by " // trim (VERSION_STRING)
    call slha_write_MODSEL (u, model, mssm_type)
    if (input) then
       call slha_write_SMINPUTS (u, model)
       call slha_write_MINPAR (u, model, mssm_type)
    end if
    if (spectrum) then
       call msg_bug ("SLHA: spectrum output not supported yet")
    end if
    if (decays) then
       call msg_bug ("SLHA: decays output not supported yet")
    end if
    close (u)
  end subroutine slha_write_file

@ %def slha_write_file
@
\subsection{Unit tests}
<<SLHA: public>>=
  public :: slha_test
<<SLHA: procedures>>=
  subroutine slha_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SLHA: execute tests>>  
  end subroutine slha_test

@  %def slha_test
@ Checking the basics of the SLHA interface.
<<SLHA: execute tests>>=
  call test (slha_1, "slha_1", &
       "check SLHA interface", &
       u, results)
<<SLHA: tests>>=   
  subroutine slha_1 (u) 
    integer, intent(in) :: u
    type(os_data_t), pointer :: os_data => null ()
    type(parse_tree_t), pointer :: parse_tree => null ()
    integer :: u_file, iostat
    character(80) :: buffer
    character(*), parameter :: file_slha = "slha_test.dat"
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    
    write (u, "(A)")  "* Test output: SLHA Interface"
    write (u, "(A)")  "*   Purpose: test SLHA file reading and writing"
    write (u, "(A)")            

    write (u, "(A)")  "* Initializing"
    write (u, "(A)")    
    
    allocate (os_data)
    allocate (parse_tree)
    call os_data_init (os_data)
    call syntax_model_file_init ()
    call model_list%read_model &
         (var_str("MSSM"), var_str("MSSM.mdl"), os_data, model)
    call syntax_slha_init ()

    write (u, "(A)")  "* Reading SLHA file sps1ap_decays.slha"
    write (u, "(A)")    
    
    call slha_parse_file (var_str ("sps1ap_decays.slha"), os_data, parse_tree)

    write (u, "(A)")  "* Writing the parse tree:"
    write (u, "(A)")    

    call parse_tree_write (parse_tree, u)
    
    write (u, "(A)")  "* Interpreting the parse tree"
    write (u, "(A)")    
    
    call slha_interpret_parse_tree (parse_tree, os_data, model_list, model, &
         input=.true., spectrum=.true., decays=.true.)    
    call parse_tree_final (parse_tree)

    write (u, "(A)")  "* Writing out the list of variables (reals only):"
    write (u, "(A)")    
    
    call var_list_write (model%get_var_list_ptr (), &
         only_type = V_REAL, unit = u)

    write (u, "(A)")
    write (u, "(A)")  "* Writing SLHA output to '" // file_slha // "'"
    write (u, "(A)")    
        
    call slha_write_file (var_str (file_slha), model, input=.true., &
         spectrum=.false., decays=.false.)
    u_file = free_unit ()
    open (u_file, file = file_slha, action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:37) == "# Output generated by WHIZARD version") then
          buffer = "[...]"
       end if
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")
    
    call parse_tree_final (parse_tree)
    deallocate (parse_tree)
    deallocate (os_data)

    write (u, "(A)")  "* Test output end: slha_1"
    write (u, "(A)")
    
  end subroutine slha_1

@ %def slha_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NLO infrastructure}
\section{BLHA interface}

These modules implement the communication with one loop matrix element providers
according to the Binoth LesHouches Accord Interface. The actual matrix
element(s) are loaded as a dynamic library.

The module is split into a configuration interface which manages configuration
and handles the request and contract files, a module which interfaces the OLP
matrix elements and a driver.

<<[[blha_config.f90]]>>=
<<File header>>

module blha_config

  use kinds
<<Use strings>>
  use io_units
  use constants
  use string_utils
  use system_defs, only: EOF
  use diagnostics
  use md5
  use models
  use flavors
  use quantum_numbers
  use pdg_arrays
  use sorting
  use lexers
  use parser
  use syntax_rules
  use ifiles

<<Standard module head>>

<<BLHA config: public>>

<<BLHA config: parameters>>

<<BLHA config: types>>

<<BLHA config: variables>>

<<BLHA config: interfaces>>

contains

<<BLHA config: procedures>>

end module blha_config

@ %def blha_config
@
<<[[blha_interface.f90]]>>=
<<File header>>

module blha_interface

<<Use strings>>
  use io_units
  use string_utils
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use models
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use, intrinsic :: iso_c_binding !NODEP!
  use os_interface

<<Standard module head>>

<<BLHA interface: public>>

<<BLHA interface: types>>

<<BLHA interface: interfaces>>

contains

<<BLHA interface: procedures>>

end module blha_interface
@ %def blha_interface
@ %
<<[[blha_driver.f90]]>>=
<<File header>>

module blha_driver

<<Use strings>>
  use io_units
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use models
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use blha_interface

<<Standard module head>>

<<BLHA driver: public>>

contains

<<BLHA driver: procedures>>

end module blha_driver
@ %def blha_driver
@ %

\subsection{Configuration}

Parameters to enumerate the different options in the order.
<<BLHA config: parameters>>=
  integer, public, parameter :: &
       BLHA_MEST_SUM=1, BLHA_MEST_AVG=2, BLHA_MEST_OTHER=3
  integer, public, parameter :: &
       BLHA_CT_QCD=1, BLHA_CT_EW=2, BLHA_CT_QED=3, BLHA_CT_OTHER=4
  integer, public, parameter :: &
       BLHA_IRREG_CDR=1, BLHA_IRREG_DRED=2, BLHA_IRREG_THV=3, &
       BLHA_IRREG_MREG=4, BLHA_IRREG_OTHER=5
  integer, public, parameter :: &
       BLHA_SUBMODE_NONE = 1, BLHA_SUBMODE_OTHER = 2
  integer, public, parameter :: &
       BLHA_MPS_ONSHELL=1, BLHA_MPS_OTHER=2
  integer, public, parameter :: &
       BLHA_MODE_GOSAM=1, BLHA_MODE_FEYNARTS = 2, BLHA_MODE_GENERIC=3
  integer, public, parameter :: &
       BLHA_OM_NONE=1, BLHA_OM_NOCPL=2, BLHA_OM_OTHER=3
   integer, public, parameter :: &
       BLHA_VERSION_1 = 1, BLHA_VERSION_2 = 2
  integer, public, parameter :: &
       BLHA_AMP_LOOP = 1, BLHA_AMP_CC = 2, BLHA_AMP_SC = 3, &
       BLHA_AMP_TREE = 4, BLHA_AMP_LOOPINDUCED = 5
  integer, public, parameter :: &
       BLHA_EW_GF = 1, BLHA_EW_MZ = 2, BLHA_EW_MSBAR = 3, &
       BLHA_EW_0 = 4, BLHA_EW_RUN = 5, BLHA_EW_DEFAULT = 6
  integer, public, parameter :: &
       BLHA_WIDTH_COMPLEX = 1, BLHA_WIDTH_FIXED = 2, &
       BLHA_WIDTH_RUNNING = 3, BLHA_WIDTH_POLE = 4, &
       BLHA_WIDTH_DEFAULT = 5 

@ %def blha_mest_sum blha_mest_avg blha_mest_other
@ %def blha_ct_qcd blha_ct_ew blha_ct_qed blha_ct_other
@ %def blha_irreg_cdr blha_irreg_dred blha_irreg_thv blha_irreg_mreg blha_irreg_other
@ %def blha_submode_none blha_submode_other
@ %def blha_mps_onshell blha_mps_other
@ %def blha_mode_gosam blha_mode_feynarts blha_mode_generic
@ %def blha_om_none blha_om_nocpl blha_om_other
@ %def blha version blha_amp blha_ew blha_width
@
This type encapsulates a BLHA request.
<<BLHA config: public>>=
  public :: blha_configuration_t
  public :: blha_cfg_process_node_t
<<BLHA config: types>>=
  type :: blha_cfg_process_node_t
     integer, dimension(:), allocatable :: pdg_in, pdg_out
     integer, dimension(:), allocatable :: fingerprint
     integer :: nsub
     integer, dimension(:), allocatable :: ids
     integer :: amplitude_type
     type(blha_cfg_process_node_t), pointer :: next => null ()
  end type blha_cfg_process_node_t

  type :: blha_configuration_t
     type(string_t) :: name
     type(model_t), pointer :: model => null ()
     type(string_t) :: md5
     integer :: version = 2
     logical :: dirty = .false.
     integer :: n_proc = 0
     real(default) :: accuracy_target
     logical :: debug_unstable
     integer :: mode = BLHA_MODE_GENERIC
     type(blha_cfg_process_node_t), pointer :: processes => null ()
     integer, dimension(2) :: matrix_element_square_type = BLHA_MEST_SUM
     !!! !!! !!! Triggers gfortran 4.9.0 ICE     
     ! type(string_t), dimension (2) :: matrix_element_square_type_other
!     integer :: amplitude_type = BLHA_AMP_LOOP
     integer :: correction_type = BLHA_CT_QCD
     type(string_t) :: correction_type_other
     integer :: irreg = BLHA_IRREG_THV
     type(string_t) :: irreg_other
     integer :: massive_particle_scheme = BLHA_MPS_ONSHELL
     type(string_t) :: massive_particle_scheme_other
     integer :: subtraction_mode = BLHA_SUBMODE_NONE
     type(string_t) :: subtraction_mode_other
     type(string_t) :: model_file
     logical :: subdivide_subprocesses = .false.
     integer :: alphas_power = -1, alpha_power = -1
     integer :: ew_scheme = BLHA_EW_DEFAULT
     integer :: width_scheme = BLHA_WIDTH_DEFAULT
     integer :: operation_mode = BLHA_OM_NONE
     type(string_t) :: operation_mode_other
  end type blha_configuration_t

@ %def blha_cffg_process_node_t blha_configuration_t
@
This types control the creation of BLHA-interface files
<<BLHA config: public>>=
  public :: blha_flv_state_t
  public :: blha_master_t
<<BLHA config: types>>=
  type:: blha_flv_state_t
    integer, dimension(:), allocatable :: flavors
    integer :: flv_mult
    logical :: flv_real = .false.
  end type blha_flv_state_t

  type :: blha_master_t
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    integer :: n_in, n_out
    logical :: compute_loops = .true.
    logical :: compute_correlations = .false.
    logical :: compute_real_trees = .false.
    integer :: alpha_power, alphas_power
    type(string_t) :: basename
    type(blha_configuration_t), dimension(:), allocatable :: blha_cfg
  contains
  <<BLHA config: blha master: TBP>>
  end type blha_master_t

@ %def blha_flv_state_t, blha_master_t
@
Master-Routines
<<BLHA config: blha master: TBP>>=
  procedure :: init => blha_master_init 
<<BLHA config: procedures>>=
  subroutine blha_master_init (master, basename, model, &
                               n_in, n_out, &
                               cmp_loops, cmp_corr, cmp_real, &
                               alpha_power, alphas_power, &
                               flv_born, flv_real)
    class(blha_master_t), intent(inout) :: master
    type(string_t), intent(in) :: basename
    type(model_t), intent(in) :: model
    integer, intent(in) :: n_in, n_out
    logical, intent(in) :: cmp_loops, cmp_corr, cmp_real
    integer, intent(in) :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable, intent(in) :: &
                             flv_born, flv_real
    integer :: n_proc, n_proc_real, n_flv
    type(blha_flv_state_t), dimension(:), allocatable :: blha_flavor
    integer :: i, i_flv
    integer, dimension(:), allocatable :: amp_type

    n_proc = 0; n_flv = 1; n_proc_real = 0
    master%compute_real_trees = cmp_real
    if (cmp_loops) n_proc = n_proc+1
    if (cmp_corr) n_proc = n_proc+2
    if (cmp_real) then
       if (allocated (flv_real)) then
         allocate (master%blha_cfg(2))
         n_proc_real = size (flv_real, 2)
         n_flv = n_flv + n_proc_real
       end if
    else
       allocate (master%blha_cfg(1))
    end if
    allocate (blha_flavor (n_flv))
    do i_flv = 1, n_flv
       if (i_flv == 1) then
          i = 1
          if (allocated (flv_born)) then
            allocate (blha_flavor(i_flv)%flavors (n_in + n_out))
            blha_flavor(i_flv)%flavors = flv_born (:,1) 
            blha_flavor(i_flv)%flv_mult = n_proc
            allocate (amp_type (n_proc))
            if (cmp_loops) then
               amp_type(i) = BLHA_AMP_LOOP
               i = i+1
            end if
            if (cmp_corr) then
               amp_type(i) = BLHA_AMP_CC
               amp_type(i+1) = BLHA_AMP_SC
            end if

            call blha_configuration_init (master%blha_cfg(1), basename // "_VS", &
                                          model, BLHA_MODE_GOSAM)
            call blha_configuration_append_processes (master%blha_cfg(1), &
                                                      blha_flavor(1:1), amp_type)
            call blha_configuration_set (master%blha_cfg(1), 2, &
                                         correction_type = BLHA_CT_QCD, &
                                         irreg = BLHA_IRREG_CDR, &
                                         alphas_power = alphas_power, &
                                         alpha_power = alpha_power, &
                                         ew_scheme = BLHA_EW_GF, &
                                         debug = .true.)
          end if
       else
          allocate (blha_flavor(i_flv)%flavors (n_in + n_out + 1))
          if (allocated (flv_real)) then
             blha_flavor(i_flv)%flavors = flv_real(:,i_flv-1)
             blha_flavor(i_flv)%flv_mult = 1
             allocate (amp_type (1))
             amp_type(1) = BLHA_AMP_TREE
             
             call blha_configuration_init (master%blha_cfg(2), basename // "_TREE", &
                                           model, BLHA_MODE_GOSAM)
             call blha_configuration_append_processes (master%blha_cfg(2), &
                                                       blha_flavor(i_flv:i_flv), amp_type)
             call blha_configuration_set (master%blha_cfg(2), 2, &
                                          correction_type = BLHA_CT_QCD, &
                                          irreg = BLHA_IRREG_CDR, &
                                          alphas_power = alphas_power+1, &
                                          alpha_power = alpha_power, &
                                          ew_scheme = BLHA_EW_GF, &
                                          debug = .true.)
          end if
       end if
       if (allocated (amp_type)) deallocate (amp_type)
    end do
  end subroutine blha_master_init

@ %def blha_master_init
@
<<BLHA config: blha master: TBP>>=
  procedure :: generate => blha_master_generate
<<BLHA config: procedures>>=
  subroutine blha_master_generate (master, basename)
    class(blha_master_t), intent(in) :: master
    type(string_t), intent(in) :: basename
    integer :: unit
    type(string_t), dimension(:), allocatable :: filename
    integer :: n_files, i_file
    if (master%compute_real_trees) then
      allocate (filename (2))
      filename(1) = basename // "_VS.olp"
      filename(2) = basename // "_TREE.olp"
      n_files = 2
    else
      allocate (filename (1))
      filename(1) = basename // "_VS.olp"
      n_files = 1
    end if
    do i_file = 1, n_files
       unit = free_unit ()
       open (unit, file = char (filename(i_file)), status = 'replace', action = 'write')
       call blha_configuration_write (master%blha_cfg(i_file), unit)
       close (unit)
    end do
  end subroutine blha_master_generate

@ %def blha_master_generate
@    
Initializer.
<<BLHA config: public>>=
  public :: blha_configuration_init
<<BLHA config: procedures>>=
  subroutine blha_configuration_init (cfg, name, model, mode)
    type(blha_configuration_t), intent(out) :: cfg
    type(string_t), intent(in) :: name
    type(model_t), target, intent(in) :: model
    integer, intent(in), optional :: mode
    cfg%name = name
    cfg%model => model
    if (present (mode)) cfg%mode = mode
  end subroutine blha_configuration_init

@ %def blha_configuration_init
@
Finalizer.
<<BLHA config: public>>=
  public :: blha_configuration_final
<<BLHA config: procedures>>=
  subroutine blha_configuration_final (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_cfg_process_node_t), pointer :: cur, next
    cur => cfg%processes
    do while (associated (cur))
       next => cur%next
       deallocate (cur)
       nullify (cur)
       cur => next
    end do
  end subroutine blha_configuration_final

@ %def blha_configuration_final
@
Merge sort a process list w.r.t. to the process fingerprints. This is
necessary for canonicalizing the process list prior to calculating the
MD5 sum. 
<<BLHA config: procedures>>=
  subroutine sort_processes (list, n)
    type(blha_cfg_process_node_t), pointer :: list
    integer, intent(in), optional :: n
    type :: pnode
       type(blha_cfg_process_node_t), pointer :: p
    end type pnode
    type(pnode), dimension(:), allocatable :: array
    integer :: count, i, s, i1, i2, i3
    type(blha_cfg_process_node_t), pointer :: node
    if (present (n)) then
       count = n
    else
       node => list
       count = 0
       do while (associated (node))
          node => node%next
          count = count + 1
       end do
    end if
    ! Store list nodes into an array
    if (count == 0) return
    allocate (array(count))
    i = 1
    node => list
    do i = 1, count
       array(i)%p => node
       node => node%next
    end do
    s = 1
    ! Merge sort the array
    do while (s < count)
       i = 0
       i1 = 1
       i2 = s
       do while (i2 < count)
          i3 = min (s*(i+2), count)
          array(i1:i3) = merge (array(i1:i2), array(i2+1:i3))
          i = i + 2
          i1 = s*i+1
          i2 = s*(i+1)
       end do
       s = s * 2
    end do
    ! Relink according to their new order
    list => array(1)%p
    nullify (array(count)%p%next)
    node => list
    do i = 2, count
       node%next => array(i)%p
       node => node%next
    end do

  contains

    ! .le. comparision
    function lt (n1, n2) result (predicate)
      type(blha_cfg_process_node_t), intent(in) :: n1, n2
      logical :: predicate
      integer :: i
      predicate = .true.
      do i = 1, size (n1%fingerprint)
         if (n1%fingerprint(i) < n2%fingerprint(i)) return
         if (n1%fingerprint(i) > n2%fingerprint(i)) then
            predicate = .false.
            return
         end if
      end do
    end function lt

    ! Sorting core --- merge two sorted chunks
    function merge (l1, l2) result (lo)
      type(pnode), dimension(:), intent(in) :: l1, l2
      type(pnode), dimension(size (l1) + size (l2)) :: lo
      integer :: i, i1, i2
      i1 = 1
      i2 = 1
      do i = 1, size (lo)
         if (i1 > size (l1)) then
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         elseif (i2 > size (l2)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         elseif (lt (l1(i1)%p, l2(i2)%p)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         else
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         end if
      end do
    end function merge

  end subroutine sort_processes
  
@ %def sort_processes
@
Append a process. This expands the flavor sum, sorts it and then
eliminates any duplicates.
<<BLHA config: public>>=
  public :: blha_configuration_append_process
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_process (cfg, pdg_in, pdg_out, nsub, ids)
    type(blha_configuration_t), intent(inout) :: cfg
    type(pdg_array_t), dimension(:), intent(in) :: pdg_in, pdg_out
    integer, optional, intent(in) :: nsub
    integer, optional, dimension(:), intent(in) :: ids
    type(blha_cfg_process_node_t), pointer :: root, node, tmp
    ! Multiindex for counting through the PDG numbers
    integer, dimension(size (pdg_in)) :: i_in
    integer, dimension(size (pdg_out)) :: i_out
    ! Handle the list of lists
    type :: ilist
       integer, dimension(:), allocatable :: i
    end type ilist
    type(ilist), dimension(size (pdg_in)) :: ilist_i
    type(ilist), dimension(size (pdg_out)) :: ilist_o
    integer :: i, j, nproc
    logical :: inc
    ! Extract PDGs into integer lists
    do i = 1, size (pdg_in)
       ilist_i(i)%i = pdg_in(i)
    end do
    do i = 1, size (pdg_out)
       ilist_o(i)%i = pdg_out(i)
    end do
    i_in = 1
    i_out = 1
    allocate (root)
    node => root
    ! Perform the expansion
    nproc = 0
    EXPAND: do
       ! Transfer the PDG selection...
       allocate (node%pdg_in(size (pdg_in)))
       allocate (node%pdg_out(size (pdg_out)))
       allocate (node%fingerprint (size (pdg_in) + size (pdg_out)))
       if (present (nsub)) node%nsub = nsub
       if (present (ids)) then
          allocate (node%ids(size (ids)))
          node%ids = ids
       end if
       forall (j=1:size(ilist_i)) &
          node%pdg_in(j) = ilist_i(j)%i(i_in(j))
       forall (j=1:size(ilist_o)) &
          node%pdg_out(j) = ilist_o(j)%i(i_out(j))
       node%fingerprint = [ node%pdg_in, sort (node%pdg_out) ]
       nproc = nproc + 1
       inc = .false.
       ! ... and increment the multiindex
       do j = 1, size (i_out)
          if (i_out(j) < size (ilist_o(j)%i)) then
             i_out(j) = i_out(j) + 1
             inc = .true.
             exit
          else
             i_out(j) = 1
          end if
       end do
       if (.not. inc) then
          do j = 1, size (i_in)
             if (i_in(j) < size (ilist_i(j)%i)) then
                i_in(j) = i_in(j) + 1
                inc = .true.
                exit
             else
                i_in(j) = 1
             end if
          end do
       end if
       if (.not. inc) exit EXPAND
       allocate (node%next)
       node => node%next
    end do EXPAND
    ! Do the sorting
    call sort_processes (root, nproc)
    ! Kill duplicates
    node => root
    do while (associated (node))
       if (.not. associated (node%next)) exit
       if (all (node%fingerprint == node%next%fingerprint)) then
          tmp => node%next%next
          deallocate (node%next)
          node%next => tmp
          nproc = nproc - 1
       else
          node => node%next
       end if
    end do
    ! Append the remaining list
    if (associated (cfg%processes)) then
       node => cfg%processes
       do while (associated (node%next))
          node => node%next
       end do
       node%next => root
    else
       cfg%processes => root
    end if
    cfg%n_proc = cfg%n_proc + nproc
    cfg%dirty = .true.
    
  end subroutine blha_configuration_append_process

@ %def blha_configuration_append_process
@
<<BLHA config: public>>=
  public :: blha_configuration_append_processes
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_processes (cfg, flavor, amp_type)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_flv_state_t), dimension(:), intent(in) :: flavor
    integer, dimension(:), intent(in), optional :: amp_type
    integer :: n_tot
    type(blha_cfg_process_node_t), pointer :: current_node
    integer :: i_process, i_flv
    integer, dimension(:), allocatable :: pdg_in, pdg_out
    integer, dimension(:), allocatable :: flavor_state
    integer :: proc_offset, n_proc_tot
    proc_offset = 0; n_proc_tot = 0
    do i_flv = 1, size (flavor)
       n_proc_tot = n_proc_tot + flavor(i_flv)%flv_mult
    end do
    if (.not. associated (cfg%processes)) &
      allocate (cfg%processes)
    current_node => cfg%processes
    do i_flv = 1, size (flavor)
       n_tot = size (flavor(i_flv)%flavors)
       allocate (pdg_in (2), pdg_out (n_tot - 2))
       allocate (flavor_state (n_tot))
       flavor_state = flavor(i_flv)%flavors
       do i_process = 1, flavor(i_flv)%flv_mult
          pdg_in = flavor_state (1:2)
          pdg_out = flavor_state (3:)
          current_node%pdg_in = pdg_in
          current_node%pdg_out = pdg_out
          current_node%amplitude_type = amp_type (proc_offset+i_process)
          if (proc_offset+i_process /= n_proc_tot) then
            allocate (current_node%next)
            current_node => current_node%next
          end if
          if (i_process == flavor(i_flv)%flv_mult) &
             proc_offset = proc_offset + flavor(i_flv)%flv_mult
       end do
       deallocate (pdg_in, pdg_out)
       deallocate (flavor_state)
    end do
  end subroutine blha_configuration_append_processes

@ %def blha_configuration_append_processes
@ Change parameter(s).
<<BLHA config: public>>=
  public :: blha_configuration_set
<<BLHA config: procedures>>=
!  subroutine blha_configuration_set ( cfg, &
!       matrix_element_square_type_hel, matrix_element_square_type_hel_other, &
!       matrix_element_square_type_col, matrix_element_square_type_col_other, &
!       correction_type, correction_type_other, &
!       irreg, irreg_other, &
!       massive_particle_scheme, massive_particle_scheme_other, &
!       subtraction_mode, subtraction_mode_other, &
!       model_file, subdivide_subprocesses, alphas_power, alpha_power, &
!       operation_mode, operation_mode_other)
  subroutine blha_configuration_set (cfg, &
!       version, amplitude_type, correction_type, irreg, massive_particle_scheme, &
       version, correction_type, irreg, massive_particle_scheme, &
       model_file, alphas_power, alpha_power, ew_scheme, width_scheme, &
       accuracy, debug)
    type(blha_configuration_t), intent(inout) :: cfg
    integer, optional, intent(in) :: version
!    integer, optional, intent(in) :: amplitude_type
!    integer, optional, intent(in) :: matrix_element_square_type_hel
!    type(string_t), optional, intent(in) :: matrix_element_square_type_hel_other
!    integer, optional, intent(in) :: matrix_element_square_type_col
!    type(string_t), optional, intent(in) :: matrix_element_square_type_col_other
    integer, optional, intent(in) :: correction_type
!    type(string_t), optional, intent(in) :: correction_type_other
    integer, optional, intent(in) :: irreg
!    type(string_t), optional, intent(in) :: irreg_other
    integer, optional, intent(in) :: massive_particle_scheme
!    type(string_t), optional, intent(in) :: massive_particle_scheme_other
!    integer, optional, intent(in) :: subtraction_mode
!    type(string_t), optional, intent(in) :: subtraction_mode_other
    type(string_t), optional, intent(in) :: model_file
!    logical, optional, intent(in) :: subdivide_subprocesses
    integer, optional, intent(in) :: alphas_power, alpha_power
    integer, optional, intent(in) :: ew_scheme
    integer, optional, intent(in) :: width_scheme
    real(default), optional, intent(in) :: accuracy
    logical, optional, intent(in) :: debug
!    integer, intent(in), optional :: operation_mode
!    type(string_t), intent(in), optional :: operation_mode_other
!    if (present (matrix_element_square_type_hel)) &
!       cfg%matrix_element_square_type(1) = matrix_element_square_type_hel
!    if (present (matrix_element_square_type_hel_other)) &
!       cfg%matrix_element_square_type_other(1) = matrix_element_square_type_hel_other
!    if (present (matrix_element_square_type_col)) &
!       cfg%matrix_element_square_type(2) = matrix_element_square_type_col
!    if (present (matrix_element_square_type_col_other)) &
!       cfg%matrix_element_square_type_other(2) = matrix_element_square_type_col_other
    if (present (version)) &
       cfg%version = version
!    if (present (amplitude_type)) &
!       cfg%amplitude_type = amplitude_type
    if (present (correction_type)) &
       cfg%correction_type = correction_type
!    if (present (correction_type_other)) &
!       cfg%correction_type_other = correction_type_other
    if (present (irreg)) &
       cfg%irreg = irreg
!    if (present (irreg_other)) &
!       cfg%irreg_other = irreg_other
    if (present (massive_particle_scheme)) &
       cfg%massive_particle_scheme = massive_particle_scheme
!    if (present (massive_particle_scheme_other)) &
!       cfg%massive_particle_scheme_other = massive_particle_scheme_other
!    if (present (subtraction_mode)) &
!       cfg%subtraction_mode = subtraction_mode
!    if (present (subtraction_mode_other)) &
!       cfg%subtraction_mode_other = subtraction_mode_other
    if (present (model_file)) &
       cfg%model_file = model_file
!    if (present (subdivide_subprocesses)) &
!       cfg%subdivide_subprocesses = subdivide_subprocesses
    if (present (alphas_power)) &
       cfg%alphas_power = alphas_power
    if (present (alpha_power)) &
       cfg%alpha_power = alpha_power
!    if (present (operation_mode)) &
!       cfg%operation_mode = operation_mode
!    if (present (operation_mode_other)) &
!       cfg%operation_mode_other = operation_mode_other
    if (present (ew_scheme)) &
       cfg%ew_scheme = ew_scheme
    if (present (width_scheme)) &
       cfg%width_scheme = width_scheme
    if (present (accuracy)) &
       cfg%accuracy_target = accuracy
    if (present (debug)) &
       cfg%debug_unstable = debug
    cfg%dirty = .false.
  end subroutine blha_configuration_set

@ %def blha_configuration_set
@
<<BLHA config: public>>=
  public :: blha_configuration_get_n_proc
<<BLHA config: procedures>>=
  function blha_configuration_get_n_proc (cfg) result (n_proc)
    type(blha_configuration_t), intent(in) :: cfg
    integer :: n_proc
    n_proc = cfg%n_proc
  end function blha_configuration_get_n_proc

@ %def blha_configuration_get_n_proc
@
Write the BLHA file. Internal mode is intented for md5summing only. 
<<BLHA config: public>>=
  public :: blha_configuration_write
<<BLHA config: procedures>>=
  subroutine blha_configuration_write (cfg, unit, internal)
    type(blha_configuration_t), intent(in) :: cfg
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: internal
    integer :: u
    logical :: full
    type(string_t) :: buf
    type(blha_cfg_process_node_t), pointer :: node
    integer :: i
    character(3) :: pdg_char
    character(6) :: accuracy
    character(len=25), parameter :: pad = ""
    u = given_output_unit (unit)
    full = .true.; if (present (internal)) full = .not. internal
    if (full .and. cfg%dirty) call msg_bug ( &
       "BUG: attempted to write out a dirty BLHA configuration")
    if (full) then
       write (u,'(A)') "# BLHA order written by WHIZARD <<Version>>"
       write (u,'(A)')
    end if
    select case (cfg%mode)
       case (BLHA_MODE_GOSAM); buf = "GoSam"
       case default; buf = "vanilla"
    end select
    write (u,'(A)') "# BLHA interface mode: " // char (buf)
    write (u,'(A)') "# process: " // char (cfg%name)
    write (u,'(A)') "# model: " // char (cfg%model%get_name ())
!    if (full) then
!       write (u,'(A)')
!       write (u,'(A)') '#@WO MD5 "' // char (cfg%md5) // '"'
!       write (u,'(A)')
!    end if
!    if (all (cfg%matrix_element_square_type == BLHA_MEST_SUM)) then
!       buf = "CHsummed"
!    elseif (all (cfg%matrix_element_square_type == BLHA_MEST_AVG)) then
!       buf = "CHaveraged"
!    else
!       buf = (render_mest ("H", cfg%matrix_element_square_type(1), &
!             cfg%matrix_element_square_type_other(1)) // " ") // &
!          render_mest ("C", cfg%matrix_element_square_type(2), &
!             cfg%matrix_element_square_type_other(2))
!    end if
!    write (u,'(A25,A)') "MatrixElementSquareType" // pad, char (buf)
    select case (cfg%version)
       case (1); buf = "BLHA1"
       case (2); buf = "BLHA2"
    end select
    write (u, '(A25,A)') "InterfaceVersion " // pad, char (buf)
    select case (cfg%correction_type)
       case (BLHA_CT_QCD); buf = "QCD"
       case (BLHA_CT_EW); buf = "EW"
       case (BLHA_CT_QED); buf = "QED"
       case default; buf = cfg%correction_type_other
    end select
    write (u,'(A25,A)') "CorrectionType" // pad, char (buf)
    select case (cfg%irreg)
       case (BLHA_IRREG_CDR); buf = "CDR"
       case (BLHA_IRREG_DRED); buf = "DRED"
       case (BLHA_IRREG_THV); buf = "tHV"
       case (BLHA_IRREG_MREG); buf = "MassReg"
       case default; buf = cfg%irreg_other
    end select
    write (u,'(A25,A)') "IRregularisation" // pad, char (buf)
    select case (cfg%massive_particle_scheme)
       case (BLHA_MPS_ONSHELL); buf = "OnShell"
       case default; buf = cfg%massive_particle_scheme_other
    end select
    write (u,'(A25,A)') "MassiveParticleScheme" // pad, char (buf)
!    select case (cfg%subtraction_mode)
!       case (BLHA_SUBMODE_NONE); buf = "None"
!       case default; buf = cfg%subtraction_mode_other
!    end select
!    write (u,'(A25,A)') "IRsubtractionMethod" // pad, char (buf)
!    write (u,'(A25,A)') "ModelFile" // pad, char (cfg%model_file)
!    if (cfg%subdivide_subprocesses) then
!       write (u,'(A25,A)') "SubdivideSubprocesses" // pad, "yes"
!    else
!       write (u,'(A25,A)') "SubdivideSubprocess" // pad, "no"
!    end if
    if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
       "AlphasPower" // pad, int2char (cfg%alphas_power)
    if (cfg%alpha_power >= 0) write (u,'(A25,A)') &
       "AlphaPower " // pad, int2char (cfg%alpha_power)
    select case (cfg%ew_scheme)
       case (BLHA_EW_GF); buf = "alphaGF"
       case (BLHA_EW_MZ); buf = "alphaMZ"
       case (BLHA_EW_MSBAR); buf = "alphaMSbar"
       case (BLHA_EW_0); buf = "alpha0"
       case (BLHA_EW_RUN); buf = "alphaRUN"
       case (BLHA_EW_DEFAULT); buf = "OLPDefined"
    end select
    write (u, '(A25, A)') "EWScheme " // pad, char (buf)
    if (full) then
       write (u,'(A)')
       write (u,'(A)') "# Process definitions"
       write (u,'(A)')
    end if
!    if (cfg%accuracy_target /= 0) then
!      write (accuracy, '(f6.5)') cfg%accuracy_target
!      write (u, '(A25,A)') "AccuracyTarget " // pad , accuracy 
!    end if
    if (cfg%debug_unstable) then
      buf = "True"
    else
      buf = "False"
    end if
    write (u, '(A25,A)') "DebugUnstable " // pad, char (buf)
    write (u, *)
    node => cfg%processes
    do while (associated (node))
       select case (node%amplitude_type)
         case (BLHA_AMP_LOOP); buf = "Loop"
         case (BLHA_AMP_CC); buf = "ccTree"
         case (BLHA_AMP_SC); buf = "scTree"
         case (BLHA_AMP_TREE); buf = "Tree"
         case (BLHA_AMP_LOOPINDUCED); buf = "LoopInduced"
       end select
       write (u, '(A25, A)') "AmplitudeType " // pad, char (buf)

       buf = ""
       do i = 1, size (node%pdg_in)
          write (pdg_char,'(I3)') node%pdg_in(i)
          buf = (buf // pdg_char) // " "
       end do
       buf = buf // "-> "
       do i = 1, size (node%pdg_out)
          write (pdg_char,'(I3)') node%pdg_out(i)
          buf = (buf // pdg_char) // " "
       end do
       write (u,'(A)') char (trim (buf))
       write (u, *)
       node => node%next
    end do

  contains

    function render_mest (prefix, mest, other) result (tag)
      character, intent(in) :: prefix
      integer, intent(in) :: mest
      type(string_t), intent(in) :: other
      type(string_t) :: tag
      select case (mest)
      case (BLHA_MEST_AVG); tag = prefix // "averaged"
      case (BLHA_MEST_SUM); tag = prefix // "summed"
      case default; tag = other
      end select
    end function render_mest

  end subroutine blha_configuration_write

@ %def blha_configuration_write
@
``Freeze'' the configuration by calculating the MD5 sum.
<<BLHA config: public>>=
  public :: blha_configuration_freeze
<<BLHA config: procedures>>=
  subroutine blha_configuration_freeze (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    integer :: u
    if (.not. cfg%dirty) return
    call sort_processes (cfg%processes)
    u = free_unit ()
    open (unit=u, status="scratch", action="readwrite")
    call blha_configuration_write (cfg, u, internal=.true.)
    rewind (u)
    cfg%md5 = md5sum (u)
    cfg%dirty = .false.
    close (u)
  end subroutine blha_configuration_freeze

@ %def blha_configuration_freeze
@
Read a contract file, again creating a [[blha_configuration_t]]
object. 
<<BLHA config: public>>=
  public :: blha_read_contract
<<BLHA config: interfaces>>=
  interface blha_read_contract
     module procedure blha_read_contract_unit, &
          blha_read_contract_file
  end interface blha_read_contract 
  
<<BLHA config: procedures>>=
  subroutine blha_read_contract_file (cfg, ok, fname, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(string_t), intent(in) :: fname
    logical, intent(out), optional :: success
    integer :: u, stat
    u = free_unit ()
    open (u, file=char (fname), status="old", action="read", iostat=stat)
    if (stat /= 0) then
       if (present (success)) then
          success = .false.
          return
       else
          call msg_bug ('Unable to open contract file "' // char (fname) // '"')
       end if
    end if
    call blha_read_contract_unit (cfg, ok, u, success)
    close (u)
  end subroutine blha_read_contract_file

  subroutine blha_read_contract_unit (cfg, ok, u, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    integer, intent(in) :: u
    logical, intent(out), optional :: success
    type(stream_t) :: stream
    type(ifile_t) :: preprocessed
    type(lexer_t) :: lexer
    type(parse_tree_t) :: parse_tree
    type(string_t) :: md5
    call stream_init (stream, u)
    call contract_preprocess (stream, preprocessed)
    call stream_final (stream)
    call stream_init (stream, preprocessed)
    call blha_init_lexer (lexer)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_blha_contract, lexer)
    call blha_transfer_contract (cfg, ok, parse_tree, success)
    call blha_configuration_write (cfg, internal=.true.)
    call lexer_final (lexer)
    call stream_final (stream)
    call ifile_final (preprocessed)
    if (ok) then
       md5 = cfg%md5
       call blha_configuration_freeze (cfg)
       if (char (trim (md5 )) /= "") then
          if (md5 /= cfg%md5) then
             call msg_warning ("BLHA contract does not match the recorded " &
                // "checksum --- this counts as an error!")
             ok = .false.
          end if
       else
          call msg_warning ("It seems the OLP scrubbed our checksum, unable " &
             // "to check contract consistency.")
       end if
    end if
  end subroutine blha_read_contract_unit

@ %def blha_read_contract blha_read_contract_file 
@ %def blha_read_contract_unit
@
Walk the parse tree and transfer the results to the
[[blha_configuration]] object. The [[goto]] is a poor man's
replacement for exceptions which would be an appropiate error handling  
mechanism here. 
<<BLHA config: procedures>>=
  subroutine blha_transfer_contract (cfg, ok, parse_tree, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(parse_tree_t), intent(in), target :: parse_tree
    logical, intent(out), optional :: success
    type(parse_node_t), pointer :: pn_root, pn_line, pn_request, &
         pn_result, pn_key, pn_opt, pn_state_in, pn_state_out, pn_pdg
    type(string_t) :: emsg
    integer :: nopt, i, nsub
    integer, dimension(:), allocatable :: ids
    logical, dimension(2) :: flags
    type(pdg_array_t), dimension(:), allocatable :: pdg_in, pdg_out
    ok = .true.
    pn_root => parse_tree_get_root_ptr (parse_tree)
    pn_line => parse_node_get_sub_ptr (pn_root)
    do while (associated (pn_line))
       pn_request => parse_node_get_sub_ptr (pn_line)
       if (.not. associated (pn_request)) cycle
       if (char (parse_node_get_rule_key (pn_request)) == "process") then
          pn_result => parse_node_get_sub_ptr (pn_line, 2)
          pn_state_in => parse_node_get_sub_ptr (pn_request, 1)
          pn_state_out => parse_node_get_sub_ptr (pn_request, 3)
          allocate (pdg_in (parse_node_get_n_sub (pn_state_in)))
          allocate (pdg_out (parse_node_get_n_sub (pn_state_out)))
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_in)
          do while (associated (pn_pdg))
             pdg_in(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_out)
          do while (associated (pn_pdg))
             pdg_out(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = parse_node_get_n_sub (pn_result)
          emsg = "broken process line"
          if (i < 2) goto 10
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          do while (associated (pn_opt))
             if (char (parse_node_get_rule_key (pn_opt)) == "string") then
                call msg_warning ("While reading the BLHA contract: " // &
                   'the OLP returned an error for a process: "' // &
                   char (parse_node_get_string (pn_opt)) // '"')
                ok = .false.
                return
             end if
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          nsub = get_int (pn_opt)
          if (nsub /= i - 2) goto 10
          allocate (ids(nsub))
          i = 1
          pn_opt => parse_node_get_next_ptr (pn_opt)
          do while (associated (pn_opt))
             ids(i) = get_int (pn_opt)
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          call blha_configuration_append_process (cfg, pdg_in, pdg_out, &
             nsub=nsub, ids=ids)
          deallocate (pdg_in, pdg_out, ids)
       else
          pn_result => parse_node_get_sub_ptr (parse_node_get_next_ptr (pn_request), 2)
          pn_key => parse_node_get_sub_ptr (pn_request)
          pn_opt => parse_node_get_next_ptr (pn_key)
          nopt = parse_node_get_n_sub (pn_request) - 1
          select case (char (parse_node_get_rule_key (pn_key)))
             case ("md5")
                cfg%md5 = parse_node_get_string (pn_opt)
             case ("modelfile")
                cfg%model_file = get_fname (pn_opt)
                call check_result (pn_result, "ModelFile")
             case ("irregularisation")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("cdr"); cfg%irreg = BLHA_IRREG_CDR
                   case ("dred"); cfg%irreg = BLHA_IRREG_DRED
                   case ("thv"); cfg%irreg = BLHA_IRREG_THV
                   case ("mreg"); cfg%irreg = BLHA_IRREG_MREG
                   case default
                      cfg%irreg = BLHA_IRREG_OTHER 
                      cfg%irreg_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "IRRegularisation")
             case ("irsubtractionmethod")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("none"); cfg%subtraction_mode = BLHA_SUBMODE_NONE
                   case default
                      cfg%subtraction_mode = BLHA_SUBMODE_OTHER
                      cfg%subtraction_mode_other = parse_node_get_string(pn_opt)
                end select
                call check_result (pn_result, "IRSubtractionMethod")
             case ("massiveparticlescheme")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("onshell")
                      cfg%massive_particle_scheme = BLHA_MPS_ONSHELL
                   case default
                      cfg%massive_particle_scheme = BLHA_MPS_OTHER
                      cfg%massive_particle_scheme_other = &
                         parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "MassiveParticleScheme")
             case ("matrixelementsquaretype")
                select case (nopt)
                   case (1)
                      select case (lower_case (char (parse_node_get_string (pn_opt))))
                         case ("chsummed")
                            cfg%matrix_element_square_type = BLHA_MEST_SUM
                         case ("chaveraged")
                            cfg%matrix_element_square_type = BLHA_MEST_AVG
                         case default
                            emsg = "invalid MatrixElementSquareType: " // &
                               parse_node_get_string (pn_opt)
                            goto 10
                      end select
                   case (2)
                      do i = 1, 2
                         pn_opt => parse_node_get_next_ptr (pn_key, i)
                         select case (lower_case (char (parse_node_get_string ( &
                               pn_opt))))
                            case ("csummed")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_SUM
                               flags(2) = .true.
                            case ("caveraged")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_AVG
                               flags(2) = .true.
                            case ("hsummed")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_SUM
                               flags(1) = .true.
                            case ("haveraged")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_AVG
                               flags(1) = .true.
                            case default
                               emsg = "invalid MatrixElementSquareType: " // &
                                  parse_node_get_string (pn_opt)
                               goto 10
                         end select
                      end do
                      if (.not. all (flags)) then
                         emsg = "MatrixElementSquareType: setup not exhaustive"
                         goto 10
                      end if
                   case default
                      emsg = "MatrixElementSquareType: too many options"
                      goto 10
                end select
                call check_result (pn_result, "MatrixElementSquareType")
             case ("correctiontype")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("qcd"); cfg%correction_type = BLHA_CT_QCD
                   case ("qed"); cfg%correction_type = BLHA_CT_QED
                   case ("ew"); cfg%correction_type = BLHA_CT_EW
                   case default
                      cfg%correction_type = BLHA_CT_OTHER
                      cfg%correction_type_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "CorrectionType")
             case ("alphaspower")
                cfg%alphas_power = get_int (pn_opt)
                call check_result (pn_result, "AlphasPower")
             case ("alphapower")
                cfg%alpha_power = get_int (pn_opt)
                call check_result (pn_result, "AlphaPower")
             case ("subdividesubprocess")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("yes"); cfg%subdivide_subprocesses = .true.
                   case ("no"); cfg%subdivide_subprocesses = .false.
                   case default
                      emsg = 'SubdivideSubprocess: invalid argument "' // &
                         parse_node_get_string (pn_opt) // '"'
                      goto 10
                end select
                call check_result (pn_result, "SubdivideSubprocess")
             case default
                emsg = "unknown statement: " // parse_node_get_rule_key (pn_key)
                goto 10
          end select
       end if
       pn_line => parse_node_get_next_ptr (pn_line)
    end do
    if (present (success)) success = .true.
    return
10  continue
    if (present (success)) then
       call msg_error ("Error reading BLHA contract: " // char (emsg))
       success = .false.
       return
    else
       call msg_fatal ("Error reading BLHA contract: " // char (emsg))
    end if

  contains

    function get_int (pn) result (i)
      type(parse_node_t), pointer :: pn
      integer :: i
      if (char (parse_node_get_rule_key (pn)) == "integer") then
         i = parse_node_get_integer (pn)
      else
         i = parse_node_get_integer (parse_node_get_sub_ptr (pn, 2))
         if (char (parse_node_get_rule_key (parse_node_get_sub_ptr (pn))) &
              == "-") i = -i
      end if
    end function get_int

    subroutine check_result (pn, step)
      type(parse_node_t), pointer :: pn
      character(*), intent(in) :: step
      type(string_t) :: res
      res = parse_node_get_string (pn)
      if (char (trim (res)) == "") then
         call msg_warning ("BLHA contract file: " // step // &
              ": OLP didn't return a status --- assuming an error")
         ok = .false.
      elseif (char (upper_case (res)) /= "OK") then
         call msg_warning ("BLHA contract file: " // step // &
              ': OLP error "' // char (res) // '"')
         ok = .false.
      end if
    end subroutine check_result

    function get_fname (pn) result (fname)
      type(parse_node_t), pointer :: pn
      type(string_t) :: fname
      type(parse_node_t), pointer :: pn_component
      if (char (parse_node_get_rule_key (pn)) == "string") then
         fname = parse_node_get_string (pn)
      else
         fname = ""
         pn_component => parse_node_get_sub_ptr (pn)
         do while (associated (pn_component))
            if (char (parse_node_get_rule_key (pn_component)) == "id") then
               fname = fname // parse_node_get_string (pn_component)
            else
               fname = fname // parse_node_get_key (pn_component)
            end if
            pn_component => parse_node_get_next_ptr (pn_component)
         end do
      end if
    end function get_fname

  end subroutine blha_transfer_contract

@ %def blha_transfer_contract
@
Initialize the lexer.
<<BLHA config: procedures>>=
  subroutine blha_init_lexer (lexer)
    type(lexer_t), intent(inout) :: lexer
    call lexer_init (lexer, &
       comment_chars = "#", &
       quote_chars = '"', &
       quote_match = '"', &
       single_chars = '{}|./\:', &
       special_class = ["->"], &
       keyword_list = syntax_get_keyword_list_ptr (syntax_blha_contract), &
       upper_case_keywords = .false. &
       ) 
  end subroutine blha_init_lexer

@ %def blha_init_lexer
@
Define the parser syntax table.
<<BLHA config: variables>>=
  type(syntax_t), target, save :: syntax_blha_contract
<<BLHA config: public>>=
  public :: syntax_blha_contract_init
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_init ()
    type(ifile_t) :: ifile
    call ifile_append (ifile, "SEQ contract = line*")
    call ifile_append (ifile, "KEY '->'")
    call ifile_append (ifile, "KEY '.'")
    call ifile_append (ifile, "KEY '/'")
    call ifile_append (ifile, "KEY '\'")
    call ifile_append (ifile, "KEY '+'")
    call ifile_append (ifile, "KEY '-'")
    call ifile_append (ifile, "KEY '|'")
    call ifile_append (ifile, "KEY ':'")
    call ifile_append (ifile, "IDE id")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "ALT sign = '+' | '-'")
    call ifile_append (ifile, "SEQ signed_integer = sign integer")
    call ifile_append (ifile, "QUO string = '""'...'""'")
    call ifile_append (ifile, "GRO line = '{' line_contents '}'")
    call ifile_append (ifile, "SEQ line_contents = request result?")
    call ifile_append (ifile, "ALT request = definition | process")
    call ifile_append (ifile, "ALT definition = option_unary | option_nary | " &
       // "option_path | option_numeric")
    call ifile_append (ifile, "KEY matrixelementsquaretype")
    call ifile_append (ifile, "KEY irregularisation")
    call ifile_append (ifile, "KEY massiveparticlescheme")
    call ifile_append (ifile, "KEY irsubtractionmethod")
    call ifile_append (ifile, "KEY modelfile")
    call ifile_append (ifile, "KEY operationmode")
    call ifile_append (ifile, "KEY subdividesubprocess")
    call ifile_append (ifile, "KEY alphaspower")
    call ifile_append (ifile, "KEY alphapower")
    call ifile_append (ifile, "KEY correctiontype")
    call ifile_append (ifile, "KEY md5")
    call ifile_append (ifile, "SEQ option_unary = key_unary arg")
    call ifile_append (ifile, "SEQ option_nary = key_nary arg+")
    call ifile_append (ifile, "SEQ option_path = key_path arg_path")
    call ifile_append (ifile, "SEQ option_numeric = key_numeric arg_numeric")
    call ifile_append (ifile, "ALT key_unary = irregularisation | " &
       // "massiveparticlescheme | irsubtractionmethod | subdividesubprocess | " &
       // "correctiontype | md5")
    call ifile_append (ifile, "ALT key_nary = matrixelementsquaretype | " &
       // "operationmode")
    call ifile_append (ifile, "ALT key_numeric = alphaspower | alphapower")
    call ifile_append (ifile, "ALT key_path = modelfile")
    call ifile_append (ifile, "ALT arg = id | string")
    call ifile_append (ifile, "ALT arg_numeric = integer | signed_integer")
    call ifile_append (ifile, "ALT arg_path = filename | string")
    call ifile_append (ifile, "SEQ filename = filename_atom+")
    call ifile_append (ifile, "ALT filename_atom = id | '.' | '/' | '\' | ':'")
    call ifile_append (ifile, "SEQ process = state '->' state")
    call ifile_append (ifile, "SEQ state = pdg+")
    call ifile_append (ifile, "ALT pdg = integer | signed_integer")
    call ifile_append (ifile, "SEQ result = '|' result_atom+")
    call ifile_append (ifile, "ALT result_atom = integer | string")
    call syntax_init (syntax_blha_contract, ifile)
    call ifile_final (ifile)
  end subroutine syntax_blha_contract_init

@ %def syntax_blha_contract_init
@
<<BLHA config: public>>=
  public :: syntax_blha_contract_final
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_final
    call syntax_final (syntax_blha_contract)
  end subroutine syntax_blha_contract_final

@ %def syntax_blha_contract_final
@
As the contract file is line-oriented, we apply a preprocessing step which
reformats the file in a way suitable for our free-form parser.
<<BLHA config: procedures>>=
  subroutine contract_preprocess (stream, ifile)
    type(stream_t), intent(inout) :: stream
    type(ifile_t), intent(out) :: ifile
    type(string_t) :: buf, reg, transformed
    integer :: stat, n
    buf = ""
    LINES: do
       call stream_get_record (stream, reg, stat)
       select case (stat)
          case (0)
          case (EOF); exit LINES
          case default
             call msg_bug ("I/O error while reading BLHA contract file")
       end select
       buf = buf // trim (reg)
       ! Take care of continuation lines
       if (char (extract (buf, len (buf), len(buf))) == '&') then
          buf = extract (buf, 1, len (buf) - 1) // " "
          cycle LINES
       end if
       buf = adjustl (buf)
       ! Transform #@WO comments into ordinary statements
       if (char (extract (buf, 1, 4)) == "#@WO") &
          buf = extract (buf, 5)
       ! Kill comments and blank lines
       if ((char (trim (buf)) == "") .or. &
          (char (extract (buf, 1, 1)) == "#")) then
             buf = ""
             cycle LINES
          end if
       ! Chop off any end-of-line comments
       call split (buf, reg, "#")
       ! Split line into order and result
       call split (reg, buf, "|")
       reg = trim (adjustl (reg))
       buf = trim (adjustl (buf))
       ! Check whether the order is a process definition
       n = scan (buf, ">")
       if (n == 0) then
          ! No -> quote result
          reg = ('"' // reg) // '"'
       else
          ! Yes -> leave any numbers as they are, quote any leftovers
          n = scan (reg, "0123456789", back=.true.)
          if (n < len (reg)) &
             reg = char (extract (reg, 1, n)) // ' "' // &
                char (trim (adjustl (extract (reg, n+1)))) // '"'
       end if
       ! Enclose the line into curly brackets
       transformed = "{" // char (buf) // " | " // char (reg) // "}"
       call ifile_append (ifile, transformed)
       buf = ""
    end do LINES
  end subroutine contract_preprocess

@ %def contract_preprocess
@
Test.
<<BLHA config: public>>=
  public :: blha_config_test
<<BLHA config: procedures>>=
  subroutine blha_config_test (model, cfg, ok)
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(4) :: pdg_out
    type(model_t), pointer :: model
    type(blha_configuration_t), intent(out) :: cfg
    logical, intent(out) :: ok
    integer :: u
    logical :: flag
    ok = .false.
    pdg_in(1) = [1, 2, -1, -2]
    pdg_in(2) = pdg_in(1)
    pdg_out(1) = pdg_in(1)
    pdg_out(2) = [11]
    pdg_out(3) = [-11]
    pdg_out(4) = pdg_out(1)
    call blha_configuration_init (cfg, var_str ("test"), model)
    call blha_configuration_set (cfg, alphas_power = 2, alpha_power = 3)
    call blha_configuration_append_process (cfg, pdg_in, pdg_out)
    call blha_configuration_freeze (cfg)
    print *
    call blha_configuration_write (cfg)
    print *
    call blha_configuration_final (cfg)
    call blha_configuration_init (cfg, var_str ("test"), model, &
       mode=BLHA_MODE_GOSAM)
    call blha_configuration_set (cfg, alphas_power = 0, &
       model_file = var_str ("test.slha"))
    pdg_in(1) = [1]
    pdg_in(2) = [-1]
    pdg_out(1) = [22]
    pdg_out(2) = [22]   
    call blha_configuration_append_process (cfg, pdg_in, pdg_out(1:2))
    call blha_configuration_freeze (cfg)
    u = free_unit ()
    open (u, file="test.blha.order", action="write", status="replace")
    call blha_configuration_write (cfg, u)
    call blha_configuration_final (cfg)
    inquire (file="test.blha.contract", exist=flag)
    if (.not. flag) return
    call blha_configuration_init (cfg, var_str ("test"), model, mode=BLHA_MODE_GOSAM)
    call blha_read_contract (cfg, ok, var_str ("test.blha.contract"), success=flag)
    print *, "Reading back processed configuration: success? ", ok
  end subroutine blha_config_test

@ %def blha_config_test
@

\subsection{OLP matrix element interface}

The prototypes of the OLP functions.
<<BLHA interface: interfaces>>=
  abstract interface
     subroutine ext_olp_start (file, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: file
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_Start

     subroutine ext_olp_evalsubprocess &
          (label, momenta, scale, parameters, amp) bind(c)
       import
       integer(c_int), intent(in), value :: label
       real(c_double), dimension(*), intent(in) :: momenta
       real(c_double), intent(in), value :: scale
       real(c_double), dimension(*), intent(in) :: parameters
       real(c_double), dimension(*), intent(out) :: amp
     end subroutine ext_olp_evalsubprocess

     subroutine ext_olp_finalize () bind(c)
     end subroutine ext_olp_finalize

     subroutine ext_olp_option (assignment, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: assignment
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_option
  end interface

@ %def ext_olp_start ext_olp_evalsubprocess ext_olp_finalize
@ %def ext_olp_option
@
The OLP library is encapsulated together with the configuration in
derived type: 
<<BLHA interface: public>>=
  public :: blha_olp_t
<<BLHA interface: types>>=
  type :: blha_olp_t
     private
     type(blha_configuration_t) :: cfg
     type(string_t) :: library
     integer :: n_in, n_out, n_flv, n_hel, n_col
     integer, dimension(:,:), allocatable :: flv_state
     logical :: color_summed = .true., flavor_summed = .true.
     logical :: loaded = .false.
     type(dlaccess_t) :: lib_handle
     procedure(ext_olp_start), pointer, nopass :: olp_start => null ()
     procedure(ext_olp_evalsubprocess), pointer, nopass :: &
        olp_evalsubprocess => null ()
     procedure(ext_olp_finalize), pointer, nopass :: olp_finalize => null ()
     procedure(ext_olp_option), pointer, nopass :: olp_option => null ()
  end type blha_olp_t

@ %def blha_olpt_t
@
Init the [[blha_olp_t]] object and try to dlopen the library. 
<<BLHA interface: public>>=
  public :: blha_olp_init
<<BLHA interface: procedures>>=
  subroutine blha_olp_init (olp, cfg, library, success)
    type(blha_olp_t), intent(out) :: olp
    type(string_t), intent(in), optional :: library
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out), optional :: success
    type(blha_cfg_process_node_t), pointer :: node
    type(string_t) :: prefix, libname
    type(c_funptr) :: fptr
    integer :: olp_status
    success = .true.
    node => cfg%processes
    if (.not. associated (node)) then
       call error ("blha_interface_init: empty process list")
       return
    end if
    olp%n_in = size (node%pdg_in)
    olp%n_out = size (node%pdg_out)
    do while (associated (node))
       if ((olp%n_in /= size (node%pdg_in)) .or. &
             (olp%n_out /= size (node%pdg_out))) then
          call error ("blha_interface_init: inconsistent process list")
          return
       end if
       node => node%next
    end do
    if (present (library)) then
       olp%library = library
    else
       olp%library = cfg%name // ".so"
    end if
    if (char (extract (olp%library, 1, 1)) == "/") then
       prefix = ""
       libname = extract (olp%library, 2)
    else
       prefix = "."
       libname = olp%library
    end if
    call dlaccess_init (olp%lib_handle, prefix, libname)
    if (dlaccess_has_error (olp%lib_handle)) then
       call error ("blha_interface_init: error opening library: " // &
          char (dlaccess_get_error (olp%lib_handle)))
       call dlaccess_final (olp%lib_handle)
       return
    end if
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Start"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_start)
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_EvalSubProcess"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_evalsubprocess)
    if (olp%cfg%mode == BLHA_MODE_GOSAM) then
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Finalize"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_finalize)
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Option"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_option)
    end if
    call olp%olp_start (string_f2c (cfg%model_file), olp_status)
    if (olp_status /= 1) then
       call error ("blha_interface_init: OLP initialization failed")
       call dlaccess_final (olp%lib_handle)
    end if
    success = .true.
    olp%loaded = .true.

  contains

    function check_dlstate () result (ok)
      logical :: ok
      ok = .not. dlaccess_has_error (olp%lib_handle)
      if (.not. ok) then
         call error ("blha_interface_init: error loading library: " // &
              char (dlaccess_get_error (olp%lib_handle)))
         call dlaccess_final (olp%lib_handle)
      end if
    end function check_dlstate
   
    subroutine error (msg)
      character(*), intent(in) :: msg
      if (present (success)) then
         call msg_error (msg)
         success = .false.
      else
         call msg_fatal (msg)
      end if
    end subroutine error

  end subroutine blha_olp_init

@ %def blha_olp_init
@ Finalizer.
<<BLHA interface: public>>=
  public :: blha_olp_final
<<BLHA interface: procedures>>=
  subroutine blha_olp_final (olp)
    type(blha_olp_t), intent(inout) :: olp
    if (.not. olp%loaded) return
    if (associated (olp%olp_finalize)) call olp%olp_finalize
    call dlaccess_final (olp%lib_handle)
    olp%loaded = .false.
  end subroutine blha_olp_final

@ %def blha_olp_final
@ Test.
<<BLHA interface: public>>=
  public :: blha_interface_test
<<BLHA interface: procedures>>=
  subroutine blha_interface_test (cfg, ok)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_olp_t) :: olp
    logical, intent(out) :: ok
    call blha_olp_init (olp, cfg, library=var_str ("blha_test.so"), success=ok)
    print *, "loading OLP library: success?", ok
    call blha_olp_final (olp)
  end subroutine blha_interface_test

@ %def blha_interface_test
@
\subsection{OLP driver}

<<BLHA driver: public>>=
  public :: blha_test
<<BLHA driver: procedures>>=
  subroutine blha_test (model)
    type(model_t), pointer :: model
    type (blha_configuration_t) :: cfg
    logical :: ok
    call blha_config_test (model, cfg, ok)
    if (ok) call blha_interface_test (cfg, ok)
  end subroutine blha_test

@ %def blha_test
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integration and simulation}

This layer of modules is just below the top-level API.  We lay out specific
data types for integration and simulation and implement the corresponding
algorithms as methods acting on them.  This helps to keep the command-level
implementation concise and simple.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User-controlled File I/O}

The SINDARIN language includes commands that write output to file (input may
be added later).  We identify files by their name, and manage the unit
internally.  We need procedures for opening, closing, and printing files.

<<[[user_files.f90]]>>=
<<File header>>

module user_files

<<Use strings>>
  use io_units
  use diagnostics
  use ifiles
  use analysis

<<Standard module head>>

<<User files: public>>

<<User files: types>>

<<User files: interfaces>>

contains

<<User files: procedures>>

end module user_files
@ %def user_files
@
\subsection{The file type}
This is a type that describes an open user file and its properties.  The entry
is part of a doubly-linked list.
<<User files: types>>=
  type :: file_t
     private
     type(string_t) :: name
     integer :: unit = -1
     logical :: reading = .false.
     logical :: writing = .false.
     type(file_t), pointer :: prev => null ()
     type(file_t), pointer :: next => null ()
  end type file_t

@ %def file_t
@ The initializer opens the file.
<<User files: procedures>>=
  subroutine file_init (file, name, action, status, position)
    type(file_t), intent(out) :: file
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action, status, position
    file%unit = free_unit ()
    file%name = name
    open (unit = file%unit, file = char (file%name), &
          action = action, status = status, position = position)
    select case (action)
    case ("read")
       file%reading = .true.
    case ("write")
       file%writing = .true.
    case ("readwrite")
       file%reading = .true.    
       file%writing = .true.    
    end select
  end subroutine file_init

@ %def file_init
@ The finalizer closes it.
<<User files: procedures>>=
  subroutine file_final (file)
    type(file_t), intent(inout) :: file
    close (unit = file%unit)
    file%unit = -1
  end subroutine file_final

@ %def file_init
@ Check if a file is open with correct status.
<<User files: procedures>>=
  function file_is_open (file, action) result (flag)
    logical :: flag
    type(file_t), intent(in) :: file
    character(*), intent(in) :: action
    select case (action)
    case ("read")
       flag = file%reading
    case ("write")
       flag = file%writing
    case ("readwrite")
       flag = file%reading .and. file%writing
    case default
       call msg_bug ("Checking file '" // char (file%name) &
            // "': illegal action specifier")
    end select
  end function file_is_open

@ %def file_is_open
@ Write to the file.  Error if in wrong mode.  If there is no string, just
write an empty record.  If there is a string, respect the [[advancing]]
option.
<<User files: procedures>>=
  subroutine file_write_string (file, string, advancing)
    type(file_t), intent(in) :: file
    type(string_t), intent(in), optional :: string
    logical, intent(in), optional :: advancing
    if (file%writing) then
       if (present (string)) then
          if (present (advancing)) then
             if (advancing) then
                write (file%unit, "(A)")  char (string)
             else
                write (file%unit, "(A)", advance="no")  char (string)
             end if
          else
             write (file%unit, "(A)")  char (string)
          end if
       else
          write (file%unit, *)
       end if
    else
       call msg_error ("Writing to file: File '" // char (file%name) &
            // "' is not open for writing.")
    end if
  end subroutine file_write_string

@ %def file_write
@ Write a whole ifile, line by line.
<<User files: procedures>>=
  subroutine file_write_ifile (file, ifile)
    type(file_t), intent(in) :: file
    type(ifile_t), intent(in) :: ifile
    type(line_p) :: line
    call line_init (line, ifile)
    do while (line_is_associated (line))
       call file_write_string (file, line_get_string_advance (line))
    end do
  end subroutine file_write_ifile

@ %def file_write_ifile
@ Write an analysis object (or all objects) to an open file.
<<User files: procedures>>=
  subroutine file_write_analysis (file, tag)
    type(file_t), intent(in) :: file
    type(string_t), intent(in), optional :: tag
    if (file%writing) then
       if (present (tag)) then
          call analysis_write (tag, unit = file%unit)
       else
          call analysis_write (unit = file%unit)
       end if
    else
       call msg_error ("Writing analysis to file: File '" // char (file%name) &
            // "' is not open for writing.")
    end if
  end subroutine file_write_analysis

@ %def file_write_analysis
@
\subsection{The file list}
We maintain a list of all open files and their attributes.  The list must be
doubly-linked because we may delete entries.
<<User files: public>>=
  public :: file_list_t
<<User files: types>>=
  type :: file_list_t
     type(file_t), pointer :: first => null ()
     type(file_t), pointer :: last => null ()
  end type file_list_t

@ %def file_list_t
@ There is no initialization routine, but a finalizer which deletes all:
<<User files: public>>=
  public :: file_list_final
<<User files: procedures>>=
  subroutine file_list_final (file_list)
    type(file_list_t), intent(inout) :: file_list
    type(file_t), pointer :: current
    do while (associated (file_list%first))
       current => file_list%first
       file_list%first => current%next
       call file_final (current)
       deallocate (current)
    end do
    file_list%last => null ()
  end subroutine file_list_final

@ %def file_list_final
@ Find an entry in the list.  Return null pointer on failure.
<<User files: procedures>>=
  function file_list_get_file_ptr (file_list, name) result (current)
    type(file_t), pointer :: current
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    current => file_list%first
    do while (associated (current))
       if (current%name == name)  return
       current => current%next
    end do
  end function file_list_get_file_ptr

@ %def file_list_get_file_ptr
@ Check if a file is open, public version:
<<User files: public>>=
  public :: file_list_is_open
<<User files: procedures>>=
  function file_list_is_open (file_list, name, action) result (flag)
    logical :: flag
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       flag = file_is_open (current, action)
    else
       flag = .false.
    end if
  end function file_list_is_open

@ %def file_list_is_open
@ Append a new file entry, i.e., open this file.  Error if it is
already open.
<<User files: public>>=
  public :: file_list_open
<<User files: procedures>>=
  subroutine file_list_open (file_list, name, action, status, position)
    type(file_list_t), intent(inout) :: file_list
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action, status, position
    type(file_t), pointer :: current
    if (.not. associated (file_list_get_file_ptr (file_list, name))) then
       allocate (current)
       call msg_message ("Opening file '" // char (name) // "' for output")
       call file_init (current, name, action, status, position)
       if (associated (file_list%last)) then
          file_list%last%next => current
          current%prev => file_list%last
       else
          file_list%first => current
       end if
       file_list%last => current
    else
       call msg_error ("Opening file: File '" // char (name) &
            // "' is already open.")
    end if
  end subroutine file_list_open

@ %def file_list_open
@ Delete a file entry, i.e., close this file.  Error if it is not open.
<<User files: public>>=
  public :: file_list_close
<<User files: procedures>>=
  subroutine file_list_close (file_list, name)
    type(file_list_t), intent(inout) :: file_list
    type(string_t), intent(in) :: name
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       if (associated (current%prev)) then
          current%prev%next => current%next
       else
          file_list%first => current%next
       end if
       if (associated (current%next)) then
          current%next%prev => current%prev
       else
          file_list%last => current%prev
       end if
       call msg_message ("Closing file '" // char (name) // "' for output")
       call file_final (current)
       deallocate (current)
    else
       call msg_error ("Closing file: File '" // char (name) &
            // "' is not open.")
    end if
  end subroutine file_list_close

@ %def file_list_close
@ Write a string to file.  Error if it is not open.
<<User files: public>>=
  public :: file_list_write
<<User files: interfaces>>=
  interface file_list_write
     module procedure file_list_write_string
     module procedure file_list_write_ifile
  end interface
<<User files: procedures>>=
  subroutine file_list_write_string (file_list, name, string, advancing)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: string
    logical, intent(in), optional :: advancing
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       call file_write_string (current, string, advancing)
    else
       call msg_error ("Writing to file: File '" // char (name) &
            // "'is not open.")
    end if
  end subroutine file_list_write_string

  subroutine file_list_write_ifile (file_list, name, ifile)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(ifile_t), intent(in) :: ifile
    type(line_p) :: line
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       call file_write_ifile (current, ifile)
    else
       call msg_error ("Writing to file: File '" // char (name) &
            // "'is not open.")
    end if
  end subroutine file_list_write_ifile

@ %def file_list_write
@ Write an analysis object or all objects to data file.  Error if it is not
open.  If the file name is empty, write to standard output.
<<User files: public>>=
  public :: file_list_write_analysis
<<User files: procedures>>=
  subroutine file_list_write_analysis (file_list, name, tag)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: tag
    type(file_t), pointer :: current
    if (name == "") then
       if (present (tag)) then
          call analysis_write (tag)
       else
          call analysis_write
       end if
    else
       current => file_list_get_file_ptr (file_list, name)
       if (associated (current)) then
          call file_write_analysis (current, tag)
       else
          call msg_error ("Writing analysis to file: File '" // char (name) &
               // "' is not open.")
       end if
    end if
  end subroutine file_list_write_analysis

@ %def file_list_write_analysis
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Runtime data}

<<[[rt_data.f90]]>>=
<<File header>>

module rt_data

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use system_dependencies
  use diagnostics
  use pdf_builtin !NODEP!
  use sf_lhapdf !NODEP!
  use os_interface
  use ifiles
  use lexers
  use parser
  use model_data, only: field_data_t
  use models
  use flavors
  use jets
  use variables
  use eval_trees
  use polarizations
  use beams
  use process_libraries
  use prclib_stacks
  use prc_core
  use beam_structures
  use user_files
  use process_stacks
  use iterations

<<Standard module head>>

<<RT data: public>>

<<RT data: types>>

contains

<<RT data: procedures>>

<<RT data: tests>>

end module rt_data
@ %def rt_data
@
\subsection{Container for parse nodes}
The runtime data set contains a bunch of parse nodes (chunks of code
that have not been compiled into evaluation trees but saved for later
use).  We collect them here.

This implementation has the useful effect that an assignment between two
objects of this type will establish a pointer-target relationship for
all components.
<<RT data: types>>=
  type :: rt_parse_nodes_t
     type(parse_node_t), pointer :: cuts_lexpr => null ()
     type(parse_node_t), pointer :: scale_expr => null ()     
     type(parse_node_t), pointer :: fac_scale_expr => null ()
     type(parse_node_t), pointer :: ren_scale_expr => null ()     
     type(parse_node_t), pointer :: weight_expr => null ()
     type(parse_node_t), pointer :: selection_lexpr => null ()
     type(parse_node_t), pointer :: reweight_expr => null ()
     type(parse_node_t), pointer :: analysis_lexpr => null ()
     type(parse_node_p), dimension(:), allocatable :: alt_setup
   contains
   <<RT data: rt parse nodes: TBP>>
  end type rt_parse_nodes_t
     
@ %def rt_parse_nodes_t
@ Clear individual components.  The parse nodes are nullified.  No
finalization needed since the pointer targets are part of the global
parse tree.
<<RT data: rt parse nodes: TBP>>=
  procedure :: clear => rt_parse_nodes_clear
<<RT data: procedures>>=
  subroutine rt_parse_nodes_clear (rt_pn, name)
    class(rt_parse_nodes_t), intent(inout) :: rt_pn
    type(string_t), intent(in) :: name
    select case (char (name))
    case ("cuts")
       rt_pn%cuts_lexpr => null ()
    case ("scale")
       rt_pn%scale_expr => null ()
    case ("factorization_scale")
       rt_pn%fac_scale_expr => null ()
    case ("renormalization_scale")
       rt_pn%ren_scale_expr => null ()
    case ("weight")
       rt_pn%weight_expr => null ()
    case ("selection")
       rt_pn%selection_lexpr => null ()
    case ("reweight")
       rt_pn%reweight_expr => null ()
    case ("analysis")
       rt_pn%analysis_lexpr => null ()
    end select
  end subroutine rt_parse_nodes_clear
  
@ %def rt_parse_nodes_clear
@ Output for the parse nodes.
<<RT data: rt parse nodes: TBP>>=
  procedure :: write => rt_parse_nodes_write
<<RT data: procedures>>=
  subroutine rt_parse_nodes_write (object, unit)
    class(rt_parse_nodes_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    call wrt ("Cuts", object%cuts_lexpr)
    call write_separator (u)
    call wrt ("Scale", object%scale_expr)
    call write_separator (u)
    call wrt ("Factorization scale", object%fac_scale_expr)
    call write_separator (u)
    call wrt ("Renormalization scale", object%ren_scale_expr)
    call write_separator (u)
    call wrt ("Weight", object%weight_expr)
    call write_separator (u, 2)
    call wrt ("Event selection", object%selection_lexpr)
    call write_separator (u)
    call wrt ("Event reweighting factor", object%reweight_expr)
    call write_separator (u)
    call wrt ("Event analysis", object%analysis_lexpr)
    if (allocated (object%alt_setup)) then
       call write_separator (u, 2)
       write (u, "(1x,A,':')")  "Alternative setups"
       do i = 1, size (object%alt_setup)
          call write_separator (u)
          call wrt ("Commands", object%alt_setup(i)%ptr)
       end do
    end if
  contains
    subroutine wrt (title, pn)
      character(*), intent(in) :: title
      type(parse_node_t), intent(in), pointer :: pn
      if (associated (pn)) then
         write (u, "(1x,A,':')")  title
         call write_separator (u)
         call parse_node_write_rec (pn, u)
      else
         write (u, "(1x,A,':',1x,A)")  title, "[undefined]"
      end if
    end subroutine wrt
  end subroutine rt_parse_nodes_write
    
@ %def rt_parse_nodes_write
@ Screen output for individual components.  (This should eventually be more
condensed, currently we print the internal representation tree.)
<<RT data: rt parse nodes: TBP>>=
  procedure :: show => rt_parse_nodes_show
<<RT data: procedures>>=
  subroutine rt_parse_nodes_show (rt_pn, name, unit)
    class(rt_parse_nodes_t), intent(in) :: rt_pn
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: unit
    type(parse_node_t), pointer :: pn
    integer :: u
    u = given_output_unit (unit)
    select case (char (name))
    case ("cuts")
       pn => rt_pn%cuts_lexpr
    case ("scale")
       pn => rt_pn%scale_expr
    case ("factorization_scale")
       pn => rt_pn%fac_scale_expr
    case ("renormalization_scale")
       pn => rt_pn%ren_scale_expr
    case ("weight")
       pn => rt_pn%weight_expr
    case ("selection")
       pn => rt_pn%selection_lexpr
    case ("reweight")
       pn => rt_pn%reweight_expr
    case ("analysis")
       pn => rt_pn%analysis_lexpr
    end select
    if (associated (pn)) then
       write (u, "(A,1x,A,1x,A)")  "Expression:", char (name), "(parse tree):"
       call parse_node_write_rec (pn, u)
    else
       write (u, "(A,1x,A,A)")  "Expression:", char (name), ": [undefined]"
    end if
  end subroutine rt_parse_nodes_show
  
@ %def rt_parse_nodes_show
@
\subsection{Container for particle data}
If we locally modify particle properties, we must be able to revert them to
their original status.  This transparent container stores the original state
for a stack of particles.
<<RT data: types>>=
  type :: rt_particle_entry_t
     integer :: pdg = 0
     logical :: stable = .true.
     logical :: isotropic = .false.
     logical :: diagonal = .false.
     logical :: polarized = .false.
     type(rt_particle_entry_t), pointer :: next => null ()
  end type rt_particle_entry_t
  
@ %def rt_particle_entry_t
<<RT data: types>>=
  type :: rt_particle_stack_t
     type(model_t), pointer :: model => null ()
     type(rt_particle_entry_t), pointer :: first => null ()
   contains
   <<RT data: rt particle stack: TBP>>
  end type rt_particle_stack_t
  
@ %def rt_particle_data_t
@ Finalize the stack.
<<RT data: rt particle stack: TBP>>=
  procedure :: final => rt_particle_stack_final
<<RT data: procedures>>=
  subroutine rt_particle_stack_final (object)
    class(rt_particle_stack_t), intent(inout) :: object
    type(rt_particle_entry_t), pointer :: entry
    do while (associated (object%first))
       entry => object%first
       object%first => entry%next
       deallocate (entry)
    end do
    object%model => null ()
  end subroutine rt_particle_stack_final

@ %def rt_particle_stack_final
@ Write the current contents of the particle stack, if it is nonempty.
<<RT data: rt particle stack: TBP>>=
  procedure :: write => rt_particle_stack_write
<<RT data: procedures>>=
  subroutine rt_particle_stack_write (object, unit)
    class(rt_particle_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    type(rt_particle_entry_t), pointer :: entry
    u = given_output_unit (unit)
    if (.not. object%is_empty ()) then
       write (u, "(1x,A)")  "Stored particle data"
       if (associated (object%model)) then
          write (u, "(3x,A,A)") "Model = ", char (object%model%get_name ())
       else
          write (u, "(3x,A,A)") "Model = [undefined]"
       end if
       entry => object%first
       do while (associated (entry))
          write (u, "(3x,I0,':',4(2x,A,L1))")  entry%pdg, &
               "stable = ", entry%stable, &
               "isotropic = ", entry%isotropic, &
               "diagonal = ", entry%diagonal, &
               "polarized = ", entry%polarized
          entry => entry%next
       end do
    end if
  end subroutine rt_particle_stack_write

@ %def rt_particle_stack_write
@ Initialize for a model.
<<RT data: rt particle stack: TBP>>=
  procedure :: init => rt_particle_stack_init
<<RT data: procedures>>=
  subroutine rt_particle_stack_init (stack, model)
    class(rt_particle_stack_t), intent(out) :: stack
    type(model_t), intent(in), target :: model
    stack%model => model
  end subroutine rt_particle_stack_init
    
@ %def rt_particle_stack_init
@ Reset a stack: if the model changes, discard the previous stack
and re-initialize.
<<RT data: rt particle stack: TBP>>=
  procedure :: reset => rt_particle_stack_reset
<<RT data: procedures>>=
  subroutine rt_particle_stack_reset (stack, model)
    class(rt_particle_stack_t), intent(inout) :: stack
    type(model_t), intent(in), target :: model
    if (associated (stack%model)) then
       if (model%get_name () /= stack%model%get_name ()) then
          call stack%final ()
          call stack%init (model)
       end if
    else
       call stack%init (model)
    end if
  end subroutine rt_particle_stack_reset

@ %def rt_particle_stack_reset
@ Push an entry on the stack, storing the current state of the particle in the
model.
<<RT data: rt particle stack: TBP>>=
  procedure :: push => rt_particle_stack_push
<<RT data: procedures>>=
  subroutine rt_particle_stack_push (stack, pdg)
    class(rt_particle_stack_t), intent(inout) :: stack
    integer, intent(in) :: pdg
    type(rt_particle_entry_t), pointer :: entry
    type(field_data_t), pointer :: field_data
    logical :: anti
    allocate (entry)
    entry%pdg = pdg
    anti = pdg < 0
    field_data => stack%model%get_field_ptr (pdg)
    entry%stable = field_data%is_stable (anti)
    entry%polarized = field_data%is_polarized (anti)
    entry%isotropic = field_data%decays_isotropically (anti)
    entry%diagonal = field_data%decays_diagonal (anti)
    entry%next => stack%first
    stack%first => entry
  end subroutine rt_particle_stack_push
    
@ %def rt_particle_stack_push
<<RT data: rt particle stack: TBP>>=
  procedure :: is_empty => rt_particle_stack_is_empty
<<RT data: procedures>>=
  function rt_particle_stack_is_empty (stack) result (flag)
    class(rt_particle_stack_t), intent(in) :: stack
    logical :: flag
    flag = .not. associated (stack%first)
  end function rt_particle_stack_is_empty
  
@ %def rt_particle_stack_is_empty
@ Check whether a particle is already on the stack.
<<RT data: rt particle stack: TBP>>=
  procedure :: contains => rt_particle_stack_contains
<<RT data: procedures>>=
  function rt_particle_stack_contains (stack, pdg) result (flag)
    class(rt_particle_stack_t), intent(in) :: stack
    integer, intent(in) :: pdg
    logical :: flag
    type(rt_particle_entry_t), pointer :: entry
    flag = .false.
    entry => stack%first
    do while (associated (entry))
       if (entry%pdg == pdg) then
          flag = .true.;  return
       end if
       entry => entry%next
    end do
  end function rt_particle_stack_contains
  
@ %def rt_particle_stack_contains
@ Restore the previous state of the model that is referenced by the particle
stack.  Then, we can delete the stack since it is no longer necessary.
<<RT data: rt particle stack: TBP>>=
  procedure :: restore_model => rt_particle_stack_restore_model
<<RT data: procedures>>=
  subroutine rt_particle_stack_restore_model (stack)
    class(rt_particle_stack_t), intent(inout) :: stack
    type(rt_particle_entry_t), pointer :: entry
    type(field_data_t), pointer :: field_data
    if (associated (stack%model)) then
       entry => stack%first
       do while (associated (entry))
          field_data => stack%model%get_field_ptr (entry%pdg)
          if (entry%pdg > 0) then
             call field_data%set ( &
                  p_is_stable = entry%stable, &
                  p_polarized = entry%polarized, &
                  p_decays_isotropically = entry%isotropic, &
                  p_decays_diagonal = entry%diagonal)
          else
             call field_data%set ( &
                  a_is_stable = entry%stable, &
                  a_polarized = entry%polarized, &
                  a_decays_isotropically = entry%isotropic, &
                  a_decays_diagonal = entry%diagonal)
          end if
          entry => entry%next
       end do
    end if
    call stack%final ()
  end subroutine rt_particle_stack_restore_model
    
@ %def rt_particle_stack_restore_model
@
\subsection{The data type}
This is a big data container which contains everything that is used and
modified during the command flow.  A local copy of this can be used to
temporarily override defaults.  The data set is transparent.
<<RT data: public>>=
  public :: rt_data_t
<<RT data: types>>=
  type :: rt_data_t
     type(lexer_t), pointer :: lexer => null ()
     type(var_list_t) :: var_list
     type(iterations_list_t) :: it_list
     type(os_data_t) :: os_data
     type(model_list_t) :: model_list
     type(model_t), pointer :: model => null ()
     type(model_t), pointer :: fallback_model => null ()
     type(rt_particle_stack_t) :: particle_stack
     type(prclib_stack_t) :: prclib_stack
     type(process_library_t), pointer :: prclib => null ()
     type(beam_structure_t) :: beam_structure
     type(rt_parse_nodes_t) :: pn
     type(process_stack_t) :: process_stack
     type(string_t), dimension(:), allocatable :: sample_fmt
     type(file_list_t), pointer :: out_files => null ()
     logical :: quit = .false.
     integer :: quit_code = 0
     type(string_t) :: logfile 
     logical :: nlo_calculation = .false.
     logical, dimension(3) :: active_nlo_components
   contains
   <<RT data: rt data: TBP>>
  end type rt_data_t

@ %def rt_data_t
@
\subsection{Output}
<<RT data: rt data: TBP>>=
  procedure :: write => rt_data_write
<<RT data: procedures>>=
  subroutine rt_data_write (object, unit, vars, pacify)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(string_t), dimension(:), intent(in), optional :: vars
    logical, intent(in), optional :: pacify
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Runtime data:"
    if (present (vars)) then
       if (size (vars) /= 0) then
          call write_separator (u, 2)
          write (u, "(1x,A)")  "Selected variables:"
          call write_separator (u)
          call object%write_vars (u, vars)
       end if
    else
       call write_separator (u, 2)
       call var_list_write (object%var_list, u, follow_link=.true.)
    end if
    if (object%it_list%get_n_pass () > 0) then
       call write_separator (u, 2)
       write (u, "(1x)", advance="no")
       call object%it_list%write (u)
    end if
    if (associated (object%model)) then
       call write_separator (u, 2)
       call object%model_list%write (u)
       if (.not. object%particle_stack%is_empty ()) then
          call write_separator (u)
          call object%particle_stack%write (u)
       end if
    end if
    call object%prclib_stack%write (u)
    call object%beam_structure%write (u)
    call write_separator (u, 2)
    call object%pn%write (u)
    if (allocated (object%sample_fmt)) then
       call write_separator (u)
       write (u, "(1x,A)", advance="no")  "Event sample formats = "
       do i = 1, size (object%sample_fmt)
          if (i > 1)  write (u, "(A,1x)", advance="no")  ","
          write (u, "(A)", advance="no")  char (object%sample_fmt(i))
       end do
       write (u, "(A)")
    end if
    call object%process_stack%write (u, pacify)
    write (u, "(1x,A,1x,L1)")  "quit     :", object%quit
    write (u, "(1x,A,1x,I0)")  "quit_code:", object%quit_code
    call write_separator (u, 2)
    write (u, "(1x,A,1x,A)")   "Logfile  :", "'" // trim (char (object%logfile)) // "'"
    call write_separator (u, 2)
  end subroutine rt_data_write
  
@ %def rt_data_write
@ Write only selected variables.
<<RT data: rt data: TBP>>=
  procedure :: write_vars => rt_data_write_vars
<<RT data: procedures>>=
  subroutine rt_data_write_vars (object, unit, vars)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(string_t), dimension(:), intent(in), optional :: vars
    integer :: u, i
    u = given_output_unit (unit)
    if (present (vars)) then
       do i = 1, size (vars)
          call var_list_write_var (object%var_list, vars(i), unit = u, &
               follow_link = .true.)
       end do
    end if
  end subroutine rt_data_write_vars
  
@ %def rt_data_write_vars
@ Write only the model list.
<<RT data: rt data: TBP>>=
  procedure :: write_model_list => rt_data_write_model_list
<<RT data: procedures>>=
  subroutine rt_data_write_model_list (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%model_list%write (u)
  end subroutine rt_data_write_model_list

@ %def rt_data_write_model_list
@ Write only the library stack.
<<RT data: rt data: TBP>>=
  procedure :: write_libraries => rt_data_write_libraries
<<RT data: procedures>>=
  subroutine rt_data_write_libraries (object, unit, libpath)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: libpath
    integer :: u
    u = given_output_unit (unit)
    call object%prclib_stack%write (u, libpath)
  end subroutine rt_data_write_libraries

@ %def rt_data_write_libraries
@ Write only the beam data.
<<RT data: rt data: TBP>>=
  procedure :: write_beams => rt_data_write_beams
<<RT data: procedures>>=
  subroutine rt_data_write_beams (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call object%beam_structure%write (u)
    call write_separator (u, 2)
  end subroutine rt_data_write_beams

@ %def rt_data_write_beams
@ Write only the process and event expressions.
<<RT data: rt data: TBP>>=
  procedure :: write_expr => rt_data_write_expr
<<RT data: procedures>>=
  subroutine rt_data_write_expr (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call object%pn%write (u)
    call write_separator (u, 2)
  end subroutine rt_data_write_expr
  
@ %def rt_data_write_expr
@ Write only the process stack.
<<RT data: rt data: TBP>>=
  procedure :: write_process_stack => rt_data_write_process_stack
<<RT data: procedures>>=
  subroutine rt_data_write_process_stack (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call object%process_stack%write (unit)
  end subroutine rt_data_write_process_stack
  
@ %def rt_data_write_process_stack
@
\subsection{Clear}
The [[clear]] command can remove the contents of various subobjects.
The objects themselves should stay.
<<RT data: rt data: TBP>>=
  procedure :: clear_beams => rt_data_clear_beams
<<RT data: procedures>>=
  subroutine rt_data_clear_beams (global)
    class(rt_data_t), intent(inout) :: global
    call global%beam_structure%final_sf ()
    call global%beam_structure%final_pol ()
    call global%beam_structure%final_mom ()
  end subroutine rt_data_clear_beams
  
@ %def rt_data_clear_beams
@ 
\subsection{Initialization}
Initialize runtime data.  This defines special variables such as
[[sqrts]], and should be done only for the instance that is actually
global.   Local copies will inherit the special variables.

We link the global variable list to the process stack variable list,
so the latter is always available (and kept global).
<<RT data: rt data: TBP>>=
  procedure :: global_init => rt_data_global_init
<<RT data: procedures>>=
  subroutine rt_data_global_init (global, paths, logfile)
    class(rt_data_t), intent(out), target :: global
    type(paths_t), intent(in), optional :: paths
    type(string_t), intent(in), optional :: logfile
    logical, target, save :: known = .true.
    integer :: seed
    real(default), parameter :: real_specimen = 1.
    call os_data_init (global%os_data, paths)
    if (present (logfile)) then
       global%logfile = logfile
    else
       global%logfile = ""
    end if
    allocate (global%out_files)
    call system_clock (seed)
    call var_list_append_log_ptr &
         (global%var_list, var_str ("?logging"), logging, known, &
         intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("seed"), seed, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$model_name"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("process_num_id"), &
         intrinsic=.true.)	  
    call var_list_append_string &
         (global%var_list, var_str ("$method"), var_str ("omega"), &
         intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?report_progress"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$restrictions"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$omega_flags"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?read_color_factors"), .true., &
          intrinsic=.true.)
!!! JRR: WK please check (#529)    
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_cut"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_event_shape"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_obs1"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_obs2"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_sf"), var_str (""), &
!           intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_input"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_spectrum"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_decays"), .false., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$library_name"), &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("sqrts"), &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("luminosity"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?sf_trace"), .false., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sf_trace_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?sf_allow_s_mapping"), .true., &
          intrinsic=.true.)
    if (present (paths)) then
       call var_list_append_string &
            (global%var_list, var_str ("$lhapdf_dir"), paths%lhapdfdir, &
             intrinsic=.true.)
    else
       call var_list_append_string &
            (global%var_list, var_str ("$lhapdf_dir"), var_str(""), &
             intrinsic=.true.)
    end if 
    call var_list_append_string &
         (global%var_list, var_str ("$lhapdf_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$lhapdf_photon_file"), var_str (""), &
          intrinsic=.true.)    
    call var_list_append_int &
         (global%var_list, var_str ("lhapdf_member"), 0, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("lhapdf_photon_scheme"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?hoppet_b_matching"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_alpha"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_q_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("isr_order"), 3, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?isr_recoil"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_alpha"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_x_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_q_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_e_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?epa_recoil"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_x_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_pt_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ewa_keep_momentum"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?ewa_keep_energy"), .false., &
          intrinsic=.true.)	  	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_photon1"), .false., &
          intrinsic=.true.)	
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_photon2"), .false., &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_sqrts"), &
          intrinsic=.true.)    	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_generate"), .true., &
          intrinsic=.true.)	    	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_map"), .true., &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_mapping_slope"), 2._default, &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_eps"), 1e-5_default, &
          intrinsic=.true.)	 	  
    call var_list_append_int &
         (global%var_list, var_str ("circe1_ver"), 0, intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("circe1_rev"), 0, intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$circe1_acc"), var_str ("SBAND"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("circe1_chat"), 0, intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?circe2_polarized"), .true., &
          intrinsic=.true.)	 	  
    call var_list_append_string &    
         (global%var_list, var_str ("$circe2_file"), &
          intrinsic=.true.)	 
    call var_list_append_string &    
         (global%var_list, var_str ("$circe2_design"), var_str ("*"), &
          intrinsic=.true.)	 	  
    call var_list_append_string &    
         (global%var_list, var_str ("$beam_events_file"), &
          intrinsic=.true.)	 
    call var_list_append_log &
         (global%var_list, var_str ("?beam_events_warn_eof"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?energy_scan_normalize"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_is_fixed"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_lhapdf"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_pdf_builtin"), .false., &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("alpha_s_order"), 0, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("alpha_s_nf"), 5, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_mz"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_lambda_qcd"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("lambda_qcd"), 200.e-3_default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?fatal_beam_decay"), .true., &
          intrinsic=.true.)          
    call var_list_append_log &
         (global%var_list, var_str ("?helicity_selection_active"), .true., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("helicity_selection_threshold"), &
          1E10_default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("helicity_selection_cutoff"), 1000, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$rng_method"), var_str ("tao"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$integration_method"), var_str ("vamp"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("threshold_calls"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_calls_per_channel"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_calls_per_bin"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_bins"), 3, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("max_bins"), 20, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?stratified"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?use_vamp_equivalences"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_verbose"), .false., &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_global"), &
         .true., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_global_verbose"), &
         .false., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_channels"), &
         .false., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_channels_verbose"), &
         .false., intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("channel_weights_power"), 0.25_default, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$phs_method"), var_str ("default"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vis_channels"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?check_phs_file"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$phs_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_only"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_threshold_s"), 50._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_threshold_t"), 100._default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("phs_off_shell"), 2, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("phs_t_channel"), 6, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_e_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_m_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_q_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_keep_nonresonant"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_step_mapping"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_step_mapping_exp"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_s_mapping"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$run_id"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("n_calls_test"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?integration_timer"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?check_grid_file"), .true., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("accuracy_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("error_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("relative_error_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("error_threshold"), &
         0._default, intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vis_history"), .true., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?diags"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?diags_color"), .false., &
          intrinsic=.true.)    
    call var_list_append_log &
         (global%var_list, var_str ("?check_event_file"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$event_file_version"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("n_events"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?unweighted"), .true., &
          intrinsic=.true.)	  
    call var_list_append_real &
         (global%var_list, var_str ("safety_factor"), 1._default, &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?negative_weights"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?keep_beams"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?recover_beams"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?update_event"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?update_sqme"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?update_weight"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?allow_decays"), .true., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?auto_decays"), .false., &
          intrinsic=.true.)	  
    call var_list_append_int &
         (global%var_list, var_str ("auto_decays_multiplicity"), 2, &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?auto_decays_radiative"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?decay_rest_frame"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?isotropic_decay"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?diagonal_decay"), .false., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sample"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sample_normalization"), var_str ("auto"),&
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?sample_pacify"), .false., &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_max_tries"), 10000, &
         intrinsic = .true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_split_n_evt"), 0, &
         intrinsic = .true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_split_index"), 0, &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$rescan_input_format"), var_str ("raw"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?read_raw"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?write_raw"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_raw"), var_str ("evx"), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_default"), var_str ("evt"), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$debug_extension"), var_str ("debug"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_process"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_transforms"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_decay"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_verbose"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepevt"), var_str ("hepevt"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_ascii_short"), &
          var_str ("short.evt"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_ascii_long"), &
          var_str ("long.evt"), intrinsic=.true.)	 
    call var_list_append_string &
         (global%var_list, var_str ("$extension_athena"), &
          var_str ("athena.evt"), intrinsic=.true.) 
    call var_list_append_string &
          (global%var_list, var_str ("$extension_mokka"), &
           var_str ("mokka.evt"), intrinsic=.true.) 	  
    call var_list_append_string &
         (global%var_list, var_str ("$lhef_version"), var_str ("2.0"), &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$lhef_extension"), var_str ("lhe"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_prc"), .true., &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_ref"), .false., &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_alt"), .true., &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lha"), var_str ("lha"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepmc"), var_str ("hepmc"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lcio"), var_str ("slcio"), &
          intrinsic=.true.)    
    call var_list_append_string &
         (global%var_list, var_str ("$extension_stdhep"), var_str ("hep"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_stdhep_up"), &
          var_str ("up.hep"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepevt_verb"), &
          var_str ("hepevt.verb"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lha_verb"), &
          var_str ("lha.verb"), intrinsic=.true.)
    call var_list_append_int (global%var_list, &
         var_str ("n_bins"), 20, &
         intrinsic=.true.)
    call var_list_append_log (global%var_list, &
         var_str ("?normalize_bins"), .false., &
         intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$obs_label"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$obs_unit"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$title"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$description"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$x_label"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$y_label"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("graph_width_mm"), 130, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("graph_height_mm"), 90, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?y_log"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?x_log"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("x_min"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("x_max"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("y_min"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("y_max"),  &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$gmlcode_bg"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$gmlcode_fg"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_histogram"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_base"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_piecewise"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?fill_curve"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_curve"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_errors"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_symbols"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$fill_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$draw_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$err_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$symbol"), &
          intrinsic=.true.)
    call var_list_append_real (global%var_list, &
         var_str ("tolerance"), 0._default, &
          intrinsic=.true.)
    call var_list_append_int (global%var_list, &
         var_str ("checkpoint"), 0, &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?pacify"), .false., &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$out_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?out_advance"), .true., &
          intrinsic=.true.)
!!! JRR: WK please check (#542)    
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_custom"), .false., &
!           intrinsic=.true.)
!     call var_list_append_string &
!          (global%var_list, var_str ("$out_comment"), var_str ("# "), &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_header"), .true., &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_yerr"), .true., &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_xerr"), .true., &
!           intrinsic=.true.)
    call var_list_append_int (global%var_list, var_str ("real_range"), &
         range (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, var_str ("real_precision"), &
         precision (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_real (global%var_list, var_str ("real_epsilon"), &
         epsilon (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_real (global%var_list, var_str ("real_tiny"), &
         tiny (real_specimen), intrinsic = .true., locked = .true.)
    !!! FastJet parameters
    call var_list_append_int (global%var_list, &
         var_str ("kt_algorithm"), &
         kt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("cambridge_algorithm"), &
         cambridge_algorithm, intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("antikt_algorithm"), &
         antikt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("genkt_algorithm"), &
         genkt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("cambridge_for_passive_algorithm"), &
         cambridge_for_passive_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("genkt_for_passive_algorithm"), &
         genkt_for_passive_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ee_kt_algorithm"), &
         ee_kt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ee_genkt_algorithm"), &
         ee_genkt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("plugin_algorithm"), &
         plugin_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("undefined_jet_algorithm"), &
         undefined_jet_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("jet_algorithm"), undefined_jet_algorithm, &
         intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("jet_r"), 0._default, &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?polarized_events"), .false., &
            intrinsic=.true.)
    !!! Default settings for shower
    call var_list_append_log &
         (global%var_list, var_str ("?allow_shower"), .true., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_fsr_active"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_use_PYTHIA_shower"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_PYTHIA_verbose"), .false., &
            intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$ps_PYTHIA_PYGIVE"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_active"), .false., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_mass_cutoff"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_fsr_lambda"), 0.29_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_isr_lambda"), 0.29_default, intrinsic = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ps_max_n_flavors"), 5, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_alpha_s_running"), .true., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_fsr_alpha_s_running"), .true., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str ("ps_fixed_alpha_s"), &
         0._default, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_pt_ordered"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_angular_ordered"), .true., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_primordial_kt_width"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_primordial_kt_cutoff"), 5._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_z_cutoff"), 0.999_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_minenergy"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_tscalefactor"), 1._default, intrinsic = .true.)
    call var_list_append_log (global%var_list, var_str &
         ("?ps_isr_only_onshell_emitted_partons"), .false., intrinsic=.true.)
    !!! Default settings for hadronization
    call var_list_append_log &
         (global%var_list, var_str ("?hadronization_active"), .false., &
            intrinsic=.true.)
    !!! Setting for mlm matching
    call var_list_append_log &
         (global%var_list, var_str ("?mlm_matching"), .false., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Qcut_ME"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Qcut_PS"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ptmin"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_etamax"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Rmin"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Emin"), 0._default, intrinsic = .true.)
    call var_list_append_int (global%var_list, var_str &
         ("mlm_nmaxMEjets"), 0, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ETclusfactor"), 0.2_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ETclusminE"), 5._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_etaclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Rclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Eclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ckkw_matching"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?muli_active"), .false., &
            intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$pdf_builtin_set"), var_str ("CTEQ6L"), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?omega_openmp"), &
         openmp_is_active (), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?openmp_is_active"), &
         openmp_is_active (), &
         locked=.true., intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("openmp_num_threads_default"), &
         openmp_get_default_max_threads (), &
         locked=.true., intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("openmp_num_threads"), &        
         openmp_get_max_threads (), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?openmp_logging"), &
         .true., intrinsic=.true.)    
    call var_list_append_log &
        (global%var_list, var_str ("?use_gosam_loops"), &
         .true., intrinsic = .true.)
    call var_list_append_log &
        (global%var_list, var_str ("?use_gosam_correlations"), &
         .false., intrinsic = .true.)
    call var_list_append_log &
        (global%var_list, var_str ("?use_gosam_real_trees"), &
         .false., intrinsic = .true.)
    call var_list_append_real &
        (global%var_list, var_str ("fks_dij_exp1"), &
         1._default, intrinsic = .true.)
    call var_list_append_real &
        (global%var_list, var_str ("fks_dij_exp2"), &
         1._default, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("fks_mapping_type"), &
         1, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("alpha_power"), &
         2, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("alphas_power"), &
         0, intrinsic = .true.)
    call global%init_pointer_variables ()
    call global%process_stack%init_var_list (global%var_list)
  end subroutine rt_data_global_init

@ %def rt_data_global_init
@ 
\subsection{Local copies}
This is done at compile time when a local copy of runtime data is
needed: Link the variable list and initialize all derived parameters.
This allows for synchronizing them with local variable changes without
affecting global data.

Also re-initialize pointer variables, so they point to local copies of
their targets.
<<RT data: rt data: TBP>>=
  procedure :: local_init => rt_data_local_init
<<RT data: procedures>>=
  subroutine rt_data_local_init (local, global, env)
    class(rt_data_t), intent(inout), target :: local
    class(rt_data_t), intent(in), target :: global
    integer, intent(in), optional :: env
    call local%process_stack%link (global%process_stack)
    call local%process_stack%init_var_list (local%var_list)
    call local%process_stack%link_var_list (global%var_list)
    if (associated (global%model)) then
       call var_list_init_copies (local%var_list, &
            global%model%get_var_list_ptr (), &
            derived_only = .true.)
    end if
    call local%init_pointer_variables ()
    local%fallback_model => global%fallback_model
    local%os_data = global%os_data
    local%logfile = global%logfile
  end subroutine rt_data_local_init

@ %def rt_data_local_init
@ Switch the matrix element entry to Gosam and back
<<RT data: rt data: TBP>>=
  procedure :: change_to_gosam => rt_data_change_to_gosam
<<RT data: procedures>>=
  subroutine rt_data_change_to_gosam (global, success)
    class(rt_data_t), intent(inout) :: global
    logical, intent(out) :: success
    call var_list_replace_string &
         (global%var_list, var_str ("$method"), var_str ("gosam"), &
          intrinsic = .true., success = success)
  end subroutine rt_data_change_to_gosam

<<RT data: rt data: TBP>>=
  procedure :: change_to_omega => rt_data_change_to_omega
<<RT data: procedures>>=
  subroutine rt_data_change_to_omega (global)
    class(rt_data_t), intent(inout) :: global
    logical :: success
    call var_list_replace_string &
         (global%var_list, var_str ("$method"), var_str ("omega"), &
          intrinsic = .true., success = success)
  end subroutine rt_data_change_to_omega

@ %def rt_data_change_to_gosam, rt_data_change_to_omega
@ This copies global objects, for which local modifications
should be kept.
<<RT data: rt data: TBP>>=
  procedure :: copy_globals => rt_data_copy_globals
<<RT data: procedures>>=
  subroutine rt_data_copy_globals (global, local)
    class(rt_data_t), intent(in) :: global
    class(rt_data_t), intent(inout) :: local
    local%model_list = global%model_list
    local%prclib_stack = global%prclib_stack
  end subroutine rt_data_copy_globals
 
@ %def rt_data_copy_globals
@ These variables point to objects which get local copies:
<<RT data: rt data: TBP>>=
  procedure :: init_pointer_variables => rt_data_init_pointer_variables
<<RT data: procedures>>=
  subroutine rt_data_init_pointer_variables (local)
    class(rt_data_t), intent(inout), target :: local
    logical, target, save :: known = .true.
    call var_list_append_string_ptr &
         (local%var_list, var_str ("$fc"), local%os_data%fc, known, &
          intrinsic=.true.)
    call var_list_append_string_ptr &
         (local%var_list, var_str ("$fcflags"), local%os_data%fcflags, known, &
         intrinsic=.true.)
  end subroutine rt_data_init_pointer_variables

@ %def rt_data_init_pointer_variables
@ This is done at execution time: Copy data, transfer pointers.
[[local]] has intent(inout) because its local variable list has
already been prepared by the previous routine.

To be pedantic, the local pointers to model and library should point
to the entries in the local copies.  (However, as long as these are
just shallow copies with identical content, this is actually
irrelevant.)

The process library and process stacks behave as global objects.  The
copies of the process library and process stacks should be shallow
copies, so the contents stay identical.  Since objects may be pushed
on the stack in the local environment, upon restoring the global
environment, we should reverse the assignment.  Then the added stack
elements will end up on the global stack.  (This should be
reconsidered in a parallel environment.)
<<RT data: rt data: TBP>>=
  procedure :: link => rt_data_link
<<RT data: procedures>>=
  subroutine rt_data_link (local, global)
    class(rt_data_t), intent(inout), target :: local
    class(rt_data_t), intent(in), target :: global
    local%lexer => global%lexer
    call global%copy_globals (local)
    call local%process_stack%link (global%process_stack)
    local%os_data = global%os_data
    local%logfile = global%logfile
    if (associated (global%model)) then
       local%model => &
            local%model_list%get_model_ptr (global%model%get_name ())
       call var_list_synchronize (local%var_list, &
            local%model%get_var_list_ptr (), reset_pointers = .true.)
       call local%particle_stack%init (local%model)
    end if
    if (associated (global%prclib)) then
       local%prclib => &
            local%prclib_stack%get_library_ptr (global%prclib%get_name ())
    end if
    local%it_list = global%it_list
    local%beam_structure = global%beam_structure
    local%pn = global%pn
    if (allocated (local%sample_fmt))  deallocate (local%sample_fmt)
    if (allocated (global%sample_fmt)) then
       allocate (local%sample_fmt (size (global%sample_fmt)), &
            source = global%sample_fmt)
    end if
    local%out_files => global%out_files
  end subroutine rt_data_link

@ %def rt_data_link
@ Restore the previous state of data; in particular, the variable
list.  This applies only to model variables (which are copies); other
variables are automatically restored when local variables are removed.

We also clear the local process stack.

If the [[keep_local]] flag is set, we want to retain current settings in
the local environment.  In particular, we create an instance of the currently
selected model (which thus becomes separated from the model library!), and we
synchronize the local variable list with it.  The other local variables are also
kept.

Some command ([[read_slha]]) reads in model variables as local
entities.  In this case, the original values of model variables should
not be restored, but the global variable list should be synchronized.
However, this matters only if the local model is identical to the
global model; otherwise, restoring will apply to a different model.

Finally, model list and process library stack are copied back.
Thus, they behave like global objects: all changes in the local environment
are kept in the global context.  Note that these are shallow copies.
<<RT data: rt data: TBP>>=
  procedure :: restore => rt_data_restore
<<RT data: procedures>>=
  subroutine rt_data_restore (global, local, keep_model_vars, keep_local)
    class(rt_data_t), intent(inout) :: global
    class(rt_data_t), intent(inout) :: local
    logical, intent(in), optional :: keep_model_vars, keep_local
    logical :: same_model, restore, delete
    delete = .true.;  if (present (keep_local))  delete = .not. keep_local
    if (delete) then
       call var_list_undefine (local%var_list, follow_link=.false.)
       call local%process_stack%clear ()
    else
       if (associated (local%model)) then
          call model_pointer_to_instance (local%model)
          call var_list_synchronize (local%var_list, &
               local%model%get_var_list_ptr (), reset_pointers = .true.)
       end if
    end if
    if (associated (global%model)) then 
       call local%particle_stack%restore_model ()
       same_model = &
            global%model%get_name () == local%model%get_name ()
       if (present (keep_model_vars) .and. same_model) then
          restore = .not. keep_model_vars
       else
          if (.not. same_model)  call msg_message ("Restoring model '" // &
               char (global%model%get_name ()) // "'")
          restore = .true.
       end if
       if (restore) then
          call var_list_restore (global%var_list)
       else
          call var_list_synchronize &
               (global%var_list, global%model%get_var_list_ptr ())
       end if
    end if
    call global%restore_globals (local)
  end subroutine rt_data_restore

@ %def rt_data_restore
@ This restores global objects, for which local modifications
should be kept.
<<RT data: rt data: TBP>>=
  procedure :: restore_globals => rt_data_restore_globals
<<RT data: procedures>>=
  subroutine rt_data_restore_globals (global, local)
    class(rt_data_t), intent(inout) :: global
    class(rt_data_t), intent(in) :: local
    global%model_list = local%model_list
    global%prclib_stack = local%prclib_stack
  end subroutine rt_data_restore_globals
 
@ %def rt_data_restore_globals
@ 
\subsection{Finalization}
Finalizer for the variable list and the structure-function list.
This is done only for the global RT dataset; local copies contain
pointers to this and do not need a finalizer.
<<RT data: rt data: TBP>>=
  procedure :: final => rt_data_global_final
<<RT data: procedures>>=
  subroutine rt_data_global_final (global)
    class(rt_data_t), intent(inout) :: global
    call global%process_stack%final ()
    call global%prclib_stack%final ()
    call global%particle_stack%final ()
    call global%model_list%final ()
    call var_list_final (global%var_list)
    if (associated (global%out_files)) then
       call file_list_final (global%out_files)
       deallocate (global%out_files)
    end if
  end subroutine rt_data_global_final

@ %def rt_data_global_final
@ The local copy needs a finalizer for the variable list, which consists
of local copies.  This finalizer is called only when the local
environment is finally discarded.  (Note that the process stack should
already have been cleared after execution, which can occur many times
for the same local environment.)
<<RT data: rt data: TBP>>=
  procedure :: local_final => rt_data_local_final
<<RT data: procedures>>=
  subroutine rt_data_local_final (local)
    class(rt_data_t), intent(inout) :: local
    call var_list_final (local%var_list)
    call local%process_stack%clear ()
  end subroutine rt_data_local_final

@ %def rt_data_local_final
@
\subsection{Filling Contents}
Initialize the fallback model.  This model is used
whenever the current model does not describe all physical particles
(hadrons, mainly).  It is not supposed to be modified, and the pointer
should remain linked to this model.
<<RT data: rt data: TBP>>=
  procedure :: init_fallback_model => rt_data_init_fallback_model
<<RT data: procedures>>=
  subroutine rt_data_init_fallback_model (global, name, filename)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name, filename
    call global%model_list%read_model &
         (name, filename, global%os_data, global%fallback_model)
  end subroutine rt_data_init_fallback_model
  
@ %def rt_data_init_fallback_model
@
Read a model, filling the model list component and assigning this as
the current model.  Copy the model variables to the global var list.
<<RT data: rt data: TBP>>=
  procedure :: read_model => rt_data_read_model
<<RT data: procedures>>=
  subroutine rt_data_read_model (global, name, filename, synchronize)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name, filename
    type(var_list_t), pointer :: model_vars
    logical, intent(in), optional :: synchronize
    logical :: sync
    sync = .true.;  if (present (synchronize))  sync = synchronize
    call global%model_list%read_model &
         (name, filename, global%os_data, global%model)
    if (associated (global%model)) then
       call var_list_set_string (global%var_list, var_str ("$model_name"), &
            name, is_known = .true.)
       model_vars => global%model%get_var_list_ptr ()
       call var_list_init_copies (global%var_list, model_vars)
       if (sync) then
          call var_list_synchronize (global%var_list, model_vars, &
               reset_pointers = .true.)
       end if
       call global%particle_stack%reset (global%model)
    end if
  end subroutine rt_data_read_model
    
@ %def rt_data_read_model 
@ Select a model, assuming that it has already been read.
<<RT data: rt data: TBP>>=
  procedure :: select_model => rt_data_select_model
<<RT data: procedures>>=
  subroutine rt_data_select_model (global, name)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: model_vars
    global%model => global%model_list%get_model_ptr (name)
    if (associated (global%model)) then
       call var_list_set_string (global%var_list, var_str ("$model_name"), &
            name, is_known = .true.)
       model_vars => global%model%get_var_list_ptr ()
       call var_list_synchronize (global%var_list, model_vars, &
            reset_pointers = .true.)
       call global%particle_stack%reset (global%model)
    end if
  end subroutine rt_data_select_model
  
@ %def rt_data_select_model
@ Modify particle properties.  If necessary, we save the old status in the
[[particle_stack]] subobject, then modify the entry in the local model
directly.
<<RT data: rt data: TBP>>=
  procedure :: modify_particle => rt_data_modify_particle
<<RT data: procedures>>=
  subroutine rt_data_modify_particle &
       (global, pdg, polarized, stable, decay, isotropic_decay, diagonal_decay)
    class(rt_data_t), intent(inout) :: global
    integer, intent(in) :: pdg
    logical, intent(in), optional :: polarized, stable
    logical, intent(in), optional :: isotropic_decay, diagonal_decay
    type(string_t), dimension(:), intent(in), optional :: decay
    if (.not. global%particle_stack%contains (pdg)) then
       call global%particle_stack%push (pdg)
    end if
    if (present (polarized)) then
       if (polarized) then
          call global%model%set_polarized (pdg)
       else
          call global%model%set_unpolarized (pdg)
       end if
    end if
    if (present (stable)) then
       if (stable) then
          call global%model%set_stable (pdg)
       else if (present (decay)) then
          call global%model%set_unstable &
               (pdg, decay, isotropic_decay, diagonal_decay)
       else
          call msg_bug ("Setting particle unstable: missing decay processes")
       end if
    end if
  end subroutine rt_data_modify_particle

@ %def rt_data_modify_particle
@
Add a library (available via a pointer of type [[prclib_entry_t]]) to
the stack and update the pointer and variable list to the current
library.  The pointer association of [[prclib_entry]] will be discarded.
<<RT data: rt data: TBP>>=
  procedure :: add_prclib => rt_data_add_prclib
<<RT data: procedures>>=
  subroutine rt_data_add_prclib (global, prclib_entry)
    class(rt_data_t), intent(inout) :: global
    type(prclib_entry_t), intent(inout), pointer :: prclib_entry
    call global%prclib_stack%push (prclib_entry)
    call global%update_prclib (global%prclib_stack%get_first_ptr ())
  end subroutine rt_data_add_prclib
  
@ %def rt_data_add_prclib
@ Given a pointer to a process library, make this the currently active
library.
<<RT data: rt data: TBP>>=
  procedure :: update_prclib => rt_data_update_prclib
<<RT data: procedures>>=
  subroutine rt_data_update_prclib (global, lib)
    class(rt_data_t), intent(inout) :: global
    type(process_library_t), intent(in), target :: lib
    type(var_entry_t), pointer :: var
    global%prclib => lib
    var => var_list_get_var_ptr (global%var_list, &
         var_str ("$library_name"), follow_link = .false.)
    if (associated (var)) then
       call var_entry_set_string (var, &
            global%prclib%get_name (), is_known=.true.)
    else
       call var_list_append_string (global%var_list, &
            var_str ("$library_name"), global%prclib%get_name (), &
            intrinsic = .true.)
    end if
  end subroutine rt_data_update_prclib

@ %def rt_data_update_prclib
@
\subsection{Get contents}
The helicity selection data are distributed among several parameters.  Here,
we collect them in a single record.
<<RT data: rt data: TBP>>=
  procedure :: get_helicity_selection => rt_data_get_helicity_selection
<<RT data: procedures>>=
  function rt_data_get_helicity_selection (rt_data) result (helicity_selection)
    class(rt_data_t), intent(in) :: rt_data
    type(helicity_selection_t) :: helicity_selection
    associate (var_list => rt_data%var_list)
      helicity_selection%active = var_list_get_lval (var_list, &
           var_str ("?helicity_selection_active"))
      if (helicity_selection%active) then
         helicity_selection%threshold = var_list_get_rval (var_list, &
              var_str ("helicity_selection_threshold"))
         helicity_selection%cutoff = var_list_get_ival (var_list, &
              var_str ("helicity_selection_cutoff"))
      end if
    end associate
  end function rt_data_get_helicity_selection

@ %def rt_data_get_helicity_selection
@ Show the beam setup: beam structure and relevant global variables.
<<RT data: rt data: TBP>>=
  procedure :: show_beams => rt_data_show_beams
<<RT data: procedures>>=
  subroutine rt_data_show_beams (rt_data, unit)
    class(rt_data_t), intent(in) :: rt_data
    integer, intent(in), optional :: unit
    type(string_t) :: s
    integer :: u
    u = given_output_unit (unit)
    associate (beams => rt_data%beam_structure, var_list => rt_data%var_list)
      call beams%write (u)
      if (.not. beams%asymmetric () .and. beams%get_n_beam () == 2) then
         write (u, "(2x,A,ES19.12,1x,'GeV')") "sqrts =", &
              var_list_get_rval (var_list, var_str ("sqrts"))         
      end if
      if (beams%contains ("pdf_builtin")) then
         s = var_list_get_sval (var_list, var_str ("$pdf_builtin_set"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "PDF set =", '"', char (s), '"'
         else
            write (u, "(2x,A,1x,A)")  "PDF set =", "[undefined]"
         end if
      end if
      if (beams%contains ("lhapdf")) then
         s = var_list_get_sval (var_list, var_str ("$lhapdf_dir"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF dir    =", '"', char (s), '"'
         end if
         s = var_list_get_sval (var_list, var_str ("$lhapdf_file"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF file   =", '"', char (s), '"'
            write (u, "(2x,A,1x,I0)") "LHAPDF member =", &
                 var_list_get_ival (var_list, var_str ("lhapdf_member"))
         else
            write (u, "(2x,A,1x,A)")  "LHAPDF file   =", "[undefined]"
         end if
      end if
      if (beams%contains ("lhapdf_photon")) then
         s = var_list_get_sval (var_list, var_str ("$lhapdf_dir"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF dir    =", '"', char (s), '"'
         end if
         s = var_list_get_sval (var_list, var_str ("$lhapdf_photon_file"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF file   =", '"', char (s), '"'
            write (u, "(2x,A,1x,I0)") "LHAPDF member =", &
                 var_list_get_ival (var_list, var_str ("lhapdf_member"))
            write (u, "(2x,A,1x,I0)") "LHAPDF scheme =", &
                 var_list_get_ival (var_list, &
                 var_str ("lhapdf_photon_scheme"))
         else
            write (u, "(2x,A,1x,A)")  "LHAPDF file   =", "[undefined]"
         end if
      end if
      if (beams%contains ("isr")) then
         write (u, "(2x,A,ES19.12)") "ISR alpha =", &
              var_list_get_rval (var_list, var_str ("isr_alpha"))
         write (u, "(2x,A,ES19.12)") "ISR Q max =", &
              var_list_get_rval (var_list, var_str ("isr_q_max"))
         write (u, "(2x,A,ES19.12)") "ISR mass  =", &
              var_list_get_rval (var_list, var_str ("isr_mass"))
         write (u, "(2x,A,1x,I0)") "ISR order  =", &
              var_list_get_ival (var_list, var_str ("isr_order"))
         write (u, "(2x,A,1x,L1)") "ISR recoil =", &
              var_list_get_lval (var_list, var_str ("?isr_recoil"))
      end if
      if (beams%contains ("epa")) then
         write (u, "(2x,A,ES19.12)") "EPA alpha  =", &
              var_list_get_rval (var_list, var_str ("epa_alpha"))
         write (u, "(2x,A,ES19.12)") "EPA x min  =", &
              var_list_get_rval (var_list, var_str ("epa_x_min"))
         write (u, "(2x,A,ES19.12)") "EPA Q min  =", &
              var_list_get_rval (var_list, var_str ("epa_q_min"))
         write (u, "(2x,A,ES19.12)") "EPA E max  =", &
              var_list_get_rval (var_list, var_str ("epa_e_max"))
         write (u, "(2x,A,ES19.12)") "EPA mass   =", &
              var_list_get_rval (var_list, var_str ("epa_mass"))
         write (u, "(2x,A,1x,L1)") "EPA recoil =", &
              var_list_get_lval (var_list, var_str ("?epa_recoil"))
      end if
      if (beams%contains ("ewa")) then
         write (u, "(2x,A,ES19.12)") "EWA x min       =", &
              var_list_get_rval (var_list, var_str ("ewa_x_min"))
         write (u, "(2x,A,ES19.12)") "EWA Pt max      =", &
              var_list_get_rval (var_list, var_str ("ewa_pt_max"))
         write (u, "(2x,A,ES19.12)") "EWA mass        =", &
              var_list_get_rval (var_list, var_str ("ewa_mass"))
         write (u, "(2x,A,1x,L1)") "EWA mom cons.   =", &
              var_list_get_lval (var_list, &
              var_str ("?ewa_keep_momentum"))
         write (u, "(2x,A,1x,L1)") "EWA energ. cons. =", &
              var_list_get_lval (var_list, &
              var_str ("ewa_keep_energy"))
      end if
      if (beams%contains ("circe1")) then
         write (u, "(2x,A,1x,I0)") "CIRCE1 version    =", &
              var_list_get_ival (var_list, var_str ("circe1_ver"))
         write (u, "(2x,A,1x,I0)") "CIRCE1 revision   =", &
              var_list_get_ival (var_list, var_str ("circe1_rev")) 
         s = var_list_get_sval (var_list, var_str ("$circe1_acc"))
         write (u, "(2x,A,1x,A)") "CIRCE1 acceler.   =", char (s)
         write (u, "(2x,A,1x,I0)") "CIRCE1 chattin.   =", &
              var_list_get_ival (var_list, var_str ("circe1_chat"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 sqrts      =", &
              var_list_get_rval (var_list, var_str ("circe1_sqrts"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 epsil.     =", &
              var_list_get_rval (var_list, var_str ("circe1_eps"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 phot. 1  =", &
              var_list_get_lval (var_list, var_str ("?circe1_photon1"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 phot. 2  =", &
              var_list_get_lval (var_list, var_str ("?circe1_photon2"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 generat. =", &
              var_list_get_lval (var_list, var_str ("?circe1_generate"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 mapping  =", &
              var_list_get_lval (var_list, var_str ("?circe1_map"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 map. slope =", &
              var_list_get_rval (var_list, var_str ("circe1_mapping_slope"))
      end if
      if (beams%contains ("circe2")) then
         s = var_list_get_sval (var_list, var_str ("$circe2_design"))
         write (u, "(2x,A,1x,A)") "CIRCE2 design   =", char (s) 
         s = var_list_get_sval (var_list, var_str ("$circe2_file"))
         write (u, "(2x,A,1x,A)") "CIRCE2 file     =", char (s)
         write (u, "(2x,A,1x,L1)") "CIRCE2 polarized =", &
              var_list_get_lval (var_list, var_str ("?circe2_polarized"))
      end if
      if (beams%contains ("beam_events")) then
         s = var_list_get_sval (var_list, var_str ("$beam_events_file"))
         write (u, "(2x,A,1x,A)") "Beam events file     =", char (s)
         write (u, "(2x,A,1x,L1)") "Beam events EOF warn =", &
              var_list_get_lval (var_list, var_str ("?beam_events_warn_eof"))
      end if
    end associate
  end subroutine rt_data_show_beams
  
@ %def rt_data_show_beams
@ Return the collision energy as determined by the current beam
settings.  Without beam setup, this is the [[sqrts]] variable.

If the value is meaningless for a setup, the function returns zero.
<<RT data: rt data: TBP>>=
  procedure :: get_sqrts => rt_data_get_sqrts
<<RT data: procedures>>=
  function rt_data_get_sqrts (rt_data) result (sqrts)
    class(rt_data_t), intent(in) :: rt_data
    real(default) :: sqrts
    sqrts = var_list_get_rval (rt_data%var_list, var_str ("sqrts"))
  end function rt_data_get_sqrts
    
@ %def rt_data_get_sqrts
@ For testing purposes, the [[rt_data_t]] contents can be pacified to
suppress numerical fluctuations in (constant) test matrix elements.
<<RT data: rt data: TBP>>=
  procedure :: pacify => rt_data_pacify
<<RT data: procedures>>=
  subroutine rt_data_pacify (rt_data, efficiency_reset, error_reset)
    class(rt_data_t), intent(inout) :: rt_data
    logical, intent(in), optional :: efficiency_reset, error_reset
    type(process_entry_t), pointer :: process
    process => rt_data%process_stack%first
    do while (associated (process))
       call process%pacify (efficiency_reset, error_reset)
       process => process%next
    end do    
  end subroutine rt_data_pacify

@ %def rt_data_pacify 
@
\subsection{Test}
This is the master for calling self-test procedures.
<<RT data: public>>=
  public :: rt_data_test
<<RT data: tests>>=
  subroutine rt_data_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<RT data: execute tests>>
  end subroutine rt_data_test

@ %def rt_data_test
@
\subsubsection{Initial content}
Force system-dependent objects to well-defined values.  Some of the
variables are locked and therefore must be addressed directly.

This is, of course, only required for testing purposes. In principle,
the [[real_specimen]] variables could be set to their values in 
[[rt_data_t]], but this depends on the precision again, so we set
them to some dummy values.
<<RT data: rt data: TBP>>=
  procedure :: fix_system_dependencies => rt_data_fix_system_dependencies
<<RT data: tests>>=
  subroutine rt_data_fix_system_dependencies (rt_data)
    class(rt_data_t), intent(inout), target :: rt_data
    type(var_list_t), pointer :: var_list
    type(var_entry_t), pointer :: var
    var_list => rt_data%var_list

    call var_list_set_log (var_list, &
         var_str ("?omega_openmp"), .false., is_known = .true.)

    var => var_list_get_var_ptr (var_list, &
         var_str ("?openmp_is_active"), V_LOG)
    call var_entry_set_log (var, .false., is_known = .true.)
    var => var_list_get_var_ptr (var_list, &
         var_str ("openmp_num_threads_default"), V_INT)
    call var_entry_set_int (var, 1, is_known = .true.)
    call var_list_set_int (var_list, &
         var_str ("openmp_num_threads"), 1, is_known = .true.)        
    var => var_list_get_var_ptr (var_list, &
         var_str ("real_range"), V_INT)
    call var_entry_set_int (var, 307, is_known = .true.)
    var => var_list_get_var_ptr (var_list, &
         var_str ("real_precision"), V_INT)
    call var_entry_set_int (var, 15, is_known = .true.)    
    var => var_list_get_var_ptr (var_list, &
         var_str ("real_epsilon"), V_REAL)
    call var_entry_set_real (var, 1.e-16_default, is_known = .true.)
    var => var_list_get_var_ptr (var_list, &
         var_str ("real_tiny"), V_REAL)
    call var_entry_set_real (var, 1.e-300_default, is_known = .true.)     
    
    rt_data%os_data%fc = "Fortran-compiler"
    rt_data%os_data%fcflags = "Fortran-flags"
        
  end subroutine rt_data_fix_system_dependencies
  
@ %def rt_data_fix_system_dependencies
@ 
Display the RT data in the state just after (global) initialization.
<<RT data: execute tests>>=
  call test (rt_data_1, "rt_data_1", &
       "initialize", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_1 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    write (u, "(A)")  "* Test output: rt_data_1"
    write (u, "(A)")  "*   Purpose: initialize global runtime data"
    write (u, "(A)")

    call rt_data%global_init (logfile = var_str ("rt_data.log"))

    call rt_data%fix_system_dependencies ()
    call var_list_set_int (rt_data%var_list, var_str ("seed"), &
         0, is_known=.true.)            

    call rt_data%it_list%init ([2, 3], [5000, 20000])

    call rt_data%write (u)

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_1"
    
  end subroutine rt_data_1
  
@ %def rt_data_1
@
\subsubsection{Fill values}
Fill in empty slots in the runtime data block.
<<RT data: execute tests>>=
  call test (rt_data_2, "rt_data_2", &
       "fill", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_2 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    type(flavor_t), dimension(2) :: flv
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    
    write (u, "(A)")  "* Test output: rt_data_2"
    write (u, "(A)")  "*   Purpose: initialize global runtime data &
         &and fill contents"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%fix_system_dependencies ()

    call rt_data%read_model (var_str ("Test"), var_str ("Test.mdl"))

    call var_list_set_real (rt_data%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_int (rt_data%var_list, var_str ("seed"), &
         0, is_known=.true.)        
    call flavor_init (flv, [25,25], rt_data%model)
    
    call var_list_set_string (rt_data%var_list, var_str ("$run_id"), &
         var_str ("run1"), is_known = .true.)
    call var_list_set_real (rt_data%var_list, var_str ("luminosity"), &
         33._default, is_known = .true.)
    
    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    rt_data%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    allocate (rt_data%sample_fmt (2))
    rt_data%sample_fmt(1) = "foo_fmt"
    rt_data%sample_fmt(2) = "bar_fmt"
    
    call rt_data%write (u)

    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()

    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_2"
    
  end subroutine rt_data_2
  
@ %def rt_data_2
@
\subsubsection{Save and restore}
Set up a local runtime data block, change some contents, restore the
global block.

For a model variable, the save-restore procedure is nontrivial.  We
first allocate a local copy of this variable and set a pointer to the
original model variable.  We set a new value, update the dependent
variables and synchronize them with the local variable list, if modified.
When restoring the old data, we recover the model variables from the
stored values and delete the local instances.
<<RT data: execute tests>>=
  call test (rt_data_3, "rt_data_3", &
       "save/restore", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_3 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data, local
    type(var_list_t), pointer :: model_vars
    type(var_entry_t), pointer :: var
    type(flavor_t), dimension(2) :: flv
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    type(prclib_entry_t), pointer :: lib
    
    write (u, "(A)")  "* Test output: rt_data_3"
    write (u, "(A)")  "*   Purpose: initialize global runtime data &
         &and fill contents;"
    write (u, "(A)")  "*            copy to local block and back"
    write (u, "(A)")

    write (u, "(A)")  "* Init global data"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%fix_system_dependencies ()
    call var_list_set_int (rt_data%var_list, var_str ("seed"), &
         0, is_known=.true.)        

    call rt_data%read_model (var_str ("Test"), var_str ("Test.mdl"))

    call var_list_set_real (rt_data%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call flavor_init (flv, [25,25], rt_data%model)
    
    call rt_data%beam_structure%init_sf (flavor_get_name (flv), [1])
    call rt_data%beam_structure%set_sf (1, 1, var_str ("pdf_builtin"))

    call var_list_set_string (rt_data%var_list, var_str ("$run_id"), &
         var_str ("run1"), is_known = .true.)
    call var_list_set_real (rt_data%var_list, var_str ("luminosity"), &
         33._default, is_known = .true.)
    
    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    rt_data%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    allocate (rt_data%sample_fmt (2))
    rt_data%sample_fmt(1) = "foo_fmt"
    rt_data%sample_fmt(2) = "bar_fmt"

    allocate (lib)
    call lib%init (var_str ("library_1"))
    call rt_data%add_prclib (lib)

    write (u, "(A)")  "* Init and modify local data"
    write (u, "(A)")

    call local%local_init (rt_data)
    call local%link (rt_data)

    write (u, "(1x,A,L1)")  "model associated   = ", associated (local%model)
    write (u, "(1x,A,L1)")  "library associated = ", associated (local%prclib)
    write (u, *)

    var => var_list_get_var_ptr (local%var_list, var_str ("ms"))
    if (var_entry_is_copy (var)) then
       call var_list_init_copy (local%var_list, var, user=.true.)
       model_vars => local%model%get_var_list_ptr ()
       call var_list_set_original_pointer (local%var_list, var_str ("ms"), &
            model_vars)
       call var_list_set_real (local%var_list, var_str ("ms"), &
         150._default, is_known = .true., model_name = var_str ("Test"))
       call local%model%update_parameters ()
       call var_list_synchronize (local%var_list, model_vars)
    end if

    call var_list_append_string (local%var_list, &
         var_str ("$integration_method"), intrinsic = .true., user = .true.)
    call var_list_set_string (local%var_list, var_str ("$integration_method"), &
         var_str ("midpoint"), is_known = .true.)
    
    call var_list_append_string (local%var_list, &
         var_str ("$phs_method"), intrinsic = .true., user = .true.)
    call var_list_set_string (local%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)

    local%os_data%fc = "Local compiler"
    
    allocate (lib)
    call lib%init (var_str ("library_2"))
    call local%add_prclib (lib)

    call local%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Restore global data"
    write (u, "(A)")
    
    call rt_data%restore (local)

    write (u, "(1x,A,L1)")  "model associated   = ", associated (rt_data%model)
    write (u, "(1x,A,L1)")  "library associated = ", associated (rt_data%prclib)
    write (u, *)

    call rt_data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()

    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_3"
    
  end subroutine rt_data_3
  
@ %def rt_data_3
@
\subsubsection{Show variables}
Display selected variables in the global record.
<<RT data: execute tests>>=
  call test (rt_data_4, "rt_data_4", &
       "show variables", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_4 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    type(string_t), dimension(0) :: empty_string_array

    write (u, "(A)")  "* Test output: rt_data_4"
    write (u, "(A)")  "*   Purpose: display selected variables"
    write (u, "(A)")

    call rt_data%global_init ()

    write (u, "(A)")  "* No variables:"
    write (u, "(A)")

    call rt_data%write_vars (u, empty_string_array)

    write (u, "(A)")  "* Two variables:"
    write (u, "(A)")

    call rt_data%write_vars (u, &
         [var_str ("?unweighted"), var_str ("$phs_method")])
    
    write (u, "(A)")
    write (u, "(A)")  "* Display whole record with selected variables"
    write (u, "(A)")

    call rt_data%write (u, &
         vars = [var_str ("?unweighted"), var_str ("$phs_method")])

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_4"
    
  end subroutine rt_data_4
  
@ %def rt_data_4
@
\subsubsection{Show parts}
Display only selected parts in the state just after (global) initialization.
<<RT data: execute tests>>=
  call test (rt_data_5, "rt_data_5", &
       "show parts", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_5 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    write (u, "(A)")  "* Test output: rt_data_5"
    write (u, "(A)")  "*   Purpose: display parts of rt data"
    write (u, "(A)")

    call rt_data%global_init ()
    call rt_data%write_libraries (u)

    write (u, "(A)")

    call rt_data%write_beams (u)

    write (u, "(A)")

    call rt_data%write_process_stack (u)

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_5"
    
  end subroutine rt_data_5
  
@ %def rt_data_5
@
\subsubsection{Local Model}
Locally modify a model and restore the global one.  We need an auxiliary
function to determine the status of a model particle:
<<RT data: tests>>=
  function is_stable (pdg, rt_data) result (flag)
    integer, intent(in) :: pdg
    type(rt_data_t), intent(in) :: rt_data
    logical :: flag
    type(flavor_t) :: flv
    call flavor_init (flv, pdg, rt_data%model)
    flag = flavor_is_stable (flv)
  end function is_stable
   
  function is_polarized (pdg, rt_data) result (flag)
    integer, intent(in) :: pdg
    type(rt_data_t), intent(in) :: rt_data
    logical :: flag
    type(flavor_t) :: flv
    call flavor_init (flv, pdg, rt_data%model)
    flag = flavor_is_polarized (flv)
  end function is_polarized
    
@ %def is_stable is_polarized
<<RT data: execute tests>>=
  call test (rt_data_6, "rt_data_6", &
       "local model", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_6 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data, local
    type(var_list_t), pointer :: model_vars
    type(var_entry_t), pointer :: var_entry
    type(string_t) :: var_name

    write (u, "(A)")  "* Test output: rt_data_6"
    write (u, "(A)")  "*   Purpose: apply and keep local modifications to model"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%read_model (var_str ("Test"), var_str ("Test.mdl"), &
         synchronize=.true.)
    
    write (u, "(A)")  "* Original model"
    write (u, "(A)")

    call rt_data%write_model_list (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, *)

    var_name = "ff"

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)", advance="no")  "Global variable: "
    call var_list_write_var (rt_data%var_list, var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Apply local modifications: unstable"
    write (u, "(A)")

    call local%local_init (rt_data)
    call local%link (rt_data)

    var_entry => var_list_get_var_ptr &
       (rt_data%var_list, var_name, V_REAL, follow_link=.false.)
    call var_list_init_copy (local%var_list, var_entry, user=.true.)

    call var_list_set_original_pointer (local%var_list, var_name, &
         local%model%get_var_list_ptr ())
    call var_list_set_real (local%var_list, var_name, 0.4_default, &
         is_known = .true., verbose = .true., model_name = var_str ("Test"))
    call var_list_restore (local%var_list)
    call local%model%update_parameters ()

    call local%modify_particle (25, stable = .false., decay = [var_str ("d1")])
    call local%modify_particle (6, stable = .false., &
         decay = [var_str ("f1")], isotropic_decay = .true.)
    call local%modify_particle (-6, stable = .false., &
         decay = [var_str ("f2"), var_str ("f3")], diagonal_decay = .true.)

    call local%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Further modifications"
    write (u, "(A)")

    call local%modify_particle (6, stable = .false., &
         decay = [var_str ("f1")], &
         diagonal_decay = .true., isotropic_decay = .false.)
    call local%modify_particle (-6, stable = .false., &
         decay = [var_str ("f2"), var_str ("f3")], &
         diagonal_decay = .false., isotropic_decay = .true.)
    call local%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Further modifications: f stable but polarized"
    write (u, "(A)")

    call local%modify_particle (6, stable = .true., polarized = .true.)
    call local%modify_particle (-6, stable = .true.)
    call local%model%write (u)

    write (u, *)
    
    call local%particle_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Global model"
    write (u, "(A)")

    call rt_data%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, "(A)")
    write (u, "(A)")  "* Local model"
    write (u, "(A)")

    call local%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, local)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, local)

    write (u, *)

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)", advance="no")  "Local model variable: "
    call var_list_write_var (local%model%get_var_list_ptr (), &
         var_name, u)

    write (u, "(A)", advance="no")  "Global variable: "
    call var_list_write_var (rt_data%var_list, var_name, u)

    write (u, "(A)", advance="no")  "Local variable: "
    call var_list_write_var (local%var_list, var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Restore global"

    call rt_data%restore (local, keep_local = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Global model"
    write (u, "(A)")

    call rt_data%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, "(A)")
    write (u, "(A)")  "* Local model"
    write (u, "(A)")

    call local%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, local)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, local)

    write (u, *)

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)", advance="no")  "Local model variable: "
    call var_list_write_var (local%model%get_var_list_ptr (), &
         var_name, u)

    write (u, "(A)", advance="no")  "Global variable: "
    call var_list_write_var (rt_data%var_list, var_name, u)

    write (u, "(A)", advance="no")  "Local variable: "
    call var_list_write_var (local%var_list, var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call local%model%final ()
    deallocate (local%model)
    
    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_6"
    
  end subroutine rt_data_6
  
@ %def rt_data_6
@
\subsubsection{Result variables}
Initialize result variables and check that they are accessible via the
global variable list.
<<RT data: execute tests>>=
  call test (rt_data_7, "rt_data_7", &
       "result variables", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_7 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data

    write (u, "(A)")  "* Test output: rt_data_7"
    write (u, "(A)")  "*   Purpose: set and access result variables"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    call rt_data%global_init ()
    call rt_data%process_stack%init_result_vars (var_str ("testproc"))
    
    call var_list_write_var (rt_data%var_list, &
         var_str ("integral(testproc)"), u)
    call var_list_write_var (rt_data%var_list, &
         var_str ("error(testproc)"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_7"
    
  end subroutine rt_data_7
  
@ %def rt_data_7
@
\subsubsection{Beam energy}
If beam parameters are set, the variable [[sqrts]] is not necessarily
the collision energy.  The method [[get_sqrts]] fetches the correct value.
<<RT data: execute tests>>=
  call test (rt_data_8, "rt_data_8", &
       "beam energy", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_8 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data

    write (u, "(A)")  "* Test output: rt_data_8"
    write (u, "(A)")  "*   Purpose: get correct collision energy"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    call rt_data%global_init ()

    write (u, "(A)")  "* Set sqrts"
    write (u, "(A)")

    call var_list_set_real (rt_data%var_list, var_str ("sqrts"), &
         1000._default, is_known = .true.)
    write (u, "(1x,A,ES19.12)")  "sqrts =", rt_data%get_sqrts ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_8"
    
  end subroutine rt_data_8
  
@ %def rt_data_8
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Select implementations}
For abstract types (process core, integrator, phase space, etc.), we need a
way to dynamically select a concrete type, using either data given by the user
or a previous selection of a concrete type.  This is done by subroutines in
the current module.

This module provides no new types, just procedures.
<<[[dispatch.f90]]>>=
<<File header>>

module dispatch
  
<<Use kinds>>
  use kinds, only: i16
<<Use strings>>
  use constants, only: PI
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use physics_defs, only: MZ_REF, ALPHA_QCD_MZ_REF
  use physics_defs, only: PROTON, PHOTON, ELECTRON
  use sm_qcd
  use pdg_arrays
  use variables
  use flavors
  use interactions
  use models
  use process_constants
  use pdf_builtin !NODEP!
  use sf_mappings
  use sf_base
  use sf_pdf_builtin
  use sf_lhapdf
  use sf_circe1
  use sf_circe2
  use sf_isr
  use sf_epa
  use sf_ewa
  use sf_escan
  use sf_beam_events
  use sf_user
  use rng_base
  use rng_tao
  use mci_base
  use mci_midpoint
  use mci_vamp
  use phs_base
  use mappings
  use phs_forests
  use phs_single
  use phs_wood
  use prc_core_def
  use prc_test
  use beams
  use prc_omega
  use prc_template_me
  use prc_core
  use processes
  use shower
  use event_transforms
  use decays
  use beam_structures
  use eio_base
  use eio_raw
  use eio_checkpoints
  use eio_lhef
  use eio_hepmc
  use eio_lcio
  use eio_stdhep
  use eio_ascii
  use eio_weights
  use rt_data
  use prc_gosam
  use phs_fks
  use fks_calculation

<<Standard module head>>

<<Dispatch: public>>

<<Dispatch: types>>

contains
  
<<Dispatch: procedures>>

<<Dispatch: tests>>

end module dispatch
@ %def dispatch
@
\subsection{Process Core Definition}
The [[prc_core_def_t]] abstract type can be instantiated by providing a
[[$method]] string variable.

Note: [[core_def]] has intent(inout) because gfortran 4.7.1 crashes for
intent(out).
<<Dispatch: public>>=
  public :: dispatch_core_def
<<Dispatch: procedures>>=
  subroutine dispatch_core_def (core_def, prt_in, prt_out, global, id)
    class(prc_core_def_t), allocatable, intent(inout) :: core_def
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in), optional :: id
    type(string_t) :: method
    type(string_t) :: model_name
    type(string_t) :: restrictions
    logical :: openmp_support
    logical :: report_progress
    logical :: diags, diags_color
    type(string_t) :: extra_options
    type(model_t), pointer :: model
    model => global%model
    associate (var_list => global%var_list)
      method = var_list_get_sval (var_list, var_str ("$method"))
      model_name = var_list_get_sval (var_list, var_str ("$model_name"))
      select case (char (method))
      case ("unit_test")
         allocate (prc_test_def_t :: core_def)
         select type (core_def)
         type is (prc_test_def_t)
            call core_def%init (model_name, prt_in, prt_out)
         end select
      case ("template")
         allocate (template_me_def_t :: core_def)
         select type (core_def)
         type is (template_me_def_t)
            call core_def%init (model, prt_in, prt_out, unity = .false.)
         end select
      case ("template_unity")
         allocate (template_me_def_t :: core_def)
         select type (core_def)
         type is (template_me_def_t)
            call core_def%init (model, prt_in, prt_out, unity = .true.)
         end select                  
      case ("omega")
         diags = var_list_get_lval (var_list, &
              var_str ("?diags"))
         diags_color = var_list_get_lval (var_list, &
              var_str ("?diags_color"))         
         restrictions = var_list_get_sval (var_list, &
              var_str ("$restrictions"))
         openmp_support = var_list_get_lval (var_list, &
              var_str ("?omega_openmp"))
         report_progress = var_list_get_lval (var_list, &
              var_str ("?report_progress"))
         extra_options = var_list_get_sval (var_list, &
              var_str ("$omega_flags"))
         allocate (omega_omega_def_t :: core_def)
         select type (core_def)
         type is (omega_omega_def_t)
            call core_def%init (model_name, prt_in, prt_out, &
                 restrictions, openmp_support, report_progress, &
                 extra_options, diags, diags_color)
         end select
      case ("ovm")
         diags = var_list_get_lval (var_list, &
              var_str ("?diags"))
         diags_color = var_list_get_lval (var_list, &
              var_str ("?diags_color"))         
         restrictions = var_list_get_sval (var_list, &
              var_str ("$restrictions"))
         openmp_support = var_list_get_lval (var_list, &
              var_str ("?omega_openmp"))
         report_progress = var_list_get_lval (var_list, &
              var_str ("?report_progress"))
         extra_options = var_list_get_sval (var_list, &
              var_str ("$omega_flags"))
         allocate (omega_ovm_def_t :: core_def)
         select type (core_def)
         type is (omega_ovm_def_t)
            call core_def%init (model_name, prt_in, prt_out, &
                 restrictions, openmp_support, report_progress, &
                 extra_options, diags, diags_color)
         end select         
      case ("gosam")
        allocate (gosam_def_t :: core_def)
        select type (core_def)
        type is (gosam_def_t)
          if (present (id)) then
             ! call core_def%init (id, prt_in, prt_out, &
             !          global%os_data, global%model)
             call core_def%init (id)
          else
             ! call core_def%init (var_str ('undefined_process'), &
             !          prt_in, prt_out, global%os_data, &
             !          global%model)
             call core_def%init (var_str ('undefined_process'))
          end if
        end select
      case default
         call msg_fatal ("Process configuration: method '" &
              // char (method) // "' not implemented")
      end select
    end associate
  end subroutine dispatch_core_def
    
@ %def dispatch_core_def
@
\subsection{Process core allocation}
Here we allocate an object of abstract type [[prc_core_t]] with a concrete
type that matches a process definition.  The [[prc_omega_t]] extension
will require the current parameter set, so we take the opportunity to
grab it from the model.
<<Dispatch: public>>=
  public :: dispatch_core
<<Dispatch: procedures>>=
  subroutine dispatch_core (core, core_def, model, &
       helicity_selection, qcd, use_color_factors)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(prc_core_def_t), intent(in) :: core_def
    type(model_t), intent(in), target, optional :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    logical, intent(in), optional :: use_color_factors
    select type (core_def)
    type is (prc_test_def_t)
       allocate (test_t :: core)
    type is (template_me_def_t)
       allocate (prc_template_me_t :: core)
       select type (core)
       type is (prc_template_me_t)
          call core%set_parameters (model) 
       end select       
    class is (omega_def_t)
       if (.not. allocated (core)) allocate (prc_omega_t :: core)
       select type (core)
       type is (prc_omega_t)
          call core%set_parameters (model, & 
               helicity_selection, qcd, use_color_factors)
       end select
    type is (gosam_def_t)
      if (.not. allocated (core)) allocate (prc_gosam_t :: core)
      select type (core)
      type is (prc_gosam_t)
        call core%set_parameters (qcd)
      end select
    class default
       call msg_bug ("Process core: unexpected process definition type")
    end select
  end subroutine dispatch_core

@ %def dispatch_core
@
\subsection{Process core update and restoration}
Here we take an existing object of abstract type [[prc_core_t]] and
update the parameters as given by the current state of [[model]].
Optionally, we can save the previous state as [[saved_core]].  The
second routine restores the original from the save.

(In the test case, there is no possible update.)
<<Dispatch: public>>=
  public :: dispatch_core_update
  public :: dispatch_core_restore
<<Dispatch: procedures>>=
  subroutine dispatch_core_update (core, model, helicity_selection, qcd, &
       saved_core)
    class(prc_core_t), allocatable, intent(inout) :: core
    type(model_t), intent(in), optional, target :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    class(prc_core_t), allocatable, intent(inout), optional :: saved_core
    if (present (saved_core)) then
       allocate (saved_core, source = core)
    end if
    select type (core)
    type is (test_t)
    type is (prc_omega_t)
       call core%set_parameters (model, helicity_selection, qcd)
       call core%activate_parameters ()
    type is (prc_gosam_t)
      call msg_message ("dispatch core restore: Gosam implementation not present yet!")
    class default
       call msg_bug ("Process core update: unexpected process definition type")
    end select
  end subroutine dispatch_core_update

  subroutine dispatch_core_restore (core, saved_core)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(prc_core_t), allocatable, intent(inout) :: saved_core
    call move_alloc (from = saved_core, to = core)
    select type (core)
    type is (test_t)
    type is (prc_omega_t)
       call core%activate_parameters ()
    class default
       call msg_bug ("Process core restore: unexpected process definition type")
    end select
  end subroutine dispatch_core_restore

@ %def dispatch_core_update dispatch_core_restore
@
\subsection{Integrator allocation}
Allocate an integrator according to the variable [[$integration_method]].
<<Dispatch: public>>=
  public :: dispatch_mci
<<Dispatch: procedures>>=
  subroutine dispatch_mci (mci, global, process_id)
    class(mci_t), allocatable, intent(inout) :: mci
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in) :: process_id
    type(string_t) :: run_id
    type(string_t) :: integration_method
    type(grid_parameters_t) :: grid_par
    type(history_parameters_t) :: history_par
    logical :: rebuild_grids, check_grid_file, negative_weights, verbose
    integration_method = var_list_get_sval (global%var_list, &
         var_str ("$integration_method"))
    select case (char (integration_method))
    case ("midpoint")
       allocate (mci_midpoint_t :: mci)
    case ("vamp", "default")
       associate (var_list => global%var_list)
         grid_par%threshold_calls = &
              var_list_get_ival (var_list, var_str ("threshold_calls"))
         grid_par%min_calls_per_channel = &
              var_list_get_ival (var_list, var_str ("min_calls_per_channel"))
         grid_par%min_calls_per_bin = &
              var_list_get_ival (var_list, var_str ("min_calls_per_bin"))
         grid_par%min_bins = &
              var_list_get_ival (var_list, var_str ("min_bins"))
         grid_par%max_bins = &
              var_list_get_ival (var_list, var_str ("max_bins"))
         grid_par%stratified = &
              var_list_get_lval (var_list, var_str ("?stratified"))
         grid_par%use_vamp_equivalences = &
              var_list_get_lval (var_list, var_str ("?use_vamp_equivalences"))
         grid_par%channel_weights_power = &
              var_list_get_rval (var_list, var_str ("channel_weights_power"))
         grid_par%accuracy_goal = &
              var_list_get_rval (var_list, var_str ("accuracy_goal"))
         grid_par%error_goal = &
              var_list_get_rval (var_list, var_str ("error_goal"))
         grid_par%rel_error_goal = &
              var_list_get_rval (var_list, var_str ("relative_error_goal"))
         history_par%global = &
              var_list_get_lval (var_list, &
              var_str ("?vamp_history_global"))
         history_par%global_verbose = &
              var_list_get_lval (var_list, &
              var_str ("?vamp_history_global_verbose"))
         history_par%channel = &
              var_list_get_lval (var_list, &
              var_str ("?vamp_history_channels"))
         history_par%channel_verbose = &
              var_list_get_lval (var_list, &
              var_str ("?vamp_history_channels_verbose"))
         verbose = var_list_get_lval (var_list, var_str ("?vamp_verbose"))
         check_grid_file = &
              var_list_get_lval (var_list, var_str ("?check_grid_file"))
         run_id = &
              var_list_get_sval (var_list, var_str ("$run_id"))
         rebuild_grids = &
              var_list_get_lval (var_list, var_str ("?rebuild_grids"))
         negative_weights = &
              var_list_get_lval (var_list, var_str ("?negative_weights"))
       end associate
       allocate (mci_vamp_t :: mci)
       select type (mci)
       type is (mci_vamp_t)
          call mci%set_grid_parameters (grid_par)
          if (run_id /= "") then
             call mci%set_grid_filename (process_id, run_id)
          else
             call mci%set_grid_filename (process_id)
          end if
          call mci%set_history_parameters (history_par)
          call mci%set_rebuild_flag (rebuild_grids, check_grid_file)
          mci%negative_weights = negative_weights
          mci%verbose = verbose
       end select
    case default
       call msg_fatal ("Integrator '" &
            // char (integration_method) // "' not implemented")
    end select
  end subroutine dispatch_mci
  
@ %def dispatch_mci
@
\subsection{Phase-space allocation}
Allocate a phase-space object according to the variable [[$phs_method]].
<<Dispatch: public>>=
  public :: dispatch_phs
<<Dispatch: procedures>>=
  subroutine dispatch_phs (phs, global, process_id, mapping_defaults, phs_par, &
                           phs_method_in)
    class(phs_config_t), allocatable, intent(inout) :: phs
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in) :: process_id
    type(mapping_defaults_t), intent(in), optional :: mapping_defaults
    type(phs_parameters_t), intent(in), optional :: phs_par
    type(string_t), intent(in), optional :: phs_method_in
    type(string_t) :: phs_method, phs_file, run_id
    logical :: use_equivalences, vis_channels, fatal_beam_decay
    integer :: u_phs
    logical :: exist
    if (present (phs_method_in)) then
       phs_method = phs_method_in
    else
       phs_method = var_list_get_sval (global%var_list, &
            var_str ("$phs_method"))
    end if
    phs_file = var_list_get_sval (global%var_list, &
         var_str ("$phs_file"))
    use_equivalences = var_list_get_lval (global%var_list, &
         var_str ("?use_vamp_equivalences"))
    vis_channels = var_list_get_lval (global%var_list, &
         var_str ("?vis_channels"))
    fatal_beam_decay = var_list_get_lval (global%var_list, &
         var_str ("?fatal_beam_decay"))
    run_id = &
         var_list_get_sval (global%var_list, var_str ("$run_id"))    
    select case (char (phs_method))
    case ("single")
       allocate (phs_single_config_t :: phs)
       if (vis_channels) then
          call msg_warning ("Visualizing phase space channels not " // &
               "available for method 'single'.")
       end if
    case ("fks")
      allocate (phs_fks_config_t :: phs)
    case ("wood", "default")
       allocate (phs_wood_config_t :: phs)
       select type (phs)
       type is (phs_wood_config_t)
          if (phs_file /= "") then
             inquire (file = char (phs_file), exist = exist)
             if (exist) then
                call msg_message ("Phase space: reading configuration from '" &
                     // char (phs_file) // "'")
                u_phs = free_unit ()
                open (u_phs, file = char (phs_file), &
                     action = "read", status = "old")
                call phs%set_input (u_phs)
             else
                call msg_fatal ("Phase space: configuration file '" &
                     // char (phs_file) // "' not found")
             end if
          end if
          if (present (phs_par)) &
               call phs%set_parameters (phs_par)
          if (use_equivalences) &
               call phs%enable_equivalences ()
          if (present (mapping_defaults)) &
               call phs%set_mapping_defaults (mapping_defaults)
          phs%vis_channels = vis_channels
          phs%fatal_beam_decay = fatal_beam_decay
          phs%os_data = global%os_data
          phs%run_id = run_id
       end select
    case default
       call msg_fatal ("Phase space: parameterization method '" &
            // char (phs_method) // "' not implemented")
    end select
  end subroutine dispatch_phs
  
@ %def dispatch_phs
@
\subsection{FKS parameter}
Initialize parameters used to optimize FKS calculations.
<<Dispatch: public>>=
  public :: dispatch_fks
<<Dispatch: procedures>>=
  subroutine dispatch_fks (fks_template, global)
    type(fks_template_t), intent(inout) :: fks_template
    type(rt_data_t), intent(in) :: global
    real(default) :: fks_dij_exp1, fks_dij_exp2
    integer :: fks_mapping_type
    
    fks_dij_exp1 = var_list_get_rval (global%var_list, &
         var_str ("fks_dij_exp1"))
    fks_dij_exp2 = var_list_get_rval (global%var_list, &
         var_str ("fks_dij_exp2")) 
    fks_mapping_type = var_list_get_ival (global%var_list, &
         var_str ("fks_mapping_type"))

    call fks_template%set_dij_exp (fks_dij_exp1, fks_dij_exp2)
    call fks_template%set_mapping_type (fks_mapping_type)
    
  end subroutine dispatch_fks

@ %def dispatch_fks
@
\subsection{Random-number generator}
Allocate a random-number generator factory according to the variable
[[$rng_method]], using the current seed in the global record.  We take
only the lower 15 bits of the seed, so the actual value fits into a
positive 16-bit signed integer.

Since we want to guarantee that all random-number generators in a run
are independent, we increment the global seed by one after creating
the rng factory.  If the user wants to have identical sequences, he
can always set the seed manually, before it is used.
<<Dispatch: public>>=
  public :: dispatch_rng_factory
<<Dispatch: procedures>>=
  subroutine dispatch_rng_factory (rng_factory, global, local_input)
    class(rng_factory_t), allocatable, intent(inout) :: rng_factory
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target, optional :: local_input
    type(rt_data_t), pointer :: local
    type(string_t) :: rng_method
    integer :: seed
    character(30) :: buffer
    integer(i16) :: s
    if (present (local_input)) then
       local => local_input
    else
       local => global
    end if
    rng_method = var_list_get_sval (local%var_list, var_str ("$rng_method"))
    seed = var_list_get_ival (local%var_list, var_str ("seed"))
    s = mod (seed, 32768)
    select case (char (rng_method))
    case ("unit_test")
       allocate (rng_test_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing Test random-number generator")
    case ("tao")
       allocate (rng_tao_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing TAO random-number generator")       
    case default
       call msg_fatal ("Random-number generator '" &
            // char (rng_method) // "' not implemented")
    end select
    write (buffer, "(I0)")  s
    call msg_message ("RNG: Setting seed for random-number generator to " &
            // trim (buffer))
    call rng_factory%init (s)
    call var_list_set_int (global%var_list, var_str ("seed"), seed + 1, &
         is_known = .true.)
  end subroutine dispatch_rng_factory
  
@ %def dispatch_rng_factory
@
\subsection{Structure function configuration data}
This data type is a container for transferring structure-function
specific data from the [[dispatch_sf_data]] to the
[[dispatch_sf_channels]] subroutine.
<<Dispatch: public>>=
  public :: sf_prop_t
<<Dispatch: types>>=
  type :: sf_prop_t
     real(default), dimension(2) :: isr_eps = 1
  end type sf_prop_t
  
@ %def sf_prop_t
@
Allocate a structure-function configuration object according to the
[[sf_method]] string.

The [[sf_prop]] object can be used to transfer structure-function
specific data up and to the [[dispatch_sf_channels]] subroutine below,
so they can be used for particular mappings.

The [[global]] object is intent(inout) because the RNG generator seed may change
during initialization.

The [[pdg_in]] array is the array of incoming flavors, corresponding
to the upstream structure function or the beam array.  This will be
checked for the structure function in question and replaced by the
outgoing flavors.  The [[pdg_prc]] array is the array of incoming
flavors (beam index, component index) for the hard process.
<<Dispatch: public>>=
  public :: dispatch_sf_data
<<Dispatch: procedures>>=
  subroutine dispatch_sf_data (data, sf_method, i_beam, sf_prop, global, &
       pdg_in, pdg_prc)
    class(sf_data_t), allocatable, intent(inout) :: data
    type(string_t), intent(in) :: sf_method
    integer, dimension(:), intent(in) :: i_beam
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_in
    type(pdg_array_t), dimension(:,:), intent(in) :: pdg_prc
    type(sf_prop_t), intent(inout) :: sf_prop
    type(rt_data_t), intent(inout) :: global
    type(model_t), pointer :: model
    type(pdg_array_t), dimension(:), allocatable :: pdg_out
    real(default) :: sqrts, isr_alpha, isr_q_max, isr_mass
    integer :: isr_order
    logical :: isr_recoil
    real(default) :: epa_alpha, epa_x_min, epa_q_min, epa_e_max, epa_mass
    logical :: epa_recoil
    real(default) :: ewa_x_min, ewa_pt_max, ewa_mass
    logical :: ewa_keep_momentum, ewa_keep_energy   
    type(pdg_array_t), dimension(:), allocatable :: pdg_prc1
    integer :: ewa_id
    type(string_t) :: pdf_name
    type(string_t) :: lhapdf_dir, lhapdf_file
    type(string_t), dimension(13) :: lhapdf_photon_sets
    integer :: lhapdf_member, lhapdf_photon_scheme
    logical :: hoppet_b_matching
    class(rng_factory_t), allocatable :: rng_factory
    logical :: circe1_photon1, circe1_photon2, circe1_generate
    real(default) :: circe1_sqrts, circe1_eps
    integer :: circe1_version, circe1_chattiness, &
         circe1_revision
    character(6) :: circe1_accelerator
    logical :: circe2_polarized
    type(string_t) :: circe2_design, circe2_file
    logical :: beam_events_warn_eof
    type(string_t) :: beam_events_dir, beam_events_file
    logical :: escan_normalize
    lhapdf_photon_sets = [var_str ("DOG0.LHgrid"), var_str ("DOG1.LHgrid"), &
         var_str ("DGG.LHgrid"), var_str ("LACG.LHgrid"), &
         var_str ("GSG0.LHgrid"), var_str ("GSG1.LHgrid"), &
         var_str ("GSG960.LHgrid"), var_str ("GSG961.LHgrid"), &
         var_str ("GRVG0.LHgrid"), var_str ("GRVG1.LHgrid"), &
         var_str ("ACFGPG.LHgrid"), var_str ("WHITG.LHgrid"), &
         var_str ("SASG.LHgrid")]
    model => global%model
    sqrts = global%get_sqrts ()
    associate (var_list => global%var_list)
      select case (char (sf_method))
      case ("sf_test_0", "sf_test_1")
         allocate (sf_test_data_t :: data)
         select type (data)
         type is (sf_test_data_t)
            select case (char (sf_method))
            case ("sf_test_0");  call data%init (model, pdg_in(i_beam(1)))
            case ("sf_test_1");  call data%init (model, pdg_in(i_beam(1)), &
                 mode = 1)
            end select
         end select
      case ("pdf_builtin")
         allocate (pdf_builtin_data_t :: data)
         select type (data)
         type is (pdf_builtin_data_t)
            pdf_name = &
                 var_list_get_sval (var_list, var_str ("$pdf_builtin_set"))
            hoppet_b_matching = &
                 var_list_get_lval (var_list, var_str ("?hoppet_b_matching"))
            call data%init ( &
                 model, pdg_in(i_beam(1)), &
                 name = pdf_name, &
                 path = global%os_data%pdf_builtin_datapath, &
                 hoppet_b_matching = hoppet_b_matching)
         end select
      case ("pdf_builtin_photon")
         call msg_fatal ("Currently, there are no photon PDFs built into WHIZARD,", &
              [var_str ("for the photon content inside a proton or neutron use"), &
               var_str ("the 'lhapdf_photon' structure function.")])
      case ("lhapdf")
         allocate (lhapdf_data_t :: data)
         if (pdg_array_get (pdg_in(i_beam(1)), 1) == PHOTON) then
            call msg_fatal ("The 'lhapdf' structure is intended only for protons and", &
                 [var_str ("pions, please use 'lhapdf_photon' for photon beams.")])
         end if         
         lhapdf_dir = &
              var_list_get_sval (var_list, var_str ("$lhapdf_dir"))  
         lhapdf_file = &
              var_list_get_sval (var_list, var_str ("$lhapdf_file")) 
         lhapdf_member = &
              var_list_get_ival (var_list, var_str ("lhapdf_member"))
         lhapdf_photon_scheme = &
              var_list_get_ival (var_list, var_str ("lhapdf_photon_scheme"))
         hoppet_b_matching = &
              var_list_get_lval (var_list, var_str ("?hoppet_b_matching"))
         select type (data)
         type is (lhapdf_data_t)
            call data%init &
                 (model, pdg_in(i_beam(1)), &
                  lhapdf_dir, lhapdf_file, lhapdf_member, &
                  lhapdf_photon_scheme, hoppet_b_matching)
         end select
      case ("lhapdf_photon")
         allocate (lhapdf_data_t :: data)
         if (pdg_array_get_length (pdg_in(i_beam(1))) /= 1 .or. &
              pdg_array_get (pdg_in(i_beam(1)), 1) /= PHOTON) then
            call msg_fatal ("The 'lhapdf_photon' structure function is exclusively for", &
                 [var_str ("photon PDFs, i.e. for photons as beam particles")])
         end if
         lhapdf_dir = &
              var_list_get_sval (var_list, var_str ("$lhapdf_dir"))  
         lhapdf_file = &
              var_list_get_sval (var_list, var_str ("$lhapdf_photon_file")) 
         lhapdf_member = &
              var_list_get_ival (var_list, var_str ("lhapdf_member"))
         lhapdf_photon_scheme = &
              var_list_get_ival (var_list, var_str ("lhapdf_photon_scheme"))
         if (.not. any (lhapdf_photon_sets == lhapdf_file)) then
            call msg_fatal ("This PDF set is not supported or not " // & 
                 "intended for photon beams.")
         end if
         select type (data)
         type is (lhapdf_data_t)
            call data%init &
                 (model, pdg_in(i_beam(1)), &
                  lhapdf_dir, lhapdf_file, lhapdf_member, &
                  lhapdf_photon_scheme)
         end select         
      case ("isr")
         allocate (isr_data_t :: data)
         isr_alpha = var_list_get_rval (var_list, var_str ("isr_alpha"))
         if (isr_alpha == 0) then
            isr_alpha = (var_list_get_rval (var_list, var_str ("ee"))) &
                 ** 2 / (4 * PI)
         end if
         isr_q_max = var_list_get_rval (var_list, var_str ("isr_q_max"))
         if (isr_q_max == 0) then
            isr_q_max = sqrts
         end if
         isr_mass   = var_list_get_rval (var_list, var_str ("isr_mass"))
         isr_order  = var_list_get_ival (var_list, var_str ("isr_order"))
         isr_recoil = var_list_get_lval (var_list, var_str ("?isr_recoil")) 
         select type (data)
         type is (isr_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), isr_alpha, isr_q_max, &
                 isr_mass, isr_order, isr_recoil)
            call data%check ()
            sf_prop%isr_eps(i_beam(1)) = data%get_eps ()
         end select
      case ("epa")
         allocate (epa_data_t :: data)
         epa_alpha = var_list_get_rval (var_list, var_str ("epa_alpha"))
         if (epa_alpha == 0) then
            epa_alpha = (var_list_get_rval (var_list, var_str ("ee"))) &
                 ** 2 / (4 * PI)
         end if         
         epa_x_min = var_list_get_rval (var_list, var_str ("epa_x_min"))
         epa_q_min = var_list_get_rval (var_list, var_str ("epa_q_min"))
         epa_e_max = var_list_get_rval (var_list, var_str ("epa_e_max"))
         if (epa_e_max == 0) then
            epa_e_max = sqrts
         end if
         epa_mass   = var_list_get_rval (var_list, var_str ("epa_mass"))
         epa_recoil = var_list_get_lval (var_list, var_str ("?epa_recoil"))
         select type (data)            
         type is (epa_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), epa_alpha, epa_x_min, &
                 epa_q_min, epa_e_max, epa_mass, epa_recoil)
            call data%check ()
         end select
      case ("ewa")
         allocate (ewa_data_t :: data)
         allocate (pdg_prc1 (size (pdg_prc, 2)))
         pdg_prc1 = pdg_prc(i_beam(1),:)
         if (any (pdg_array_get_length (pdg_prc1) /= 1) &
              .or. any (pdg_prc1 /= pdg_prc1(1))) then
            call msg_fatal &
                 ("EWA: process incoming particle (W/Z) must be unique")
         end if
         ewa_id = abs (pdg_array_get (pdg_prc1(1), 1))
         ewa_x_min = var_list_get_rval (var_list, var_str ("ewa_x_min"))
         ewa_pt_max = var_list_get_rval (var_list, var_str ("ewa_pt_max")) 
         if (ewa_pt_max == 0) then
            ewa_pt_max = sqrts
         end if
         ewa_mass = var_list_get_rval (var_list, var_str ("ewa_mass"))  
         ewa_keep_momentum = var_list_get_lval (var_list, &
              var_str ("?ewa_keep_momentum"))
         ewa_keep_energy = var_list_get_lval (var_list, &
                    var_str ("?ewa_keep_energy"))                  
         if (ewa_keep_momentum .and. ewa_keep_energy) &
              call msg_fatal (" EWA cannot conserve both energy " &
                 // "and momentum.")          
         select type (data)
         type is (ewa_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), ewa_x_min, &
                 ewa_pt_max, sqrts, ewa_keep_momentum, &
                 ewa_keep_energy, ewa_mass)
            call data%set_id (ewa_id)
            call data%check ()
         end select
      case ("circe1")
         allocate (circe1_data_t :: data)
         select type (data)
         type is (circe1_data_t)
            circe1_photon1 = &
                 var_list_get_lval (var_list, var_str ("?circe1_photon1"))	
            circe1_photon2 = &
                 var_list_get_lval (var_list, var_str ("?circe1_photon2"))	
            circe1_sqrts = &
                 var_list_get_rval (var_list, var_str ("circe1_sqrts"))
            circe1_eps = &
                 var_list_get_rval (var_list, var_str ("circe1_eps"))
            if (circe1_sqrts <= 0)  circe1_sqrts = sqrts
            circe1_generate = &
                 var_list_get_lval (var_list, var_str ("?circe1_generate"))
            circe1_version = &
                 var_list_get_ival (var_list, var_str ("circe1_ver"))
            circe1_revision = &
                 var_list_get_ival (var_list, var_str ("circe1_rev"))
            circe1_accelerator = &
                 char (var_list_get_sval (var_list, var_str ("$circe1_acc")))
            circe1_chattiness = &
                 var_list_get_ival (var_list, var_str ("circe1_chat"))
            call data%init (model, pdg_in, circe1_sqrts, circe1_eps, &
                 [circe1_photon1, circe1_photon2], &
                 circe1_version, circe1_revision, circe1_accelerator, &
                 circe1_chattiness)
            if (circe1_generate) then
               call msg_message ("Circe1: activating generator mode")
               call dispatch_rng_factory (rng_factory, global)
               call data%set_generator_mode (rng_factory)
            end if
         end select
      case ("circe2")
         allocate (circe2_data_t :: data)
         select type (data)
         type is (circe2_data_t)
            circe2_polarized = &
                 var_list_get_lval (var_list, var_str ("?circe2_polarized"))
            circe2_file = &
                 var_list_get_sval (var_list, var_str ("$circe2_file"))
            circe2_design = &
                 var_list_get_sval (var_list, var_str ("$circe2_design"))
            call data%init (global%os_data, model, pdg_in, sqrts, &
                 circe2_polarized, circe2_file, circe2_design)
            call msg_message ("Circe2: activating generator mode")
            call dispatch_rng_factory (rng_factory, global)
            call data%set_generator_mode (rng_factory)
         end select
      case ("beam_events")
         allocate (beam_events_data_t :: data)
         select type (data)
         type is (beam_events_data_t)
            beam_events_dir = global%os_data%whizard_beamsimpath
            beam_events_file = var_list_get_sval (var_list, &
                 var_str ("$beam_events_file"))
            beam_events_warn_eof = var_list_get_lval (var_list, &
                 var_str ("?beam_events_warn_eof"))
            call data%init (model, pdg_in, &
                    beam_events_dir, beam_events_file, beam_events_warn_eof)  
         end select
      case ("energy_scan")
         escan_normalize = &
              var_list_get_lval (var_list, var_str ("?energy_scan_normalize"))
         allocate (escan_data_t :: data)
         select type (data) 
         type is (escan_data_t)
            if (escan_normalize) then
               call data%init (model, pdg_in)  
            else
               call data%init (model, pdg_in, sqrts)  
            end if
         end select
      case default
         call msg_bug ("Structure function '" &
              // char (sf_method) // "' not implemented yet")
      end select
    end associate
    if (allocated (data)) then
       allocate (pdg_out (size (pdg_prc, 1)))
       call data%get_pdg_out (pdg_out)
       pdg_in(i_beam) = pdg_out
    end if
  end subroutine dispatch_sf_data
  
@ %def dispatch_sf_data
@ This is an auxiliary procedure, used by the beam-structure
expansion: tell for a given structure function name, whether it
corresponds to a pair spectrum ($n=2$), a single-particle structure
function ($n=1$), or nothing ($n=0$). Though [[energy_scan]] can
in principle also be a pair spectrum, it always has only one
parameter.
<<Dispatch: procedures>>=
  function strfun_mode (name) result (n)
    type(string_t), intent(in) :: name
    integer :: n
    select case (char (name))
    case ("none")
       n = 0
    case ("sf_test_0", "sf_test_1")
       n = 1
    case ("pdf_builtin","pdf_builtin_photon", &
          "lhapdf","lhapdf_photon")
       n = 1
    case ("isr","epa","ewa")
       n = 1
    case ("circe1", "circe2")
       n = 2
    case ("beam_events")
       n = 2
    case ("energy_scan")
       n = 2
    case default
       call msg_bug ("Structure function '" // char (name) &
            // "' not supported yet")
    end select
  end function strfun_mode
    
@ %def strfun_mode
@ Dispatch a whole structure-function chain, given beam data and beam
structure data.

This could be done generically, but we should look at the specific
combination of structure functions in order to select appropriate mappings.

The [[beam_structure]] argument gets copied because
we want to expand it to canonical form (one valid structure-function
entry per record) before proceeding further.

The [[pdg_prc]] argument is the array of incoming flavors.  The first
index is the beam index, the second one the process component index.
Each element is itself a PDG array, notrivial if there is a flavor sum
for the incoming state of this component.

The dispatcher is divided in two parts.  The first part configures the
structure function data themselves.  After this, we can configure the
phase space for the elementary process.
<<Dispatch: public>>=
  public :: dispatch_sf_config
<<Dispatch: procedures>>=
  subroutine dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    type(sf_config_t), dimension(:), allocatable, intent(out) :: sf_config
    type(sf_prop_t), intent(out) :: sf_prop
    type(rt_data_t), intent(inout) :: global
    type(beam_structure_t) :: beam_structure
    class(sf_data_t), allocatable :: sf_data
    type(pdg_array_t), dimension(:,:), intent(in) :: pdg_prc
    type(string_t), dimension(:), allocatable :: prt_in
    type(pdg_array_t), dimension(:), allocatable :: pdg_in
    type(flavor_t) :: flv_in
    integer :: n_beam, n_record, i
    beam_structure = global%beam_structure
    call beam_structure%expand (strfun_mode)
    n_record = beam_structure%get_n_record ()
    allocate (sf_config (n_record))
    n_beam = beam_structure%get_n_beam ()
    if (n_beam > 0) then
       allocate (prt_in (n_beam), pdg_in (n_beam))
       prt_in = beam_structure%get_prt ()
       do i = 1, n_beam
          call flavor_init (flv_in, prt_in(i), global%model)
          pdg_in(i) = flavor_get_pdg (flv_in)
       end do
    else
       n_beam = size (pdg_prc, 1)
       allocate (pdg_in (n_beam))
       pdg_in = pdg_prc(:,1)
    end if
    do i = 1, n_record
       call dispatch_sf_data (sf_data, &
            beam_structure%get_name (i), &
            beam_structure%get_i_entry (i), &
            sf_prop, global, pdg_in, pdg_prc)
       call sf_config(i)%init (beam_structure%get_i_entry (i), sf_data)
       deallocate (sf_data)
    end do
  end subroutine dispatch_sf_config
    
@ %def dispatch_sf_config
@ The second part configures channel mappings, using some conditions
from the phase space configuration.  If there are no structure
functions, we enable a default setup with a single (dummy)
structure-function channel.  Otherwise, we look at the channel
collection that we got from the phase-space configuration step.  Each
entry should be translated into an independent structure-function
channel, where typically there is one default entry, which could be
mapped using a standard s-channel mapping if the structure function
setup recommends this, and other entries with s-channel resonances.
The latter need to be translated into global mappings from the
structure-function chain.
<<Dispatch: public>>=
  public :: dispatch_sf_channels
<<Dispatch: procedures>>=
  subroutine dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    type(sf_channel_t), dimension(:), allocatable, intent(out) :: sf_channel
    type(string_t), intent(out) :: sf_string
    type(sf_prop_t), intent(in) :: sf_prop
    type(phs_channel_collection_t), intent(in) :: coll
    type(rt_data_t), intent(in) :: global
    type(beam_structure_t) :: beam_structure
    class(channel_prop_t), allocatable :: prop
    integer :: n_strfun, n_sf_channel, i
    logical :: sf_allow_s_mapping, circe1_map, circe1_generate
    logical :: s_mapping_enable, endpoint_mapping, power_mapping
    integer, dimension(:), allocatable :: s_mapping, single_mapping
    real(default) :: sqrts, s_mapping_power
    real(default) :: circe1_mapping_slope, endpoint_mapping_slope
    real(default) :: power_mapping_eps
    sqrts = global%get_sqrts ()
    beam_structure = global%beam_structure
    call beam_structure%expand (strfun_mode)
    n_strfun = beam_structure%get_n_record ()
    sf_string = beam_structure%to_string (sf_only = .true.)
    sf_allow_s_mapping = &
         var_list_get_lval (global%var_list, var_str ("?sf_allow_s_mapping"))
    circe1_generate = &
         var_list_get_lval (global%var_list, var_str ("?circe1_generate"))
    circe1_map = &
         var_list_get_lval (global%var_list, var_str ("?circe1_map"))
    circe1_mapping_slope = &
         var_list_get_rval (global%var_list, var_str ("circe1_mapping_slope"))
    s_mapping_enable = .false.
    s_mapping_power = 1
    endpoint_mapping = .false.
    endpoint_mapping_slope = 1
    power_mapping = .false.
    select case (char (sf_string))
    case ("", "[any particles]")
    case ("pdf_builtin, none", &
         "pdf_builtin_photon, none", &
         "none, pdf_builtin", &
         "none, pdf_builtin_photon", &
         "lhapdf, none", &
         "lhapdf_photon, none", &
         "none, lhapdf", &
         "none, lhapdf_photon")
    case ("pdf_builtin, none => none, pdf_builtin", &
          "pdf_builtin, none => none, pdf_builtin_photon", &
          "pdf_builtin_photon, none => none, pdf_builtin", &
          "pdf_builtin_photon, none => none, pdf_builtin_photon", &
          "lhapdf, none => none, lhapdf", &
          "lhapdf, none => none, lhapdf_photon", &
          "lhapdf_photon, none => none, lhapdf", &
          "lhapdf_photon, none => none, lhapdf_photon")
       allocate (s_mapping (2), source = [1, 2])
       s_mapping_enable = .true.
       s_mapping_power = 2
    case ("pdf_builtin, none => none, pdf_builtin => epa, none => none, epa", &
          "pdf_builtin, none => none, pdf_builtin => ewa, none => none, ewa", &
          "pdf_builtin, none => none, pdf_builtin => ewa, none => none, epa", &
          "pdf_builtin, none => none, pdf_builtin => epa, none => none, ewa")
       allocate (s_mapping (2), source = [1, 2])
       s_mapping_enable = .true.
       s_mapping_power = 2
    case ("isr, none", &
         "none, isr")
       allocate (single_mapping (1), source = [1])
    case ("isr, none => none, isr")
       allocate (s_mapping (2), source = [1, 2])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("isr, none => none, isr => epa, none => none, epa", &
          "isr, none => none, isr => ewa, none => none, ewa", &
          "isr, none => none, isr => ewa, none => none, epa", &
          "isr, none => none, isr => epa, none => none, ewa")
       allocate (s_mapping (2), source = [1, 2])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("circe1 => isr, none => none, isr => epa, none => none, epa", &
          "circe1 => isr, none => none, isr => ewa, none => none, ewa", &
          "circe1 => isr, none => none, isr => ewa, none => none, epa", &
          "circe1 => isr, none => none, isr => epa, none => none, ewa")
       if (circe1_generate) then
          allocate (s_mapping (2), source = [2, 3])
       else
          allocate (s_mapping (3), source = [1, 2, 3])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       end if
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)       
    case ("pdf_builtin, none => none, isr", &
         "pdf_builtin_photon, none => none, isr", &
         "lhapdf, none => none, isr", &
         "lhapdf_photon, none => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("isr, none => none, pdf_builtin", &
         "isr, none => none, pdf_builtin_photon", &
         "isr, none => none, lhapdf", &
         "isr, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])
    case ("epa, none", &
          "none, epa")
       allocate (single_mapping (1), source = [1])
    case ("epa, none => none, epa")
       allocate (single_mapping (2), source = [1, 2])
    case ("epa, none => none, isr", &
         "isr, none => none, epa", &
         "ewa, none => none, isr", &
         "isr, none => none, ewa")
       allocate (single_mapping (2), source = [1, 2])
    case ("pdf_builtin, none => none, epa", &
         "pdf_builtin_photon, none => none, epa", &
         "lhapdf, none => none, epa", &
         "lhapdf_photon, none => none, epa")
       allocate (single_mapping (1), source = [2])
    case ("pdf_builtin, none => none, ewa", &
         "pdf_builtin_photon, none => none, ewa", &
         "lhapdf, none => none, ewa", &
         "lhapdf_photon, none => none, ewa")
       allocate (single_mapping (1), source = [2])       
    case ("epa, none => none, pdf_builtin", &
         "epa, none => none, pdf_builtin_photon", &
         "epa, none => none, lhapdf", &
         "epa, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])
    case ("ewa, none => none, pdf_builtin", &
         "ewa, none => none, pdf_builtin_photon", &
         "ewa, none => none, lhapdf", &
         "ewa, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])       
    case ("ewa, none", &
          "none, ewa")
       allocate (single_mapping (1), source = [1])
    case ("ewa, none => none, ewa")
       allocate (single_mapping (2), source = [1, 2])
    case ("energy_scan, none => none, energy_scan")
       allocate (s_mapping (2), source = [1, 2])
    case ("sf_test_1, none => none, sf_test_1")
       allocate (s_mapping (2), source = [1, 2])
    case ("circe1")
       if (circe1_generate) then
          !!! no mapping
       else if (circe1_map) then
          allocate (s_mapping (1), source = [1])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       else
          allocate (s_mapping (1), source = [1])
          s_mapping_enable = .true.
       end if
    case ("circe1 => isr, none => none, isr")
       if (circe1_generate) then
          allocate (s_mapping (2), source = [2, 3])
       else
          allocate (s_mapping (3), source = [1, 2, 3])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       end if
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("circe1 => isr, none", &
         "circe1 => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("circe1 => epa, none => none, epa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => ewa, none => none, ewa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else 
          call msg_fatal ("Circe/EWA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => epa, none", &
         "circe1 => none, epa")
       if (circe1_generate) then
          allocate (single_mapping (1), source = [2])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => epa, none => none, isr", &
         "circe1 => isr, none => none, epa", &
         "circe1 => ewa, none => none, isr", &
         "circe1 => isr, none => none, ewa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe2")
    case ("beam_events")
    case ("beam_events => isr, none => none, isr")
       allocate (s_mapping (2), source = [2, 3])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("beam_events => isr, none", &
         "beam_events => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("beam_events => epa, none => none, epa")
       allocate (single_mapping (2), source = [2, 3])
    case ("beam_events => epa, none", &
         "beam_events => none, epa", &
         "beam_events => ewa, none", &
         "beam_events => none, ewa")
       allocate (single_mapping (1), source = [2])
    case ("beam_events => epa, none => none, isr", &
         "beam_events => isr, none => none, epa", &
         "beam_events => ewa, none => none, isr", &
         "beam_events => isr, none => none, ewa")
       allocate (single_mapping (2), source = [2, 3])
    case ("energy_scan")
    case default
       call msg_fatal ("Beam structure: " &
            // char (sf_string) // " not supported")
    end select
    if (sf_allow_s_mapping .and. coll%n > 0) then
       n_sf_channel = coll%n
       allocate (sf_channel (n_sf_channel))
       do i = 1, n_sf_channel
          call sf_channel(i)%init (n_strfun)
          if (allocated (single_mapping)) then
             call sf_channel(i)%activate_mapping (single_mapping)
          end if
          if (allocated (prop))  deallocate (prop)
          call coll%get_entry (i, prop)
          if (allocated (prop)) then
             if (endpoint_mapping .and. power_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_eir_mapping (s_mapping, &
                        a = endpoint_mapping_slope, eps = power_mapping_eps, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_eio_mapping (s_mapping, &
                        a = endpoint_mapping_slope, eps = power_mapping_eps, &
                        m = prop%mass / sqrts)
                end select
             else if (endpoint_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_epr_mapping (s_mapping, &
                        a = endpoint_mapping_slope, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_epo_mapping (s_mapping, &
                        a = endpoint_mapping_slope, &
                        m = prop%mass / sqrts)
                end select
             else if (power_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_ipr_mapping (s_mapping, &
                        eps = power_mapping_eps, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_ipo_mapping (s_mapping, &
                        eps = power_mapping_eps, &
                        m = prop%mass / sqrts)
                end select
             else if (allocated (s_mapping)) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_res_mapping (s_mapping, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_os_mapping (s_mapping, &
                        m = prop%mass / sqrts)
                end select
             else if (allocated (single_mapping)) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_res_mapping (single_mapping, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_os_mapping (single_mapping, &
                        m = prop%mass / sqrts)
                end select
             end if
          else if (endpoint_mapping .and. power_mapping) then
             call sf_channel(i)%set_ei_mapping (s_mapping, &
                  a = endpoint_mapping_slope, eps = power_mapping_eps)
          else if (endpoint_mapping .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_ep_mapping (s_mapping, &
                  a = endpoint_mapping_slope)
          else if (power_mapping .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_ip_mapping (s_mapping, &
                  eps = power_mapping_eps)
          else if (s_mapping_enable .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_s_mapping (s_mapping, &
                  power = s_mapping_power)
          end if
       end do
    else if (sf_allow_s_mapping) then
       allocate (sf_channel (1))
       call sf_channel(1)%init (n_strfun)
       if (allocated (single_mapping)) then
          call sf_channel(1)%activate_mapping (single_mapping)
       else if (endpoint_mapping .and. power_mapping) then
          call sf_channel(i)%set_ei_mapping (s_mapping, &
               a = endpoint_mapping_slope, eps = power_mapping_eps)
       else if (endpoint_mapping) then
          call sf_channel(1)%set_ep_mapping (s_mapping, &
                  a = endpoint_mapping_slope)
       else if (power_mapping) then
          call sf_channel(1)%set_ip_mapping (s_mapping, &
                  eps = power_mapping_eps)
       else if (s_mapping_enable) then
          call sf_channel(1)%set_s_mapping (s_mapping, &
               power = s_mapping_power)
       end if
    else
       allocate (sf_channel (1))
       call sf_channel(1)%init (n_strfun)
       if (allocated (single_mapping)) then
          call sf_channel(1)%activate_mapping (single_mapping)
       end if
    end if
  end subroutine dispatch_sf_channels
    
@ %def dispatch_sf_channels
@
\subsection{Event I/O stream}
<<Dispatch: public>>=
  public :: dispatch_eio
<<Dispatch: procedures>>=
  subroutine dispatch_eio (eio, method, global)
    class(eio_t), intent(inout), allocatable :: eio
    type(string_t), intent(in) :: method
    type(rt_data_t), intent(in) :: global
    logical :: check, keep_beams, recover_beams
    logical :: write_sqme_prc, write_sqme_ref, write_sqme_alt
    type(string_t) :: lhef_version, lhef_extension
    type(string_t) :: extension_default, debug_extension, extension_hepmc, &
         extension_lha, extension_hepevt, extension_ascii_short, &
         extension_ascii_long, extension_athena, extension_mokka, &
         extension_stdhep, extension_stdhep_up, extension_raw, &
         extension_hepevt_verb, extension_lha_verb, extension_lcio
    integer :: checkpoint
    logical :: show_process, show_transforms, show_decay, verbose, pacify
    select case (char (method))
    case ("raw")
       allocate (eio_raw_t :: eio)
       select type (eio)
       type is (eio_raw_t)
          check = var_list_get_lval &
               (global%var_list, var_str ("?check_event_file"))
          extension_raw = &
               var_list_get_sval (global%var_list, var_str ("$extension_raw"))
          call eio%set_parameters (check, extension_raw)
       end select
    case ("checkpoint")
       allocate (eio_checkpoints_t :: eio)
       select type (eio)
       type is (eio_checkpoints_t)
          checkpoint = var_list_get_ival &
               (global%var_list, var_str ("checkpoint"))
          pacify = var_list_get_lval &
               (global%var_list, var_str ("?pacify"))
          call eio%set_parameters (checkpoint, blank = pacify)
       end select
    case ("lhef")
       allocate (eio_lhef_t :: eio)
       select type (eio)
       type is (eio_lhef_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          recover_beams = &
               var_list_get_lval (global%var_list, var_str ("?recover_beams"))
          lhef_version = &
               var_list_get_sval (global%var_list, var_str ("$lhef_version"))
          lhef_extension = &
               var_list_get_sval (global%var_list, var_str ("$lhef_extension"))
          write_sqme_prc = var_list_get_lval (global%var_list, &
               var_str ("?lhef_write_sqme_prc"))
          write_sqme_ref = var_list_get_lval (global%var_list, &
               var_str ("?lhef_write_sqme_ref"))
          write_sqme_alt = var_list_get_lval (global%var_list, &
               var_str ("?lhef_write_sqme_alt"))
          call eio%set_parameters (keep_beams, recover_beams, &
               char (lhef_version), lhef_extension, &
               write_sqme_ref, write_sqme_prc, write_sqme_alt)
       end select
    case ("hepmc")
       allocate (eio_hepmc_t :: eio)
       select type (eio)
       type is (eio_hepmc_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          recover_beams = &
               var_list_get_lval (global%var_list, var_str ("?recover_beams"))
          extension_hepmc = var_list_get_sval ( &
               global%var_list, var_str ("$extension_hepmc"))          
          call eio%set_parameters (keep_beams, recover_beams, extension_hepmc)
       end select
    case ("lcio")
       allocate (eio_lcio_t :: eio)
       select type (eio)
       type is (eio_lcio_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          recover_beams = &
               var_list_get_lval (global%var_list, var_str ("?recover_beams"))
          extension_lcio = var_list_get_sval ( &
               global%var_list, var_str ("$extension_lcio"))
          call eio%set_parameters (keep_beams, recover_beams, extension_lcio)
       end select       
    case ("stdhep")
       allocate (eio_stdhep_hepevt_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepevt_t)                   
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_stdhep = var_list_get_sval ( &
               global%var_list, var_str ("$extension_stdhep"))          
          call eio%set_parameters (keep_beams, extension_stdhep)          
       end select
    case ("stdhep_up")
       allocate (eio_stdhep_hepeup_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepeup_t)          
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_stdhep_up = var_list_get_sval ( &
               global%var_list, var_str ("$extension_stdhep_up"))          
          call eio%set_parameters (keep_beams, extension_stdhep_up)          
       end select       
    case ("ascii")   
       allocate (eio_ascii_ascii_t :: eio)
       select type (eio)
       type is (eio_ascii_ascii_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_default = var_list_get_sval ( &
               global%var_list, var_str ("$extension_default"))          
          call eio%set_parameters (keep_beams, extension_default)
       end select       
    case ("athena")   
       allocate (eio_ascii_athena_t :: eio)
       select type (eio)
       type is (eio_ascii_athena_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_athena = var_list_get_sval ( &
               global%var_list, var_str ("$extension_athena"))
          call eio%set_parameters (keep_beams, extension_athena)
       end select              
    case ("debug")   
       allocate (eio_ascii_debug_t :: eio)
       select type (eio)
       type is (eio_ascii_debug_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          debug_extension = var_list_get_sval ( &
               global%var_list, var_str ("$debug_extension"))          
          show_process = var_list_get_lval ( &
               global%var_list, var_str ("?debug_process"))
          show_transforms = var_list_get_lval ( &
               global%var_list, var_str ("?debug_transforms"))
          show_decay = var_list_get_lval ( &
               global%var_list, var_str ("?debug_decay"))
          verbose = var_list_get_lval ( &
               global%var_list, var_str ("?debug_verbose"))
          call eio%set_parameters (keep_beams, debug_extension, &
               show_process, show_transforms, show_decay, verbose)
       end select
    case ("hepevt")   
       allocate (eio_ascii_hepevt_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_hepevt = var_list_get_sval ( &
               global%var_list, var_str ("$extension_hepevt"))          
          call eio%set_parameters (keep_beams, extension_hepevt)
       end select              
    case ("hepevt_verb")   
       allocate (eio_ascii_hepevt_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_verb_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_hepevt_verb = var_list_get_sval ( &
               global%var_list, var_str ("$extension_hepevt_verb"))          
          call eio%set_parameters (keep_beams, extension_hepevt_verb)
       end select                     
    case ("lha")   
       allocate (eio_ascii_lha_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_lha = var_list_get_sval ( &
               global%var_list, var_str ("$extension_lha"))          
          call eio%set_parameters (keep_beams, extension_lha)
       end select                     
    case ("lha_verb")   
       allocate (eio_ascii_lha_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_verb_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_lha_verb = var_list_get_sval ( &
               global%var_list, var_str ("$extension_lha_verb"))          
          call eio%set_parameters (keep_beams, extension_lha_verb)
       end select                            
    case ("long")   
       allocate (eio_ascii_long_t :: eio)
       select type (eio)
       type is (eio_ascii_long_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_ascii_long = var_list_get_sval ( &
               global%var_list, var_str ("$extension_ascii_long"))          
          call eio%set_parameters (keep_beams, extension_ascii_long)
       end select              
    case ("mokka")   
       allocate (eio_ascii_mokka_t :: eio)
       select type (eio)
       type is (eio_ascii_mokka_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_mokka = var_list_get_sval ( &
               global%var_list, var_str ("$extension_mokka"))          
          call eio%set_parameters (keep_beams, extension_mokka)
       end select                     
    case ("short")   
       allocate (eio_ascii_short_t :: eio)
       select type (eio)
       type is (eio_ascii_short_t)
          keep_beams = &
               var_list_get_lval (global%var_list, var_str ("?keep_beams"))
          extension_ascii_short = var_list_get_sval ( &
               global%var_list, var_str ("$extension_ascii_short"))          
          call eio%set_parameters (keep_beams, extension_ascii_short)
       end select                     
    case ("weight_stream")
       allocate (eio_weights_t :: eio)
       select type (eio)
       type is (eio_weights_t)
          pacify = var_list_get_lval &
               (global%var_list, var_str ("?pacify"))
          call eio%set_parameters (pacify = pacify)       
       end select
    case default
       call msg_fatal ("Event I/O method '" // char (method) &
            // "' not implemented")
    end select
    call eio%set_fallback_model (global%fallback_model)
  end subroutine dispatch_eio
  
@ %def dispatch_eio
@
\subsection{QCD coupling}
Allocate the [[alpha]] (running coupling) component of the [[qcd]] block with
a concrete implementation, depending on the variable settings in the
[[global]] record.

If a fixed $\alpha_s$ is requested, we do not allocate the
[[qcd%alpha]] object.  In this case, the matrix element code will just take
the model parameter as-is, which implies fixed $\alpha_s$.  If the
object is allocated, the $\alpha_s$ value is computed and updated for
each matrix-element call.
<<Dispatch: public>>=
  public :: dispatch_qcd
<<Dispatch: procedures>>=
  subroutine dispatch_qcd (qcd, global)
    type(qcd_t), intent(inout) :: qcd
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    logical :: fixed, from_mz, from_pdf_builtin, from_lhapdf, from_lambda_qcd
    real(default) :: mz, alpha_val, lambda
    integer :: nf, order, lhapdf_member
    type(string_t) :: pdfset, lhapdf_dir, lhapdf_file
    var_list => global%var_list
    fixed = &
         var_list_get_lval (var_list, var_str ("?alpha_s_is_fixed"))
    from_mz = &
         var_list_get_lval (var_list, var_str ("?alpha_s_from_mz"))
    from_pdf_builtin = &
         var_list_get_lval (var_list, var_str ("?alpha_s_from_pdf_builtin"))
    from_lhapdf = &
         var_list_get_lval (var_list, var_str ("?alpha_s_from_lhapdf"))
    from_lambda_qcd = &
         var_list_get_lval (var_list, var_str ("?alpha_s_from_lambda_qcd"))
    pdfset = &
         var_list_get_sval (var_list, var_str ("$pdf_builtin_set"))    
    lambda = &
         var_list_get_rval (var_list, var_str ("lambda_qcd"))
    nf = &
         var_list_get_ival (var_list, var_str ("alpha_s_nf"))
    order = &
         var_list_get_ival (var_list, var_str ("alpha_s_order"))
    lhapdf_dir = &
         var_list_get_sval (var_list, var_str ("$lhapdf_dir"))
    lhapdf_file = &
         var_list_get_sval (var_list, var_str ("$lhapdf_file"))
    lhapdf_member = &
         var_list_get_ival (var_list, var_str ("lhapdf_member"))         
    var_list => global%model%get_var_list_ptr ()
    if (var_list_exists (var_list, var_str ("mZ"))) then
       mz = var_list_get_rval (var_list, var_str ("mZ"))
    else
       mz = MZ_REF
    end if
    if (var_list_exists (var_list, var_str ("alphas"))) then
       alpha_val = var_list_get_rval (var_list, var_str ("alphas"))
    else
       alpha_val = ALPHA_QCD_MZ_REF
    end if
    if (allocated (qcd%alpha))  deallocate (qcd%alpha)
    if (from_lhapdf .and. from_pdf_builtin) then
        call msg_fatal (" Mixing alphas evolution",  &
             [var_str (" from LHAPDF and builtin PDF is not permitted")])
    end if 
    select case (count ([from_mz, from_pdf_builtin, from_lhapdf, from_lambda_qcd]))
    case (0)
       if (fixed) then 
          allocate (alpha_qcd_fixed_t :: qcd%alpha)          
       else
          call msg_fatal ("QCD alpha: no calculation mode set")
       end if
    case (2:)
       call msg_fatal ("QCD alpha: calculation mode is ambiguous")
    case (1)
       if (fixed) then
          call msg_fatal ("QCD alpha: use '?alpha_s_is_fixed = false' for " // &
               "running alphas")          
       else if (from_mz) then
          allocate (alpha_qcd_from_scale_t :: qcd%alpha)
       else if (from_pdf_builtin) then
          allocate (alpha_qcd_pdf_builtin_t :: qcd%alpha)
       else if (from_lhapdf) then
          allocate (alpha_qcd_lhapdf_t :: qcd%alpha)
       else if (from_lambda_qcd) then
          allocate (alpha_qcd_from_lambda_t :: qcd%alpha)
       end if
       call msg_message ("QCD alpha: using a running strong coupling")
    end select
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_fixed_t)
       alpha%val = alpha_val
    type is (alpha_qcd_from_scale_t)
       alpha%mu_ref = mz
       alpha%ref = alpha_val
       alpha%order = order
       alpha%nf = nf
    type is (alpha_qcd_from_lambda_t)
       alpha%lambda = lambda
       alpha%order = order
       alpha%nf = nf
    type is (alpha_qcd_pdf_builtin_t)
       call alpha%init (pdfset, &
            global%os_data%pdf_builtin_datapath)
    type is (alpha_qcd_lhapdf_t)
       call alpha%init (lhapdf_file, lhapdf_member, lhapdf_dir)
    end select
  end subroutine dispatch_qcd
  
@ %def dispatch_qcd
@
\subsection{Parton Shower}
Transfer the settings and parameters for shower and hadronization from
the [[global]] object to the [[shower_settings]] object.
<<Dispatch: public>>=
  public :: dispatch_shower
<<Dispatch: procedures>>=
  subroutine dispatch_shower (shower_settings, global)
    class(shower_settings_t), intent(inout) :: shower_settings
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    var_list => global%var_list
    call shower_settings%init (var_list)
  end subroutine dispatch_shower

@ %def dispatch_shower  
@
\subsection{Event Transform}
An event transform is responsible for dressing a partonic event.
Since event transforms are not mutually exclusive but are
concatenated, we provide individual dispatchers for each of them.
<<Dispatch: public>>=
  public :: dispatch_evt_decay
  public :: dispatch_evt_shower
<<Dispatch: procedures>>=
  subroutine dispatch_evt_decay (evt, global)
    class(evt_t), intent(out), pointer :: evt
    type(rt_data_t), intent(in) :: global
    logical :: allow_decays
    allow_decays = &
         var_list_get_lval (global%var_list, var_str ("?allow_decays"))
    if (allow_decays) then
       allocate (evt_decay_t :: evt)
       call msg_message ("Simulate: activating decays")
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_decay

  subroutine dispatch_evt_shower (evt, global, process)
    class(evt_t), intent(out), pointer :: evt
    type(rt_data_t), intent(in) :: global
    type(process_t), intent(in), optional, target :: process
    logical :: allow_shower
    type(shower_settings_t) :: settings
    allow_shower = &
         var_list_get_lval (global%var_list, var_str ("?allow_shower"))    
    if (allow_shower) then
       allocate (evt_shower_t :: evt)
       call msg_message ("Simulate: activating parton shower")
       call dispatch_shower (settings, global)
       if (settings%mlm_matching) &
            call msg_message ("Simulate: applying MLM matching")
       if (settings%ckkw_matching) &
            call msg_warning ("Simulate: CKKW(-L) matching not yet supported")
       if (settings%hadronization_active) &
            call msg_message ("Simulate: applying hadronization")
       select type (evt)
       type is (evt_shower_t)
          call evt%init (settings, global%fallback_model, global%os_data)
          if (present (process)) &
               call evt%setup_pdf (process, global%beam_structure)
       end select
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_shower

@ %def dispatch_evt_decay
@ %def dispatch_evt_shower
@
\subsection{SLHA Interface}
This is a container for the settings for the SLHA Interface
<<Dispatch: public>>=
  public :: dispatch_slha
<<Dispatch: procedures>>=
  subroutine dispatch_slha (global, input, spectrum, decays)
    type(rt_data_t), intent(inout), target :: global
    logical, intent(out) :: input, spectrum, decays
    input = var_list_get_lval (global%var_list, &
         var_str ("?slha_read_input"))
    spectrum = var_list_get_lval (global%var_list, &
         var_str ("?slha_read_spectrum"))
    decays = var_list_get_lval (global%var_list, &
         var_str ("?slha_read_decays"))    
  end subroutine dispatch_slha

@ %def dispatch_slha  
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Dispatch: public>>=
  public :: dispatch_test
<<Dispatch: tests>>=
  subroutine dispatch_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Dispatch: execute tests>>
  end subroutine dispatch_test

@ %def dispatch_test
@
\subsubsection{Select type: process definition}
<<Dispatch: execute tests>>=
  call test (dispatch_1, "dispatch_1", &
       "process configuration method", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_1 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    
    write (u, "(A)")  "* Test output: dispatch_1"
    write (u, "(A)")  "*   Purpose: select process configuration method"
    write (u, "(A)")

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core_def as prc_test_def"

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    select type (core_def)
    type is (prc_test_def_t)
       call core_def%write (u)
    end select
    
    deallocate (core_def)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate core_def as omega_def"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    select type (core_def)
    type is (omega_omega_def_t)
       call core_def%write (u)
    end select
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_1"
    
  end subroutine dispatch_1
  
@ %def dispatch_1
@
\subsubsection{Select type: process core}
<<Dispatch: execute tests>>=
  call test (dispatch_2, "dispatch_2", &
       "process core", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_2 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    class(prc_core_t), allocatable :: core
    
    write (u, "(A)")  "* Test output: dispatch_2"
    write (u, "(A)")  "*   Purpose: select process configuration method"
    write (u, "(A)")  "             and allocate process core"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core as test_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    call dispatch_core (core, core_def)
    select type (core)
    type is (test_t)
       call core%write (u)
    end select
    
    deallocate (core)
    deallocate (core_def)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate core as prc_omega_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)

    call global%read_model (var_str ("Test"), var_str ("Test.mdl"))

    call var_list_set_log (global%var_list, &
         var_str ("?helicity_selection_active"), &
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, &
         var_str ("helicity_selection_threshold"), &
         1e9_default, is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("helicity_selection_cutoff"), &
         10, is_known = .true.)
    
    call dispatch_core (core, core_def, &
         global%model, global%get_helicity_selection ())
    call core_def%allocate_driver (core%driver, var_str (""))

    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_2"
    
  end subroutine dispatch_2
  
@ %def dispatch_2
@
\subsubsection{Select type: integrator core}
<<Dispatch: execute tests>>=
  call test (dispatch_3, "dispatch_3", &
       "integration method", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_3 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(mci_t), allocatable :: mci
    type(string_t) :: process_id
    
    write (u, "(A)")  "* Test output: dispatch_3"
    write (u, "(A)")  "*   Purpose: select integration method"
    write (u, "(A)")

    call global%global_init ()
    process_id = "dispatch_3"

    write (u, "(A)")  "* Allocate MCI as midpoint_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("midpoint"), is_known = .true.)
    call dispatch_mci (mci, global, process_id)
    select type (mci)
    type is (mci_midpoint_t)
       call mci%write (u)
    end select

    call mci%final ()
    deallocate (mci)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate MCI as vamp_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("vamp"), is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("threshold_calls"), &
         1, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_calls_per_channel"), &
         2, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_calls_per_bin"), &
         3, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_bins"), &
         4, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("max_bins"), &
         5, is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?stratified"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("channel_weights_power"),&
         4._default, is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_global_verbose"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_channels"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_channels_verbose"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?stratified"), &
         .false., is_known = .true.)

    call dispatch_mci (mci, global, process_id)
    select type (mci)
    type is (mci_vamp_t)
       call mci%write (u)
       call mci%write_history_parameters (u)
    end select

    call mci%final ()
    deallocate (mci)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate MCI as vamp_t, allow for negative weights"
    write (u, "(A)")    
    
    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?negative_weights"), &
         .true., is_known = .true.)
    
    call dispatch_mci (mci, global, process_id)
    select type (mci)       
    type is (mci_vamp_t)
       call mci%write (u)
       call mci%write_history_parameters (u)
    end select
    
    call mci%final ()
    deallocate (mci)
    
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_3"
    
  end subroutine dispatch_3
  
@ %def dispatch_3
@
\subsubsection{Select type: phase-space configuration object}
<<Dispatch: execute tests>>=
  call test (dispatch_4, "dispatch_4", &
       "phase-space configuration", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_4 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(phs_config_t), allocatable :: phs
    type(phs_parameters_t) :: phs_par
    type(mapping_defaults_t) :: mapping_defs
    
    write (u, "(A)")  "* Test output: dispatch_4"
    write (u, "(A)")  "*   Purpose: select phase-space configuration method"
    write (u, "(A)")

    call global%global_init ()

    write (u, "(A)")  "* Allocate PHS as phs_single_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_4"))
    call phs%write (u)

    call phs%final ()
    deallocate (phs)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate PHS as phs_wood_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_4"))
    call phs%write (u)
          
    call phs%final ()
    deallocate (phs)
    
    write (u, "(A)")
    write (u, "(A)")  "* Setting parameters for phs_wood_t"
    write (u, "(A)")        

    phs_par%m_threshold_s = 123
    phs_par%m_threshold_t = 456
    phs_par%t_channel = 42
    phs_par%off_shell = 17
    phs_par%keep_nonresonant = .false.    
    mapping_defs%energy_scale = 987
    mapping_defs%invariant_mass_scale = 654
    mapping_defs%momentum_transfer_scale = 321
    mapping_defs%step_mapping = .false.   
    mapping_defs%step_mapping_exp = .false.       
    mapping_defs%enable_s_mapping = .true.       
    call dispatch_phs (phs, global, var_str ("dispatch_4"), &
         mapping_defs, phs_par)    
    call phs%write (u)    
        
    call phs%final ()

    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_4"
    
  end subroutine dispatch_4
  
@ %def dispatch_4
@
\subsubsection{Select type: random number generator}
<<Dispatch: execute tests>>=
  call test (dispatch_5, "dispatch_5", &
       "random-number generator", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_5 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(rng_factory_t), allocatable :: rng_factory
    
    write (u, "(A)")  "* Test output: dispatch_5"
    write (u, "(A)")  "*   Purpose: select random-number generator"
    write (u, "(A)")

    call global%global_init ()

    write (u, "(A)")  "* Allocate RNG factory as rng_test_factory_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$rng_method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("seed"), 1, is_known = .true.)
    call dispatch_rng_factory (rng_factory, global)
    call rng_factory%write (u)
    deallocate (rng_factory)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate RNG factory as rng_tao_factory_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$rng_method"), &
         var_str ("tao"), is_known = .true.)
    call dispatch_rng_factory (rng_factory, global)
    call rng_factory%write (u)
    deallocate (rng_factory)
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_5"
    
  end subroutine dispatch_5
  
@ %def dispatch_5
@
\subsubsection{Phase-space configuration with file}
<<Dispatch: execute tests>>=
  call test (dispatch_6, "dispatch_6", &
       "configure phase space using file", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_6 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: dispatch_6"
    write (u, "(A)")  "*   Purpose: select 'wood' phase-space &
         &for a test process"
    write (u, "(A)")  "*            and read phs configuration from file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call global%global_init ()

    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%read_model (var_str ("Test"), var_str ("Test.mdl"))

    call syntax_phs_forest_init ()
    
    call init_test_process_data (var_str ("dispatch_6"), process_data)

    write (u, "(A)")  "* Write phase-space file"

    u_phs = free_unit ()
    open (u_phs, file = "dispatch_6.phs", action = "write", status = "replace")
    call write_test_phs_file (u_phs, var_str ("dispatch_6"))
    close (u_phs)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate PHS as phs_wood_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, &
         var_str ("$phs_file"), &
         var_str ("dispatch_6.phs"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_6"))

    call phs%init (process_data, global%model)
    call phs%configure (sqrts = 1000._default)

    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_config_t)
       call phs%write_forest (u)
    end select

    call phs%final ()

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_6"
    
  end subroutine dispatch_6
  
@ %def dispatch_6
@
\subsubsection{Select type: structure-function data}
<<Dispatch: execute tests>>=
  call test (dispatch_7, "dispatch_7", &
       "structure-function data", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_7 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(string_t) :: prt, sf_method
    type(sf_prop_t) :: sf_prop
    class(sf_data_t), allocatable :: data
    type(pdg_array_t), dimension(1) :: pdg_in
    type(pdg_array_t), dimension(1,1) :: pdg_prc
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    
    write (u, "(A)")  "* Test output: dispatch_7"
    write (u, "(A)")  "*   Purpose: select and configure &
         &structure function data"
    write (u, "(A)")

    call global%global_init ()
    
    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%read_model (var_str ("QCD"), var_str ("QCD.mdl"))
    
    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         14000._default, is_known = .true.)
    prt = "p"
    call global%beam_structure%init_sf ([prt, prt], [1])
    pdg_in = 2212
    
    write (u, "(A)")  "* Allocate data as sf_pdf_builtin_t"
    write (u, "(A)")

    sf_method = "pdf_builtin"
    call dispatch_sf_data &
         (data, sf_method, [1], sf_prop, global, pdg_in, pdg_prc)
    call data%write (u)

    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(A)")
    write (u, "(1x,A,99(1x,I0))")  "PDG(out) = ", pdg1

    deallocate (data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate data for different PDF set"
    write (u, "(A)")

    pdg_in = 2212
    
    call var_list_set_string (global%var_list, var_str ("$pdf_builtin_set"), &
         var_str ("CTEQ6M"), is_known = .true.)
    sf_method = "pdf_builtin"
    call dispatch_sf_data &
         (data, sf_method, [1], sf_prop, global, pdg_in, pdg_prc)
    call data%write (u)

    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(A)")
    write (u, "(1x,A,99(1x,I0))")  "PDG(out) = ", pdg1

    deallocate (data)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_7"
    
  end subroutine dispatch_7
  
@ %def dispatch_7
@
\subsubsection{Beam structure}
<<Dispatch: execute tests>>=
  call test (dispatch_8, "dispatch_8", &
       "beam structure", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_8 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(flavor_t), dimension(2) :: flv
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_prop_t) :: sf_prop
    type(sf_channel_t), dimension(:), allocatable :: sf_channel
    type(phs_channel_collection_t) :: coll
    type(string_t) :: sf_string
    integer :: i
    type(pdg_array_t), dimension (2,1) :: pdg_prc
    
    write (u, "(A)")  "* Test output: dispatch_8"
    write (u, "(A)")  "*   Purpose: configure a structure-function chain"
    write (u, "(A)")

    call global%global_init ()
    
    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%read_model (var_str ("QCD"), var_str ("QCD.mdl"))
    
    write (u, "(A)")  "* Allocate LHC beams with PDF builtin"
    write (u, "(A)")

    call flavor_init (flv(1), PROTON, global%model)
    call flavor_init (flv(2), PROTON, global%model)

    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         14000._default, is_known = .true.)
         
    call global%beam_structure%init_sf (flavor_get_name (flv), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("pdf_builtin"))
    
    call dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    do i = 1, size (sf_config)
       call sf_config(i)%write (u)
    end do

    call dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    write (u, "(1x,A)")  "Mapping configuration:"
    do i = 1, size (sf_channel)
       write (u, "(2x)", advance = "no")
       call sf_channel(i)%write (u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Allocate ILC beams with CIRCE1"
    write (u, "(A)")

    call global%read_model (var_str ("QED"), var_str ("QED.mdl"))
    call flavor_init (flv(1), ELECTRON, global%model)
    call flavor_init (flv(2),-ELECTRON, global%model)

    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         500._default, is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?circe1_generate"), &
         .false., is_known = .true.)
         
    call global%beam_structure%init_sf (flavor_get_name (flv), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("circe1"))
    
    call dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    do i = 1, size (sf_config)
       call sf_config(i)%write (u)
    end do

    call dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    write (u, "(1x,A)")  "Mapping configuration:"
    do i = 1, size (sf_channel)
       write (u, "(2x)", advance = "no")
       call sf_channel(i)%write (u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_8"
    
  end subroutine dispatch_8
  
@ %def dispatch_8
@
\subsubsection{Event I/O}
<<Dispatch: execute tests>>=
  call test (dispatch_9, "dispatch_9", &
       "event I/O", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_9 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(eio_t), allocatable :: eio
    
    write (u, "(A)")  "* Test output: dispatch_9"
    write (u, "(A)")  "*   Purpose: allocate an event I/O (eio) stream"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    
    write (u, "(A)")  "* Allocate as raw"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("raw"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as checkpoints:"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("checkpoint"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as LHEF:"
    write (u, "(A)")
    
    call var_list_set_string (global%var_list, var_str ("$lhef_extension"), &
         var_str ("lhe_custom"), is_known = .true.)
    call dispatch_eio (eio, var_str ("lhef"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as HepMC:"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("hepmc"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as weight_stream"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("weight_stream"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as debug format"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?debug_verbose"), &
         .false., is_known = .true.)
    call dispatch_eio (eio, var_str ("debug"), global)

    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_9"
    
  end subroutine dispatch_9
  
@ %def dispatch_9
@
\subsubsection{Update process core parameters}
This test dispatches a process core, temporarily modifies parameters,
then restores the original.
<<Dispatch: execute tests>>=
  call test (dispatch_10, "dispatch_10", &
       "process core update", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_10 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    class(prc_core_t), allocatable :: core, saved_core
    type(var_list_t), pointer :: var_list
    
    write (u, "(A)")  "* Test output: dispatch_10"
    write (u, "(A)")  "*   Purpose: select process configuration method,"
    write (u, "(A)")  "             allocate process core,"
    write (u, "(A)")  "             temporarily reset parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core as prc_omega_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)

    call global%read_model (var_str ("Test"), var_str ("Test.mdl"))

    call dispatch_core (core, core_def, global%model)
    call core_def%allocate_driver (core%driver, var_str (""))

    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Update core with modified model and helicity selection"
    write (u, "(A)")

    var_list => global%model%get_var_list_ptr ()
    call var_list_set_real (var_list, var_str ("gy"), 2._default, &
         is_known = .true.)
    call global%model%update_parameters ()

    call var_list_set_log (global%var_list, &
         var_str ("?helicity_selection_active"), &
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, &
         var_str ("helicity_selection_threshold"), &
         2e10_default, is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("helicity_selection_cutoff"), &
         5, is_known = .true.)
    
    call dispatch_core_update (core, global%model, &
         global%get_helicity_selection (), &
         saved_core = saved_core)
    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Restore core from save"
    write (u, "(A)")

    call dispatch_core_restore (core, saved_core)
    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_10"
    
  end subroutine dispatch_10
  
@ %def dispatch_10
@
\subsubsection{QCD Coupling}
This test dispatches an [[qcd]] object, which is used to compute the
(running) coupling by one of several possible methods.
<<Dispatch: execute tests>>=
  call test (dispatch_11, "dispatch_11", &
       "QCD coupling", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_11 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(qcd_t) :: qcd
    type(var_list_t), pointer :: model_vars
    
    write (u, "(A)")  "* Test output: dispatch_11"
    write (u, "(A)")  "*   Purpose: select QCD coupling formula"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%read_model (var_str ("SM"), var_str ("SM.mdl"))
    model_vars => global%model%get_var_list_ptr ()

    write (u, "(A)")  "* Allocate alpha_s as fixed"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .true., is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (built-in)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?alpha_s_from_mz"), &
         .true., is_known = .true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_order"), 1, is_known = .true.)
    call var_list_set_real &
         (model_vars, var_str ("alphas"), 0.1234_default, &
          is_known=.true.)
    call var_list_set_real &
         (model_vars, var_str ("mZ"), 91.234_default, &
          is_known=.true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (built-in, Lambda defined)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?alpha_s_from_mz"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?alpha_s_from_lambda_qcd"), &
         .true., is_known = .true.)
    call var_list_set_real &
         (global%var_list, var_str ("lambda_qcd"), 250.e-3_default, &
          is_known=.true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_order"), 2, is_known = .true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_nf"), 4, is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (using builtin PDF set)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, &
         var_str ("?alpha_s_from_lambda_qcd"), &
         .false., is_known = .true.)
    call var_list_set_log &
         (global%var_list, var_str ("?alpha_s_from_pdf_builtin"), &
         .true., is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_11"
    
  end subroutine dispatch_11
  
@ %def dispatch_11
@
\subsubsection{Shower settings}
This test dispatches an [[shower_settings]] object, which is used 
to steer the initial and final state.
<<Dispatch: execute tests>>=
  call test (dispatch_12, "dispatch_12", &
       "Shower settings", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_12 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(shower_settings_t) :: shower_settings
    
    write (u, "(A)")  "* Test output: dispatch_12"
    write (u, "(A)")  "*   Purpose: setting ISR/FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Default settings"    
    write (u, "(A)")    
    
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .true., is_known = .true.)
    call dispatch_shower (shower_settings, global)
    call write_separator (u)
    call shower_settings%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Switch on ISR/FSR showers, hadronization"
    write (u, "(A)")  "      and MLM matching"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?ps_fsr_active"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?ps_isr_active"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?hadronization_active"), &
         .true., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?mlm_matching"), &
         .true., is_known = .true.)        
    call var_list_set_int &
         (global%var_list, var_str ("ps_max_n_flavors"), 4, is_known = .true.)
    call var_list_set_real &
         (global%var_list, var_str ("ps_isr_z_cutoff"), 0.1234_default, &
          is_known=.true.)
    call var_list_set_real (global%var_list, &
         var_str ("mlm_etamax"), 3.456_default, is_known=.true.)
    call var_list_set_string (global%var_list, &
         var_str ("$ps_PYTHIA_PYGIVE"), var_str ("abcdefgh"), is_known=.true.)    
    call dispatch_shower (shower_settings, global)
    call write_separator (u)
    call shower_settings%write (u)
    call write_separator (u)
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_12"
    
  end subroutine dispatch_12
  
@ %def dispatch_12
@
\subsubsection{Event transforms}
This test dispatches an [[evt]] (event transform) object.  Currently,
the only nontrivial transform is the partonic decay chain..
<<Dispatch: execute tests>>=
  call test (dispatch_13, "dispatch_13", &
       "event transforms", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_13 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(evt_t), pointer :: evt
    
    write (u, "(A)")  "* Test output: dispatch_13"
    write (u, "(A)")  "*   Purpose: configure event transform"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    write (u, "(A)")  "* Partonic decays"
    write (u, "(A)")

    call dispatch_evt_decay (evt, global)
    select type (evt)
    type is (evt_decay_t)
       call evt%write (u, show_decay_tree = .true., verbose = .true.)
    end select

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* Shower"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?allow_shower"), .true., &
         is_known = .true.)
    call dispatch_evt_shower (evt, global)
    select type (evt)
    type is (evt_shower_t)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    call evt%final ()
    deallocate (evt)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_13"
    
  end subroutine dispatch_13
  
@ %def dispatch_13
@
\subsubsection{SLHA interface}
This rather trivial sets all input values for the SLHA interface
to [[false]].
<<Dispatch: execute tests>>=
  call test (dispatch_14, "dispatch_14", &
       "SLHA interface", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_14 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    logical :: input, spectrum, decays
    
    write (u, "(A)")  "* Test output: dispatch_14"
    write (u, "(A)")  "*   Purpose: SLHA interface settings"
    write (u, "(A)")

    write (u, "(A)")  "* Default settings"    
    write (u, "(A)")    
    
    call global%global_init ()
    call dispatch_slha (global, &
         input = input, spectrum = spectrum, decays = decays)

    write (u, "(A,1x,L1)")  " slha_read_input     =", input
    write (u, "(A,1x,L1)")  " slha_read_spectrum  =", spectrum   
    write (u, "(A,1x,L1)")  " slha_read_decays    =", decays

    call global%final ()
    call global%global_init ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Set all entries to [false]"    
    write (u, "(A)")        
            
    call var_list_set_log (global%var_list, var_str ("?slha_read_input"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?slha_read_spectrum"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?slha_read_decays"), &
         .false., is_known = .true.)    

    call dispatch_slha (global, &
         input = input, spectrum = spectrum, decays = decays)

    write (u, "(A,1x,L1)")  " slha_read_input     =", input
    write (u, "(A,1x,L1)")  " slha_read_spectrum  =", spectrum   
    write (u, "(A,1x,L1)")  " slha_read_decays    =", decays
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_14"
    
  end subroutine dispatch_14
  
@ %def dispatch_14
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process Configuration}
This module communicates between the toplevel command structure with
its runtime data set and the process-library handling modules which
collect the definition of individual processes.  Its primary purpose
is to select from the available matrix-element generating methods and
configure the entry in the process library accordingly.
<<[[process_configurations.f90]]>>=
<<File header>>

module process_configurations
  
<<Use strings>>
  use unit_tests
  use diagnostics

  use variables
  use models
  use prc_core_def
  use particle_specifiers
  use process_libraries
  use prclib_stacks
  use prc_test
  use prc_omega
  use rt_data
  use dispatch

  use prc_gosam
  
<<Standard module head>>

<<Process configurations: public>>

<<Process configurations: types>>

contains
  
<<Process configurations: procedures>>

<<Process configurations: tests>>

end module process_configurations
@ %def process_configurations
@
\subsection{Data Type}
<<Process configurations: public>>=
  public :: process_configuration_t
<<Process configurations: types>>=
  type :: process_configuration_t
     type(process_def_entry_t), pointer :: entry => null ()
     type(string_t) :: id
     integer :: num_id = 0
   contains
   <<Process configurations: process configuration: TBP>>
  end type process_configuration_t
  
@ %def process_configuration_t
@ Initialize a process.  We only need the name, the number of incoming
particles, and the number of components.
<<Process configurations: process configuration: TBP>>=
  procedure :: init => process_configuration_init
<<Process configurations: procedures>>=
  subroutine process_configuration_init &
       (config, prc_name, n_in, n_components, global)
    class(process_configuration_t), intent(out) :: config
    type(string_t), intent(in) :: prc_name
    integer, intent(in) :: n_in
    integer, intent(in) :: n_components 
    type(rt_data_t), intent(in) :: global
    type(model_t), pointer :: model
    model => global%model
    config%id = prc_name
    allocate (config%entry)
    if (var_list_is_known (global%var_list, var_str ("process_num_id"))) then
       config%num_id = &
            var_list_get_ival (global%var_list, var_str ("process_num_id"))
       call config%entry%init (prc_name, &
            model = model, n_in = n_in, n_components = n_components, &
            num_id = config%num_id, nlo_process = global%nlo_calculation)
    else
       call config%entry%init (prc_name, &
            model = model, n_in = n_in, n_components = n_components, &
            nlo_process = global%nlo_calculation)
    end if
  end subroutine process_configuration_init
    
@ %def process_configuration_init
@ Initialize a process component.  The details depend on the process method,
which determines the type of the process component core.  We set the incoming
and outgoing particles (as strings, to be interpreted by the process driver).
All other information is taken from the variable list.

The dispatcher gets only the names of the particles.  The process
component definition gets the complete specifiers which contains a
polarization flag and names of decay processes, where applicable.
<<Process configurations: process configuration: TBP>>=
  procedure :: setup_component => process_configuration_setup_component
<<Process configurations: procedures>>=
  subroutine process_configuration_setup_component &
       (config, i_component, prt_in, prt_out, global, &
        nlo_type, associated_born, active_in)
    class(process_configuration_t), intent(inout) :: config
    integer, intent(in) :: i_component
    type(prt_spec_t), dimension(:), intent(in) :: prt_in
    type(prt_spec_t), dimension(:), intent(in) :: prt_out
    type(rt_data_t), intent(inout) :: global
    type(string_t), intent(in), optional :: nlo_type
    integer, intent(in), optional :: associated_born
    logical, intent(in), optional :: active_in
    type(string_t), dimension(:), allocatable :: prt_str_in
    type(string_t), dimension(:), allocatable :: prt_str_out
    class(prc_core_def_t), allocatable :: core_def
    type(string_t) :: method
    integer :: i
    logical :: active

    allocate (prt_str_in  (size (prt_in)))
    allocate (prt_str_out (size (prt_out)))
    forall (i = 1:size (prt_in))  prt_str_in(i)  = prt_in(i)% get_name ()
    forall (i = 1:size (prt_out)) prt_str_out(i) = prt_out(i)%get_name ()
    if (present (active_in)) then
      active = active_in
    else
      active = .true.
    end if

    call dispatch_core_def (core_def, prt_str_in, prt_str_out, global, config%id)
    method = var_list_get_sval (global%var_list, var_str ("$method"))
    if (present (nlo_type) .and. present (associated_born)) then
      call config%entry%import_component (i_component, &
          n_out = size (prt_out), &
          prt_in = prt_in, &
          prt_out = prt_out, &
          method = method, &
          variant = core_def, &
          nlo_type = nlo_type, &
          i_born = associated_born, &
          active = active)
    else
      call config%entry%import_component (i_component, &
         n_out = size (prt_out), &
         prt_in = prt_in, &
         prt_out = prt_out, &
         method = method, &
         variant = core_def, &
         i_born = i_component, &
         active = active)
     end if
  end subroutine process_configuration_setup_component
  
@ %def process_configuration_setup_component
@ Record a process configuration: append it to the currently selected process
definition library.
<<Process configurations: process configuration: TBP>>=
  procedure :: record => process_configuration_record
<<Process configurations: procedures>>=
  subroutine process_configuration_record (config, global)
    class(process_configuration_t), intent(inout) :: config
    type(rt_data_t), intent(inout) :: global
    if (associated (global%prclib)) then
       call global%prclib%open ()
       call global%prclib%append (config%entry)
       if (config%num_id /= 0) then
          write (msg_buffer, "(5A,I0,A)") "Process library '", &
               char (global%prclib%get_name ()), &
               "': recorded process '", char (config%id), "' (", &
               config%num_id, ")"
       else
          write (msg_buffer, "(5A)") "Process library '", &
               char (global%prclib%get_name ()), &
               "': recorded process '", char (config%id), "'"          
       end if
       call msg_message ()
    else
       call msg_fatal ("Recording process '" // char (config%id) &
            // "': active process library undefined")
    end if
  end subroutine process_configuration_record
  
@ %def process_configuration_record
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Process configurations: public>>=
  public :: process_configurations_test
<<Process configurations: tests>>=
  subroutine process_configurations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Process configurations: execute tests>>
  end subroutine process_configurations_test

@ %def process_configurations_test
@
\subsubsection{Minimal setup}
The workflow for setting up a minimal process configuration with the
test matrix element method.

We wrap this in a public procedure, so we can reuse it in later modules.
The procedure prepares a process definition list for two processes
(one [[prc_test]] and one [[omega]] type) and appends this to the
process library stack in the global data set.

The [[mode]] argument determines which processes to build.

The [[procname]] argument replaces the predefined procname(s).
<<Process configurations: public>>=
  public :: prepare_test_library
<<Process configurations: tests>>=
  subroutine prepare_test_library (global, libname, mode, procname)
    type(rt_data_t), intent(inout), target :: global
    type(string_t), intent(in) :: libname
    integer, intent(in) :: mode
    type(string_t), intent(in), dimension(:), optional :: procname
   
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prc_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    integer :: n_components
    type(process_configuration_t) :: prc_config

    allocate (lib)
    call lib%init (libname)
    call global%add_prclib (lib)

    if (btest (mode, 0) .or. btest (mode, 2)) then
       call global%read_model (var_str ("Test"), var_str ("Test.mdl"))
    end if

    if (btest (mode, 1)) then
       call global%read_model (var_str ("QED"), var_str ("QED.mdl"))
    end if

    if (btest (mode, 0)) then

       call global%select_model (var_str ("Test"))

       if (present (procname)) then
          prc_name = procname(1)
       else
          prc_name = "prc_config_a"
       end if
       n_components = 1
       allocate (prt_in (2), prt_out (2))
       prt_in = [var_str ("s"), var_str ("s")]
       prt_out = [var_str ("s"), var_str ("s")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("unit_test"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if

    if (btest (mode, 1)) then

       call global%select_model (var_str ("QED"))

       if (present (procname)) then
          prc_name = procname(2)
       else
          prc_name = "prc_config_b"
       end if
       n_components = 1
       allocate (prt_in (2), prt_out (2))
       prt_in = [var_str ("e+"), var_str ("e-")]
       prt_out = [var_str ("m+"), var_str ("m-")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("omega"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if
    
    if (btest (mode, 2)) then

       call global%select_model (var_str ("Test"))

       if (present (procname)) then
          prc_name = procname(1)
       else
          prc_name = "prc_config_a"
       end if
       n_components = 1
       allocate (prt_in (1), prt_out (2))
       prt_in = [var_str ("s")]
       prt_out = [var_str ("f"), var_str ("fbar")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("unit_test"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if

  end subroutine prepare_test_library
    
@ %def prepare_test_library
@ The actual test: the previous procedure with some prelude and postlude.
In the global variable list, just before printing we reset the
variables where the value may depend on the system and run environment.
<<Process configurations: execute tests>>=
  call test (process_configurations_1, "process_configurations_1", &
       "test processes", &
       u, results)
<<Process configurations: tests>>=
  subroutine process_configurations_1 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: process_configurations_1"
    write (u, "(A)")  "*   Purpose: configure test processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    write (u, "(A)")  "* Configure processes as prc_test, model Test"
    write (u, "(A)")  "*                     and omega, model QED"
    write (u, *)

    call var_list_set_int (global%var_list, var_str ("process_num_id"), &
         42, is_known = .true.)
    call prepare_test_library (global, var_str ("prc_config_lib_1"), 3)

    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_configurations_1"
    
  end subroutine process_configurations_1
  
@ %def process_configurations_1
@
\subsubsection{\oMega\ options}
Slightly extended example where we pass \oMega\ options to the
library.  The [[prepare_test_library]] contents are spelled out.
<<Process configurations: execute tests>>=
  call test (process_configurations_2, "process_configurations_2", &
       "omega options", &
       u, results)
<<Process configurations: tests>>=
  subroutine process_configurations_2 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    
    type(string_t) :: libname
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prc_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    integer :: n_components
    type(process_configuration_t) :: prc_config

    write (u, "(A)")  "* Test output: process_configurations_2"
    write (u, "(A)")  "*   Purpose: configure test processes with options"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    
    write (u, "(A)")  "* Configure processes as omega, model QED"
    write (u, *)

    libname = "prc_config_lib_2"
    
    allocate (lib)
    call lib%init (libname)
    call global%add_prclib (lib)

    call global%read_model (var_str ("QED"), var_str ("QED.mdl"))

    prc_name = "prc_config_c"
    n_components = 2
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]

    call var_list_set_string (global%var_list, var_str ("$method"),&
         var_str ("omega"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    call prc_config%init (prc_name, size (prt_in), n_components, global)

    call var_list_set_log (global%var_list, var_str ("?report_progress"), &
         .true., is_known = .true.)
    call prc_config%setup_component (1, &
         new_prt_spec (prt_in), new_prt_spec (prt_out), global)

    call var_list_set_log (global%var_list, var_str ("?report_progress"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .true., is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$restrictions"),&
         var_str ("3+4~A"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$omega_flags"), &
         var_str ("-fusion:progress_file omega_prc_config.log"), &
         is_known = .true.)
    call prc_config%setup_component (2, &
         new_prt_spec (prt_in), new_prt_spec (prt_out), global)
    
    call prc_config%record (global)

    deallocate (prt_in, prt_out)
    
    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    call global%write_vars (u, [ &
         var_str ("$model_name"), &
         var_str ("$method"), &
         var_str ("?report_progress"), &
         var_str ("$restrictions"), &
         var_str ("$omega_flags")])
    write (u, "(A)")
    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_configurations_2"
    
  end subroutine process_configurations_2
  
@ %def process_configurations_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation}
This module manages compilation and loading of of process libraries.  It is
needed as a separate module because integration depends on it.
<<[[compilations.f90]]>>=
<<File header>>

module compilations

<<Use strings>>
  use io_units
  use unit_tests
  use system_defs, only: TAB
  use diagnostics
  use os_interface
  use md5
  use variables
  use models
  use process_libraries
  use prclib_stacks
  use rt_data
  use process_configurations

<<Standard module head>>

<<Compilations: public>>

<<Compilations: types>>

contains

<<Compilations: procedures>>

<<Compilations: tests>>

end module compilations
@ %def compilations
@
\subsection{The data type}
The compilation item handles the compilation and loading of a single
process library.
<<Compilations: types>>=
  type :: compilation_item_t
     type(string_t) :: libname
     type(process_library_t), pointer :: lib => null ()
     logical :: recompile_library = .false.
   contains
   <<Compilations: compilation item: TBP>>
  end type compilation_item_t

@ %def compilation_item_t
@ Initialize:
<<Compilations: compilation item: TBP>>=
  procedure :: init => compilation_item_init
<<Compilations: procedures>>=
  subroutine compilation_item_init (comp, libname, stack, var_list)
    class(compilation_item_t), intent(out) :: comp
    type(string_t), intent(in) :: libname
    type(prclib_stack_t), intent(inout) :: stack
    type(var_list_t), intent(in) :: var_list
    comp%libname = libname
    comp%lib => stack%get_library_ptr (comp%libname)
    if (.not. associated (comp%lib)) then
       call msg_fatal ("Process library '" // char (comp%libname) &
            // "' has not been declared.")
    end if
    comp%recompile_library = &
         var_list_get_lval (var_list, var_str ("?recompile_library"))
  end subroutine compilation_item_init

@ %def compilation_item_init
@ Compile the current library.  The [[force]] flag has the
effect that we first delete any previous files, as far as accessible
by the current makefile.  It also guarantees that previous files not
accessible by a makefile will be overwritten.
<<Compilations: compilation item: TBP>>=
  procedure :: compile => compilation_item_compile
<<Compilations: procedures>>=
  subroutine compilation_item_compile (comp, os_data, force, recompile)
    class(compilation_item_t), intent(inout) :: comp
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: force, recompile
    if (associated (comp%lib)) then
       call msg_message ("Process library '" &
            // char (comp%libname) // "': compiling ...")
       call comp%lib%configure (os_data)
       if (signal_is_pending ())  return
       call comp%lib%compute_md5sum ()
       call comp%lib%write_makefile (os_data, force)
       if (signal_is_pending ())  return
       if (force) then
          call comp%lib%clean (os_data, distclean = .false.)
          if (signal_is_pending ())  return
       end if
       call comp%lib%write_driver (force)
       if (signal_is_pending ())  return
       if (recompile) then
          call comp%lib%load (os_data, keep_old_source = .true.)
          if (signal_is_pending ())  return
       end if
       call comp%lib%update_status (os_data)
    end if
  end subroutine compilation_item_compile

@ %def compilation_item_compile
@ Load the current library, just after compiling it.
<<Compilations: compilation item: TBP>>=
  procedure :: load => compilation_item_load
<<Compilations: procedures>>=
  subroutine compilation_item_load (comp, os_data)
    class(compilation_item_t), intent(inout) :: comp
    type(os_data_t), intent(in) :: os_data
    if (associated (comp%lib)) then
       call comp%lib%load (os_data)
    end if
  end subroutine compilation_item_load

@ %def compilation_item_load
@ Message as a separate call:
<<Compilations: compilation item: TBP>>=
  procedure :: success => compilation_item_success
<<Compilations: procedures>>=
  subroutine compilation_item_success (comp)
    class(compilation_item_t), intent(in) :: comp
    if (associated (comp%lib)) then
       call msg_message ("Process library '" // char (comp%libname) &
            // "': ... success.")
    end if
  end subroutine compilation_item_success

@ %def compilation_item_success
@
\subsection{API for library compilation and loading}
This is a shorthand for compiling and loading a single library.  The
[[compilation_item]] object is used only internally.

The [[global]] data set may actually be local to the caller.  The
compilation affects the library specified by its name if it is on the
stack, but it does not reset the currently selected library.
<<Compilations: public>>=
  public :: compile_library
<<Compilations: procedures>>=
  subroutine compile_library (libname, global)
    type(string_t), intent(in) :: libname
    type(rt_data_t), intent(inout), target :: global
    type(compilation_item_t) :: comp
    logical :: force, recompile
    force = &
         var_list_get_lval (global%var_list, var_str ("?rebuild_library"))
    recompile = &
         var_list_get_lval (global%var_list, var_str ("?recompile_library"))
    call comp%init (libname, global%prclib_stack, global%var_list)
    call comp%compile (global%os_data, force, recompile)
    if (signal_is_pending ())  return
    call comp%load (global%os_data)
    if (signal_is_pending ())  return
    call comp%success ()
  end subroutine compile_library

@ %def compile_library
@
\subsection{Compiling static executable}
This object handles the creation of a static executable which should
contain a set of static process libraries.
<<Compilations: types>>=
  type :: compilation_t
     private
     type(string_t) :: exe_name
     type(string_t), dimension(:), allocatable :: lib_name
   contains
   <<Compilations: compilation: TBP>>
  end type compilation_t

@ %def compilation_t
@ Output.
<<Compilations: compilation: TBP>>=
  procedure :: write => compilation_write
<<Compilations: procedures>>=
  subroutine compilation_write (object, unit)
    class(compilation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Compilation object:"
    write (u, "(3x,3A)")  "executable        = '", &
         char (object%exe_name), "'"
    write (u, "(3x,A)", advance="no")  "process libraries ="
    do i = 1, size (object%lib_name)
       write (u, "(1x,3A)", advance="no")  "'", char (object%lib_name(i)), "'"
    end do
    write (u, *)
  end subroutine compilation_write
  
@ %def compilation_write
@ Initialize: we know the names of the executable and of the libraries.
<<Compilations: compilation: TBP>>=
  procedure :: init => compilation_init
<<Compilations: procedures>>=
  subroutine compilation_init (compilation, exe_name, lib_name)
    class(compilation_t), intent(out) :: compilation
    type(string_t), intent(in) :: exe_name
    type(string_t), dimension(:), intent(in) :: lib_name
    compilation%exe_name = exe_name
    allocate (compilation%lib_name (size (lib_name)))
    compilation%lib_name = lib_name
  end subroutine compilation_init
    
@ %def compilation_init
@ Write the dispatcher subroutine for the compiled libraries.  Also
write a subroutine which returns the names of the compiled libraries.
<<Compilations: compilation: TBP>>=
  procedure :: write_dispatcher => compilation_write_dispatcher
<<Compilations: procedures>>=
  subroutine compilation_write_dispatcher (compilation)
    class(compilation_t), intent(in) :: compilation
    type(string_t) :: file
    integer :: u, i
    file = compilation%exe_name // "_prclib_dispatcher.f90"
    call msg_message ("Static executable '" // char (compilation%exe_name) &
         // "': writing library dispatcher")
    u = free_unit ()
    open (u, file = char (file), status="replace", action="write")
    write (u, "(3A)")  "! Whizard: process libraries for executable '", &
         char (compilation%exe_name), "'"
    write (u, "(A)")  "! Automatically generated file, do not edit"
    write (u, "(A)")  "subroutine dispatch_prclib_static " // &
         "(driver, basename, modellibs_ldflags)"
    write (u, "(A)")  "  use iso_varying_string, string_t => varying_string"
    write (u, "(A)")  "  use prclib_interfaces"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A)")  "  use " // char (lib_name) // "_driver"
       end associate
    end do
    write (u, "(A)")  "  implicit none"
    write (u, "(A)")  "  class(prclib_driver_t), intent(inout), allocatable &
         &:: driver"
    write (u, "(A)")  "  type(string_t), intent(in) :: basename"
    write (u, "(A)")  "  logical, intent(in), optional :: " // &
         "modellibs_ldflags"
    write (u, "(A)")  "  select case (char (basename))"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(3A)")  "  case ('", char (lib_name), "')"
         write (u, "(3A)")  "     allocate (", char (lib_name), "_driver_t &
              &:: driver)"
       end associate
    end do
    write (u, "(A)")  "  end select"
    write (u, "(A)")  "end subroutine dispatch_prclib_static"
    write (u, *)
    write (u, "(A)")  "subroutine get_prclib_static (libname)"
    write (u, "(A)")  "  use iso_varying_string, string_t => varying_string"
    write (u, "(A)")  "  implicit none"
    write (u, "(A)")  "  type(string_t), dimension(:), intent(inout), &
         &allocatable :: libname"
    write (u, "(A,I0,A)")  "  allocate (libname (", &
         size (compilation%lib_name), "))"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A,I0,A,A,A)")  "  libname(", i, ") = '", &
              char (lib_name), "'"
       end associate
    end do
    write (u, "(A)")  "end subroutine get_prclib_static"
    close (u)
  end subroutine compilation_write_dispatcher
    
@ %def compilation_write_dispatcher
@ Write the Makefile subroutine for the compiled libraries.
<<Compilations: compilation: TBP>>=
  procedure :: write_makefile => compilation_write_makefile
<<Compilations: procedures>>=
  subroutine compilation_write_makefile (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: file
    integer :: u, i
    file = compilation%exe_name // ".makefile"
    call msg_message ("Static executable '" // char (compilation%exe_name) &
         // "': writing makefile")
    u = free_unit ()
    open (u, file = char (file), status="replace", action="write")
    write (u, "(3A)")  "# WHIZARD: Makefile for executable '", &
         char (compilation%exe_name), "'"
    write (u, "(A)")  "# Automatically generated file, do not edit"
    write (u, "(A)") ""
    write (u, "(A)") "# Executable name"
    write (u, "(A)") "EXE = " // char (compilation%exe_name)
    write (u, "(A)") ""
    write (u, "(A)") "# Compiler"
    write (u, "(A)") "FC = " // char (os_data%fc)
    write (u, "(A)") ""
    write (u, "(A)") "# Included libraries"
    write (u, "(A)") "FCINCL = " // char (os_data%whizard_includes)
    write (u, "(A)") ""
    write (u, "(A)") "# Compiler flags"
    write (u, "(A)") "FCFLAGS = " // char (os_data%fcflags)
    write (u, "(A)") "LDFLAGS = " // char (os_data%ldflags)
    write (u, "(A)") "LDFLAGS_STATIC = " // char (os_data%ldflags_static)   
    write (u, "(A)") "LDFLAGS_HEPMC = " // char (os_data%ldflags_hepmc)
    write (u, "(A)") "LDFLAGS_HOPPET = " // char (os_data%ldflags_hoppet)    
    write (u, "(A)") "LDWHIZARD = " // char (os_data%whizard_ldflags)
    write (u, "(A)") ""
    write (u, "(A)") "# Libtool"
    write (u, "(A)") "LIBTOOL = " // char (os_data%whizard_libtool)
    write (u, "(A)") "FCOMPILE = $(LIBTOOL) --tag=FC --mode=compile"
    write (u, "(A)") "LINK = $(LIBTOOL) --tag=FC --mode=link"
    write (u, "(A)") ""
    write (u, "(A)") "# Compile commands (default)"
    write (u, "(A)") "LTFCOMPILE = $(FCOMPILE) $(FC) -c $(FCINCL) $(FCFLAGS)"
    write (u, "(A)") ""
    write (u, "(A)") "# Default target"
    write (u, "(A)") "all: link"
    write (u, "(A)") ""
    write (u, "(A)") "# Libraries"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A)") "LIBRARIES += " // char (lib_name) // ".la"
         write (u, "(A)") char (lib_name) // ".la:"
         write (u, "(A)") TAB // "$(MAKE) -f " // char (lib_name) // ".makefile"
       end associate
    end do
    write (u, "(A)") ""
    write (u, "(A)") "# Library dispatcher"
    write (u, "(A)") "DISP = $(EXE)_prclib_dispatcher"
    write (u, "(A)") "$(DISP).lo: $(DISP).f90 $(LIBRARIES)"
    write (u, "(A)") TAB // "$(LTFCOMPILE) $<"
    write (u, "(A)") ""
    write (u, "(A)") "# Executable"
    write (u, "(A)") "$(EXE): $(DISP).lo $(LIBRARIES)"
    write (u, "(A)") TAB // "$(LINK) $(FC) -static-libtool-libs $(FCFLAGS) \"
    write (u, "(A)") TAB // "   $(LDWHIZARD) $(LDFLAGS) \" 
    write (u, "(A)") TAB // "   -o $(EXE) $^ \"
    write (u, "(A)") TAB // "   $(LDFLAGS_HEPMC) $(LDFLAGS_HOPPET) \"
    write (u, "(A)") TAB // "   $(LDFLAGS_STATIC)" 
    write (u, "(A)") ""
    write (u, "(A)") "# Main targets"
    write (u, "(A)") "link: compile $(EXE)"
    write (u, "(A)") "compile: $(LIBRARIES) $(DISP).lo"
    write (u, "(A)") ".PHONY: link compile"
    write (u, "(A)") ""
    write (u, "(A)") "# Cleanup targets"
    write (u, "(A)") "clean-exe:"
    write (u, "(A)") TAB // "rm -f $(EXE)"
    write (u, "(A)") "clean-objects:"
    write (u, "(A)") TAB // "rm -f $(DISP).lo"
    write (u, "(A)") "clean-source:"
    write (u, "(A)") TAB // "rm -f $(DISP).f90"
    write (u, "(A)") "clean-makefile:"
    write (u, "(A)") TAB // "rm -f $(EXE).makefile"
    write (u, "(A)") ""
    write (u, "(A)") "clean: clean-exe clean-objects clean-source"
    write (u, "(A)") "distclean: clean clean-makefile"
    write (u, "(A)") ".PHONY: clean distclean"
    close (u)
  end subroutine compilation_write_makefile
    
@ %def compilation_write_makefile
@ Compile the dispatcher source code.
<<Compilations: compilation: TBP>>=
  procedure :: make_compile => compilation_make_compile
<<Compilations: procedures>>=
  subroutine compilation_make_compile (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make compile " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_compile
  
@ %def compilation_make_compile
@ Link the dispatcher together with all matrix-element code and the
\whizard\ and \oMega\ main libraries, to generate a static executable.
<<Compilations: compilation: TBP>>=
  procedure :: make_link => compilation_make_link
<<Compilations: procedures>>=
  subroutine compilation_make_link (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make link " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_link
  
@ %def compilation_make_link
@ Cleanup.
<<Compilations: compilation: TBP>>=
  procedure :: make_clean_exe => compilation_make_clean_exe
<<Compilations: procedures>>=
  subroutine compilation_make_clean_exe (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make clean-exe " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_clean_exe
  
@ %def compilation_make_clean_exe
@
\subsection{API for executable compilation}
This is a shorthand for compiling and loading an executable, including
the enclosed libraries.  The [[compilation]] object is used only internally.

The [[global]] data set may actually be local to the caller.  The
compilation affects the library specified by its name if it is on the
stack, but it does not reset the currently selected library.
<<Compilations: public>>=
  public :: compile_executable
<<Compilations: procedures>>=
  subroutine compile_executable (exename, libname, global)
    type(string_t), intent(in) :: exename
    type(string_t), dimension(:), intent(in) :: libname
    type(rt_data_t), intent(inout), target :: global
    type(compilation_t) :: compilation
    type(compilation_item_t) :: item
    logical :: force, recompile
    integer :: i
    force = &
         var_list_get_lval (global%var_list, var_str ("?rebuild_library"))
    recompile = &
         var_list_get_lval (global%var_list, var_str ("?recompile_library"))
    call compilation%init (exename, [libname])
    if (signal_is_pending ())  return
    call compilation%write_dispatcher ()
    if (signal_is_pending ())  return
    call compilation%write_makefile (global%os_data)
    if (signal_is_pending ())  return
    do i = 1, size (libname)
       call item%init (libname(i), global%prclib_stack, global%var_list)
       call item%compile (global%os_data, force=force, recompile=recompile)
       if (signal_is_pending ())  return
       call item%success ()
    end do
    call compilation%make_compile (global%os_data)
    if (signal_is_pending ())  return
    call compilation%make_link (global%os_data)
  end subroutine compile_executable

@ %def compile_executable
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Compilations: public>>=
  public :: compilations_test
<<Compilations: tests>>=
  subroutine compilations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Compilations: execute tests>>
end subroutine compilations_test

@ %def compilations_test
@
\subsubsection{Intrinsic Matrix Element}
Compile an intrinsic test matrix element ([[prc_test]] type).

Note: In this and the following test, we reset the Fortran compiler and flag
variables immediately before they are printed, so the test is portable.
<<Compilations: execute tests>>=
  call test (compilations_1, "compilations_1", &
       "intrinsic test processes", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: compilations_1"
    write (u, "(A)")  "*   Purpose: configure and compile test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "compilation_1"
    procname = "prc_comp_1"
    call prepare_test_library (global, libname, 1, [procname])

    call compile_library (libname, global)
    
    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_1"
    
  end subroutine compilations_1
  
@ %def compilations_1
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type)
<<Compilations: execute tests>>=
  call test (compilations_2, "compilations_2", &
       "external process (omega)", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: compilations_2"
    write (u, "(A)")  "*   Purpose: configure and compile test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilation_2"
    procname = "prc_comp_2"
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compile_library (libname, global)
    
    call global%write_libraries (u, libpath = .false.)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_2"
    
  end subroutine compilations_2
  
@ %def compilations_2
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
create driver files for a static executable.
<<Compilations: execute tests>>=
  call test (compilations_3, "compilations_3", &
       "static executable: driver", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_t) :: compilation
    integer :: u_file
    character(80) :: buffer

    write (u, "(A)")  "* Test output: compilations_3"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_3_lib"
    procname = "prc_comp_3"
    exename = "compilations_3"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compilation%init (exename, [libname])
    call compilation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write dispatcher"
    write (u, "(A)")

    call compilation%write_dispatcher ()

    u_file = free_unit ()
    open (u_file, file = char (exename) // "_prclib_dispatcher.f90", &
         status = "old", action = "read")
    do
       read (u_file, "(A)", end = 1)  buffer
       write (u, "(A)")  trim (buffer)
    end do
1   close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Write Makefile"
    write (u, "(A)")

    associate (os_data => global%os_data)
      os_data%fc = "fortran-compiler"
      os_data%whizard_includes = "my-includes"
      os_data%fcflags = "my-fcflags"
      os_data%ldflags = "my-ldflags"
      os_data%ldflags_static = "my-ldflags-static"
      os_data%ldflags_hepmc = "my-ldflags-hepmc"
      os_data%ldflags_hoppet = "my-ldflags-hoppet"      
      os_data%whizard_ldflags = "my-ldwhizard"
      os_data%whizard_libtool = "my-libtool"
    end associate

    call compilation%write_makefile (global%os_data)

    open (u_file, file = char (exename) // ".makefile", &
         status = "old", action = "read")
    do
       read (u_file, "(A)", end = 2)  buffer
       write (u, "(A)")  trim (buffer)
    end do
2   close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_3"
    
  end subroutine compilations_3
  
@ %def compilations_3
@
\subsection{Test static build}
The tests for building a static executable are separate, since they
should be skipped if the \whizard\ build itself has static libraries
disabled.
<<Compilations: public>>=
  public :: compilations_static_test
<<Compilations: tests>>=
  subroutine compilations_static_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Compilations: static tests>>
end subroutine compilations_static_test

@ %def compilations_static_test
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
incorporate this in a new static WHIZARD executable.
<<Compilations: static tests>>=
  call test (compilations_static_1, "compilations_static_1", &
       "static executable: compilation", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_static_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_item_t) :: item
    type(compilation_t) :: compilation
    logical :: exist

    write (u, "(A)")  "* Test output: compilations_static_1"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library"

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_static_1_lib"
    procname = "prc_comp_stat_1"
    exename = "compilations_static_1"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compilation%init (exename, [libname])

    write (u, "(A)")
    write (u, "(A)")  "* Write dispatcher"

    call compilation%write_dispatcher ()

    write (u, "(A)")
    write (u, "(A)")  "* Write Makefile"

    call compilation%write_makefile (global%os_data)

    write (u, "(A)")
    write (u, "(A)")  "* Build libraries"

    call item%init (libname, global%prclib_stack, global%var_list)
    call item%compile (global%os_data, force=.true., recompile=.false.)
    call item%success ()

    write (u, "(A)")
    write (u, "(A)")  "* Check executable (should be absent)"
    write (u, "(A)")
    
    call compilation%make_clean_exe (global%os_data)
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Build executable"
    write (u, "(A)")

    call compilation%make_compile (global%os_data)
    call compilation%make_link (global%os_data)

    write (u, "(A)")  "* Check executable (should be present)"
    write (u, "(A)")
    
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call compilation%make_clean_exe (global%os_data)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_static_1"
    
  end subroutine compilations_static_1
  
@ %def compilations_static_1
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
incorporate this in a new static WHIZARD executable.  In this version,
we use the wrapper [[compile_executable]] procedure.
<<Compilations: static tests>>=
  call test (compilations_static_2, "compilations_static_2", &
       "static executable: shortcut", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_static_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_item_t) :: item
    type(compilation_t) :: compilation
    logical :: exist
    integer :: u_file

    write (u, "(A)")  "* Test output: compilations_static_2"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library and compile"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_static_2_lib"
    procname = "prc_comp_stat_2"
    exename = "compilations_static_2"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compile_executable (exename, [libname], global)

    write (u, "(A)")  "* Check executable (should be present)"
    write (u, "(A)")
    
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    u_file = free_unit ()
    open (u_file, file = char (exename), status = "old", action = "write")
    close (u_file, status = "delete")

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_static_2"
    
  end subroutine compilations_static_2
  
@ %def compilations_static_2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integration}
This module manages phase space setup, matrix-element evaluation and
integration, as far as it is not done by lower-level routines, in particular
in the [[processes]] module.
<<[[integrations.f90]]>>=
<<File header>>

module integrations

<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use os_interface
  use cputime
  use sm_qcd
  use ifiles
  use lexers
  use parser
  use flavors
  use pdg_arrays
  use variables
  use expr_base
  use eval_trees
  use models
  use interactions
  use sf_mappings
  use sf_base
  use phs_base
  use mappings
  use phs_forests
  use phs_wood
  use rng_base
  use mci_base
  use process_libraries
  use prc_core
  use processes
  use process_stacks
  use iterations
  use rt_data
  use dispatch
  use process_configurations
  use compilations

  use process_constants
  use prc_omega
  use prc_gosam
  use fks_calculation

<<Standard module head>>

<<Integrations: public>>

<<Integrations: types>>

contains

<<Integrations: procedures>>

<<Integrations: tests>>

end module integrations
@ %def integrations
@
\subsection{The integration type}
This type holds all relevant data, the integration methods operates on this.
In contrast to the [[simulation_t]] introduced later, the [[integration_t]]
applies to a single process.
<<Integrations: public>>=
  public :: integration_t
<<Integrations: types>>=
  type :: integration_t
    private
    type(string_t) :: process_id
    type(string_t) :: run_id
    type(process_t), pointer :: process => null ()
    logical :: rebuild_phs = .false.
    logical :: ignore_phs_mismatch = .false.
    logical :: phs_only = .false.
    logical :: process_has_me = .true.
    integer :: n_calls_test = 0
    logical :: vis_history = .true.
    type(string_t) :: history_filename
    type(string_t) :: log_filename
   contains
   <<Integrations: integration: TBP>> 
  end type integration_t

@ %def integration_t
@
\subsection{Initialization}
Initialization, first part: Create and initialize a process entry and
push it on the stack.  Only the basic process data (ID, run ID, etc.)
are configured, we postpone the rest.

The local environment contributes parameters, but the new process
entry is pushed onto the global process stack.
<<Integrations: integration: TBP>>=
  procedure :: create_process => integration_create_process
<<Integrations: procedures>>=
  subroutine integration_create_process (intg, process_id, global, local)
    class(integration_t), intent(out) :: intg
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target :: local
    type(string_t), intent(in) :: process_id
    type(var_list_t), pointer :: var_list
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(process_entry_t), pointer :: process_entry

    var_list => global%var_list
    intg%process_id = process_id
    intg%run_id = var_list_get_sval (var_list, var_str ("$run_id"))

    call dispatch_qcd (qcd, local)    
    call dispatch_rng_factory (rng_factory, global, local)

    allocate (process_entry)
    call process_entry%init (intg%process_id, intg%run_id, global%prclib, &
         global%os_data, qcd, rng_factory, global%model_list)
    call global%process_stack%push (process_entry)

  end subroutine integration_create_process

@ %def integration_create_process
@ Complete process configuration.   This procedure does not modify the
[[local]] stack directly.  The intent(inout) attribute for the
[[local]] data set is due to the random generator seed which may be
incremented during initialization.

If the [[process]] argument is given, use it.  Otherwise, take the process
object from the stack.
<<Integrations: integration: TBP>>=
  procedure :: setup_process => integration_setup_process
<<Integrations: procedures>>=
  subroutine integration_setup_process (intg, local, process, verbose)
    class(integration_t), intent(inout) :: intg
    type(rt_data_t), intent(inout), target :: local
    type(process_t), intent(in), target, optional :: process
    logical, intent(in), optional :: verbose
    
    class(prc_core_t), allocatable :: core_template
    class(phs_config_t), allocatable :: phs_config_template
    class(phs_config_t), allocatable :: phs_config_template_real
    type(phs_parameters_t) :: phs_par
    type(mapping_defaults_t) :: mapping_defs
    class(mci_t), allocatable :: mci_template
    type(qcd_t) :: qcd
    integer :: n_components, n_in, i_component
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_prc
    type(process_component_def_t), pointer :: config
    type(helicity_selection_t), allocatable :: helicity_selection
    real(default) :: sqrts
    logical :: decay_rest_frame, use_color_factors
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_prop_t) :: sf_prop
    type(sf_channel_t), dimension(:), allocatable :: sf_channel
    type(phs_channel_collection_t) :: phs_channel_collection
    logical :: sf_trace
    type(string_t) :: sf_string, sf_trace_file
    logical :: verb
    type(process_constants_t) :: prc_const
    integer :: i_born
    type(fks_template_t) :: fks_template
    type(gosam_writer_template_t) :: gosam_template
    type(eval_tree_factory_t) :: expr_factory
  
    verb = .true.; if (present (verbose))  verb = verbose
    
    if (present (process)) then
       intg%process => process
       intg%process_id = process%get_id ()
       intg%run_id = process%get_run_id ()
    else
       intg%process => local%process_stack%get_process_ptr (intg%process_id)
    end if

    call intg%process%set_var_list (local%var_list)

    intg%rebuild_phs = &
         var_list_get_lval (local%var_list, var_str ("?rebuild_phase_space"))
    intg%ignore_phs_mismatch = &
         .not. var_list_get_lval (local%var_list, var_str ("?check_phs_file"))
    intg%phs_only = var_list_get_lval &
         (local%var_list, var_str ("?phs_only"))
    phs_par%m_threshold_s = var_list_get_rval &
         (local%var_list, var_str ("phs_threshold_s"))
    phs_par%m_threshold_t = var_list_get_rval &
         (local%var_list, var_str ("phs_threshold_t"))
    phs_par%off_shell = var_list_get_ival &
         (local%var_list, var_str ("phs_off_shell"))
    phs_par%keep_nonresonant = var_list_get_lval &
         (local%var_list, var_str ("?phs_keep_nonresonant"))
    phs_par%t_channel = var_list_get_ival &
         (local%var_list, var_str ("phs_t_channel"))
    mapping_defs%energy_scale = var_list_get_rval &
         (local%var_list, var_str ("phs_e_scale"))
    mapping_defs%invariant_mass_scale = var_list_get_rval &
         (local%var_list, var_str ("phs_m_scale"))
    mapping_defs%momentum_transfer_scale = var_list_get_rval &
         (local%var_list, var_str ("phs_q_scale"))
    mapping_defs%step_mapping = var_list_get_lval &
         (local%var_list, var_str ("?phs_step_mapping"))
    mapping_defs%step_mapping_exp = var_list_get_lval &
         (local%var_list, var_str ("?phs_step_mapping_exp"))
    mapping_defs%enable_s_mapping = var_list_get_lval &
         (local%var_list, var_str ("?phs_s_mapping"))

    call dispatch_phs (phs_config_template, local, &
         intg%process_id, mapping_defs, phs_par)
    
    
    intg%n_calls_test = &
         var_list_get_ival (local%var_list, var_str ("n_calls_test"))

    !!! We avoid two dots in the filename due to a bug in certain MetaPost versions.
    if (intg%run_id /= "") then
       intg%history_filename = intg%process_id // "." // intg%run_id &
            // "-history"
       intg%log_filename = intg%process_id // "." // intg%run_id // ".log"
    else
       intg%history_filename = intg%process_id // "-history"
       intg%log_filename = intg%process_id // ".log"
    end if

    call dispatch_mci (mci_template, local, intg%process_id)

    if (verb) then
       call msg_message ("Initializing integration for process " &
            // char (intg%process_id) // ":")
       if (intg%run_id /= "") then
          call msg_message ("Run ID = " // '"' // char (intg%run_id) // '"')
       end if
    end if
    
    helicity_selection = local%get_helicity_selection ()

    intg%vis_history = &
         var_list_get_lval (local%var_list, var_str ("?vis_history"))
    use_color_factors = var_list_get_lval &
         (local%var_list, var_str ("?read_color_factors"))
    
    call dispatch_qcd (qcd, local)    

    n_components = intg%process%get_n_components ()
    n_in = intg%process%get_n_in ()
    
    do i_component = 1, n_components
       config => intg%process%get_component_def_ptr (i_component)
       call dispatch_core (core_template, config%get_core_def_ptr (), &
            intg%process%get_model_ptr (), helicity_selection, qcd, &
            use_color_factors)
       select case (char (config%get_nlo_type ()))
       case ('Virtual')
         gosam_template%compute_loops = var_list_get_lval (local%var_list, &
                                     var_str ('?use_gosam_loops'))
         gosam_template%compute_correlations = var_list_get_lval (local%var_list, &
                                     var_str ('?use_gosam_correlations'))
         gosam_template%data = prc_const
         gosam_template%alpha_power = var_list_get_ival (local%var_list, &
                                      var_str ('alpha_power'))
         gosam_template%alphas_power = var_list_get_ival (local%var_list, &
                                       var_str ('alphas_power'))
         gosam_template%new = .true.
         call intg%process%init_component &
            (i_component, core_template, mci_template, phs_config_template, &
             gosam_template = gosam_template)
       case ('Real')
         call dispatch_phs (phs_config_template_real, local, &
             intg%process_id, mapping_defs, phs_par, &
             var_str ('fks'))
         call dispatch_fks (fks_template, local)
         call intg%process%init_component &
            (i_component, core_template, mci_template, &
             phs_config_template_real, fks_template = fks_template)
       case ('Born')
         call intg%process%init_component &
            (i_component, core_template, mci_template, phs_config_template)
         i_born = config%get_associated_born ()
         prc_const = intg%process%get_constants (i_born)
       case ('Subtraction')
         gosam_template%new = .false.
         call intg%process%init_component &
             (i_component, core_template, mci_template, phs_config_template, &
              gosam_template = gosam_template)
       case default
         call msg_fatal ("setup_process: NLO type not implemented!")
       end select
       deallocate (core_template)
    end do

    call intg%process%write (screen = .true.)
    
    intg%process_has_me = intg%process%has_matrix_element ()
    if (.not. intg%process_has_me) then
       call msg_warning ("Process '" &
            // char (intg%process_id) // "': matrix element vanishes")
    end if
    
    sqrts = local%get_sqrts ()
    decay_rest_frame = &
         var_list_get_lval (local%var_list, var_str ("?decay_rest_frame"))    
    if (intg%process_has_me) then
       if (local%beam_structure%is_set ()) then
          call intg%process%setup_beams_beam_structure &
               (local%beam_structure, sqrts, local%model, decay_rest_frame)
        else if (n_in == 2) then
          call intg%process%setup_beams_sqrts &
               (sqrts, local%beam_structure)
       else 
          call intg%process%setup_beams_decay &
               (decay_rest_frame, local%beam_structure)
       end if
    end if
    call intg%process%check_masses ()
    if (intg%process_has_me)  call intg%process%beams_startup_message &
         (beam_structure = local%beam_structure)

    if (intg%process_has_me) then
       call intg%process%get_pdg_in (pdg_prc)
    else
       allocate (pdg_prc (n_in, n_components))
       pdg_prc = 0
    end if
    call dispatch_sf_config (sf_config, sf_prop, local, pdg_prc)
    sf_trace = &
         var_list_get_lval (local%var_list, var_str ("?sf_trace"))
    sf_trace_file = &
         var_list_get_sval (local%var_list, var_str ("$sf_trace_file"))
    if (sf_trace) then
       call intg%process%init_sf_chain (sf_config, sf_trace_file)
    else
       call intg%process%init_sf_chain (sf_config)
    end if

    if (intg%process_has_me) then
       call intg%process%configure_phs (intg%rebuild_phs, intg%ignore_phs_mismatch)
       if (size (sf_config) > 0) then
          call intg%process%collect_channels (phs_channel_collection)
       else if (intg%process%contains_trivial_component ()) then
          call msg_fatal ("Integrate: 2 -> 1 process can't be handled &
               &with fixed-energy beams")
       end if
       call dispatch_sf_channels &
            (sf_channel, sf_string, sf_prop, phs_channel_collection, local)
       if (allocated (sf_channel)) then
          if (size (sf_channel) > 0) then
             call intg%process%set_sf_channel (sf_channel)
          end if
       end if
       call phs_channel_collection%final ()
       call intg%process%sf_startup_message (sf_string)    
    end if
    
    call intg%process%setup_mci ()
    call intg%process%setup_terms ()

    if (associated (local%pn%cuts_lexpr)) then
       if (verb)  call msg_message ("Applying user-defined cuts.")
       call expr_factory%init (local%pn%cuts_lexpr)
       call intg%process%set_cuts (expr_factory)
    else
       if (verb)  call msg_warning ("No cuts have been defined.")
    end if    
    if (associated (local%pn%scale_expr) .and. verb) then
       call msg_message ("Using user-defined general scale.")
       call expr_factory%init (local%pn%scale_expr)
       call intg%process%set_scale (expr_factory)
    end if
    if (associated (local%pn%fac_scale_expr) .and. verb) then
       call msg_message ("Using user-defined factorization scale.")
       call expr_factory%init (local%pn%fac_scale_expr)
       call intg%process%set_fac_scale (expr_factory)
    end if
    if (associated (local%pn%ren_scale_expr) .and. verb) then
       call msg_message ("Using user-defined renormalization scale.")
       call expr_factory%init (local%pn%ren_scale_expr)
       call intg%process%set_ren_scale (expr_factory)
    end if
    if (associated (local%pn%weight_expr) .and. verb) then
       call msg_message ("Using user-defined reweighting factor.")
       call expr_factory%init (local%pn%weight_expr)
       call intg%process%set_weight (expr_factory)
    end if

    call intg%process%compute_md5sum ()
  end subroutine integration_setup_process

@ %def integration_setup_process
@
\subsection{Integration}
Integrate: do the final integration.  Here, we do a multi-iteration
integration.  Again, we skip iterations that are already on file.
Record the results in the global variable list.
<<Integrations: integration: TBP>>=
  procedure :: evaluate => integration_evaluate
<<Integrations: procedures>>=
  subroutine integration_evaluate &
       (intg, process_instance, i_mci, pass, it_list, pacify)
    class(integration_t), intent(inout) :: intg
    type(process_instance_t), intent(inout), target :: process_instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: pass
    type(iterations_list_t), intent(in) :: it_list
    logical, intent(in), optional :: pacify
    integer :: n_calls, n_it
    logical :: adapt_grids, adapt_weights, final
        
    n_it = it_list%get_n_it (pass)
    n_calls = it_list%get_n_calls (pass)
    adapt_grids = it_list%adapt_grids (pass)
    adapt_weights = it_list%adapt_weights (pass)
    final = pass == it_list%get_n_pass ()
    
    call intg%process%integrate (process_instance, &
         i_mci, n_it, n_calls, adapt_grids, adapt_weights, &
         final, pacify)

  end subroutine integration_evaluate

@ %def integration_evaluate
@ In case the user has not provided a list of iterations, make a
reasonable default.  This can depend on the process.  The usual
approach is to define two distinct passes, one for adaptation and one
for integration.
<<Integrations: integration: TBP>>=
  procedure :: make_iterations_list => integration_make_iterations_list
<<Integrations: procedures>>=
  subroutine integration_make_iterations_list (intg, it_list)
    class(integration_t), intent(in) :: intg
    type(iterations_list_t), intent(out) :: it_list
    integer :: pass, n_pass
    integer, dimension(:), allocatable :: n_it, n_calls
    logical, dimension(:), allocatable :: adapt_grids, adapt_weights
    n_pass = intg%process%get_n_pass_default ()
    allocate (n_it (n_pass), n_calls (n_pass))
    allocate (adapt_grids (n_pass), adapt_weights (n_pass))
    do pass = 1, n_pass
       n_it(pass)          = intg%process%get_n_it_default (pass)
       n_calls(pass)       = intg%process%get_n_calls_default (pass)
       adapt_grids(pass)   = intg%process%adapt_grids_default (pass)
       adapt_weights(pass) = intg%process%adapt_weights_default (pass)
    end do
    call it_list%init (n_it, n_calls, &
         adapt_grids = adapt_grids, adapt_weights = adapt_weights)
  end subroutine integration_make_iterations_list
  
@ %def integration_make_iterations_list
@
\subsection{API for integration objects}
This initializer does everything except assigning cuts/scale/weight
expressions.  If [[ok]] is false, initialization failed, and the integration
should be skipped.

If [[me_only]] is set, prepare just matrix-element evaluation:  no phase
space, no iterations.

<<Integrations: integration: TBP>>=
  procedure :: init => integration_init
<<Integrations: procedures>>=
  subroutine integration_init (intg, process_id, global, local)
    class(integration_t), intent(out) :: intg
    type(string_t), intent(in) :: process_id
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(inout), target :: local
    
    call intg%create_process (process_id, global, local)
    call intg%setup_process (local)
  end subroutine integration_init

@ %def integration_init
@ Do the integration for a single process, both warmup and final evaluation.
The [[eff_reset]] flag is to suppress numerical noise in the graphical output
of the integration history.
<<Integrations: integration: TBP>>=
  procedure :: integrate => integration_integrate
<<Integrations: procedures>>=
  subroutine integration_integrate (intg, local, eff_reset)
    class(integration_t), intent(inout) :: intg
    type(rt_data_t), intent(in), target :: local
    logical, intent(in), optional :: eff_reset
    type(string_t) :: log_filename
    type(process_instance_t), allocatable, target :: process_instance
    type(iterations_list_t) :: it_list
    logical :: pacify
    integer :: pass, i_mci, n_mci, n_pass
    class(prc_core_t), allocatable :: core_born
    type(string_t) :: nlo_type
    integer :: i_born, i_sub
    logical :: display_summed
    logical :: use_internal_color_correlations

    allocate (process_instance)
    call process_instance%init (intg%process)

    call openmp_set_num_threads_verbose &
         (var_list_get_ival (local%var_list, "openmp_num_threads"), &
          var_list_get_lval (local%var_list, "?openmp_logging"))    
    pacify = var_list_get_lval (local%var_list, var_str ("?pacify"))

    display_summed = .true.
    n_mci = intg%process%get_n_mci ()
    if (n_mci == 1) then
       write (msg_buffer, "(A,A,A)") &
            "Starting integration for process '", &
            char (intg%process%get_id ()), "'"
       call msg_message ()
    end if
    do i_mci = 1, n_mci
       nlo_type = intg%process%get_component_nlo_type (i_mci)
       if (intg%process%is_active_nlo_component (i_mci)) then
         i_born = intg%process%get_component_associated_born (i_mci)
         i_sub = i_born + 3
         select case (char (nlo_type))
         case ('Real', 'Virtual')
           call intg%process%extract_component_core (i_sub, core_born)
           call intg%process%init_sub_born (i_mci, core_born)
           call intg%process%restore_component_core (i_sub, core_born)
           call process_instance%init_born_amps (i_mci, i_born)
         end select
         if (n_mci > 1) then
            write (msg_buffer, "(A,A,A,I0)") &
                 "Starting integration for process '", &
                 char (intg%process%get_id ()), "' part ", i_mci
            call msg_message ()
         end if
         n_pass = local%it_list%get_n_pass ()
         if (n_pass == 0) then
            call msg_message ("Integrate: iterations not specified, &
                 &using default")
            call intg%make_iterations_list (it_list)
            n_pass = it_list%get_n_pass ()
         else
            it_list = local%it_list
         end if
         call msg_message ("Integrate: " // char (it_list%to_string ()))
         do pass = 1, n_pass
            call intg%evaluate (process_instance, i_mci, pass, it_list, pacify)
            if (signal_is_pending ())  return
         end do
         call intg%process%final_integration (i_mci)       
         if (intg%vis_history) then
            call intg%process%display_integration_history &
                 (i_mci, intg%history_filename, local%os_data, eff_reset)
         end if       
         if (local%logfile == intg%log_filename) then
            if (intg%run_id /= "") then
               log_filename = intg%process_id // "." // intg%run_id // &
                    ".var.log"
            else
               log_filename = intg%process_id // ".var.log"
            end if
            call msg_message ("Name clash for global logfile and process log: ", &
                 arr =[var_str ("| Renaming log file from ") // local%logfile, &
                       var_str ("|   to ") // log_filename // var_str (" .")])
         else
            log_filename = intg%log_filename
         end if
         call intg%process%write_logfile (i_mci, log_filename)    
       else
         if (nlo_type /= "Subtraction") display_summed = .false.
       end if          
    end do

    if (n_mci > 1 .and. display_summed) then
       call msg_message ("Integrate: sum of all components")
       call intg%process%display_summed_results ()
    end if

    call process_instance%final ()
    deallocate (process_instance)

  end subroutine integration_integrate
  
@ %def integration_integrate
@ Do a dummy integration for a process which could not be initialized (e.g.,
has no matrix element).  The result is zero.
<<Integrations: integration: TBP>>=
  procedure :: integrate_dummy => integration_integrate_dummy 
<<Integrations: procedures>>=
  subroutine integration_integrate_dummy (intg)
    class(integration_t), intent(inout) :: intg
    call intg%process%integrate_dummy ()
  end subroutine integration_integrate_dummy
     
@ %def integration_integrate_dummy
@ Just sample the matrix element under realistic conditions (but no
cuts); throw away the results.
<<Integrations: integration: TBP>>=
  procedure :: sampler_test => integration_sampler_test
<<Integrations: procedures>>=
  subroutine integration_sampler_test (intg)
    class(integration_t), intent(inout) :: intg
    type(process_instance_t), allocatable, target :: process_instance
    integer :: n_mci, i_mci
    type(timer_t) :: timer_mci, timer_tot
    real(default) :: t_mci, t_tot
    allocate (process_instance)
    call process_instance%init (intg%process)
    n_mci = intg%process%get_n_mci ()
    if (n_mci == 1) then
       write (msg_buffer, "(A,A,A)") &
            "Test: probing process '", &
            char (intg%process%get_id ()), "'"
       call msg_message ()
    end if
    call timer_tot%start ()
    do i_mci = 1, n_mci
       if (n_mci > 1) then
          write (msg_buffer, "(A,A,A,I0)") &
               "Test: probing process '", &
               char (intg%process%get_id ()), "' part ", i_mci
          call msg_message ()
       end if
       call timer_mci%start ()
       call intg%process%sampler_test &
            (process_instance, i_mci, intg%n_calls_test)
       call timer_mci%stop ()
       t_mci = timer_mci
       write (msg_buffer, "(A,ES12.5)")  "Test: " &
            // "time in seconds (wallclock): ", t_mci
       call msg_message ()
    end do
    call timer_tot%stop ()
    t_tot = timer_tot
    if (n_mci > 1) then
       write (msg_buffer, "(A,ES12.5)")  "Test: " &
            // "total time      (wallclock): ", t_tot
       call msg_message ()
    end if
    call process_instance%final ()
  end subroutine integration_sampler_test

@ %def integration_sampler_test
@ Simply integrate, do a dummy integration if necessary.  The [[integration]]
object exists only internally.

The [[init_only]] flag can be used to skip the actual integration part.  We
will end up with a process object that is completely initialized, including
phase space configuration. 

The [[eff_reset]] flag is to suppress numerical noise in the visualization
of the integration history.
<<Integrations: public>>=
  public :: integrate_process
<<Integrations: procedures>>=
  subroutine integrate_process &
       (process_id, global, local_input, init_only, eff_reset)
    type(string_t), intent(in) :: process_id
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target, optional :: local_input
    logical, intent(in), optional :: init_only, eff_reset
    type(rt_data_t), pointer :: local
    type(string_t) :: prclib_name
    type(integration_t) :: intg
    character(32) :: buffer

    if (present (local_input)) then
       local => local_input
    else
       local => global
    end if

    if (.not. associated (global%prclib)) then
       call msg_fatal ("Integrate: current process library is undefined")
       return
    end if

    if (.not. global%prclib%is_active ()) then
       call msg_message ("Integrate: current process library needs compilation")
       prclib_name = global%prclib%get_name ()
       call compile_library (prclib_name, global)
       if (signal_is_pending ())  return
       call msg_message ("Integrate: compilation done")
    end if

    call intg%init (process_id, global, local)
    if (signal_is_pending ())  return

    if (present (init_only)) then
       if (init_only) return
    end if

    if (intg%n_calls_test > 0) then
       write (buffer, "(I0)")  intg%n_calls_test
       call msg_message ("Integrate: test (" // trim (buffer) // " calls) ...")
       call intg%sampler_test ()
       call msg_message ("Integrate: ... test complete.")
       if (signal_is_pending ())  return
    end if

    if (intg%phs_only) then
       call msg_message ("Integrate: phase space only, skipping integration")
    else
       if (intg%process_has_me) then
          call intg%integrate (local, eff_reset)
       else
          call intg%integrate_dummy ()
       end if
    end if
  end subroutine integrate_process

@ %def integrate_process
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Integrations: public>>=
  public :: integrations_test
<<Integrations: tests>>=
  subroutine integrations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Integrations: execute tests>>
  end subroutine integrations_test

@ %def integrations_test
@ 
<<Integrations: public>>=
  public :: integrations_history_test    
<<Integrations: tests>>=
  subroutine integrations_history_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Integrations: execute history tests>>
  end subroutine integrations_history_test  

@ %def integrations_history_test
@ 
\subsubsection{Integration of test process}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type).  The phase-space implementation is [[phs_single]]
(single-particle phase space), the integrator is [[mci_midpoint]].

The cross section for the $2\to 2$ process $ss\to ss$ with its
constant matrix element is given by
\begin{equation}
  \sigma = c\times f\times \Phi_2 \times |M|^2.
\end{equation}
$c$ is the conversion constant
\begin{equation}
  c = 0.3894\times 10^{12}\;\mathrm{fb}\,\mathrm{GeV}^2.
\end{equation}
$f$ is the flux of the incoming particles with mass
$m=125\,\mathrm{GeV}$ and energy $\sqrt{s}=1000\,\mathrm{GeV}$
\begin{equation}
  f = \frac{(2\pi)^4}{2\lambda^{1/2}(s,m^2,m^2)}
    = \frac{(2\pi)^4}{2\sqrt{s}\,\sqrt{s - 4m^2}}
    = 8.048\times 10^{-4}\;\mathrm{GeV}^{-2}
\end{equation}
$\Phi_2$ is the volume of the two-particle phase space
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.5529\times 10^{-5}.
\end{equation}
The squared matrix element $|M|^2$ is unity.
Combining everything, we obtain
\begin{equation}
  \sigma = 8000\;\mathrm{fb}
\end{equation}
This number should appear as the final result.

Note: In this and the following test, we reset the Fortran compiler and flag
variables immediately before they are printed, so the test is portable.
<<Integrations: execute tests>>=
  call test (integrations_1, "integrations_1", &
       "intrinsic test process", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_1"
    write (u, "(A)")  "*   Purpose: integrate test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integration_1"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.) 
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call reset_interaction_counter ()
    call integrate_process (procname, global)

    call global%write (u, vars = [ &
         var_str ("$method"), &
         var_str ("sqrts"), &
         var_str ("$integration_method"), &
         var_str ("$phs_method"), &
         var_str ("$run_id")])
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_1"
    
  end subroutine integrations_1
  
@ %def integrations_1
@
\subsubsection{Integration with cuts}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) with cuts set.
<<Integrations: execute tests>>=
  call test (integrations_2, "integrations_2", &
       "intrinsic test process with cut", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global

    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    
    type(string_t), dimension(0) :: empty_string_array

    write (u, "(A)")  "* Test output: integrations_2"
    write (u, "(A)")  "*   Purpose: integrate test process with cut"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    write (u, "(A)")  "* Prepare a cut expression"
    write (u, "(A)")

    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    global%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "integration_3"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)  
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])
    
    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%write (u, vars = empty_string_array)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_2"
    
  end subroutine integrations_2
  
@ %def integrations_2
@ 
\subsubsection{Standard phase space}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space implementation.  We
use an explicit phase-space configuration file with a single channel
and integrate by [[mci_midpoint]].
<<Integrations: execute tests>>=
  call test (integrations_3, "integrations_3", &
       "standard phase space", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: integrations_3"
    write (u, "(A)")  "*   Purpose: integrate test process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integration_3"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("default"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)   
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, file = "integrations_3.phs", &
         status = "replace", action = "write")
    call write_test_phs_file (u_phs, var_str ("prc_config_a_i1"))
    close (u_phs)

    call var_list_set_string (global%var_list, var_str ("$phs_file"),&
         var_str ("integrations_3.phs"), is_known = .true.)

    call global%it_list%init ([1], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%write (u, vars = [ &
         var_str ("$phs_method"), &
         var_str ("$phs_file")])
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_3"
    
  end subroutine integrations_3
  
@ %def integrations_3
@ 
\subsubsection{VAMP integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].
<<Integrations: execute tests>>=
  call test (integrations_4, "integrations_4", &
       "VAMP integration (one iteration)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_4 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_4"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_4_lib"
    procname = "integrations_4"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = [var_str ("$integration_method")], &
            pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_4"
    
  end subroutine integrations_4
  
@ %def integrations_4
@ 
\subsubsection{Multiple iterations integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
iterations.
<<Integrations: execute tests>>=
  call test (integrations_5, "integrations_5", &
       "VAMP integration (three iterations)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_5 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_5"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_5_lib"
    procname = "integrations_5"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = [var_str ("$integration_method")], &
            pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_5"
    
  end subroutine integrations_5
  
@ %def integrations_5
@ 
\subsubsection{Multiple passes integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
passes with three iterations each.
<<Integrations: execute tests>>=
  call test (integrations_6, "integrations_6", &
       "VAMP integration (three passes)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_6 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    
    write (u, "(A)")  "* Test output: integrations_6"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_6_lib"
    procname = "integrations_6"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3, 3, 3], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_6"
    
  end subroutine integrations_6
  
@ %def integrations_6
@ 
\subsubsection{VAMP and default phase space}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
passes with three iterations each.  We enable channel equivalences and
groves.
<<Integrations: execute tests>>=
  call test (integrations_7, "integrations_7", &
       "VAMP integration with wood phase space", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_7 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    integer :: iostat, u_phs
    character(95) :: buffer
    type(string_t) :: phs_file
    logical :: exist
    
    write (u, "(A)")  "* Test output: integrations_7"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_7_lib"
    procname = "integrations_7"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)    
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3, 3, 3], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Generated phase-space file"
    write (u, "(A)")

    phs_file = procname // "_i1.r1.phs"
    inquire (file = char (phs_file), exist = exist)
    if (exist) then
       u_phs = free_unit ()
       open (u_phs, file = char (phs_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_phs, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_phs)
    else
       write (u, "(A)")  "[file is missing]"
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_7"
    
  end subroutine integrations_7
  
@ %def integrations_7
@ 
\subsubsection{Structure functions}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space
implementation.  The integration method is [[vamp]].  There is a structure
function of type [[unit_test]].

We use a test structure function $f(x)=x$ for both beams.  Together with the
$1/x_1x_2$ factor from the phase-space flux and a unit matrix element, we
should get the same result as previously for the process without structure
functions.  There is a slight correction due to the $m_s$ mass which we set to
zero here.
<<Integrations: execute tests>>=
  call test (integrations_8, "integrations_8", &
       "integration with structure function", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_8 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(flavor_t) :: flv
    
    write (u, "(A)")  "* Test output: integrations_8"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP &
         &with structure function"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_8_lib"
    procname = "integrations_8"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)  
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call reset_interaction_counter ()

    call flavor_init (flv, 25, global%model)
         
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call global%it_list%init ([1], [1000])
    call integrate_process (procname, global)
    
    call global%write (u, vars = [var_str ("ms")])

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_8"
    
  end subroutine integrations_8
  
@ %def integrations_8
@ 
\subsubsection{Integration history for VAMP integration with default
  phase space}
This test is only run when event analysis can be done.
<<Integrations: execute history tests>>=
  call test (integrations_history_1, "integrations_history_1", &
       "Test integration history files", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_history_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    integer :: iostat, u_his
    character(91) :: buffer
    type(string_t) :: his_file, ps_file, pdf_file
    logical :: exist, exist_ps, exist_pdf
    
    write (u, "(A)")  "* Test output: integrations_history_1"
    write (u, "(A)")  "*   Purpose: test integration history files"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_history_1_lib"
    procname = "integrations_history_1"

    call var_list_set_log (global%var_list, var_str ("?vis_history"), &
         .true., is_known = .true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)    
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("error_threshold"),&
         5E-6_default, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([2, 2, 2], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, eff_reset = .true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generated history files"
    write (u, "(A)")

    his_file = procname // ".r1-history.tex"
    ps_file  = procname // ".r1-history.ps"
    pdf_file = procname // ".r1-history.pdf"
    inquire (file = char (his_file), exist = exist)
    if (exist) then
       u_his = free_unit ()
       open (u_his, file = char (his_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_his, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_his)
    else
       write (u, "(A)")  "[History LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[History Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[History Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[History PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[History PDF file is missing/non-regular]"
    end if    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()    
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_history_1"
    
  end subroutine integrations_history_1
  
@ %def integrations_history_1
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Streams}
This module manages I/O from/to multiple concurrent event streams.
Usually, there is at most one input stream, but several output
streams.  For the latter, we set up an array which can hold [[eio_t]]
(event I/O) objects of different dynamic types simultaneously.  One of
them may be marked as an input channel.
<<[[event_streams.f90]]>>=
<<File header>>

module event_streams
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use variables
  use models
  use processes
  use events
  use eio_data
  use eio_base
  use rt_data
  use dispatch
  
<<Standard module head>>

<<Event streams: public>>

<<Event streams: types>>

contains

<<Event streams: tests>>

<<Event streams: procedures>>

end module event_streams
@ %def event_streams
@
\subsection{Event Stream Array}
Each entry is an [[eio_t]] object.  Since the type is dynamic, we need
a wrapper:
<<Event streams: types>>=
  type :: event_stream_entry_t
     class(eio_t), allocatable :: eio
  end type event_stream_entry_t
  
@ %def event_stream_entry_t
@ An array of event-stream entry objects.  If one of the entries is an
input channel, [[i_in]] is the corresponding index.
<<Event streams: public>>=
  public :: event_stream_array_t
<<Event streams: types>>=
  type :: event_stream_array_t
     type(event_stream_entry_t), dimension(:), allocatable :: entry
     integer :: i_in = 0
   contains
   <<Event streams: event stream array: TBP>>
  end type event_stream_array_t
  
@ %def event_stream_array_t
@ Output.
<<Event streams: event stream array: TBP>>=
  procedure :: write => event_stream_array_write
<<Event streams: procedures>>=
  subroutine event_stream_array_write (object, unit)
    class(event_stream_array_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event stream array:"
    if (allocated (object%entry)) then
       select case (size (object%entry))
       case (0)
          write (u, "(3x,A)")  "[empty]"
       case default
          do i = 1, size (object%entry)
             if (i == object%i_in)  write (u, "(1x,A)")  "Input stream:"
             call object%entry(i)%eio%write (u)
          end do
       end select
    else
       write (u, "(3x,A)")  "[undefined]"
    end if
  end subroutine event_stream_array_write

@ %def event_stream_array_write
@ Finalize all streams.
<<Event streams: event stream array: TBP>>=
  procedure :: final => event_stream_array_final
<<Event streams: procedures>>=
  subroutine event_stream_array_final (es_array)
    class(event_stream_array_t), intent(inout) :: es_array
    integer :: i
    do i = 1, size (es_array%entry)
       call es_array%entry(i)%eio%final ()
    end do
  end subroutine event_stream_array_final

@ %def event_stream_array_final
@ Initialization.  We use a generic [[sample]] name, open event I/O
objects for all provided stream types (using the [[dispatch_eio]]
routine), and initialize for the given list of process pointers.  If
there is an [[input]] argument, this channel is initialized as an input
channel and appended to the array.

The [[input_data]] or, if not present, [[data]] may be modified.  This
happens if we open a stream for reading and get new information there.
<<Event streams: event stream array: TBP>>=
  procedure :: init => event_stream_array_init
<<Event streams: procedures>>=
  subroutine event_stream_array_init &
       (es_array, sample, stream_fmt, process_ptr, global, &
       data, input, input_sample, input_data, allow_switch, checkpoint, &
       error)
    class(event_stream_array_t), intent(out) :: es_array
    type(string_t), intent(in) :: sample
    type(string_t), dimension(:), intent(in) :: stream_fmt
    type(process_ptr_t), dimension(:), intent(in) :: process_ptr
    type(rt_data_t), intent(in) :: global
    type(event_sample_data_t), intent(inout), optional :: data
    type(string_t), intent(in), optional :: input
    type(string_t), intent(in), optional :: input_sample
    type(event_sample_data_t), intent(inout), optional :: input_data
    logical, intent(in), optional :: allow_switch
    integer, intent(in), optional :: checkpoint
    logical, intent(out), optional :: error
    type(string_t) :: sample_in
    integer :: n, i
    logical :: success, switch
    if (present (input)) then
       n = size (stream_fmt) + 1
    else
       n = size (stream_fmt)
    end if
    if (present (input_sample)) then
       sample_in = input_sample
    else
       sample_in = sample
    end if
    if (present (allow_switch)) then
       switch = allow_switch
    else
       switch = .true.
    end if
    if (present (error)) then
       error = .false.
    end if
    if (present (checkpoint)) then
       allocate (es_array%entry (n + 1))
       call dispatch_eio &
            (es_array%entry(n+1)%eio, var_str ("checkpoint"), global)
       call es_array%entry(n+1)%eio%init_out (sample, process_ptr, data)
    else
       allocate (es_array%entry (n))
    end if
    if (present (input)) then
       call dispatch_eio (es_array%entry(n)%eio, input, global)
       if (present (input_data)) then
          call es_array%entry(n)%eio%init_in &
               (sample_in, process_ptr, input_data, success)
       else
          call es_array%entry(n)%eio%init_in &
               (sample_in, process_ptr, data, success)
       end if
       if (success) then
          es_array%i_in = n
       else if (present (input_sample)) then
          if (present (error)) then
             error = .true.
          else
             call msg_fatal ("Events: &
                  &parameter mismatch in input, aborting")
          end if
       else
          call msg_message ("Events: &
               &parameter mismatch, discarding old event set")
          call es_array%entry(n)%eio%final ()
          if (switch) then
             call msg_message ("Events: generating new events")
             call es_array%entry(n)%eio%init_out &
                  (sample, process_ptr, data)
          end if
       end if
    end if
    do i = 1, size (stream_fmt)
       call dispatch_eio (es_array%entry(i)%eio, stream_fmt(i), global)
       call es_array%entry(i)%eio%init_out (sample, process_ptr, data)
    end do
  end subroutine event_stream_array_init
  
@ %def event_stream_array_init
@ Switch the (only) input channel to an output channel, so further
events are appended to the respective stream.
<<Event streams: event stream array: TBP>>=
  procedure :: switch_inout => event_stream_array_switch_inout
<<Event streams: procedures>>=
  subroutine event_stream_array_switch_inout (es_array)
    class(event_stream_array_t), intent(inout) :: es_array
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%switch_inout ()
       es_array%i_in = 0
    else
       call msg_bug ("Reading events: switch_inout: no input stream selected")
    end if
  end subroutine event_stream_array_switch_inout
  
@ %def event_stream_array_switch_inout
@ Output an event (with given process number) to all output streams.
If there is no output stream, do nothing.
<<Event streams: event stream array: TBP>>=
  procedure :: output => event_stream_array_output
<<Event streams: procedures>>=
  subroutine event_stream_array_output (es_array, event, i_prc, event_index)
    class(event_stream_array_t), intent(inout) :: es_array
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc, event_index
    integer :: i
    do i = 1, size (es_array%entry)
       if (i /= es_array%i_in) then
          associate (eio => es_array%entry(i)%eio)
            if (eio%split) then
               if (event_index > 1 .and. &
                    mod (event_index, eio%split_n_evt) == 1) then
                  call eio%split_out ()
               end if
            end if
            call eio%output (event, i_prc, reading = es_array%i_in /= 0)
          end associate
       end if
    end do
  end subroutine event_stream_array_output
  
@ %def event_stream_array_output
@ Input the [[i_prc]] index which selects the process for the current
event.  This is separated from reading the event, because it
determines which event record to read.  [[iostat]] may indicate an
error or an EOF condition, as usual.
<<Event streams: event stream array: TBP>>=
  procedure :: input_i_prc => event_stream_array_input_i_prc
<<Event streams: procedures>>=
  subroutine event_stream_array_input_i_prc (es_array, i_prc, iostat)
    class(event_stream_array_t), intent(inout) :: es_array
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%input_i_prc (i_prc, iostat)
    else
       call msg_fatal ("Reading events: no input stream selected")
    end if
  end subroutine event_stream_array_input_i_prc
  
@ %def event_stream_array_input_i_prc
@ Input an event from the selected input stream.  [[iostat]] may indicate an
error or an EOF condition, as usual.
<<Event streams: event stream array: TBP>>=
  procedure :: input_event => event_stream_array_input_event
<<Event streams: procedures>>=
  subroutine event_stream_array_input_event (es_array, event, iostat)
    class(event_stream_array_t), intent(inout) :: es_array
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%input_event (event, iostat)
    else
       call msg_fatal ("Reading events: no input stream selected")
    end if
  end subroutine event_stream_array_input_event
  
@ %def event_stream_array_input_event
@ Return true if there is an input channel among the event streams.
<<Event streams: event stream array: TBP>>=
  procedure :: has_input => event_stream_array_has_input
<<Event streams: procedures>>=
  function event_stream_array_has_input (es_array) result (flag)
    class(event_stream_array_t), intent(in) :: es_array
    logical :: flag
    flag = es_array%i_in /= 0
  end function event_stream_array_has_input
  
@ %def event_stream_array_has_input
@ 
\subsection{Unit Tests}
<<Event streams: public>>=
  public :: event_streams_test
<<Event streams: tests>>=
  subroutine event_streams_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event streams: execute tests>>
  end subroutine event_streams_test
  
@ %def event_streams_test
@
\subsubsection{Empty event stream}
This should set up an empty event output stream array, including
initialization, output, and finalization (which are all no-ops).
<<Event streams: execute tests>>=
  call test (event_streams_1, "event_streams_1", &
       "empty event stream array", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_1 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(event_t) :: event
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    type(process_ptr_t), dimension(0) :: empty_process_ptr_array

    write (u, "(A)")  "* Test output: event_streams_1"
    write (u, "(A)")  "*   Purpose: handle empty event stream array"
    write (u, "(A)")

    sample = "event_streams_1"

    call es_array%init &
         (sample, empty_string_array, empty_process_ptr_array, global)
    call es_array%output (event, 42, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_1"
    
  end subroutine event_streams_1
  
@ %def event_streams_1
@
\subsubsection{Nontrivial event stream}
Here we generate a trivial event and choose [[raw]] output as an entry in
the stream array.
<<Event streams: execute tests>>=
  call test (event_streams_2, "event_streams_2", &
       "nontrivial event stream array", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_2 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(process_ptr_t) :: process_ptr
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    integer :: i_prc, iostat

    write (u, "(A)")  "* Test output: event_streams_2"
    write (u, "(A)")  "*   Purpose: handle empty event stream array"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, global%model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Allocate raw eio stream and write event to file"
    write (u, "(A)")

    sample = "event_streams_2"

    call es_array%init (sample, [var_str ("raw")], [process_ptr], global)
    call es_array%output (event, 1, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    sample = "foo"
    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         input = var_str ("raw"), input_sample = var_str ("event_streams_2"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call es_array%input_event (event, iostat)
    call es_array%final ()
    
    call event%write (u)
    
    call global%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_2"
    
  end subroutine event_streams_2
  
@ %def event_streams_2
@
\subsubsection{Switch in/out}
Here we generate an event file and test switching from writing to
reading when the file is exhausted.
<<Event streams: execute tests>>=
  call test (event_streams_3, "event_streams_3", &
       "switch input/output", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_3 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(process_ptr_t) :: process_ptr
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    integer :: i_prc, iostat

    write (u, "(A)")  "* Test output: event_streams_3"
    write (u, "(A)")  "*   Purpose: handle in/out switching"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    allocate (process)
    process_ptr%ptr => process
    allocate (process_instance)
    call prepare_test_process (process, process_instance, global%model_list)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()

    write (u, "(A)") "* Allocate raw eio stream and write event to file"
    write (u, "(A)")

    sample = "event_streams_3"

    call es_array%init (sample, [var_str ("raw")], [process_ptr], global)
    call es_array%output (event, 1, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         input = var_str ("raw"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    call es_array%input_event (event, iostat)

    write (u, "(A)") "* Attempt to read another event (fail), then generate"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    if (iostat < 0) then
       call es_array%switch_inout ()
       call event%generate (1, [0.3_default, 0.3_default])
       call event%evaluate_expressions ()
       call es_array%output (event, 1, 2)
    end if
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         input = var_str ("raw"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread two events and display 2nd event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    call es_array%input_event (event, iostat)
    call es_array%input_i_prc (i_prc, iostat)
    
    call es_array%input_event (event, iostat)
    call es_array%final ()

    call event%write (u)
    
    call global%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_3"
    
  end subroutine event_streams_3
  
@ %def event_streams_3
@
\subsubsection{Checksum}
Here we generate an event file and repeat twice, once with identical
parameters and once with modified parameters.
<<Event streams: execute tests>>=
  call test (event_streams_4, "event_streams_4", &
       "check MD5 sum", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_4 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(process_t), allocatable, target :: process
    type(process_ptr_t) :: process_ptr
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data

    write (u, "(A)")  "* Test output: event_streams_4"
    write (u, "(A)")  "*   Purpose: handle in/out switching"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    
    call var_list_set_log (global%var_list, var_str ("?check_event_file"), &
         .true., is_known = .true.)

    allocate (process)
    process_ptr%ptr => process

    write (u, "(A)") "* Allocate raw eio stream for writing"
    write (u, "(A)")

    sample = "event_streams_4"
    data%md5sum_cfg = "1234567890abcdef1234567890abcdef"

    call es_array%init &
         (sample, [var_str ("raw")], [process_ptr], global, data)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()

    write (u, "(A)")
    write (u, "(A)") "* Reallocate modified raw eio stream for reading (fail)"
    write (u, "(A)")

    data%md5sum_cfg = "1234567890______1234567890______"
    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Repeat ignoring checksum"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?check_event_file"), &
         .false., is_known = .true.)
    call es_array%init (sample, empty_string_array, [process_ptr], global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()
    
    call global%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_4"
    
  end subroutine event_streams_4
  
@ %def event_streams_4
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulation}
This module manages simulation: event generation and reading/writing of event
files.  The [[simulation]] object is intended to be used (via a pointer)
outside of \whizard, if events are generated individually by an external
driver.
<<[[simulations.f90]]>>=
<<File header>>

module simulations

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use sm_qcd
  use md5
  use ifiles
  use lexers
  use parser
  use variables
  use eval_trees
  use flavors
  use particles
  use state_matrices
  use interactions
  use models
  use beams
  use phs_forests
  use rng_base
  use selectors
  use prc_core
  use prclib_stacks
  use processes
  use events
  use event_transforms
  use decays
  use eio_data
  use eio_base
  use eio_raw
  use eio_ascii
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams

<<Standard module head>>

<<Simulations: public>>

<<Simulations: types>>

<<Simulations: interfaces>>

contains

<<Simulations: procedures>>

<<Simulations: tests>>

end module simulations
@ %def simulations
@
\subsection{Event counting}
In this object we collect statistical information about an event
sample or sub-sample.
<<Simulations: types>>=
  type :: counter_t
     integer :: total = 0
     integer :: generated = 0
     integer :: read = 0
     integer :: positive = 0
     integer :: negative = 0
     integer :: zero = 0
     integer :: excess = 0
     real(default) :: max_excess = 0
     real(default) :: sum_excess = 0
   contains
   <<Simulations: counter: TBP>>
  end type counter_t
  
@ %def simulation_counter_t
@ Output.
<<Simulations: counter: TBP>>=
  procedure :: write => counter_write
<<Simulations: procedures>>=
  subroutine counter_write (object, unit)
    class(counter_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
1   format (3x,A,I0)
2   format (5x,A,I0)
3   format (5x,A,ES19.12)
    write (u, 1)  "Events total      = ", object%total
    write (u, 2)  "generated       = ", object%generated
    write (u, 2)  "read            = ", object%read
    write (u, 2)  "positive weight = ", object%positive
    write (u, 2)  "negative weight = ", object%negative
    write (u, 2)  "zero weight     = ", object%zero
    write (u, 2)  "excess weight   = ", object%excess
    if (object%excess /= 0) then
       write (u, 3)  "max excess      = ", object%max_excess
       write (u, 3)  "avg excess      = ", object%sum_excess / object%total
    end if
  end subroutine counter_write

@ %def counter_write
@ This is a screen message: if there was an excess, display statistics.
<<Simulations: counter: TBP>>=
  procedure :: show_excess => counter_show_excess
<<Simulations: procedures>>=
  subroutine counter_show_excess (counter)
    class(counter_t), intent(in) :: counter
    if (counter%excess > 0) then
       write (msg_buffer, "(A,1x,I0,1x,A,1x,'(',F7.3,' %)')") &
            "Encountered events with excess weight:", counter%excess, &
            "events", 100 * counter%excess / real (counter%total)
       call msg_warning ()
       write (msg_buffer, "(A,ES10.3)") &
            "Maximum excess weight =", counter%max_excess
       call msg_message ()
       write (msg_buffer, "(A,ES10.3)") &
            "Average excess weight =", counter%sum_excess / counter%total
       call msg_message ()
    end if
  end subroutine counter_show_excess
    
@ %def counter_show_excess
@ Count an event.  The weight and event source are optional; by
default we assume that the event has been generated and has positive
weight.
<<Simulations: counter: TBP>>=
  procedure :: record => counter_record
<<Simulations: procedures>>=
  subroutine counter_record (counter, weight, excess, from_file)
    class(counter_t), intent(inout) :: counter
    real(default), intent(in), optional :: weight, excess
    logical, intent(in), optional :: from_file
    counter%total = counter%total + 1
    if (present (from_file)) then
       if (from_file) then
          counter%read = counter%read + 1
       else
          counter%generated = counter%generated + 1
       end if
    else
       counter%generated = counter%generated + 1
    end if
    if (present (weight)) then
       if (weight > 0) then
          counter%positive = counter%positive + 1
       else if (weight < 0) then
          counter%negative = counter%negative + 1
       else
          counter%zero = counter%zero + 1
       end if
    else
       counter%positive = counter%positive + 1
    end if
    if (present (excess)) then
       if (excess > 0) then
          counter%excess = counter%excess + 1
          counter%max_excess = max (counter%max_excess, excess)
          counter%sum_excess = counter%sum_excess + excess
       end if
    end if
  end subroutine counter_record
    
@ %def counter_record
@
\subsection{Simulation: component sets}
For each set of process components that share a MCI entry in the
process configuration, we keep a separate event record.
<<Simulations: types>>=
  type :: mci_set_t
     private
     integer :: n_components = 0
     integer, dimension(:), allocatable :: i_component
     type(string_t), dimension(:), allocatable :: component_id
     logical :: has_integral = .false.
     real(default) :: integral = 0
     real(default) :: error = 0
     real(default) :: weight_mci = 0
     type(counter_t) :: counter
   contains
   <<Simulations: mci set: TBP>>
  end type mci_set_t
     
@ %def mci_set_t
@ Output.
<<Simulations: mci set: TBP>>=
  procedure :: write => mci_set_write
<<Simulations: procedures>>=
  subroutine mci_set_write (object, unit)
    class(mci_set_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "Components:"
    do i = 1, object%n_components
       write (u, "(5x,I0,A,A,A)")  object%i_component(i), &
            ": '", char (object%component_id(i)), "'"
    end do
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral  = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error     = ", object%error
       write (u, "(3x,A,F13.10)")  "Weight    =", object%weight_mci
    else
       write (u, "(3x,A)")  "Integral  = [undefined]"
    end if
    call object%counter%write (u)
  end subroutine mci_set_write
  
@ %def mci_set_write
@ Initialize: Get the indices and names for the process components
that will contribute to this set.
<<Simulations: mci set: TBP>>=
  procedure :: init => mci_set_init
<<Simulations: procedures>>=
  subroutine mci_set_init (object, i_mci, process)
    class(mci_set_t), intent(out) :: object
    integer, intent(in) :: i_mci
    type(process_t), intent(in), target :: process
    integer :: i
    call process%get_i_component (i_mci, object%i_component)
    object%n_components = size (object%i_component)
    allocate (object%component_id (object%n_components))
    do i = 1, size (object%component_id)
       object%component_id(i) = &
            process%get_component_id (object%i_component(i))
    end do
    if (process%has_integral (i_mci)) then
       object%integral = process%get_integral (i_mci)
       object%error = process%get_error (i_mci)
       object%has_integral = .true.
    end if
  end subroutine mci_set_init
    
@ %def mci_set_init
@
\subsection{Process-core Safe}
This is an object that temporarily holds a process core object.  We
need this while rescanning a process with modified parameters.  After
the rescan, we want to restore the original state.
<<Simulations: types>>=
  type :: core_safe_t
     class(prc_core_t), allocatable :: core
  end type core_safe_t
  
@ %def core_safe_t
@
\subsection{Process Object}
The simulation works on process objects.  This subroutine makes a
process object available for simulation.  The process is in the
process stack.  If integration is not yet
done, do it.
<<Simulations: procedures>>=
  subroutine prepare_process (process, process_id, integrate, global, local)
    type(process_t), pointer, intent(out) :: process
    type(string_t), intent(in) :: process_id
    logical, intent(in) :: integrate
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target :: local
    process => global%process_stack%get_process_ptr (process_id)
    if (.not. associated (process)) then
       if (integrate) then
          call msg_message ("Simulate: process '" &
               // char (process_id) // "' needs integration")
       else
          call msg_message ("Simulate: process '" &
               // char (process_id) // "' needs initialization")
       end if
       call integrate_process (process_id, global, local, &
            init_only = .not. integrate)
       if (signal_is_pending ())  return
       process => global%process_stack%get_process_ptr (process_id)
       if (associated (process)) then
          if (integrate) then
             call msg_message ("Simulate: integration done")
             call global%process_stack%fill_result_vars (process_id)
          else
             call msg_message ("Simulate: process initialization done")
          end if
       else
          call msg_fatal ("Simulate: process '" &
               // char (process_id) // "' could not be initialized: aborting")
       end if
    end if
  end subroutine prepare_process
    
@ %def prepare_process
@
\subsection{Simulation entry}
For each process that we consider for event generation, we need a
separate entry.  The entry separately records the process ID and run ID.  The
[[weight_mci]] array is used for selecting a component set (which
shares a MCI record inside the process container) when generating an
event for the current process.

The simulation entry is an extension of the [[event_t]] event record.
This core object contains configuration data, pointers to the process
and process instance, the expressions, flags and values that are
evaluated at runtime, and the resulting particle set.

The entry explicitly allocate the [[process_instance]], which becomes
the process-specific workspace for the event record.

If entries with differing environments are present simultaneously, we
may need to switch QCD parameters and/or the model event by event.  In
this case, the [[qcd]] and/or [[model]] components are present.
<<Simulations: types>>=
  type, extends (event_t) :: entry_t
     private
     type(string_t) :: process_id
     type(string_t) :: library
     type(string_t) :: run_id
     logical :: has_integral = .false.
     real(default) :: integral = 0
     real(default) :: error = 0
     real(default) :: process_weight = 0
     logical :: valid = .false.
     type(counter_t) :: counter
     integer :: n_in = 0
     integer :: n_mci = 0
     type(mci_set_t), dimension(:), allocatable :: mci_set
     type(selector_t) :: mci_selector
     type(core_safe_t), dimension(:), allocatable :: core_safe
     type(model_t), pointer :: model => null ()
     type(qcd_t) :: qcd
     logical :: nlo_event = .false.
   contains
   <<Simulations: entry: TBP>>
  end type entry_t

@ %def entry_t
@ Output.  Write just the configuration, the event is written by a
separate routine.

The [[verbose]] option is unused, it is required by the interface of
the base-object method.
<<Simulations: entry: TBP>>=
  procedure :: write_config => entry_write_config
<<Simulations: procedures>>=
  subroutine entry_write_config (object, unit)
    class(entry_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A,A,A)")  "Process   = '", char (object%process_id), "'"
    write (u, "(3x,A,A,A)")  "Library   = '", char (object%library), "'"
    write (u, "(3x,A,A,A)")  "Run       = '", char (object%run_id), "'"
    write (u, "(3x,A,L1)")   "is valid  = ", object%valid
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral  = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error     = ", object%error
       write (u, "(3x,A,F13.10)")  "Weight    =", object%process_weight
    else
       write (u, "(3x,A)")  "Integral  = [undefined]"
    end if
    write (u, "(3x,A,I0)")   "MCI sets  = ", object%n_mci
    call object%counter%write (u)
    do i = 1, size (object%mci_set)
       write (u, "(A)")
       write (u, "(1x,A,I0,A)")  "MCI set #", i, ":"
       call object%mci_set(i)%write (u)
    end do
    if (allocated (object%core_safe)) then
       do i = 1, size (object%core_safe)
          write (u, "(1x,A,I0,A)")  "Saved process-component core #", i, ":"
          call object%core_safe(i)%core%write (u)
       end do
    end if
  end subroutine entry_write_config
  
@ %def entry_write_config
@ Finalizer.  The [[instance]] pointer component of the [[event_t]]
base type points to a target which we did explicitly allocate in the
[[entry_init]] procedure.  Therefore, we finalize and explicitly
deallocate it here.  Then we call the finalizer of the base type.
<<Simulations: entry: TBP>>=
  procedure :: final => entry_final
<<Simulations: procedures>>=
  subroutine entry_final (object)
    class(entry_t), intent(inout) :: object
    integer :: i
    if (associated (object%instance)) then
       do i = 1, object%n_mci
          call object%instance%final_simulation (i)
       end do
       call object%instance%final ()
       deallocate (object%instance)
    end if
    call object%event_t%final ()
  end subroutine entry_final
  
@ %def entry_final
@ Initialization.  Search for a process entry and allocate a process
instance as an anonymous object, temporarily accessible via the
[[process_instance]] pointer.  Assign data by looking at the process
object and at the environment.

If [[n_alt]] is set, we prepare for additional alternate sqme and weight
entries.

If the process object is not found initially: if [[integrate]] is set, attempt
an integration pass and try again.  Otherwise, just initialize the object.

If [[generate]] is set, prepare the MCI objects for generating new events.
For pure rescanning, this is not necessary.

When done, we assign the [[instance]] and [[process]] pointers of the
base type by the [[connect]] method, so we can reference them later.
<<Simulations: entry: TBP>>=
  procedure :: init => entry_init
<<Simulations: procedures>>=
  subroutine entry_init &
       (entry, process_id, integrate, generate, global, local, n_alt)
    class(entry_t), intent(inout), target :: entry
    type(string_t), intent(in) :: process_id
    logical, intent(in) :: integrate, generate
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target :: local
    integer, intent(in), optional :: n_alt
    type(process_t), pointer :: process
    type(process_instance_t), pointer :: process_instance
    type(eval_tree_factory_t) :: expr_factory
    class(evt_t), pointer :: evt
    integer :: i
    logical :: enable_qcd
    
    enable_qcd = var_list_get_lval (local%var_list, var_str ("?ps_isr_active")) &
            .or. var_list_get_lval (local%var_list, var_str ("?ps_fsr_active")) &
            .or. var_list_get_lval (local%var_list, var_str &
                     ("?hadronization_active")) &
            .or. var_list_get_lval (local%var_list, var_str ("?mlm_matching")) &
            .or. var_list_get_lval (local%var_list, var_str ("?ckkw_matching")) &
            .or. var_list_get_lval (local%var_list, var_str ("?muli_active"))
    
    call prepare_process (process, process_id, integrate, global, local)
    if (signal_is_pending ())  return

    if (.not. process%has_matrix_element ()) then
       entry%has_integral = .true.
       entry%process_id = process_id
       entry%valid = .false.          
       return
    end if
    
    call entry%basic_init (local%var_list, n_alt)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()

    entry%process_id = process_id
    entry%library = process%get_library_name ()
    entry%run_id = process%get_run_id ()
    entry%n_in = process%get_n_in ()
    entry%n_mci = process%get_n_mci ()
    allocate (entry%mci_set (entry%n_mci))
    do i = 1, size (entry%mci_set)
       call entry%mci_set(i)%init (i, process)
    end do
    if (process%is_nlo_calculation ()) then
      entry%nlo_event = .true.
      call entry%combine_mci_sets ()
    end if
    if (process%has_integral ()) then
       entry%integral = process%get_integral ()
       entry%error = process%get_error ()
       call entry%set_sigma (entry%integral)
       entry%has_integral = .true.
    end if

    call expr_factory%init (local%pn%selection_lexpr)
    call entry%set_selection (expr_factory)
    call expr_factory%init (local%pn%reweight_expr)
    call entry%set_reweight (expr_factory)
    call expr_factory%init (local%pn%analysis_lexpr)
    call entry%set_analysis (expr_factory)
    if (generate) then
       do i = 1, entry%n_mci
          call process%prepare_simulation (i)
          call process_instance%init_simulation (i, entry%config%safety_factor)
       end do
    end if

    if (process%contains_unstable (local%model)) then
       call dispatch_evt_decay (evt, local)
       if (associated (evt))  call entry%import_transform (evt)
    end if
    
    if (enable_qcd) then 
       call dispatch_evt_shower (evt, local, process)
       if (associated (evt))  call entry%import_transform (evt)
    end if

    call entry%connect (process_instance, local%model, global%process_stack)
    call entry%setup_expressions ()
    entry%model => process%get_model_ptr ()
    call dispatch_qcd (entry%qcd, local)
    entry%valid = .true.
    
  end subroutine entry_init
    
@ %def entry_init
@ Compute weights.  The integral in the argument is the sum of integrals for
all processes in the sample.  After computing the process weights, we repeat
the normalization procedure for the process components.
<<Simulations: entry: TBP>>=
  procedure :: init_mci_selector => entry_init_mci_selector
<<Simulations: procedures>>=
  subroutine entry_init_mci_selector (entry)
    class(entry_t), intent(inout) :: entry
    integer :: i
    if (entry%has_integral) then
       call entry%mci_selector%init (entry%mci_set%integral)
       do i = 1, entry%n_mci
          entry%mci_set(i)%weight_mci = entry%mci_selector%get_weight (i)
       end do
    end if
  end subroutine entry_init_mci_selector
  
@ %def entry_init_mci_selector
@ Select a MCI entry, using the embedded random-number generator.
<<Simulations: entry: TBP>>=
  procedure :: select_mci => entry_select_mci
<<Simulations: procedures>>=
  function entry_select_mci (entry) result (i_mci)
    class(entry_t), intent(inout) :: entry
    integer :: i_mci
    call entry%mci_selector%generate (entry%rng, i_mci)
  end function entry_select_mci
  
@ %def entry_select_mci
@ Record an event for this entry, i.e., increment the appropriate counters.
<<Simulations: entry: TBP>>=
  procedure :: record => entry_record
<<Simulations: procedures>>=
  subroutine entry_record (entry, i_mci, from_file)
    class(entry_t), intent(inout) :: entry
    integer, intent(in) :: i_mci
    logical, intent(in), optional :: from_file
    real(default) :: weight, excess
    weight = entry%weight_prc
    excess = entry%excess_prc
    call entry%counter%record (weight, excess, from_file)
    call entry%mci_set(i_mci)%counter%record (weight, excess)
  end subroutine entry_record
    
@ %def entry_record
@ Update and restore the process core that this entry accesses, when
parameters change.  If explicit arguments [[model]], [[qcd]], or
[[helicity_selection]] are provided, use those.  Otherwise use the
parameters stored in the process object.
<<Simulations: entry: TBP>>=
  procedure :: update_process => entry_update_process
  procedure :: restore_process => entry_restore_process
<<Simulations: procedures>>=
  subroutine entry_update_process (entry, model, qcd, helicity_selection)
    class(entry_t), intent(inout) :: entry
    type(model_t), intent(in), optional, target :: model
    type(qcd_t), intent(in), optional :: qcd
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(process_t), pointer :: process
    class(prc_core_t), allocatable :: core
    integer :: i, n_components
    type(model_t), pointer :: model_local
    type(qcd_t) :: qcd_local
    if (present (model)) then
       model_local => model
    else
       model_local => entry%model
    end if
    if (present (qcd)) then
       qcd_local = qcd
    else
       qcd_local = entry%qcd
    end if
    process => entry%get_process_ptr ()
    n_components = process%get_n_components ()
    allocate (entry%core_safe (n_components))
    do i = 1, n_components
       if (process%has_matrix_element (i)) then
          call process%extract_component_core (i, core)
          call dispatch_core_update (core, &
               model_local, helicity_selection, qcd_local, &
               entry%core_safe(i)%core)
          call process%restore_component_core (i, core)
       end if
    end do
  end subroutine entry_update_process
  
  subroutine entry_restore_process (entry)
    class(entry_t), intent(inout) :: entry
    type(process_t), pointer :: process
    class(prc_core_t), allocatable :: core
    integer :: i, n_components
    process => entry%get_process_ptr ()
    n_components = process%get_n_components ()
    do i = 1, n_components
       if (process%has_matrix_element (i)) then
          call process%extract_component_core (i, core)
          call dispatch_core_restore (core, entry%core_safe(i)%core)
          call process%restore_component_core (i, core)
       end if
    end do
    deallocate (entry%core_safe)
  end subroutine entry_restore_process
  
@ %def entry_update_process
@ %def entry_restore_process
<<Simulations: entry: TBP>>=
  procedure :: combine_mci_sets => entry_combine_mci_sets
<<Simulations: procedures>>=
  subroutine entry_combine_mci_sets (entry)
    class(entry_t), intent(inout) :: entry
    integer :: n_components_lo, i_component, i_virt
    n_components_lo = entry%n_mci / 3
    do i_component = 1, n_components_lo
      i_virt = i_component + 2*n_components_lo
      entry%mci_set(i_component)%integral = &
        entry%mci_set(i_component)%integral + entry%mci_set(i_virt)%integral
      entry%mci_set(i_component)%error = sqrt (&
        entry%mci_set(i_component)%error**2 + entry%mci_set(i_virt)%error**2)
      entry%mci_set(i_virt)%integral = 0._default
      entry%mci_set(i_virt)%has_integral = .false.
    end do
  end subroutine entry_combine_mci_sets
 
@ %def entry_combine_mci_sets
@
\subsection{Entries for alternative environment}
Entries for alternate environments.  [No additional components
anymore, so somewhat redundant.]
<<Simulations: types>>=
  type, extends (entry_t) :: alt_entry_t
   contains
   <<Simulations: alt entry: TBP>>
  end type alt_entry_t
  
@ %def alt_entry_t
@ The alternative entries are there to re-evaluate the event, given
momenta, in a different context.

Therefore, we allocate a local process object and use this as the
reference for the local process instance, when initializing the entry.
We temporarily import the [[process]] object into an [[integration_t]]
wrapper, to take advantage of the associated methods.  The local
process object is built in the context of the current environment,
here called [[global]].  Then, we initialize the process instance.

The [[master_process]] object contains the integration results to which we
refer when recalculating an event.  Therefore, we use this object instead of
the locally built [[process]] when we extract the integration results.

The locally built [[process]] object should be finalized when done.  It
remains accessible via the [[event_t]] base object of [[entry]], which
contains pointers to the process and instance.
<<Simulations: alt entry: TBP>>=
  procedure :: init_alt => alt_entry_init
<<Simulations: procedures>>=
  subroutine alt_entry_init (entry, process_id, &
       master_process, global)
    class(alt_entry_t), intent(inout), target :: entry
    type(string_t), intent(in) :: process_id
    type(process_t), intent(in), target :: master_process
    type(rt_data_t), intent(inout), target :: global
    class(rng_factory_t), allocatable :: rng_factory
    type(process_t), pointer :: process
    type(process_instance_t), pointer :: process_instance
    type(eval_tree_factory_t) :: expr_factory
    class(evt_t), pointer :: evt
    type(string_t) :: run_id
    type(integration_t) :: intg
    integer :: i
    logical :: enable_qcd
    
    enable_qcd = var_list_get_lval (global%var_list, var_str ("?ps_isr_active")) &
            .or. var_list_get_lval (global%var_list, var_str ("?ps_fsr_active")) &
            .or. var_list_get_lval (global%var_list, var_str &
                     ("?hadronization_active")) &
            .or. var_list_get_lval (global%var_list, var_str ("?mlm_matching")) &
            .or. var_list_get_lval (global%var_list, var_str ("?ckkw_matching")) &
            .or. var_list_get_lval (global%var_list, var_str ("?muli_active"))    

    call msg_message ("Simulate: initializing alternate process setup ...")

    run_id = var_list_get_sval (global%var_list, var_str ("$run_id"))
    call var_list_set_log (global%var_list, var_str ("?rebuild_phase_space"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?check_phs_file"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?rebuild_grids"), &
         .false., is_known = .true.)
    
    call dispatch_qcd (entry%qcd, global)
    call dispatch_rng_factory (rng_factory, global)

    allocate (process)
    call process%init (process_id, run_id, global%prclib, &
         global%os_data, entry%qcd, rng_factory, global%model_list)
    call intg%setup_process (global, process)

    call entry%basic_init (global%var_list)
    
    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    entry%process_id = process_id
    entry%library = process%get_library_name ()
    entry%run_id = run_id
    entry%n_mci = process%get_n_mci ()
    allocate (entry%mci_set (entry%n_mci))
    do i = 1, size (entry%mci_set)
       call entry%mci_set(i)%init (i, master_process)
    end do
    if (master_process%has_integral ()) then
       entry%integral = master_process%get_integral ()
       entry%error = master_process%get_error ()
       call entry%set_sigma (entry%integral)
       entry%has_integral = .true.
    end if
    
    call expr_factory%init (global%pn%selection_lexpr)
    call entry%set_selection (expr_factory)
    call expr_factory%init (global%pn%reweight_expr)
    call entry%set_reweight (expr_factory)
    call expr_factory%init (global%pn%analysis_lexpr)
    call entry%set_analysis (expr_factory)

    if (process%contains_unstable (global%model)) then
       call dispatch_evt_decay (evt, global)
       if (associated (evt))  call entry%import_transform (evt)
    end if

    if (enable_qcd) then
       call dispatch_evt_shower (evt, global)
       if (associated (evt))  call entry%import_transform (evt)
    end if

    call entry%connect (process_instance, global%model, global%process_stack)
    call entry%setup_expressions ()

    entry%model => process%get_model_ptr ()

    call msg_message ("...  alternate process setup complete.")

  end subroutine alt_entry_init

@ %def alt_entry_init
@ Copy the particle set from the master entry to the alternate entry.
This is the particle set of the hard process.
<<Simulations: alt entry: TBP>>=
  procedure :: fill_particle_set => entry_fill_particle_set
<<Simulations: procedures>>=
  subroutine entry_fill_particle_set (alt_entry, entry)
    class(alt_entry_t), intent(inout) :: alt_entry
    class(entry_t), intent(in), target :: entry
    type(particle_set_t) :: pset
    call entry%get_particle_set_hard_proc (pset)
    call alt_entry%set_particle_set_hard_proc (pset)
    call particle_set_final (pset)
  end subroutine entry_fill_particle_set
    
@ %def particle_set_copy_prt
@
\subsection{The simulation type}
Each simulation object corresponds to an event sample, identified by
the [[sample_id]].

The simulation may cover several processes simultaneously.  All
process-specific data, including the event records, are stored in the
[[entry]] subobjects.  The [[current]] index indicates which record
was selected last. [[version]] is foreseen to contain a tag on the \whizard\
event file version. It can be 
<<Simulations: public>>=
  public :: simulation_t
<<Simulations: types>>=
  type :: simulation_t
     private
     type(string_t) :: sample_id
     logical :: unweighted = .true.
     logical :: negative_weights = .false.
     integer :: norm_mode = NORM_UNDEFINED
     logical :: pacify = .false.
     integer :: n_max_tries = 10000
     integer :: n_prc = 0
     integer :: n_alt = 0
     logical :: has_integral = .false.
     logical :: valid
     real(default) :: integral = 0
     real(default) :: error = 0
     integer :: version = 1
     character(32) :: md5sum_prc = ""
     character(32) :: md5sum_cfg = ""
     character(32), dimension(:), allocatable :: md5sum_alt
     type(entry_t), dimension(:), allocatable :: entry
     type(alt_entry_t), dimension(:,:), allocatable :: alt_entry
     type(selector_t) :: process_selector
     integer :: n_evt_requested = 0
     integer :: split_n_evt = 0
     integer :: split_index = 0
     type(counter_t) :: counter
     class(rng_t), allocatable :: rng
     integer :: i_prc = 0
     integer :: i_mci = 0
     real(default) :: weight = 0
     real(default) :: excess = 0
   contains
   <<Simulations: simulation: TBP>>
  end type simulation_t
  
@ %def simulation_t
@ Output.  [[write_config]] writes just the configuration.  [[write]]
as a method of the base type [[event_t]]
writes the current event and process instance, depending on options.
<<Simulations: simulation: TBP>>=
  procedure :: write => simulation_write
<<Simulations: procedures>>=
  subroutine simulation_write (object, unit)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A,A,A)")  "Event sample: '", char (object%sample_id), "'"
    write (u, "(3x,A,I0)")  "Processes    = ", object%n_prc
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alt.wgts     = ", object%n_alt
    end if
    write (u, "(3x,A,L1)")  "Unweighted   = ", object%unweighted
    write (u, "(3x,A,A)")   "Event norm   = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A,L1)")  "Neg. weights = ", object%negative_weights
    write (u, "(3x,A,L1)")  "Pacify       = ", object%pacify
    write (u, "(3x,A,I0)")  "Max. tries   = ", object%n_max_tries
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral     = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error        = ", object%error
    else
       write (u, "(3x,A)")  "Integral     = [undefined]"
    end if
    write (u, "(3x,A,L1)")  "Sim. valid   = ", object%valid
    write (u, "(3x,A,I0)")  "Ev.file ver. = ", object%version
    if (object%md5sum_prc /= "") then
       write (u, "(3x,A,A,A)")  "MD5 sum (proc)   = '", object%md5sum_prc, "'"
    end if
    if (object%md5sum_cfg /= "") then
       write (u, "(3x,A,A,A)")  "MD5 sum (config) = '", object%md5sum_cfg, "'"
    end if
    write (u, "(3x,A,I0)")  "Events requested  = ", object%n_evt_requested
    if (object%split_n_evt > 0) then
       write (u, "(3x,A,I0)")  "Events per file   = ", object%split_n_evt
       write (u, "(3x,A,I0)")  "First file index  = ", object%split_index
    end if
    call object%counter%write (u)
    call write_separator (u)
    if (object%i_prc /= 0) then
       write (u, "(1x,A)")  "Current event:"
       write (u, "(3x,A,I0,A,A)")  "Process #", &
            object%i_prc, ": ", &
            char (object%entry(object%i_prc)%process_id)
       write (u, "(3x,A,I0)")  "MCI set #", object%i_mci
       write (u, "(3x,A," // FMT_19 // ")")  "Weight    = ", object%weight
       if (object%excess /= 0) &
            write (u, "(3x,A," // FMT_19 // ")")  "Excess    = ", object%excess
    else
       write (u, "(1x,A,I0,A,A)")  "Current event: [undefined]"
    end if
    call write_separator (u)
    if (allocated (object%rng)) then
       call object%rng%write (u)
    else
       write (u, "(3x,A)")  "Random-number generator: [undefined]"
    end if
    if (allocated (object%entry)) then
       do i = 1, size (object%entry)
          if (i == 1) then
             call write_separator (u, 2)
          else
             call write_separator (u)
          end if
          write (u, "(1x,A,I0,A)") "Process #", i, ":"
          call object%entry(i)%write_config (u)
       end do
    end if
    call write_separator (u, 2)
  end subroutine simulation_write
  
@ %def simulation_write
@ Write the current event record.  If an explicit index is given,
write that event record.

We implement writing to [[unit]] (event contents / debugging format)
and writing to an [[eio]] event stream (storage). We include a [[testflag]]
in order to suppress numerical noise in the testsuite.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_unit
  procedure :: write_event_unit => simulation_write_event_unit
<<Simulations: procedures>>=
  subroutine simulation_write_event_unit (object, unit, i_prc, verbose, testflag)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer, intent(in), optional :: i_prc
    logical, intent(in), optional :: testflag
    integer :: current
    if (present (i_prc)) then
       current = i_prc
    else
       current = object%i_prc
    end if
    if (current > 0) then
       call object%entry(current)%write (unit, verbose = verbose, &
            testflag = testflag)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_unit

@ %def simulation_write_event
@ This writes one of the alternate events, if allocated.
<<Simulations: simulation: TBP>>=
  procedure :: write_alt_event => simulation_write_alt_event
<<Simulations: procedures>>=
  subroutine simulation_write_alt_event (object, unit, j_alt, i_prc, &
       verbose, testflag)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: j_alt
    integer, intent(in), optional :: i_prc
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    integer :: i, j
    if (present (j_alt)) then
       j = j_alt
    else
       j = 1
    end if
    if (present (i_prc)) then
       i = i_prc
    else
       i = object%i_prc
    end if
    if (i > 0) then
       if (j> 0 .and. j <= object%n_alt) then
          call object%alt_entry(i,j)%write (unit, verbose = verbose, &
               testflag = testflag)
       else
          call msg_fatal ("Simulation: write alternate event: out of range")
       end if
    else
       call msg_fatal ("Simulation: write alternate event: no process selected")
    end if
  end subroutine simulation_write_alt_event

@ %def simulation_write_alt_event
@ Finalizer.
<<Simulations: simulation: TBP>>=
  procedure :: final => simulation_final
<<Simulations: procedures>>=
  subroutine simulation_final (object)
    class(simulation_t), intent(inout) :: object
    integer :: i, j
    if (allocated (object%entry)) then
       do i = 1, size (object%entry)
          call object%entry(i)%final ()
       end do
    end if
    if (allocated (object%alt_entry)) then
       do j = 1, size (object%alt_entry, 2)
          do i = 1, size (object%alt_entry, 1)
             call object%alt_entry(i,j)%final ()
          end do
       end do
    end if
    if (allocated (object%rng))  call object%rng%final ()
  end subroutine simulation_final
  
@ %def simulation_final
@ Initialization.  We can deduce all data from the given list of
process IDs and the global data set.  The process objects are taken
from the stack.  Once the individual integrals are known, we add them (and the
errors), to get the sample integral.

If there are alternative environments, we suspend initialization for
setting up alternative process objects, then restore the master
process and its parameters.  The generator or rescanner can then
switch rapidly between processes.

If [[integrate]] is set, we make sure that all affected processes are
integrated before simulation.  This is necessary if we want to actually
generate events.  If [[integrate]] is unset, we don't need the integral
because we just rescan existing events.  In that case, we just need compiled
matrix elements.

If [[generate]] is set, we prepare for actually generating events.  Otherwise,
we may only read and rescan events.
<<Simulations: simulation: TBP>>=
  procedure :: init => simulation_init
<<Simulations: procedures>>=
  subroutine simulation_init (simulation, &
       process_id, integrate, generate, global, local_input, alt_env)
    class(simulation_t), intent(out), target :: simulation
    type(string_t), dimension(:), intent(in) :: process_id
    logical, intent(in) :: integrate, generate
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target, optional :: local_input
    type(rt_data_t), dimension(:), intent(inout), target, optional :: alt_env
    type(rt_data_t), pointer :: local
    class(rng_factory_t), allocatable :: rng_factory
    type(string_t) :: norm_string, version_string
    integer :: i, j
    if (present (local_input)) then
       local => local_input
    else
       local => global
    end if
    simulation%sample_id = var_list_get_sval (local%var_list, &
         var_str ("$sample"))
    simulation%unweighted = var_list_get_lval (local%var_list, &
         var_str ("?unweighted"))
    simulation%negative_weights = var_list_get_lval (local%var_list, &
         var_str ("?negative_weights"))
    version_string = var_list_get_sval (local%var_list, &
         var_str ("$event_file_version"))
    norm_string = var_list_get_sval (local%var_list, &
         var_str ("$sample_normalization"))
    simulation%norm_mode = &
         event_normalization_mode (norm_string, simulation%unweighted)
    simulation%pacify = var_list_get_lval (local%var_list, &
         var_str ("?sample_pacify"))
    simulation%n_max_tries = var_list_get_ival (local%var_list, &
         var_str ("sample_max_tries"))
    simulation%split_n_evt = var_list_get_ival (local%var_list, &
         var_str ("sample_split_n_evt"))
    simulation%split_index = var_list_get_ival (local%var_list, &
         var_str ("sample_split_index"))
    select case (size (process_id))
    case (0)
       call msg_error ("Simulation: no process selected")
    case (1)
       write (msg_buffer, "(A,A,A)") &
            "Starting simulation for process '", &
            char (process_id(1)), "'"
       call msg_message ()
    case default
       write (msg_buffer, "(A,A,A)") &
            "Starting simulation for processes '", &
            char (process_id(1)), "' etc."
       call msg_message ()
    end select
    select case (char (version_string))
    case ("2.0","2.1")
       simulation%version = 0
    case default
       simulation%version = 1
    end select
    if (simulation%version == 0) then
       call msg_fatal ("Event file formats older than version 2.2 are " &
          // "not compatible with this version.")
    end if  	  
    simulation%n_prc = size (process_id)
    allocate (simulation%entry (simulation%n_prc))
    if (present (alt_env)) then
       simulation%n_alt = size (alt_env)
       do i = 1, simulation%n_prc
          call simulation%entry(i)%init (process_id(i), integrate, generate, &
               global, local, simulation%n_alt)
          if (signal_is_pending ())  return
       end do
       if (.not. any (simulation%entry%valid)) then
          call msg_error ("Simulate: no process has a valid matrix element.")
          simulation%valid = .false.
          return
       end if
       call simulation%update_processes ()
       allocate (simulation%alt_entry (simulation%n_prc, simulation%n_alt))
       allocate (simulation%md5sum_alt (simulation%n_alt))
       simulation%md5sum_alt = ""
       do j = 1, simulation%n_alt
          do i = 1, simulation%n_prc
             call simulation%alt_entry(i,j)%init_alt (process_id(i), &
                  simulation%entry(i)%get_process_ptr (), alt_env(j))
             if (signal_is_pending ())  return
          end do
       end do
       call simulation%restore_processes ()
    else       
       do i = 1, simulation%n_prc
          call simulation%entry(i)%init &
               (process_id(i), integrate, generate, global, local)
          if (signal_is_pending ())  return          
       end do
       if (.not. any (simulation%entry%valid)) then
          call msg_error ("Simulate: " &
               // "no process has a valid matrix element.") 
          simulation%valid = .false.
          return
       end if
    end if
    call dispatch_rng_factory (rng_factory, global)
    call rng_factory%make (simulation%rng)
    if (all (simulation%entry%has_integral)) then
       simulation%integral = sum (simulation%entry%integral)
       simulation%error = sqrt (sum (simulation%entry%error ** 2))
       simulation%has_integral = .true.
       if (integrate .and. generate) then
          do i = 1, simulation%n_prc
             if (simulation%entry(i)%integral < 0 .and. .not. &
                  simulation%negative_weights) then
                call msg_fatal ("Integral of process '" // &
                     char (process_id (i)) // "'is negative.")
             end if
          end do
       end if
    else
       if (integrate .and. generate) &
            call msg_error ("Simulation contains undefined integrals.")
    end if
    if (simulation%integral > 0 .or. &
         (simulation%integral < 0 .and. simulation%negative_weights)) then
       simulation%valid = .true.
    else if (generate) then
       call msg_error ("Simulate: " &
            // "sum of process integrals must be positive; skipping.")
       simulation%valid = .false.
       return
    end if
    if (simulation%valid)  call simulation%compute_md5sum ()
  end subroutine simulation_init

@ %def simulation_init
@ The number of events that we want to simulate is determined by the
settings of [[n_events]], [[luminosity]], and [[?unweighted]].  For
weighted events, we take [[n_events]] at face value as the number of
matrix element calls.  For unweighted events, if the process is a
decay, [[n_events]] is the number of unweighted events.  In these
cases, the luminosity setting is ignored.  

For unweighted events with a scattering process, we calculate the
event number that corresponds to the luminosity, given the current
value of the integral.  We then compare this with [[n_events]] and
choose the larger number.
<<Simulations: simulation: TBP>>=
  procedure :: compute_n_events => simulation_compute_n_events
<<Simulations: procedures>>=
  subroutine simulation_compute_n_events (simulation, n_events, var_list)
    class(simulation_t), intent(in) :: simulation
    integer, intent(out) :: n_events
    type(var_list_t) :: var_list
    real(default) :: lumi, x_events_lumi
    integer :: n_events_lumi
    logical :: is_scattering
    n_events = var_list_get_ival (var_list, var_str ("n_events"))
    lumi = var_list_get_rval (var_list, var_str ("luminosity"))
    if (simulation%unweighted) then
       is_scattering = simulation%entry(1)%n_in == 2
       if (is_scattering) then
          x_events_lumi = abs (simulation%integral * lumi)
          if (x_events_lumi < huge (n_events)) then
             n_events_lumi = nint (x_events_lumi)
          else
             call msg_message ("Simulation: luminosity too large, &
                  &limiting number of events")
             n_events_lumi = huge (n_events)
          end if
          if (n_events_lumi > n_events) then
             call msg_message ("Simulation: using n_events as computed from &
                  &luminosity value")
             n_events = n_events_lumi
          else
             write (msg_buffer, "(A,1x,I0)") &
                  "Simulation: requested number of events =", n_events
             call msg_message ()
             write (msg_buffer, "(A,1x,ES11.4)") &
                  "            corr. to luminosity [fb-1] = ", &
                   n_events / simulation%integral            
             call msg_message ()
          end if
       end if
    end if
  end subroutine simulation_compute_n_events

@ %def simulation_compute_n_events
@ Compute the checksum of the process set.  We retrieve the MD5 sums
of all processes.  This depends only on the process definitions, while
parameters are not considered.  The configuration checksum is
retrieved from the MCI records in the process objects and furthermore
includes beams, parameters, integration results, etc., so matching the
latter should guarantee identical physics.
<<Simulations: simulation: TBP>>=
  procedure :: compute_md5sum => simulation_compute_md5sum
<<Simulations: procedures>>=
  subroutine simulation_compute_md5sum (simulation)
    class(simulation_t), intent(inout) :: simulation
    type(process_t), pointer :: process
    type(string_t) :: buffer
    integer :: j, i, n_mci, i_mci, n_component, i_component
    if (simulation%md5sum_prc == "") then
       buffer = ""
       do i = 1, simulation%n_prc
          if (.not. simulation%entry(i)%valid) cycle
          process => simulation%entry(i)%get_process_ptr ()
          n_component = process%get_n_components ()
          do i_component = 1, n_component
             if (process%has_matrix_element (i_component)) then
                buffer = buffer // process%get_md5sum_prc (i_component)
             end if
          end do
       end do
       simulation%md5sum_prc = md5sum (char (buffer))
    end if
    if (simulation%md5sum_cfg == "") then
       buffer = ""
       do i = 1, simulation%n_prc
          if (.not. simulation%entry(i)%valid) cycle          
          process => simulation%entry(i)%get_process_ptr ()
          n_mci = process%get_n_mci ()
          do i_mci = 1, n_mci
             buffer = buffer // process%get_md5sum_mci (i_mci)
          end do
       end do
       simulation%md5sum_cfg = md5sum (char (buffer))
    end if
    do j = 1, simulation%n_alt
       if (simulation%md5sum_alt(j) == "") then
          buffer = ""
          do i = 1, simulation%n_prc
             process => simulation%alt_entry(i,j)%get_process_ptr ()
             buffer = buffer // process%get_md5sum_cfg ()
          end do
          simulation%md5sum_alt(j) = md5sum (char (buffer))
       end if
    end do
  end subroutine simulation_compute_md5sum

@ %def simulation_compute_md5sum
@ Initialize the process selector, using the entry integrals as process
weights.
<<Simulations: simulation: TBP>>=
  procedure :: init_process_selector => simulation_init_process_selector
<<Simulations: procedures>>=
  subroutine simulation_init_process_selector (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i
    if (simulation%has_integral) then
       call simulation%process_selector%init (simulation%entry%integral)
       do i = 1, simulation%n_prc
          associate (entry => simulation%entry(i))
            if (.not. entry%valid) then
               call msg_warning ("Process '" // char (entry%process_id) // &
                    "': matrix element vanishes, no events can be generated.")
               cycle
            end if
            call entry%init_mci_selector ()
            entry%process_weight = simulation%process_selector%get_weight (i)
          end associate
       end do
    end if
  end subroutine simulation_init_process_selector
    
@ %def simulation_init_process_selector
@ Select a process, using the random-number generator.
<<Simulations: simulation: TBP>>=
  procedure :: select_prc => simulation_select_prc
<<Simulations: procedures>>=
  function simulation_select_prc (simulation) result (i_prc)
    class(simulation_t), intent(inout) :: simulation
    integer :: i_prc
    call simulation%process_selector%generate (simulation%rng, i_prc)
  end function simulation_select_prc

@ %def simulation_select_prc
@ Select a MCI set for the selected process.
<<Simulations: simulation: TBP>>=
  procedure :: select_mci => simulation_select_mci
<<Simulations: procedures>>=
  function simulation_select_mci (simulation) result (i_mci)
    class(simulation_t), intent(inout) :: simulation
    integer :: i_mci
    if (simulation%i_prc /= 0) then
       i_mci = simulation%entry(simulation%i_prc)%select_mci ()
    end if
  end function simulation_select_mci

@ %def simulation_select_mci
@ Generate a predefined number of events.  First select a process and
a component set, then generate an event for that process and factorize
the quantum state.  The pair of random numbers can be used for
factorization.

When generating events, we drop all configurations where the event is
marked as incomplete.  This happens if the event fails cuts.  In fact,
such events are dropped already by the sampler if unweighting is in
effect, so this can happen only for weighted events.  By setting a
limit given by [[sample_max_tries]] (user parameter), we can avoid an
endless loop.
<<Simulations: simulation: TBP>>=
  procedure :: generate => simulation_generate
<<Simulations: procedures>>=
  subroutine simulation_generate (simulation, n, es_array)
    class(simulation_t), intent(inout) :: simulation
    integer, intent(in) :: n
    type(event_stream_array_t), intent(inout), optional :: es_array
    type(string_t) :: str1, str2, str3
    logical :: generate_new
    integer :: i, j
    simulation%n_evt_requested = n
    call simulation%entry%set_n (n)
    if (simulation%n_alt > 0)  call simulation%alt_entry%set_n (n)
    str1 = "Events: generating"
    if (present (es_array)) then
       if (es_array%has_input ())  str1 = "Events: reading"
    end if
    if (simulation%entry(1)%config%unweighted) then
       str2 = "unweighted"
    else
       str2 = "weighted"
    end if
    if (simulation%entry(1)%config%factorization_mode == &
         FM_IGNORE_HELICITY) then
       str3 = ", unpolarized"
    else 
       str3 = ", polarized"
    end if    
    write (msg_buffer, "(A,1x,I0,1x,A,1x,A)")  char (str1), n, &
         char (str2) // char(str3), "events ..."
    call msg_message ()
    write (msg_buffer, "(A,1x,A)") "Events: event normalization mode", &
         char (event_normalization_string (simulation%norm_mode))
    call msg_message ()
    do i = 1, n
       if (present (es_array)) then
          call simulation%read_event (es_array, .true., generate_new)
       else
          generate_new = .true.
       end if
       if (generate_new) then
          simulation%i_prc = simulation%select_prc ()
          simulation%i_mci = simulation%select_mci ()
          associate (entry => simulation%entry(simulation%i_prc))
            do j = 1, simulation%n_max_tries
               if (.not. entry%valid)  call msg_warning &
                       ("Process '" // char (entry%process_id) // "': " // &
                       "matrix element vanishes, no events can be generated.")
               call entry%generate (simulation%i_mci)
               if (signal_is_pending ()) return
               if (entry%particle_set_exists)  exit
            end do
            if (.not. entry%particle_set_exists) then
               write (msg_buffer, "(A,I0,A)")  "Simulation: failed to &
                    &generate valid event after ", &
                    simulation%n_max_tries, " tries (sample_max_tries)"
               call msg_fatal ()
            end if
            call entry%evaluate_expressions ()
            if (signal_is_pending ()) return
            simulation%weight = entry%weight_ref
            simulation%excess = entry%excess_prc
            call simulation%counter%record &
                 (simulation%weight, simulation%excess)
            call entry%record (simulation%i_mci)
          end associate
       else
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%accept_sqme_ref ()
            call entry%accept_weight_ref ()
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ()) return
            simulation%weight = entry%weight_ref
            simulation%excess = entry%excess_prc
            call simulation%counter%record &
                 (simulation%weight, simulation%excess, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       end if
       call simulation%calculate_alt_entries ()
       if (signal_is_pending ()) return
       if (simulation%pacify)  call pacify (simulation)
       if (present (es_array)) then
          call simulation%write_event (es_array)
       end if
    end do
    call msg_message ("        ... event sample complete.")
    call simulation%counter%show_excess ()
  end subroutine simulation_generate
  
@ %def simulation_generate
@ Compute the event matrix element and weight for all alternative
environments, given the current event and selected process.  We first
copy the particle set, then temporarily update the process core with
local parameters, recalculate everything, and restore the process
core.

The event weight is obtained by rescaling the original event weight with the
ratio of the new and old [[sqme]] values.  (In particular, if the old
value was zero, the weight will stay zero.)

Note: this may turn out to be inefficient because we always replace
all parameters and recalculate everything, once for each event and
environment.  However, a more fine-grained control requires more
code.  In any case, while we may keep multiple process cores (which
stay constant for a simulation run), we still have to update the
external matrix element parameters event by event.  The matrix element
``object'' is present only once.
<<Simulations: simulation: TBP>>=
  procedure :: calculate_alt_entries => simulation_calculate_alt_entries
<<Simulations: procedures>>=
  subroutine simulation_calculate_alt_entries (simulation)
    class(simulation_t), intent(inout) :: simulation
    real(default) :: factor
    real(default), dimension(:), allocatable :: sqme_alt, weight_alt
    integer :: n_alt, i, j
    i = simulation%i_prc
    n_alt = simulation%n_alt
    if (n_alt == 0)  return
    allocate (sqme_alt (n_alt), weight_alt (n_alt))
    associate (entry => simulation%entry(i))
      do j = 1, n_alt
         if (signal_is_pending ())  return
         factor = entry%get_kinematical_weight ()
         associate (alt_entry => simulation%alt_entry(i,j))
           call alt_entry%update_process ()
           call alt_entry%select &
                (entry%get_i_mci (), entry%get_i_term (), entry%get_channel ())
           call alt_entry%fill_particle_set (entry)
           call alt_entry%recalculate &
                (update_sqme = .true., weight_factor = factor)
           if (signal_is_pending ())  return
           call alt_entry%accept_sqme_prc ()
           call alt_entry%update_normalization ()
           call alt_entry%accept_weight_prc ()
           call alt_entry%check ()
           call alt_entry%evaluate_expressions ()
           if (signal_is_pending ())  return
           call alt_entry%restore_process ()
           sqme_alt(j) = alt_entry%sqme_ref
           weight_alt(j) = alt_entry%weight_ref
         end associate
      end do
      call entry%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
      call entry%check ()
      call entry%store_alt_values ()
    end associate
  end subroutine simulation_calculate_alt_entries
       
@ %def simulation_calculate_alt_entries
@ Rescan an undefined number of events.

If [[update_event]] or [[update_sqme]] is set, we have to recalculate the
event, starting from the particle set.  If the latter is set, this includes
the squared matrix element (i.e., the amplitude is evaluated).  Otherwise,
only kinematics and observables derived from it are recovered.

If any of the update flags is set, we will come up with separate
[[sqme_prc]] and [[weight_prc]] values.  (The latter is only distinct
if [[update_weight]] is set.)  Otherwise, we accept the reference values.
<<Simulations: simulation: TBP>>=
  procedure :: rescan => simulation_rescan
<<Simulations: procedures>>=
  subroutine simulation_rescan &
       (simulation, n, es_array, update_event, update_sqme, update_weight, &
       recover_beams, global)
    class(simulation_t), intent(inout) :: simulation
    integer, intent(in) :: n
    type(event_stream_array_t), intent(inout) :: es_array
    logical, intent(in) :: update_event, update_sqme, update_weight
    logical, intent(in) :: recover_beams
    type(rt_data_t), intent(inout) :: global
    type(qcd_t) :: qcd
    type(string_t) :: str1, str2, str3
    logical :: complete
    str1 = "Rescanning"
    if (simulation%entry(1)%config%unweighted) then
       str2 = "unweighted"
    else
       str2 = "weighted"
    end if
    simulation%n_evt_requested = n
    call simulation%entry%set_n (n)
    if (update_sqme .or. update_weight) then
       call dispatch_qcd (qcd, global)
       call simulation%update_processes &
            (global%model, qcd, global%get_helicity_selection ())
       str3 = "(process parameters updated) "
    else
       str3 = ""
    end if
    write (msg_buffer, "(A,1x,A,1x,A,A,A)")  char (str1), char (str2), &
         "events ", char (str3), "..."
    call msg_message ()
    do
       call simulation%read_event (es_array, .false., complete)
       if (complete)  exit
       if (update_event .or. update_sqme .or. update_weight) then
          call simulation%recalculate (update_sqme, update_weight, &
               recover_beams)
          if (signal_is_pending ())  return
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%update_normalization ()
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ())  return
            simulation%weight = entry%weight_prc
            call simulation%counter%record (simulation%weight, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       else
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%accept_sqme_ref ()
            call entry%accept_weight_ref ()
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ())  return
            simulation%weight = entry%weight_ref
            call simulation%counter%record (simulation%weight, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       end if
       call simulation%calculate_alt_entries ()
       if (signal_is_pending ())  return
       call simulation%write_event (es_array)
    end do
    if (update_sqme .or. update_weight) then
       call simulation%restore_processes ()
    end if
  end subroutine simulation_rescan
  
@ %def simulation_rescan
@ These routines take care of temporary parameter redefinitions that
we want to take effect while recalculating the matrix elements.  We
extract the core(s) of the processes that we are simulating, apply the
changes, and make sure that the changes are actually used.  This is
the duty of [[dispatch_core_update]].  When done, we restore the
original versions using [[dispatch_core_restore]].
<<Simulations: simulation: TBP>>=
  procedure :: update_processes => simulation_update_processes
  procedure :: restore_processes => simulation_restore_processes
<<Simulations: procedures>>=
  subroutine simulation_update_processes (simulation, &
       model, qcd, helicity_selection)
    class(simulation_t), intent(inout) :: simulation
    type(model_t), intent(in), optional, target :: model
    type(qcd_t), intent(in), optional :: qcd
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    integer :: i
    do i = 1, simulation%n_prc
       call simulation%entry(i)%update_process (model, qcd, helicity_selection)
    end do
  end subroutine simulation_update_processes
  
  subroutine simulation_restore_processes (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i
    do i = 1, simulation%n_prc
       call simulation%entry(i)%restore_process ()
    end do
  end subroutine simulation_restore_processes
  
@ %def simulation_update_processes
@ %def simulation_restore_processes
@ 
\subsection{Event Stream I/O} 
Write an event to a generic [[eio]] event stream.  The process index
must be selected, or the current index must be available.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_eio
  procedure :: write_event_eio => simulation_write_event_eio
<<Simulations: procedures>>=
  subroutine simulation_write_event_eio (object, eio, i_prc)
    class(simulation_t), intent(in) :: object
    class(eio_t), intent(inout) :: eio
    integer, intent(in), optional :: i_prc
    integer :: current
    if (present (i_prc)) then
       current = i_prc
    else
       current = object%i_prc
    end if
    if (current > 0) then
       if (object%split_n_evt > 0) then
          if (object%counter%total > 1 .and. &
               mod (object%counter%total, object%split_n_evt) == 1) then
             call eio%split_out ()
          end if
       end if
       call eio%output (object%entry(current)%event_t, current)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_eio

@ %def simulation_write_event
@
Read an event from a generic [[eio]] event stream.  The event stream element
must specify the process within the sample ([[i_prc]]), the MC group for this
process ([[i_mci]]), the selected term ([[i_term]]), the selected MC
integration [[channel]], and the particle set of the event.

We may encounter EOF, which we indicate by storing 0 for the process index
[[i_prc]].  An I/O error will be reported, and we also abort reading.
<<Simulations: simulation: TBP>>=
  generic :: read_event => read_event_eio
  procedure :: read_event_eio => simulation_read_event_eio
<<Simulations: procedures>>=
  subroutine simulation_read_event_eio (object, eio)
    class(simulation_t), intent(inout) :: object
    class(eio_t), intent(inout) :: eio
    integer :: iostat, current
    call eio%input_i_prc (current, iostat)
    select case (iostat)
    case (0)
       object%i_prc = current
       call eio%input_event (object%entry(current)%event_t, iostat)
    end select
    select case (iostat)
    case (:-1)
       object%i_prc = 0
       object%i_mci = 0
    case (1:)
       call msg_error ("Reading events: I/O error, aborting read")
       object%i_prc = 0
       object%i_mci = 0
    case default
       object%i_mci = object%entry(current)%get_i_mci ()
    end select
  end subroutine simulation_read_event_eio

@ %def simulation_read_event
@ 
\subsection{Event Stream Array} 
Write an event using an array of event I/O streams.
The process index must be selected, or the current index must be
available.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_es_array
  procedure :: write_event_es_array => simulation_write_event_es_array
<<Simulations: procedures>>=
  subroutine simulation_write_event_es_array (object, es_array)
    class(simulation_t), intent(in) :: object
    class(event_stream_array_t), intent(inout) :: es_array
    integer :: i_prc, event_index
    i_prc = object%i_prc
    if (i_prc > 0) then
       event_index = object%counter%total
       call es_array%output (object%entry(i_prc)%event_t, i_prc, event_index)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_es_array

@ %def simulation_write_event
@ Read an event using an array of event I/O streams.  Reading is
successful if there is an input stream within the array, and if a
valid event can be read from that stream.  If there is a stream, but
EOF is passed when reading the first item, we switch the channel to
output and return failure but no error message, such that new events
can be appended to that stream.
<<Simulations: simulation: TBP>>=
  generic :: read_event => read_event_es_array
  procedure :: read_event_es_array => simulation_read_event_es_array
<<Simulations: procedures>>=
  subroutine simulation_read_event_es_array (object, es_array, enable_switch, &
       fail)
    class(simulation_t), intent(inout) :: object
    class(event_stream_array_t), intent(inout) :: es_array
    logical, intent(in) :: enable_switch
    logical, intent(out) :: fail
    integer :: iostat, i_prc
    if (es_array%has_input ()) then
       fail = .false.
       call es_array%input_i_prc (i_prc, iostat)
       select case (iostat)
       case (0)
          object%i_prc = i_prc
          call es_array%input_event (object%entry(i_prc)%event_t, iostat)
       case (:-1)
          write (msg_buffer, "(A,1x,I0,1x,A)")  &
               "... event file terminates after", &
               object%counter%read, "events."
          call msg_message ()
          if (enable_switch) then
             call es_array%switch_inout ()
             write (msg_buffer, "(A,1x,I0,1x,A)")  &
                  "Generating remaining ", &
                  object%n_evt_requested - object%counter%read, "events ..."
             call msg_message ()
          end if
          fail = .true.
          return
       end select
       select case (iostat)
       case (0)
          object%i_mci = object%entry(i_prc)%get_i_mci ()
       case default
          write (msg_buffer, "(A,1x,I0,1x,A)")  &
               "Reading events: I/O error, aborting read after", &
               object%counter%read, "events."
          call msg_error ()
          object%i_prc = 0
          object%i_mci = 0
          fail = .true.
       end select
    else
       fail = .true.
    end if
  end subroutine simulation_read_event_es_array

@ %def simulation_read_event
@
\subsection{Recover event}
Recalculate the process instance contents, given an event with known particle
set.  The indices for MC, term, and channel must be already set.  The
[[recalculate]] method of the selected entry will import the result
into [[sqme_prc]] and [[weight_prc]].
<<Simulations: simulation: TBP>>=
  procedure :: recalculate => simulation_recalculate
<<Simulations: procedures>>=
  subroutine simulation_recalculate (simulation, update_sqme, update_weight, &
       recover_beams)
    class(simulation_t), intent(inout) :: simulation
    logical, intent(in) :: update_sqme, update_weight
    logical, intent(in), optional :: recover_beams
    integer :: i_prc
    i_prc = simulation%i_prc
    associate (entry => simulation%entry(i_prc))
      if (update_weight) then
         call simulation%entry(i_prc)%recalculate &
              (update_sqme = update_sqme, recover_beams = recover_beams, &
              weight_factor = entry%get_kinematical_weight ())
      else
         call simulation%entry(i_prc)%recalculate &
              (update_sqme = update_sqme, recover_beams = recover_beams)
      end if
    end associate
  end subroutine simulation_recalculate

@ %def simulation_recalculate
@
\subsection{Extract contents}
Return an array of pointers to the currently selected processes.
<<Simulations: simulation: TBP>>=
  procedure :: get_process_ptr => simulation_get_process_ptr
<<Simulations: procedures>>=
  function simulation_get_process_ptr (simulation) result (ptr)
    class(simulation_t), intent(in) :: simulation
    type(process_ptr_t), dimension(:), allocatable :: ptr
    integer :: i
    allocate (ptr (simulation%n_prc))
    do i = 1, size (ptr)
       ptr(i)%ptr => simulation%entry(i)%get_process_ptr ()
    end do
  end function simulation_get_process_ptr
    
@ %def simulation_get_process_ptr
@ Return the MD5 sum that summarizes configuration and integration
(but not the event file).  Used for initializing the event streams.
<<Simulations: simulation: TBP>>=
  procedure :: get_md5sum_prc => simulation_get_md5sum_prc
  procedure :: get_md5sum_cfg => simulation_get_md5sum_cfg
  procedure :: get_md5sum_alt => simulation_get_md5sum_alt
<<Simulations: procedures>>=
  function simulation_get_md5sum_prc (simulation) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    character(32) :: md5sum
    md5sum = simulation%md5sum_prc
  end function simulation_get_md5sum_prc
    
  function simulation_get_md5sum_cfg (simulation) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    character(32) :: md5sum
    md5sum = simulation%md5sum_cfg
  end function simulation_get_md5sum_cfg
    
  function simulation_get_md5sum_alt (simulation, i) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    integer, intent(in) :: i
    character(32) :: md5sum
    md5sum = simulation%md5sum_alt(i)
  end function simulation_get_md5sum_alt
    
@ %def simulation_get_md5sum_prc
@ %def simulation_get_md5sum_cfg
@ Return data that may be useful for writing event files..
<<Simulations: simulation: TBP>>=
  procedure :: get_data => simulation_get_data
<<Simulations: procedures>>=
  function simulation_get_data (simulation, alt) result (data)
    class(simulation_t), intent(in) :: simulation
    logical, intent(in), optional :: alt
    type(event_sample_data_t) :: data
    type(process_t), pointer :: process
    type(beam_data_t), pointer :: beam_data
    integer :: n, i
    logical :: enable_alt
    enable_alt = .true.;  if (present (alt))  enable_alt = alt    
    process => simulation%entry(1)%get_process_ptr ()
    beam_data => process%get_beam_data_ptr ()
    if (enable_alt) then
       call data%init (simulation%n_prc, simulation%n_alt)
       do i = 1, simulation%n_alt
          data%md5sum_alt(i) = simulation%get_md5sum_alt (i)
       end do
    else
       call data%init (simulation%n_prc)
    end if
    data%unweighted = simulation%unweighted
    data%negative_weights = simulation%negative_weights
    data%norm_mode = simulation%norm_mode
    n = beam_data_get_n_in (beam_data)
    data%n_beam = n
    data%pdg_beam(:n) = flavor_get_pdg (beam_data_get_flavor (beam_data))
    data%energy_beam(:n) = beam_data_get_energy (beam_data)
    do i = 1, simulation%n_prc
       if (.not. simulation%entry(i)%valid) cycle
       process => simulation%entry(i)%get_process_ptr ()
       data%proc_num_id(i) = process%get_num_id ()
       if (data%proc_num_id(i) == 0)  data%proc_num_id(i) = i
       if (simulation%entry(i)%has_integral) then
          data%cross_section(i) = simulation%entry(i)%integral
          data%error(i) = simulation%entry(i)%error
       end if
    end do
    data%total_cross_section = sum (data%cross_section)
    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    if (simulation%split_n_evt > 0) then
       data%split_n_evt = simulation%split_n_evt
       data%split_index = simulation%split_index
    end if
  end function simulation_get_data
    
@ %def simulation_get_data
@ Return a default name for the current event sample.  This is the
process ID of the first process.
<<Simulations: simulation: TBP>>=
  procedure :: get_default_sample_name => simulation_get_default_sample_name
<<Simulations: procedures>>=
  function simulation_get_default_sample_name (simulation) result (sample)
    class(simulation_t), intent(in) :: simulation
    type(string_t) :: sample
    type(process_t), pointer :: process
    sample = "whizard"
    if (simulation%n_prc > 0) then
       process => simulation%entry(1)%get_process_ptr ()
       if (associated (process)) then
          sample = process%get_id ()
       end if
    end if
  end function simulation_get_default_sample_name

@ %def simulation_get_default_sample_name
@
<<Simulations: simulation: TBP>>=
  procedure :: is_valid => simulation_is_valid
<<Simulations: procedures>>=
  function simulation_is_valid (simulation) result (valid)
    class(simulation_t), intent(inout) :: simulation
    logical :: valid
    valid = simulation%valid
  end function simulation_is_valid

@ %def simulation_is_valid
@ 
\subsection{Auxiliary}
Call pacify: eliminate numerical noise.
<<Simulations: interfaces>>=
  interface pacify
     module procedure pacify_simulation
  end interface
<<Simulations: procedures>>=
  subroutine pacify_simulation (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i, j
    i = simulation%i_prc
    if (i > 0) then
       call pacify (simulation%entry(i))
       do j = 1, simulation%n_alt
          call pacify (simulation%alt_entry(i,j))
       end do
    end if
  end subroutine pacify_simulation
  
@ %def pacify_simulation
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Simulations: public>>=
  public :: simulations_test
<<Simulations: tests>>=
  subroutine simulations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Simulations: execute tests>>
  end subroutine simulations_test

@ %def simulations_test
@ 
\subsubsection{Initialization}
Initialize a [[simulation_t]] object, including the embedded event records.
<<Simulations: execute tests>>=
  call test (simulations_1, "simulations_1", &
       "initialization", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, procname2
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_1"
    write (u, "(A)")  "*   Purpose: initialize simulation"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_1a"
    procname1 = "simulation_1p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global)

    libname = "simulation_1b"
    procname2 = "sim_extra"
    
    call prepare_test_library (global, libname, 1, [procname2])
    call compile_library (libname, global)
    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations2"), is_known = .true.)


    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$sample"), &
         var_str ("sim1"), is_known = .true.)
    call integrate_process (procname2, global)

    call simulation%init ([procname1, procname2], .true., .true., global)
    call simulation%init_process_selector ()
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the first process"
    write (u, "(A)")
    
    call simulation%write_event (u, i_prc = 1)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_1"
    
  end subroutine simulations_1
  
@ %def simulations_1
@ 
\subsubsection{Weighted events}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_2, "simulations_2", &
       "weighted events", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_2"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_2a"
    procname1 = "simulation_2p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_2"
    
  end subroutine simulations_2
  
@ %def simulations_2
@ 
\subsubsection{Unweighted events}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_3, "simulations_3", &
       "unweighted events", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_3"
    write (u, "(A)")  "*   Purpose: generate unweighted events &
         &for a single process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_3a"
    procname1 = "simulation_3p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_3"
    
  end subroutine simulations_3
  
@ %def simulations_3
@ 
\subsubsection{Simulating process with structure functions}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_4, "simulations_4", &
       "process with structure functions", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_4 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(flavor_t) :: flv
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_4"
    write (u, "(A)")  "*   Purpose: generate events for a single process &
         &with structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_4a"
    procname1 = "simulation_4p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    call reset_interaction_counter ()

    call flavor_init (flv, 25, global%model)
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         var_str ("simulations4"), is_known = .true.)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_4"
    
  end subroutine simulations_4
  
@ %def simulations_4
@ 
\subsubsection{Event I/O}
Generate event for a test process, write to file and reread.
<<Simulations: execute tests>>=
  call test (simulations_5, "simulations_5", &
       "raw event I/O", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_5 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(process_ptr_t) :: process_ptr
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_5"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_5a"
    procname1 = "simulation_5p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)   
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations5"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations5"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    process_ptr%ptr => global%process_stack%get_process_ptr (procname1)
    
    allocate (eio_raw_t :: eio)
    call eio%init_out (sample, [process_ptr])
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write_event (u)
    call simulation%write_event (eio)

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()
    allocate (eio_raw_t :: eio)
    call eio%init_in (sample, [process_ptr])
    
    call simulation%read_event (eio)
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recalculate process instance"
    write (u, "(A)")

    call simulation%recalculate (update_sqme = .true., update_weight = .true.)
    call simulation%entry(simulation%i_prc)%evaluate_expressions ()
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_5"
    
  end subroutine simulations_5
  
@ %def simulations_5
@ 
\subsubsection{Event I/O}
Generate event for a real process with structure functions, write to file and
reread.
<<Simulations: execute tests>>=
  call test (simulations_6, "simulations_6", &
       "raw event I/O with structure functions", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_6 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(process_ptr_t) :: process_ptr
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    
    write (u, "(A)")  "* Test output: simulations_6"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_6"
    procname1 = "simulation_6p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call flavor_init (flv, 25, global%model)
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations6"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    process_ptr%ptr => global%process_stack%get_process_ptr (procname1)
    
    allocate (eio_raw_t :: eio)
    call eio%init_out (sample, [process_ptr])
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)
    call simulation%write_event (eio)

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()
    allocate (eio_raw_t :: eio)
    call eio%init_in (sample, [process_ptr])
    
    call simulation%read_event (eio)
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Recalculate process instance"
    write (u, "(A)")

    call simulation%recalculate (update_sqme = .true., update_weight = .true.)
    call simulation%entry(simulation%i_prc)%evaluate_expressions ()
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_6"
    
  end subroutine simulations_6
  
@ %def simulations_6
@ 
\subsubsection{Automatic Event I/O}
Generate events with raw-format event file as cache: generate, reread,
append.
<<Simulations: execute tests>>=
  call test (simulations_7, "simulations_7", &
       "automatic raw event I/O", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_7 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    
    write (u, "(A)")  "* Test output: simulations_7"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_7"
    procname1 = "simulation_7p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call flavor_init (flv, 25, global%model)
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations7"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init &
         (sample, [var_str ("raw")], simulation%get_process_ptr (), global, &
         data)
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")  "* Re-read the event from file and generate another one"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, &
         var_str ("?rebuild_events"), .false., is_known = .true.)

    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init (sample, &
         empty_string_array, simulation%get_process_ptr (), global, data, &
         input = var_str ("raw"))
    
    call simulation%generate (2, es_array)
    
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init (sample, &
         empty_string_array, simulation%get_process_ptr (), global, data, &
         input = var_str ("raw"))

    call simulation%generate (2, es_array)
    
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_7"
    
  end subroutine simulations_7
  
@ %def simulations_7
@ 
\subsubsection{Rescanning Events}
Generate events and rescan the resulting raw event file.
<<Simulations: execute tests>>=
  call test (simulations_8, "simulations_8", &
       "rescan raw event file", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_8 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    
    write (u, "(A)")  "* Test output: simulations_8"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and rescan"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)        

    libname = "simulation_8"
    procname1 = "simulation_8p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)   
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call flavor_init (flv, 25, global%model)
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations8"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init &
         (sample, [var_str ("raw")], simulation%get_process_ptr (), global, &
         data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .false., .false., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, &
         empty_string_array, simulation%get_process_ptr (), global, data, &
         input = var_str ("raw"), input_sample = sample, allow_switch = .false.)
    
    call simulation%rescan (1, es_array, &
         update_event = .false., &
         update_sqme = .false., &
         update_weight = .false., &
         recover_beams = .false., &
         global = global)
    
    write (u, "(A)")

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read again and recalculate"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .false., .false., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, &
         empty_string_array, simulation%get_process_ptr (), global, data, &
         input = var_str ("raw"), input_sample = sample, allow_switch = .false.)
    
    call simulation%rescan (1, es_array, &
         update_event = .true., &
         update_sqme = .true., &
         update_weight = .false., &
         recover_beams = .false., &
         global = global)
    
    write (u, "(A)")

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_8"
    
  end subroutine simulations_8
  
@ %def simulations_8
@ 
\subsubsection{Rescanning Check}
Generate events and rescan with process mismatch.
<<Simulations: execute tests>>=
  call test (simulations_9, "simulations_9", &
       "rescan mismatch", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_9 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    logical :: error
    
    write (u, "(A)")  "* Test output: simulations_9"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and rescan"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_9"
    procname1 = "simulation_9p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call flavor_init (flv, 25, global%model)
    call global%beam_structure%init_sf (flavor_get_name ([flv, flv]), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations9"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init &
         (sample, [var_str ("raw")], simulation%get_process_ptr (), global, &
         data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")  "* Initialize event generation for different parameters"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1, procname1], .false., .false., global)
    call simulation%init_process_selector ()
    
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Attempt to re-read the events (should fail)"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, &
         empty_string_array, simulation%get_process_ptr (), global, data, &
         input = var_str ("raw"), input_sample = sample, &
         allow_switch = .false., error = error)
    
    write (u, "(1x,A,L1)")  "error = ", error
    
    call simulation%rescan (1, es_array, &
         update_event = .false., &
         update_sqme = .false., &
         update_weight = .false., &
         recover_beams = .false., &
         global = global)

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_9"
    
  end subroutine simulations_9
  
@ %def simulations_9
@ 
\subsubsection{Alternative weights}
Generate an event for a single process and reweight it in a
simultaneous calculation.
<<Simulations: execute tests>>=
  call test (simulations_10, "simulations_10", &
       "alternative weight", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_10 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, expr_text
    type(rt_data_t), target :: global
    type(rt_data_t), dimension(1), target :: alt_env
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_weight
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_10"
    write (u, "(A)")  "*   Purpose: reweight event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_pexpr_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_10a"
    procname1 = "simulation_10p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize alternative environment with custom weight"
    write (u, "(A)")
    
    call alt_env(1)%local_init (global)
    call alt_env(1)%link (global)

    expr_text = "2"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    write (u, *)
    
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)
    alt_env(1)%pn%weight_expr => parse_tree_get_root_ptr (pt_weight)
    call alt_env(1)%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    call simulation%init ([procname1], .true., .true., global, alt_env=alt_env)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the alternative setup"
    write (u, "(A)")
    
    call simulation%write_alt_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    call syntax_model_file_final ()
    call syntax_pexpr_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_10"
    
  end subroutine simulations_10
  
@ %def simulations_10
@ 
\subsubsection{Decays}
Generate an event with subsequent partonic decays.
<<Simulations: execute tests>>=
  call test (simulations_11, "simulations_11", &
       "decay", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_11 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prefix, procname1, procname2
    type(simulation_t), target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_11"
    write (u, "(A)")  "*   Purpose: apply decay"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
        
    call global%global_init ()
    allocate (lib)
    call global%add_prclib (lib)

    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)        
    
    prefix = "simulation_11"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (global%prclib, global%process_stack, global%model_list, &
         global%model, prefix, global%os_data, &
         scattering=.true., decay=.true.)
    call global%model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize simulation object"
    write (u, "(A)")

    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write (u)

    write (u, *)
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")

    call simulation%final ()
    call global%final ()
    
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_11"
    
  end subroutine simulations_11
  
@ %def simulations_11
@ 
\subsubsection{Split Event Files}
Generate event for a real process with structure functions and write to file,
accepting a limit for the number of events per file.
<<Simulations: execute tests>>=
  call test (simulations_12, "simulations_12", &
       "split event files", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_12 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(process_ptr_t) :: process_ptr
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    integer :: i_evt
    
    write (u, "(A)")  "* Test output: simulations_12"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            and write to split event files"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_12"
    procname1 = "simulation_12p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    call var_list_set_real (global%var_list, var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("ms"), &
         0._default, is_known = .true.)

    call flavor_init (flv, 25, global%model)

    call global%it_list%init ([1], [1000])

    call var_list_set_string (global%var_list, var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations_12"
    call var_list_set_string (global%var_list, var_str ("$sample"), &
         sample, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("sample_split_n_evt"), &
         2, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("sample_split_index"), &
         42, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize ASCII event file"
    write (u, "(A)")

    process_ptr%ptr => global%process_stack%get_process_ptr (procname1)
    
    allocate (eio_ascii_short_t :: eio)
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, [process_ptr], data = simulation%get_data ())
    
    write (u, "(A)")  "* Generate 5 events, distributed among three files"

    do i_evt = 1, 5
       call simulation%generate (1)
       call simulation%write_event (eio)
    end do

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, *)
    call display_file ("simulations_12.42.short.evt", u)
    write (u, *)
    call display_file ("simulations_12.43.short.evt", u)
    write (u, *)
    call display_file ("simulations_12.44.short.evt", u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_12"
    
  end subroutine simulations_12
  
@ %def simulations_12
@ Auxiliary: display file contents.
<<Simulations: tests>>=
  subroutine display_file (file, u)
    character(*), intent(in) :: file
    integer, intent(in) :: u
    character(256) :: buffer
    integer :: u_file
    write (u, "(3A)")  "* Contents of file '", file, "':"
    write (u, *)
    u_file = free_unit ()
    open (u_file, file = file, action = "read", status = "old")
    do
       read (u_file, "(A)", end = 1)  buffer
       write (u, "(A)")  trim (buffer)
    end do
1   continue
  end subroutine display_file

@ %def display_file
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{More Unit Tests}
\section{Expression Testing}

Expression objects are part of process and event objects, but the
process and event object modules should not depend on the
implementation of expressions.  Here, we collect unit tests that
depend on expression implementation.
<<[[expr_tests.f90]]>>=
<<File header>>
module expr_tests

<<Use kinds>>
<<Use strings>>
  use format_defs, only: FMT_12
  use format_utils, only: write_separator
  use unit_tests
  use os_interface
  use ifiles
  use lexers
  use parser
  use lorentz
  use sm_qcd
  use interactions, only: reset_interaction_counter
  use variables
  use expr_base
  use eval_trees
  use models
  use subevents
  use subevt_expr
  use phs_base
  use rng_base
  use mci_base
  use process_libraries
  use prc_test
  use prc_core
  use processes
  use events

<<Standard module head>>

<<Expr tests: public>>

contains
  
<<Expr tests: tests>>

end module expr_tests
@ %def expr_tests
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Expr tests: public>>=
  public :: subevt_expr_test
<<Expr tests: tests>>=
  subroutine subevt_expr_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Expr tests: execute tests>>
end subroutine subevt_expr_test

@ %def subevt_expr_test
@
\subsubsection{Parton-event expressions}
<<Expr tests: execute tests>>=
  call test (subevt_expr_1, "subevt_expr_1", &
       "parton-event expressions", &
       u, results)
<<Expr tests: tests>>=
  subroutine subevt_expr_1 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_cuts, pt_scale, pt_fac_scale, pt_ren_scale
    type(parse_tree_t) :: pt_weight
    type(parse_node_t), pointer :: pn_cuts, pn_scale, pn_fac_scale, pn_ren_scale
    type(parse_node_t), pointer :: pn_weight
    type(eval_tree_factory_t) :: expr_factory
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    type(parton_expr_t), target :: expr
    real(default) :: E, Ex, m
    type(vector4_t), dimension(6) :: p
    integer :: i, pdg
    logical :: passed
    real(default) :: scale, fac_scale, ren_scale, weight
    
    write (u, "(A)")  "* Test output: subevt_expr_1"
    write (u, "(A)")  "*   Purpose: Set up a subevt and associated &
         &process-specific expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()
    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")


    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "cuts = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_cuts, stream, .true.)
    call stream_final (stream)
    pn_cuts => parse_tree_get_root_ptr (pt_cuts)

    expr_text = "sqrts"
    write (u, "(A,A)")  "scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_scale, stream, .true.)
    call stream_final (stream)
    pn_scale => parse_tree_get_root_ptr (pt_scale)

    expr_text = "sqrts_hat"
    write (u, "(A,A)")  "fac_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_fac_scale, stream, .true.)
    call stream_final (stream)
    pn_fac_scale => parse_tree_get_root_ptr (pt_fac_scale)

    expr_text = "100"
    write (u, "(A,A)")  "ren_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_ren_scale, stream, .true.)
    call stream_final (stream)
    pn_ren_scale => parse_tree_get_root_ptr (pt_ren_scale)

    expr_text = "n_tot - n_in - n_out"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)
    pn_weight => parse_tree_get_root_ptr (pt_weight)

    call ifile_final (ifile)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize process expr"
    write (u, "(A)")

    call expr%setup_vars (1000._default)
    call var_list_append_real (expr%var_list, var_str ("tolerance"), 0._default)
    call expr%link_var_list (model%get_var_list_ptr ())

    call expr_factory%init (pn_cuts)
    call expr%setup_selection (expr_factory)
    call expr_factory%init (pn_scale)
    call expr%setup_scale (expr_factory)
    call expr_factory%init (pn_fac_scale)
    call expr%setup_fac_scale (expr_factory)
    call expr_factory%init (pn_ren_scale)
    call expr%setup_ren_scale (expr_factory)
    call expr_factory%init (pn_weight)
    call expr%setup_weight (expr_factory)

    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Fill subevt and evaluate expressions"
    write (u, "(A)")

    call subevt_init (expr%subevt_t, 6)
    E = 500._default
    Ex = 400._default
    m = 125._default
    pdg = 25
    p(1) = vector4_moving (E, sqrt (E**2 - m**2), 3)
    p(2) = vector4_moving (E, -sqrt (E**2 - m**2), 3)
    p(3) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 3)
    p(4) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 3)
    p(5) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 1)
    p(6) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 1)

    call expr%reset ()
    do i = 1, 2
       call subevt_set_beam (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 3, 4
       call subevt_set_incoming (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 5, 6
       call subevt_set_outgoing (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in = 2
    expr%n_out = 2
    expr%n_tot = 4
    expr%subevt_filled = .true.

    call expr%evaluate (passed, scale, fac_scale, ren_scale, weight)
    
    write (u, "(A,L1)")      "Event has passed      = ", passed
    write (u, "(A," // FMT_12 // ")")  "Scale                 = ", scale
    write (u, "(A," // FMT_12 // ")")  "Factorization scale   = ", fac_scale
    write (u, "(A," // FMT_12 // ")")  "Renormalization scale = ", ren_scale
    write (u, "(A," // FMT_12 // ")")  "Weight                = ", weight
    write (u, "(A)")
    
    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call expr%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: subevt_expr_1"
    
  end subroutine subevt_expr_1
  
@ %def subevt_expr_1
@
\subsubsection{Parton-event expressions}
<<Expr tests: execute tests>>=
  call test (subevt_expr_2, "subevt_expr_2", &
       "parton-event expressions", &
       u, results)
<<Expr tests: tests>>=
  subroutine subevt_expr_2 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_selection
    type(parse_tree_t) :: pt_reweight, pt_analysis
    type(parse_node_t), pointer :: pn_selection
    type(parse_node_t), pointer :: pn_reweight, pn_analysis
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    type(eval_tree_factory_t) :: expr_factory
    type(event_expr_t), target :: expr
    real(default) :: E, Ex, m
    type(vector4_t), dimension(6) :: p
    integer :: i, pdg
    logical :: passed
    real(default) :: reweight
    logical :: analysis_flag
    
    write (u, "(A)")  "* Test output: subevt_expr_2"
    write (u, "(A)")  "*   Purpose: Set up a subevt and associated &
         &process-specific expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()
    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model (var_str ("Test"), &
         var_str ("Test.mdl"), os_data, model)

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")


    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "selection = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_selection, stream, .true.)
    call stream_final (stream)
    pn_selection => parse_tree_get_root_ptr (pt_selection)

    expr_text = "n_tot - n_in - n_out"
    write (u, "(A,A)")  "reweight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_reweight, stream, .true.)
    call stream_final (stream)
    pn_reweight => parse_tree_get_root_ptr (pt_reweight)

    expr_text = "true"
    write (u, "(A,A)")  "analysis = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_analysis, stream, .true.)
    call stream_final (stream)
    pn_analysis => parse_tree_get_root_ptr (pt_analysis)

    call ifile_final (ifile)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize process expr"
    write (u, "(A)")

    call expr%setup_vars (1000._default)
    call expr%link_var_list (model%get_var_list_ptr ())
    call var_list_append_real (expr%var_list, var_str ("tolerance"), 0._default)

    call expr_factory%init (pn_selection)
    call expr%setup_selection (expr_factory)
    call expr_factory%init (pn_analysis)
    call expr%setup_analysis (expr_factory)
    call expr_factory%init (pn_reweight)
    call expr%setup_reweight (expr_factory)

    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Fill subevt and evaluate expressions"
    write (u, "(A)")

    call subevt_init (expr%subevt_t, 6)
    E = 500._default
    Ex = 400._default
    m = 125._default
    pdg = 25
    p(1) = vector4_moving (E, sqrt (E**2 - m**2), 3)
    p(2) = vector4_moving (E, -sqrt (E**2 - m**2), 3)
    p(3) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 3)
    p(4) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 3)
    p(5) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 1)
    p(6) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 1)

    call expr%reset ()
    do i = 1, 2
       call subevt_set_beam (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 3, 4
       call subevt_set_incoming (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 5, 6
       call subevt_set_outgoing (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in = 2
    expr%n_out = 2
    expr%n_tot = 4
    expr%subevt_filled = .true.

    call expr%evaluate (passed, reweight, analysis_flag)
    
    write (u, "(A,L1)")      "Event has passed      = ", passed
    write (u, "(A," // FMT_12 // ")")  "Reweighting factor    = ", reweight
    write (u, "(A,L1)")      "Analysis flag         = ", analysis_flag
    write (u, "(A)")
    
    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call expr%final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: subevt_expr_2"
    
  end subroutine subevt_expr_2
  
@ %def subevt_expr_2
@
\subsubsection{Processes: handle partonic cuts}
Initialize a process and process instance, choose a sampling point and
fill the process instance, evaluating a given cut configuration.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Expr tests: execute tests>>=
  call test (processes_5, "processes_5", &
       "handle cuts (partonic event)", &
       u, results)
<<Expr tests: tests>>=
  subroutine processes_5 (u)
    integer, intent(in) :: u
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    type(eval_tree_factory_t) :: expr_factory
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(var_list_t), target :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_5"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare a cut expression"
    write (u, "(A)")

    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes5"
    procname = libname
    run_id = "run5"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 

    model => process%get_model_ptr ()
    call var_list_init_snapshot (var_list, model%get_var_list_ptr ())
    call var_list_append_real &
         (var_list, var_str ("tolerance"), 0._default)
    call process%set_var_list (var_list)
    call var_list_final (var_list)
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization and set cuts"
    write (u, "(A)")

    call process%setup_terms ()
    call expr_factory%init (parse_tree_get_root_ptr (parse_tree))
    call process%set_cuts (expr_factory)
    call process%write (.false., u, show_var_list=.true., show_expressions=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics and subevt, check cuts (should fail)"
    write (u, "(A)")

    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
   
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set (should succeed)"
    write (u, "(A)")
     
    call process_instance%reset ()
    call process_instance%set_mcpar ([0.5_default, 0.125_default])
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()

    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set using convenience procedure &
         &(failure)"
    write (u, "(A)")
     
    call process_instance%evaluate_sqme (1, [0.0_default, 0.2_default])

    call process_instance%write_header (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set using convenience procedure &
         &(success)"
    write (u, "(A)")
     
    call process_instance%evaluate_sqme (1, [0.1_default, 0.2_default])

    call process_instance%write_header (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()
    
    call model_list%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_5"
    
  end subroutine processes_5
  
@ %def processes_5
@
\subsubsection{Processes: scales and such}
Initialize a process and process instance, choose a sampling point and
fill the process instance, evaluating a given cut configuration.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Expr tests: execute tests>>=
  call test (processes_6, "processes_6", &
       "handle scales and weight (partonic event)", &
       u, results)
<<Expr tests: tests>>=
  subroutine processes_6 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_scale, pt_fac_scale, pt_ren_scale, pt_weight
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_list_t) :: model_list
    type(model_t), pointer :: model
    type(var_list_t), target :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(eval_tree_factory_t) :: expr_factory

    write (u, "(A)")  "* Test output: processes_6"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()

    expr_text = "sqrts - 100 GeV"
    write (u, "(A,A)")  "scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_scale, stream, .true.)
    call stream_final (stream)

    expr_text = "sqrts_hat"
    write (u, "(A,A)")  "fac_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_fac_scale, stream, .true.)
    call stream_final (stream)
    
    expr_text = "eval sqrt (M2) [collect [s]]"
    write (u, "(A,A)")  "ren_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_ren_scale, stream, .true.)
    call stream_final (stream)
    
    expr_text = "n_tot * n_in * n_out * (eval Phi / pi [s])"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)

    call ifile_final (ifile)
    
    write (u, "(A)")
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes4"
    procname = libname
    run_id = "run4"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call syntax_model_file_init ()

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model_list) 

    model => process%get_model_ptr ()
    call var_list_init_snapshot (var_list, model%get_var_list_ptr ())
    call process%set_var_list (var_list)
    call var_list_final (var_list)
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization and set cuts"
    write (u, "(A)")

    call process%setup_terms ()
    call expr_factory%init (parse_tree_get_root_ptr (pt_scale))
    call process%set_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_fac_scale))
    call process%set_fac_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_ren_scale))
    call process%set_ren_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_weight))
    call process%set_weight (expr_factory)
    call process%write (.false., u, show_expressions=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance and evaluate"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, [0.5_default, 0.125_default])

    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call parse_tree_final (pt_scale)
    call parse_tree_final (pt_fac_scale)
    call parse_tree_final (pt_ren_scale)
    call parse_tree_final (pt_weight)
    call syntax_pexpr_final ()

    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_6"
    
  end subroutine processes_6
  
@ %def processes_6
@
\subsubsection{Event expressions}
After generating an event, fill the [[subevt]] and evaluate expressions for
selection, reweighting, and analysis.
<<Expr tests: execute tests>>=
  call test (events_3, "events_3", &
       "expression evaluation", &
       u, results)
<<Expr tests: tests>>=
  subroutine events_3 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_selection, pt_reweight, pt_analysis
    type(eval_tree_factory_t) :: expr_factory
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(model_list_t) :: model_list
    type(model_t), pointer :: model

    write (u, "(A)")  "* Test output: events_3"
    write (u, "(A)")  "*   Purpose: generate an event and evaluate expressions"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_pexpr_init ()

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")

    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "selection = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_selection, stream, .true.)
    call stream_final (stream)

    expr_text = "1 + sqrts_hat / sqrts"
    write (u, "(A,A)")  "reweight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_reweight, stream, .true.)
    call stream_final (stream)
    
    expr_text = "true"
    write (u, "(A,A)")  "analysis = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_analysis, stream, .true.)
    call stream_final (stream)

    call ifile_final (ifile)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize test process event"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model_list)
    model => process%get_model_ptr ()
    call process%set_var_list (model%get_var_list_ptr ())
    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object and set expressions"

    allocate (event)
    call event%basic_init ()

    call expr_factory%init (parse_tree_get_root_ptr (pt_selection))
    call event%set_selection (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_reweight))
    call event%set_reweight (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_analysis))
    call event%set_analysis (expr_factory)
    
    call event%connect (process_instance, process%get_model_ptr ())
    call var_list_append_real &
         (event%expr%var_list, var_str ("tolerance"), 0._default)
    call event%setup_expressions ()

    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process%generate_weighted_event (process_instance, 1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object and evaluate expressions"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model_list%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_3"
    
  end subroutine events_3
  
@ %def events_3
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Top level API}

\section{Commands}
This module defines the command language of the main input file.
<<[[commands.f90]]>>=
<<File header>>

module commands

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use string_utils, only: lower_case
  use format_utils, only: write_indent
  use format_defs, only: FMT_14, FMT_19
  use unit_tests
  use diagnostics
  use sm_qcd
  use pdf_builtin !NODEP!
  use sorting
  use sf_lhapdf
  use os_interface
  use ifiles
  use lexers
  use syntax_rules
  use parser
  use analysis
  use pdg_arrays
  use variables
  use eval_trees
  use models
  use auto_components
  use interactions
  use flavors
  use polarizations
  use beams
  use particle_specifiers
  use process_libraries
  use processes
  use prclib_stacks
  use slha_interface
  use user_files
  use eio_data
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams
  use simulations
  use radiation_generator
  use blha_config

<<Standard module head>>

<<Commands: public>>

<<Commands: types>>

<<Commands: variables>>

<<Commands: parameters>>

<<Commands: interfaces>>

contains

<<Commands: procedures>>

<<Commands: tests>>

end module commands
@ %def commands
@ 
\subsection{The command type}
The command type is a generic type that holds any command, compiled
for execution.

Each command may come with its own local environment.  The command list that
determines this environment is allocated as [[options]], if necessary.  (It
has to be allocated as a pointer because the type definition is recursive.) The
local environment is available as a pointer which either points to the global
environment, or is explicitly allocated and initialized.
<<Commands: types>>=
  type, abstract :: command_t
     type(parse_node_t), pointer :: pn => null ()
     class(command_t), pointer :: next => null ()
     type(parse_node_t), pointer :: pn_opt => null ()
     type(command_list_t), pointer :: options => null ()
     type(rt_data_t), pointer :: local => null ()
   contains
   <<Commands: command: TBP>>
  end type command_t

@ %def command_t
@ Finalizer: If there is an option list, finalize the option list and
deallocate.  If not, the local environment is just a pointer.
<<Commands: command: TBP>>=
  procedure :: final => command_final
<<Commands: procedures>>=
  recursive subroutine command_final (cmd)
    class(command_t), intent(inout) :: cmd
    if (associated (cmd%options)) then
       call cmd%options%final ()
       deallocate (cmd%options)
       call cmd%local%local_final ()
       deallocate (cmd%local)
    else
       cmd%local => null ()
    end if
  end subroutine command_final

@ %def command_final
@ Allocate a command with the appropriate concrete type.  Store the
parse node pointer in the command object, so we can reference to it
when compiling.
<<Commands: procedures>>=
  subroutine dispatch_command (command, pn)
    class(command_t), intent(inout), pointer :: command
    type(parse_node_t), intent(in), target :: pn
    select case (char (parse_node_get_rule_key (pn)))
    case ("cmd_model")
       allocate (cmd_model_t :: command)
    case ("cmd_library")
       allocate (cmd_library_t :: command)
    case ("cmd_process")
       allocate (cmd_process_t :: command)
    case ("cmd_nlo")
       allocate (cmd_nlo_t :: command)
    case ("cmd_compile")
       allocate (cmd_compile_t :: command)
    case ("cmd_exec")
       allocate (cmd_exec_t :: command)
     case ("cmd_num", "cmd_complex", "cmd_real", "cmd_int", &
           "cmd_log_decl", "cmd_log", "cmd_string", "cmd_string_decl", &
           "cmd_alias", "cmd_result")
       allocate (cmd_var_t :: command)
    case ("cmd_slha")
       allocate (cmd_slha_t :: command)
    case ("cmd_show")
       allocate (cmd_show_t :: command)
    case ("cmd_clear")
       allocate (cmd_clear_t :: command)
    case ("cmd_expect")
       allocate (cmd_expect_t :: command)
    case ("cmd_beams")
       allocate (cmd_beams_t :: command)
    case ("cmd_beams_pol_density")
       allocate (cmd_beams_pol_density_t :: command)
    case ("cmd_beams_pol_fraction")
       allocate (cmd_beams_pol_fraction_t :: command)
    case ("cmd_beams_momentum")
       allocate (cmd_beams_momentum_t :: command)
    case ("cmd_beams_theta")
       allocate (cmd_beams_theta_t :: command)
    case ("cmd_beams_phi")
       allocate (cmd_beams_phi_t :: command)
    case ("cmd_cuts")
       allocate (cmd_cuts_t :: command)
    case ("cmd_scale")
       allocate (cmd_scale_t :: command)
    case ("cmd_fac_scale")
       allocate (cmd_fac_scale_t :: command)
    case ("cmd_ren_scale")
       allocate (cmd_ren_scale_t :: command)
    case ("cmd_weight")
       allocate (cmd_weight_t :: command)
    case ("cmd_selection")
       allocate (cmd_selection_t :: command)
    case ("cmd_reweight")
       allocate (cmd_reweight_t :: command)
    case ("cmd_iterations")
       allocate (cmd_iterations_t :: command)
    case ("cmd_integrate")
       allocate (cmd_integrate_t :: command)
    case ("cmd_observable")
       allocate (cmd_observable_t :: command)
    case ("cmd_histogram")
       allocate (cmd_histogram_t :: command)
    case ("cmd_plot")
       allocate (cmd_plot_t :: command)
    case ("cmd_graph")
       allocate (cmd_graph_t :: command)
    case ("cmd_record")
       allocate (cmd_record_t :: command)
    case ("cmd_analysis")
       allocate (cmd_analysis_t :: command)
    case ("cmd_alt_setup")
       allocate (cmd_alt_setup_t :: command)
    case ("cmd_unstable")
       allocate (cmd_unstable_t :: command)
    case ("cmd_stable")
       allocate (cmd_stable_t :: command)
    case ("cmd_polarized")
       allocate (cmd_polarized_t :: command)
    case ("cmd_unpolarized")
       allocate (cmd_unpolarized_t :: command)
    case ("cmd_sample_format")
       allocate (cmd_sample_format_t :: command)
    case ("cmd_simulate")
       allocate (cmd_simulate_t :: command)
    case ("cmd_rescan")
       allocate (cmd_rescan_t :: command)
    case ("cmd_write_analysis")
       allocate (cmd_write_analysis_t :: command)
    case ("cmd_compile_analysis")
       allocate (cmd_compile_analysis_t :: command)
    case ("cmd_open_out")
       allocate (cmd_open_out_t :: command)
    case ("cmd_close_out")
       allocate (cmd_close_out_t :: command)
    case ("cmd_printf")
       allocate (cmd_printf_t :: command)
    case ("cmd_scan")
       allocate (cmd_scan_t :: command)
    case ("cmd_if")
       allocate (cmd_if_t :: command)
    case ("cmd_include")
       allocate (cmd_include_t :: command)
    case ("cmd_quit")
       allocate (cmd_quit_t :: command)
    case default
       print *, char (parse_node_get_rule_key (pn))
       call msg_bug ("Command not implemented")
    end select
    command%pn => pn
  end subroutine dispatch_command

@ %def dispatch_command
@ Output.  We allow for indentation so we can display a command tree.
<<Commands: command: TBP>>=
  procedure (command_write), deferred :: write
<<Commands: interfaces>>=
  abstract interface
     subroutine command_write (cmd, unit, indent)
       import
       class(command_t), intent(in) :: cmd
       integer, intent(in), optional :: unit, indent
     end subroutine command_write
  end interface
  
@ %def command_write
@ Compile a command.  The command type is already fixed, so this is a
deferred type-bound procedure.
<<Commands: command: TBP>>=
  procedure (command_compile), deferred :: compile
<<Commands: interfaces>>=
  abstract interface
     subroutine command_compile (cmd, global)
       import
       class(command_t), intent(inout) :: cmd
       type(rt_data_t), intent(inout), target :: global
     end subroutine command_compile
  end interface

@ %def command_compile
@ Execute a command.  This will use and/or modify the runtime data
set.  If the [[quit]] flag is set, the caller should terminate command
execution.
<<Commands: command: TBP>>=
  procedure (command_execute), deferred :: execute
<<Commands: interfaces>>=
  abstract interface
     subroutine command_execute (cmd, global)
       import
       class(command_t), intent(inout) :: cmd
       type(rt_data_t), intent(inout), target :: global
     end subroutine command_execute
  end interface

@ %def command_execute
@
\subsection{Options}
The [[options]] command list is allocated, initialized, and executed, if the
command is associated with an option text in curly braces.  If present, a
separate local runtime data set [[local]] will be allocated and initialized;
otherwise, [[local]] becomes a pointer to the global dataset.

For output, we indent the options list.
<<Commands: command: TBP>>=
  procedure :: write_options => command_write_options
<<Commands: procedures>>=
  recursive subroutine command_write_options (cmd, unit, indent)
    class(command_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: ind
    ind = 1;  if (present (indent))  ind = indent + 1
    if (associated (cmd%options))  call cmd%options%write (unit, ind)
  end subroutine command_write_options
  
@ %def command_write_options
@ Compile the options list, if any.  This implies initialization of the local
environment.  Should be done once the [[pn_opt]] node has been assigned (if
applicable), but before the actual command compilation.
<<Commands: command: TBP>>=
  procedure :: compile_options => command_compile_options
<<Commands: procedures>>=
  recursive subroutine command_compile_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%pn_opt)) then
       allocate (cmd%local)
       call cmd%local%local_init (global)
       call global%copy_globals (cmd%local)
       allocate (cmd%options)
       call cmd%options%compile (cmd%pn_opt, cmd%local)
       call global%restore_globals (cmd%local)
    else
       cmd%local => global
    end if
  end subroutine command_compile_options
  
@ %def command_compile_options
@ Execute options.  First prepare the local environment, then execute the
command list.  In case the process stack has been locally modified,
delete it after execution.
<<Commands: command: TBP>>=
  procedure :: execute_options => cmd_execute_options
<<Commands: procedures>>=
  recursive subroutine cmd_execute_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%options)) then
       call cmd%local%link (global)
       call cmd%options%execute (cmd%local)
    end if
  end subroutine cmd_execute_options

@ %def cmd_execute_options
@ This must be called after the parent command has been executed, to undo
temporary modifications to the global environment.
<<Commands: command: TBP>>=
  procedure :: reset_options => cmd_reset_options
<<Commands: procedures>>=
  subroutine cmd_reset_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%options)) then
       call global%restore (cmd%local)
    end if
  end subroutine cmd_reset_options
  
@ %def cmd_reset_options
@
\subsection{Specific command types}
\subsubsection{Model configuration}
The command declares a model, looks for the specified file and loads
it.
<<Commands: types>>=
  type, extends (command_t) :: cmd_model_t
     private
     type(string_t) :: name
   contains
   <<Commands: cmd model: TBP>>
  end type cmd_model_t

@ %def cmd_model_t
@ Output
<<Commands: cmd model: TBP>>=
  procedure :: write => cmd_model_write
<<Commands: procedures>>=
  subroutine cmd_model_write (cmd, unit, indent)
    class(cmd_model_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,'""',A,'""')")  "model =", char (cmd%name)
  end subroutine cmd_model_write

@ %def cmd_model_write
@ Compile.  Get the model name and read the model from file, so it is
readily available when the command list is executed.
<<Commands: cmd model: TBP>>=
  procedure :: compile => cmd_model_compile
<<Commands: procedures>>=
  subroutine cmd_model_compile (cmd, global)
    class(cmd_model_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_name
    type(string_t) :: filename
    pn_name => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%name = parse_node_get_string (pn_name)
    filename = cmd%name // ".mdl"
    call global%read_model (cmd%name, filename)
  end subroutine cmd_model_compile

@ %def cmd_model_compile
@ Execute: Insert a pointer into the global data record and reassign
the variable list.
<<Commands: cmd model: TBP>>=
  procedure :: execute => cmd_model_execute
<<Commands: procedures>>=
  subroutine cmd_model_execute (cmd, global)
    class(cmd_model_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: new_model
    new_model = .true.
    if (associated (global%model)) then
       new_model = global%model%get_name () /= cmd%name
    end if
    if (new_model) then
       if (global%model_list%model_exists (cmd%name)) then
          call msg_message ("Switching to model '" &
               // char (cmd%name) &
               // "': reassigning model parameters")
          call global%select_model (cmd%name)
       else
          call msg_fatal ("Switching to model '" &
               // char (cmd%name) &
               // "': unknown model name")
       end if
    end if
  end subroutine cmd_model_execute

@ %def cmd_model_execute
@
\subsubsection{Library configuration}
We configure a process library that should hold the subsequently
defined processes.  If the referenced library exists already, just
make it the currently active one.
<<Commands: types>>=
  type, extends (command_t) :: cmd_library_t
     private
     type(string_t) :: name
   contains
   <<Commands: cmd library: TBP>>
  end type cmd_library_t

@ %def cmd_library_t
@ Output.
<<Commands: cmd library: TBP>>=
  procedure :: write => cmd_library_write
<<Commands: procedures>>=
  subroutine cmd_library_write (cmd, unit, indent)
    class(cmd_library_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    call write_indent (u, indent)
    write (u, "(1x,A,1x,'""',A,'""')")  "library =", char (cmd%name)
  end subroutine cmd_library_write

@ %def cmd_library_write
@ Compile.  Get the library name.
<<Commands: cmd library: TBP>>=
  procedure :: compile => cmd_library_compile
<<Commands: procedures>>=
  subroutine cmd_library_compile (cmd, global)
    class(cmd_library_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_name
    pn_name => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%name = parse_node_get_string (pn_name)
  end subroutine cmd_library_compile

@ %def cmd_library_compile
@ Execute: Initialize a new library and push it on the library stack
(if it does not yet exist).   Insert a pointer to the library into the
global data record.  Then, try to load the library unless the
[[rebuild]] flag is set.
<<Commands: cmd library: TBP>>=
  procedure :: execute => cmd_library_execute
<<Commands: procedures>>=
  subroutine cmd_library_execute (cmd, global)
    class(cmd_library_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(prclib_entry_t), pointer :: lib_entry
    type(process_library_t), pointer :: lib
    logical :: rebuild_library
    lib => global%prclib_stack%get_library_ptr (cmd%name)
    rebuild_library = &
         var_list_get_lval (global%var_list, var_str ("?rebuild_library"))    
    if (.not. (associated (lib))) then
       allocate (lib_entry)
       call lib_entry%init (cmd%name)
       lib => lib_entry%process_library_t
       call global%add_prclib (lib_entry)
    else
       call global%update_prclib (lib)
    end if
    if (associated (lib) .and. .not. rebuild_library) then
       call lib%update_status (global%os_data)
    end if
  end subroutine cmd_library_execute

@ %def cmd_library_execute
@
\subsubsection{Process configuration}
We define a process-configuration command as a specific type.  The
incoming and outgoing particles are given evaluation-trees which we
transform to PDG-code arrays.  For transferring to \oMega, they are
reconverted to strings.

For the incoming particles, we store parse nodes individually.  We do
not yet resolve the outgoing state, so we store just a single parse
node. 

This also includes the choice of method for the corresponding process:
[[omega]] for \oMega\ matrix elements as Fortran code, [[ovm]] for
\oMega\ matrix elements as a bytecode virtual machine, [[test]] for
special processes, [[unit_test]] for internal test matrix elements
generated by \whizard, [[template]] and [[template_unity]] for test
matrix elements generated by \whizard\ as Fortran code similar to the 
\oMega\ code. If the one-loop program (OLP) \gosam\ is linked, also
matrix elements from there (at leading and next-to-leading order) can
be generated via [[gosam]].
<<Commands: types>>=
  type, extends (command_t) :: cmd_process_t
     private
     type(string_t) :: id
     integer :: n_in  = 0
     type(parse_node_p), dimension(:), allocatable :: pn_pdg_in
     type(parse_node_t), pointer :: pn_out => null ()
   contains
   <<Commands: cmd process: TBP>>  
  end type cmd_process_t

@ %def cmd_process_t
@ Output.  The particle expressions are not resolved, so we just list the
number of incoming particles.
<<Commands: cmd process: TBP>>=
  procedure :: write => cmd_process_write
<<Commands: procedures>>=
  subroutine cmd_process_write (cmd, unit, indent)
    class(cmd_process_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A,I0,A)")  "process: ", char (cmd%id), " (", &
         size (cmd%pn_pdg_in), " -> X)"
    call cmd%write_options (u, indent)
  end subroutine cmd_process_write

@ %def cmd_process_write
@ Compile.  Find and assign the parse nodes.
<<Commands: cmd process: TBP>>=
  procedure :: compile => cmd_process_compile
<<Commands: procedures>>=
  subroutine cmd_process_compile (cmd, global)
    class(cmd_process_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_id, pn_in, pn_codes
    integer :: i
    pn_id => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_in  => parse_node_get_next_ptr (pn_id, 2)
    cmd%pn_out => parse_node_get_next_ptr (pn_in, 2)
    cmd%pn_opt => parse_node_get_next_ptr (cmd%pn_out)
    call cmd%compile_options (global)
    cmd%id = parse_node_get_string (pn_id)
    cmd%n_in  = parse_node_get_n_sub (pn_in)
    pn_codes => parse_node_get_sub_ptr (pn_in)
    allocate (cmd%pn_pdg_in (cmd%n_in))
    do i = 1, cmd%n_in
       cmd%pn_pdg_in(i)%ptr => pn_codes
       pn_codes => parse_node_get_next_ptr (pn_codes)
    end do
  end subroutine cmd_process_compile

@ %def cmd_process_compile
@ Command execution.  Evaluate the subevents, transform PDG codes
into strings, and add the current process configuration to the
process library. 

The initial state will be unique (one or two particles).  For the final state,
we allow for expressions.  The expressions will be expanded until we have a
sum of final states.  Each distinct final state will get its own process
component.

To identify equivalent final states, we transform the final state into an array
of PDG codes, which we sort and compare.  If a particle entry is actually a
PDG array, only the first entry in the array is used for the comparison.
The user should make sure that there is no overlap between different particles
or arrays which would make the expansion ambiguous.
<<Commands: cmd process: TBP>>=
  procedure :: execute => cmd_process_execute
<<Commands: procedures>>=
  subroutine cmd_process_execute (cmd, global)
    class(cmd_process_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(pdg_array_t) :: pdg_in, pdg_out
    type(pdg_array_t), dimension(:), allocatable :: pdg_out_tab
    type(string_t), dimension(:), allocatable :: prt_in
    type(string_t) :: prt_out, prt_out1
    type(process_configuration_t) :: prc_config
    type(prt_expr_t) :: prt_expr_out
    type(prt_spec_t), dimension(:), allocatable :: prt_spec_in
    type(prt_spec_t), dimension(:), allocatable :: prt_spec_out
    integer, dimension(:), allocatable :: pdg
    integer, dimension(:), allocatable :: i_term
    integer :: i, j, n_in, n_out, n_terms, n_components
    logical :: nlo_calc
    logical, dimension(3) :: active_nlo_components
    type(pdg_array_t), dimension(:), allocatable :: pdg_array_in, pdg_array_out
    type(string_t), dimension(:), allocatable :: prt_in_nlo, prt_out_nlo
    type(radiation_generator_t) :: radiation_generator
    type(pdg_list_t) :: pl_in, pl_out
    logical :: method_changed = .false.
    logical :: use_gosam_loops
    logical :: use_gosam_correlations
    logical :: use_gosam_real_trees
    integer, dimension(:,:), allocatable :: flv_real
    integer, dimension(:,:), allocatable :: flv_born
    integer :: alpha_power, alphas_power
    type(blha_master_t) :: blha_master

    nlo_calc = cmd%local%nlo_calculation
    active_nlo_components = cmd%local%active_nlo_components

    n_in = size (cmd%pn_pdg_in)
    allocate (prt_in (n_in), prt_spec_in (n_in))
    do i = 1, n_in
       pdg_in = &
            eval_pdg_array (cmd%pn_pdg_in(i)%ptr, cmd%local%var_list)
       prt_in(i) = make_flavor_string (pdg_in, cmd%local%model)
       prt_spec_in(i) = new_prt_spec (prt_in(i))
    end do
    call compile_prt_expr &
         (prt_expr_out, cmd%pn_out, cmd%local%var_list, cmd%local%model)
    call prt_expr_out%expand ()
    n_terms = prt_expr_out%get_n_terms ()
    allocate (pdg_out_tab (n_terms))
    allocate (i_term (n_terms), source = 0)
    n_components = 0
    SCAN_COMPONENTS: do i = 1, n_terms
       if (allocated (pdg))  deallocate (pdg)
       call prt_expr_out%term_to_array (prt_spec_out, i)
       n_out = size (prt_spec_out)
       allocate (pdg (n_out))
       do j = 1, n_out
          prt_out = prt_spec_out(j)%to_string ()
          call split (prt_out, prt_out1, ":")
          pdg(j) = cmd%local%model%get_pdg (prt_out1)
       end do
       pdg_out = sort (pdg)
       do j = 1, n_components
          if (pdg_out == pdg_out_tab(j))  cycle SCAN_COMPONENTS
       end do
       n_components = n_components + 1
       i_term(n_components) = i
       pdg_out_tab(n_components) = pdg_out
    end do SCAN_COMPONENTS
    if (nlo_calc) then
      call prc_config%init (cmd%id, n_in, n_components*4, cmd%local)
    else
      call prc_config%init (cmd%id, n_in, n_components, cmd%local)
    end if
    do i = 1, n_components
       call prt_expr_out%term_to_array (prt_spec_out, i_term(i))
       if (nlo_calc) then
         associate (active_comp => cmd%local%active_nlo_components)
            use_gosam_loops  = var_list_get_lval (global%var_list, &
                                             var_str ('?use_gosam_loops'))
            use_gosam_correlations = var_list_get_lval (global%var_list, &
                                             var_str ('?use_gosam_correlations'))
            use_gosam_real_trees= var_list_get_lval (global%var_list, &
                                             var_str ('?use_gosam_real_trees'))
            alpha_power = var_list_get_ival (global%var_list, &
                                             var_str ('alpha_power'))
            alphas_power = var_list_get_ival (global%var_list, &
                                              var_str ('alphas_power'))


            call prc_config%setup_component (i, prt_spec_in, prt_spec_out, &
                                             cmd%local, var_str ('Born'), &
                                             active_in = active_comp (1))
            call split_prt (prt_spec_in, n_in, pl_in)
            call split_prt (prt_spec_out, n_out, pl_out)
            call radiation_generator_init (radiation_generator, .true., .false., &
                                           pl_in, pl_out)
            call radiation_generator%set_n (n_in, n_out, 0)
            call radiation_generator%set_constraints (.false., .false., .true., .true.)
            call radiation_generator%init_radiation_model (cmd%local%os_data)
            call radiation_generator%generate (prt_in_nlo, prt_out_nlo)

            if (use_gosam_real_trees) then
               if (.not. method_changed) &
                 call global%change_to_gosam (method_changed)
               flv_real = radiation_generator%get_raw_states ()
            end if
  
            call prc_config%setup_component (n_components + i, &
                            new_prt_spec (prt_in_nlo), &
                            new_prt_spec (prt_out_nlo),&
                            cmd%local, var_str ('Real'), i, &
                            active_in = active_comp (2))


            if (use_gosam_loops .and..not. method_changed) &
                 call global%change_to_gosam (method_changed)

            call prc_config%setup_component (n_components*2 + i, prt_spec_in, &
                            prt_spec_out, global, var_str ('Virtual'), i, &
                            active_in = active_comp (3))

            if (use_gosam_loops .or. use_gosam_correlations) &
               flv_born = radiation_generator%get_born_raw ()
               

            if (.not. use_gosam_correlations .and. method_changed) then
               call global%change_to_omega ()
            else if (use_gosam_correlations .and..not. method_changed) then
               call global%change_to_gosam (method_changed)
            end if

            call prc_config%setup_component (n_components*3 + i, prt_spec_in, &
                            prt_spec_out, global, var_str ('Subtraction'), i, &
                            .false.)                     
         end associate
       else
         call prc_config%setup_component (i, prt_spec_in, prt_spec_out, cmd%local)
       end if
    end do
    if (nlo_calc .and. &
        (use_gosam_loops .or. use_gosam_correlations .or. use_gosam_real_trees)) then
       call blha_master%init (cmd%id, global%model, &
                              n_in, size (flv_born, 1)-2, use_gosam_loops, &
                              use_gosam_correlations, use_gosam_real_trees, &
                              alpha_power, alphas_power, &
                              flv_born, flv_real)
       call blha_master%generate (cmd%id)
    end if
 
    call prc_config%record (cmd%local)
 
  contains
    subroutine split_prt (prt, n_out, pl)
      type(prt_spec_t), intent(in), dimension(:), allocatable :: prt
      integer, intent(in) :: n_out
      type(pdg_list_t), intent(out) :: pl
      type(pdg_array_t) :: pdg
      type(string_t) :: prt_string, prt_tmp
      integer, dimension(10) :: i_particle
      integer :: i, j, n
      call pl%init (n_out)
      do i = 1, n_out
         n = 1
         prt_string = prt(i)%to_string ()
         do
           call split (prt_string, prt_tmp, ":")
           if (prt_tmp /= "") then
             i_particle(n) = cmd%local%model%get_pdg (prt_tmp)
             n=n+1
           else
             exit
           end if
         end do
         call pdg_array_init (pdg, n-1)
         do j = 1, n-1 
           call pdg%set (j, i_particle(j))
         end do
         call pl%set (i, pdg)
         call pdg_array_delete (pdg)
      end do
    end subroutine split_prt
             
  end subroutine cmd_process_execute

@ %def cmd_process_execute
@ This is a method of the eval tree, but cannot be coded inside the
[[expressions]] module since it uses the [[model]] and [[flv]] types
which are not available there.
<<Commands: procedures>>=
  function make_flavor_string (aval, model) result (prt)
    type(string_t) :: prt
    type(pdg_array_t), intent(in) :: aval
    type(model_t), intent(in), target :: model
    integer, dimension(:), allocatable :: pdg
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    pdg = aval
    allocate (flv (size (pdg)))
    call flavor_init (flv, pdg, model)
    if (size (pdg) /= 0) then
       prt = flavor_get_name (flv(1))
       do i = 2, size (flv)
          prt = prt // ":" // flavor_get_name (flv(i))
       end do
    else
       prt = "?"
    end if
  end function make_flavor_string

@ %def make_flavor_string
@ Create a pdg array from a particle-specification array
<<Commands: procedures>>=
  function make_pdg_array (prt, model) result (pdg_array)
    type(prt_spec_t), intent(in), dimension(:) :: prt
    type(model_t), intent(in) :: model
    integer, dimension(:), allocatable :: aval
    type(pdg_array_t) :: pdg_array
    type(flavor_t) :: flv
    integer :: k
    allocate (aval (size (prt)))
    do k = 1, size (prt)
      call flavor_init (flv, prt(k)%to_string (), model)
      aval (k) = flavor_get_pdg (flv)
    end do
    pdg_array = aval
  end function make_pdg_array

@ %def make_pdg_array
@ Compile a (possible nested) expression, to obtain a
particle-specifier expression which we can process further.
<<Commands: procedures>>=
  recursive subroutine compile_prt_expr (prt_expr, pn, var_list, model)
    type(prt_expr_t), intent(out) :: prt_expr
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(model_t), intent(in), target :: model
    type(parse_node_t), pointer :: pn_entry, pn_term, pn_addition
    type(pdg_array_t) :: pdg
    type(string_t) :: prt_string
    integer :: n_entry, n_term, i
    select case (char (parse_node_get_rule_key (pn)))
    case ("prt_state_list")
       n_entry = parse_node_get_n_sub (pn)
       pn_entry => parse_node_get_sub_ptr (pn)
       if (n_entry == 1) then
          call compile_prt_expr (prt_expr, pn_entry, var_list, model)
       else
          call prt_expr%init_list (n_entry)
          select type (x => prt_expr%x)
          type is (prt_spec_list_t)
             do i = 1, n_entry
                call compile_prt_expr (x%expr(i), pn_entry, var_list, model)
                pn_entry => parse_node_get_next_ptr (pn_entry)
             end do
          end select
       end if
    case ("prt_state_sum")
       n_term = parse_node_get_n_sub (pn)
       pn_term => parse_node_get_sub_ptr (pn)
       pn_addition => pn_term
       if (n_term == 1) then
          call compile_prt_expr (prt_expr, pn_term, var_list, model)
       else
          call prt_expr%init_sum (n_term)
          select type (x => prt_expr%x)
          type is (prt_spec_sum_t)
             do i = 1, n_term
                call compile_prt_expr (x%expr(i), pn_term, var_list, model)
                pn_addition => parse_node_get_next_ptr (pn_addition)
                if (associated (pn_addition)) &
                     pn_term => parse_node_get_sub_ptr (pn_addition, 2)
             end do
          end select
       end if
    case ("cexpr")
       pdg = eval_pdg_array (pn, var_list)
       prt_string = make_flavor_string (pdg, model)
       call prt_expr%init_spec (new_prt_spec (prt_string))
    case default
       call parse_node_write_rec (pn)
       call msg_bug ("compile prt expr: impossible syntax rule")
    end select
  end subroutine compile_prt_expr
          
@ %def compile_prt_expr
@
\subsubsection{Initiating a NLO calculation}
<<Commands: types>>=
  type, extends (command_t) :: cmd_nlo_t
    private
    type(parse_node_p), dimension(3) :: pn_components
    logical, dimension(3) :: active_component  
  contains
    <<Commands: cmd nlo: TBP>>
  end type cmd_nlo_t

@ %def cmd_nlo_t
@
<<Commands: cmd nlo: TBP>>=
  procedure :: write => cmd_nlo_write
<<Commands: procedures>>=
  subroutine cmd_nlo_write (cmd, unit, indent)
    class(cmd_nlo_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
  end subroutine cmd_nlo_write

@ %def cmd_nlo_write
@ As it is, the NLO calculation is switched on by putting {nlo} behind the process definition. This should be made nicer in the future.
<<Commands: cmd nlo: TBP>>=
  procedure :: compile => cmd_nlo_compile
<<Commands: procedures>>=
  subroutine cmd_nlo_compile (cmd, global)
    class(cmd_nlo_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_comp
    integer :: i
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%pn_components(1)%ptr => parse_node_get_sub_ptr (pn_arg)
    pn_comp => parse_node_get_next_ptr (cmd%pn_components(1)%ptr)
    i = 2
    do 
      if (associated (pn_comp)) then
         cmd%pn_components(i)%ptr => pn_comp
         pn_comp => parse_node_get_next_ptr (cmd%pn_components(i)%ptr)
         i = i+1
      else
         exit
      end if
    end do
  end subroutine cmd_nlo_compile

@ %def cmd_nlo_compile
@
<<Commands: cmd nlo: TBP>>=
  procedure :: execute => cmd_nlo_execute
<<Commands: procedures>>=
  subroutine cmd_nlo_execute (cmd, global)
    class(cmd_nlo_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: current_component
    type(string_t) :: component_type
    integer :: i

    cmd%active_component = .false.

    current_component => cmd%pn_components(1)%ptr
    i = 2
    do 
      if (associated (current_component)) then
         component_type = eval_string (current_component, global%var_list)
         select case (char (component_type))
         case ('Born')
            cmd%active_component(1) = .true.
         case ('Real')
            cmd%active_component(2) = .true.
         case ('Virtual')
            cmd%active_component(3) = .true.
         case ('Full')
            cmd%active_component = .true.
         end select
         if (i >= 4) exit
         current_component => cmd%pn_components(i)%ptr
         i = i+1
      else
         exit
      end if
    end do   
    ! global%nlo_calculation = cmd%nlo_calc
    global%nlo_calculation = cmd%active_component(2) &
                        .or. cmd%active_component(3)
    global%active_nlo_components = cmd%active_component
  end subroutine cmd_nlo_execute

@ %def cmd_nlo_execute
@
\subsubsection{Process compilation}
<<Commands: types>>=
  type, extends (command_t) :: cmd_compile_t
     private
     type(string_t), dimension(:), allocatable :: libname
     logical :: make_executable = .false.
     type(string_t) :: exec_name
   contains
   <<Commands: cmd compile: TBP>>
  end type cmd_compile_t

@ %def cmd_compile_t
@ Output: list all libraries to be compiled.
<<Commands: cmd compile: TBP>>=
  procedure :: write => cmd_compile_write
<<Commands: procedures>>=
  subroutine cmd_compile_write (cmd, unit, indent)
    class(cmd_compile_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "compile ("
    if (allocated (cmd%libname)) then
       do i = 1, size (cmd%libname)
          if (i > 1)  write (u, "(A,1x)", advance="no")  ","
          write (u, "('""',A,'""')", advance="no")  char (cmd%libname(i))
       end do
    end if
    write (u, "(A)")  ")"
  end subroutine cmd_compile_write

@ %def cmd_compile_write
@ Compile the libraries specified in the argument.  If the argument is
empty, compile all libraries which can be found in the process library stack.
<<Commands: cmd compile: TBP>>=
  procedure :: compile => cmd_compile_compile
<<Commands: procedures>>=
  subroutine cmd_compile_compile (cmd, global)
    class(cmd_compile_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd, pn_clause, pn_arg, pn_lib
    type(parse_node_t), pointer :: pn_exec_name_spec, pn_exec_name
    integer :: n_lib, i
    pn_cmd => parse_node_get_sub_ptr (cmd%pn)
    pn_clause => parse_node_get_sub_ptr (pn_cmd)
    pn_exec_name_spec => parse_node_get_sub_ptr (pn_clause, 2)
    if (associated (pn_exec_name_spec)) then
       pn_exec_name => parse_node_get_sub_ptr (pn_exec_name_spec, 2)
    else
       pn_exec_name => null ()
    end if
    pn_arg => parse_node_get_next_ptr (pn_clause)
    cmd%pn_opt => parse_node_get_next_ptr (pn_cmd)
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_lib = parse_node_get_n_sub (pn_arg)
    else
       n_lib = 0
    end if
    if (n_lib > 0) then
       allocate (cmd%libname (n_lib))
       pn_lib => parse_node_get_sub_ptr (pn_arg)
       do i = 1, n_lib
          cmd%libname(i) = parse_node_get_string (pn_lib)
          pn_lib => parse_node_get_next_ptr (pn_lib)
       end do
    end if
    if (associated (pn_exec_name)) then
       cmd%make_executable = .true.
       cmd%exec_name = parse_node_get_string (pn_exec_name)
    end if
  end subroutine cmd_compile_compile

@ %def cmd_compile_compile
@ Command execution.  Generate code, write driver, compile and link.
Do this for all libraries in the list.

If no library names have been given and stored while compiling this
command, we collect all libraries from the current stack and compile
those.

We can compile static libraries (which actually just loads them).  However, we
can't incorporate in a generated executable.
<<Commands: cmd compile: TBP>>=
  procedure :: execute => cmd_compile_execute
<<Commands: procedures>>=
  subroutine cmd_compile_execute (cmd, global)
    class(cmd_compile_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t), dimension(:), allocatable :: libname, libname_static
    integer :: i
    if (allocated (cmd%libname)) then
       allocate (libname (size (cmd%libname)))
       libname = cmd%libname
    else
       call cmd%local%prclib_stack%get_names (libname)
    end if
    if (cmd%make_executable) then
       call get_prclib_static (libname_static)
       do i = 1, size (libname)
          if (any (libname_static == libname(i))) then
             call msg_fatal ("Compile: can't include static library '" &
                  // char (libname(i)) // "'")
          end if
       end do
       call compile_executable (cmd%exec_name, libname, cmd%local)
    else
       do i = 1, size (libname)
          call compile_library (libname(i), cmd%local)
       end do
    end if
  end subroutine cmd_compile_execute
    
@ %def cmd_compile_execute
@
This is the interface to the external procedure which returns the
names of all static libraries which are part of the executable.  (The
default is none.)  The routine must allocate the array.
<<Commands: public>>=
  public :: get_prclib_static
<<Commands: interfaces>>=
  interface
     subroutine get_prclib_static (libname)
       import
       type(string_t), dimension(:), intent(inout), allocatable :: libname
     end subroutine get_prclib_static
  end interface

@ %def get_prclib_static
@ 
\subsubsection{Execute a shell command}
The argument is a string expression.
<<Commands: types>>=
  type, extends (command_t) :: cmd_exec_t
     private
     type(parse_node_t), pointer :: pn_command => null ()
   contains
   <<Commands: cmd exec: TBP>>  
  end type cmd_exec_t

@ %def cmd_exec_t
@ Simply tell the status.
<<Commands: cmd exec: TBP>>=
  procedure :: write => cmd_exec_write
<<Commands: procedures>>=
  subroutine cmd_exec_write (cmd, unit, indent)
    class(cmd_exec_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    if (associated (cmd%pn_command)) then
       write (u, "(1x,A)")  "exec: [command associated]"
    else
       write (u, "(1x,A)")  "exec: [undefined]"       
    end if
  end subroutine cmd_exec_write

@ %def cmd_exec_write
@ Compile the exec command.
<<Commands: cmd exec: TBP>>=
  procedure :: compile => cmd_exec_compile
<<Commands: procedures>>=
  subroutine cmd_exec_compile (cmd, global)
    class(cmd_exec_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_command
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_command => parse_node_get_sub_ptr (pn_arg)
    cmd%pn_command => pn_command
  end subroutine cmd_exec_compile

@ %def cmd_exec_compile
@ Execute the specified shell command.
<<Commands: cmd exec: TBP>>=
  procedure :: execute => cmd_exec_execute
<<Commands: procedures>>=
  subroutine cmd_exec_execute (cmd, global)
    class(cmd_exec_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t) :: command
    logical :: is_known
    integer :: status
    command = eval_string (cmd%pn_command, global%var_list, is_known=is_known)
    if (is_known) then
       if (command /= "") then
          call os_system_call (command, status, verbose=.true.)
          if (status /= 0) then
             write (msg_buffer, "(A,I0)")  "Return code = ", status
             call msg_message ()
             call msg_error ("System command returned with nonzero status code")
          end if
       end if 
    end if
  end subroutine cmd_exec_execute

@ %def cmd_exec_execute
@ 
\subsubsection{Variable declaration}
A variable can have various types.  Hold the definition as an eval
tree.

There are intrinsic variables, user variables, and model variables.
The latter are further divided in independent variables and dependent
variables.

Regarding model variables: When dealing with them, we always look at
two variable lists in parallel.  The global (or local) variable list
contains the user-visible values.  It includes variables that
correspond to variables in the current model's list.  These, in turn,
are pointers to the model's parameter list, so the model is always in
sync, internally.  To keep the global variable list in sync with the
model, the global variables carry the [[is_copy]] property and contain
a separate pointer to the model variable.  (The pointer is reassigned
whenever the model changes.)  Modifying the global variable changes
two values simultaneously: the visible value and the model variable,
via this extra pointer.  After each modification, we update dependent
parameters in the model variable list and re-synchronize the global
variable list (again, using these pointers) with the model variable
this.  In the last step, modifications in the derived parameters
become visible.

When we integrate a process, we capture the current variable list of
the current model in a separate model instance, which is stored in the
process object.  Thus, the model parameters associated to this process
at this time are preserved for the lifetime of the process object.

When we generate or rescan events, we can again capture a local model
variable list in a model instance.  This allows us to reweight event
by event with different parameter sets simultaneously.
<<Commands: types>>=
  type, extends (command_t) :: cmd_var_t
     private
     type(string_t) :: name
     integer :: type = V_NONE
     type(parse_node_t), pointer :: pn_value => null ()
     logical :: is_intrinsic = .false.
     logical :: is_copy = .false.
   contains
   <<Commands: cmd var: TBP>>
  end type cmd_var_t

@ %def cmd_var_t
@ Output.  We know name, type, and properties, but not the value.
<<Commands: cmd var: TBP>>=
  procedure :: write => cmd_var_write
<<Commands: procedures>>=
  subroutine cmd_var_write (cmd, unit, indent)
    class(cmd_var_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A)", advance="no")  "var: ", char (cmd%name), " ("
    select case (cmd%type)
    case (V_NONE)
       write (u, "(A)", advance="no")  "[unknown]"
    case (V_LOG)
       write (u, "(A)", advance="no")  "logical"
    case (V_INT)
       write (u, "(A)", advance="no")  "int"
    case (V_REAL)
       write (u, "(A)", advance="no")  "real"
    case (V_CMPLX)
       write (u, "(A)", advance="no")  "complex"
    case (V_STR)
       write (u, "(A)", advance="no")  "string"
    case (V_PDG)
       write (u, "(A)", advance="no")  "alias"
    end select
    if (cmd%is_intrinsic) then
       write (u, "(A)", advance="no")  ", intrinsic"
    end if
    if (cmd%is_copy) then
       write (u, "(A)", advance="no")  ", copy"
    end if
    write (u, "(A)")  ")"
  end subroutine cmd_var_write

@ %def cmd_var_write
@ Compile the lhs and determine the variable name and type.  Check whether
this variable can be created or modified as requested, and append the value to
the variable list, if appropriate.  The value is initially undefined.
The rhs is assigned to a pointer, to be compiled and evaluated when the
command is executed.
<<Commands: cmd var: TBP>>=
  procedure :: compile => cmd_var_compile
<<Commands: procedures>>=
  subroutine cmd_var_compile (cmd, global)
    class(cmd_var_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_var, pn_name
    type(parse_node_t), pointer :: pn_result, pn_proc
    type(string_t) :: var_name
    type(var_entry_t), pointer :: var_entry
    integer :: type
    logical :: new
    pn_result => null ()
    new = .false.
    select case (char (parse_node_get_rule_key (cmd%pn)))
    case ("cmd_log_decl");    type = V_LOG
       pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
       if (.not. associated (pn_var)) then   ! handle masked syntax error 
          cmd%type = V_NONE; return
       end if
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       new = .true.
    case ("cmd_log");         type = V_LOG
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
    case ("cmd_int");         type = V_INT
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_real");        type = V_REAL
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_complex");       type = V_CMPLX
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_num");         type = V_NONE
       pn_name => parse_node_get_sub_ptr (cmd%pn)
    case ("cmd_string_decl"); type = V_STR
       pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
       if (.not. associated (pn_var)) then   ! handle masked syntax error 
          cmd%type = V_NONE; return
       end if
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       new = .true.
    case ("cmd_string");      type = V_STR
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
    case ("cmd_alias");       type = V_PDG
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_result");      type = V_REAL
       pn_name => parse_node_get_sub_ptr (cmd%pn)
       pn_result => parse_node_get_sub_ptr (pn_name)
       pn_proc => parse_node_get_next_ptr (pn_result)
    case default
       call parse_node_mismatch &
            ("logical|int|real|complex|?|$|alias|var_name", cmd%pn)  ! $
    end select
    if (.not. associated (pn_name)) then   ! handle masked syntax error 
       cmd%type = V_NONE; return
    end if
    if (.not. associated (pn_result)) then
       var_name = parse_node_get_string (pn_name)
    else
       var_name = parse_node_get_key (pn_result) &
            // "(" // parse_node_get_string (pn_proc) // ")"
    end if
    select case (type)
    case (V_LOG);  var_name = "?" // var_name
    case (V_STR);  var_name = "$" // var_name    ! $
    end select
    call var_list_check_user_var (global%var_list, var_name, type, new)
    cmd%type = type
    cmd%name = var_name
    var_entry => var_list_get_var_ptr &
       (global%var_list, cmd%name, cmd%type, follow_link=.false.)
    cmd%pn_value => parse_node_get_next_ptr (pn_name, 2)
    if (.not. associated (cmd%pn_value))  cmd%type = V_NONE
    if (associated (var_entry)) then
       cmd%is_intrinsic = var_entry_is_intrinsic (var_entry)
       cmd%is_copy = var_entry_is_copy (var_entry)
    else
       var_entry => var_list_get_var_ptr &
          (global%var_list, cmd%name, cmd%type, follow_link=.true.)
       if (associated (var_entry)) then
          cmd%is_intrinsic = var_entry_is_intrinsic (var_entry)
          if (var_entry_is_copy (var_entry)) then
             cmd%is_copy = .true.
             call var_list_init_copy (global%var_list, var_entry, user=.true.)
          end if
       end if
       if (.not. cmd%is_copy) then
          select case (cmd%type)
          case (V_LOG)
             call var_list_append_log (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_INT)
             call var_list_append_int (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_REAL)
             call var_list_append_real (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_CMPLX)
             call var_list_append_cmplx (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_PDG)
             call var_list_append_pdg_array (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_STR)
             call var_list_append_string (global%var_list, cmd%name, &
                   intrinsic=cmd%is_intrinsic, user=.true.)
          end select
       end if
    end if
  end subroutine cmd_var_compile

@ %def cmd_var_compile
@ Execute.  Evaluate the definition and assign the variable value.
If the variable is a copy, the original is a model variable.  The
original is set automatically, and an update of the dependent
parameters is in order.
<<Commands: cmd var: TBP>>=
  procedure :: execute => cmd_var_execute
<<Commands: procedures>>=
  subroutine cmd_var_execute (cmd, global)
    class(cmd_var_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t) :: model_name
    type(var_list_t), pointer :: model_vars
    if (associated (global%model)) then
       model_name = global%model%get_name ()
       model_vars => global%model%get_var_list_ptr ()
       if (cmd%is_copy) then
          call var_list_set_original_pointer (global%var_list, cmd%name, &
               model_vars)
       end if
       call cmd%set_value (global%var_list, &
            verbose=.true., model_name=model_name)
       if (cmd%is_copy) then
          call var_list_restore (global%var_list)
          call global%model%update_parameters ()
          call var_list_synchronize (global%var_list, model_vars)
       end if
    else
       call cmd%set_value (global%var_list, verbose=.true.)
    end if
  end subroutine cmd_var_execute

@ %def cmd_var_execute
@ Copy the value to the variable list, where the variable should already exist.
<<Commands: cmd var: TBP>>=
  procedure :: set_value => cmd_var_set_value
<<Commands: procedures>>=
  subroutine cmd_var_set_value (var, var_list, verbose, model_name)
    class(cmd_var_t), intent(inout) :: var
    type(var_list_t), intent(inout), target :: var_list
    logical, intent(in), optional :: verbose
    type(string_t), intent(in), optional :: model_name
    logical :: lval, pacified
    integer :: ival
    real(default) :: rval
    complex(default) :: cval
    type(pdg_array_t) :: aval
    type(string_t) :: sval
    logical :: is_known
    pacified = var_list_get_lval (var_list, var_str ("?pacify"))     
    select case (var%type)
    case (V_LOG)
       lval = eval_log (var%pn_value, var_list, is_known=is_known)
       call var_list_set_log (var_list, var%name, &
            lval, is_known, verbose=verbose, model_name=model_name)
    case (V_INT)
       ival = eval_int (var%pn_value, var_list, is_known=is_known)
       call var_list_set_int (var_list, var%name, &
            ival, is_known, verbose=verbose, model_name=model_name)
    case (V_REAL)
       rval = eval_real (var%pn_value, var_list, is_known=is_known)
       call var_list_set_real (var_list, var%name, &
            rval, is_known, verbose=verbose, &
            model_name=model_name, pacified = pacified)
    case (V_CMPLX)
       cval = eval_cmplx (var%pn_value, var_list, is_known=is_known)
       call var_list_set_cmplx (var_list, var%name, &
            cval, is_known, verbose=verbose, &
            model_name=model_name, pacified = pacified)
    case (V_PDG)
       aval = eval_pdg_array (var%pn_value, var_list, is_known=is_known)
       call var_list_set_pdg_array (var_list, var%name, &
            aval, is_known, verbose=verbose, model_name=model_name)
    case (V_STR)
       sval = eval_string (var%pn_value, var_list, is_known=is_known)
       call var_list_set_string (var_list, var%name, &
            sval, is_known, verbose=verbose, model_name=model_name)
    end select
  end subroutine cmd_var_set_value
  
@ %def cmd_var_set_value
@ 
\subsubsection{SLHA}
Read a SLHA (SUSY Les Houches Accord) file to fill the appropriate
model parameters.  We do not access the current variable record, but
directly work on the appropriate SUSY model, which is loaded if
necessary.

We may be in read or write mode.  In the latter case, we may write
just input parameters, or the complete spectrum, or the spectrum with
all decays.
<<Commands: types>>=
  type, extends (command_t) :: cmd_slha_t
     private
     type(string_t) :: file
     logical :: write_mode = .false.
   contains
   <<Commands: cmd slha: TBP>>  
  end type cmd_slha_t

@ %def cmd_slha_t
@ Output.
<<Commands: cmd slha: TBP>>=
  procedure :: write => cmd_slha_write
<<Commands: procedures>>=
  subroutine cmd_slha_write (cmd, unit, indent)
    class(cmd_slha_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "slha: file name  = ", char (cmd%file)
    write (u, "(1x,A,L1)") "slha: write mode = ", cmd%write_mode
  end subroutine cmd_slha_write

@ %def cmd_slha_write
@ Compile.  Read the filename and store it.
<<Commands: cmd slha: TBP>>=
  procedure :: compile => cmd_slha_compile
<<Commands: procedures>>=
  subroutine cmd_slha_compile (cmd, global)
    class(cmd_slha_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_key, pn_arg, pn_file
    pn_key => parse_node_get_sub_ptr (cmd%pn)
    pn_arg => parse_node_get_next_ptr (pn_key)
    pn_file => parse_node_get_sub_ptr (pn_arg)
    call cmd%compile_options (global)
    cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
    select case (char (parse_node_get_key (pn_key)))
    case ("read_slha")
       cmd%write_mode = .false.
    case ("write_slha")
       cmd%write_mode = .true.
    case default
       call parse_node_mismatch ("read_slha|write_slha",  cmd%pn)
    end select
    cmd%file = parse_node_get_string (pn_file)
  end subroutine cmd_slha_compile

@ %def cmd_slha_compile
@ Execute.  Read or write the specified SLHA file.  Behind the scenes,
this will first read the WHIZARD model file, then read the SLHA file
and assign the SLHA parameters as far as determined by
[[dispatch_slha]].  Finally, the global variables are synchronized
with the model.  This is similar to executing [[cmd_model]].
<<Commands: cmd slha: TBP>>=
  procedure :: execute => cmd_slha_execute
<<Commands: procedures>>=
  subroutine cmd_slha_execute (cmd, global)
    class(cmd_slha_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: input, spectrum, decays
    type(var_list_t), pointer :: model_vars
    if (cmd%write_mode) then
       input = .true.
       spectrum = .false.
       decays = .false.
       call slha_write_file &
            (cmd%file, cmd%local%model, &
             input = input, spectrum = spectrum, decays = decays)
    else
       call dispatch_slha (cmd%local, &
            input = input, spectrum = spectrum, decays = decays)
       call slha_read_file &
            (cmd%file, cmd%local%os_data, global%model_list, global%model, &
             input = input, spectrum = spectrum, decays = decays)
       model_vars => global%model%get_var_list_ptr ()
       call var_list_synchronize (global%var_list, model_vars, &
            reset_pointers = .true.)
       call global%particle_stack%reset (global%model)
    end if
  end subroutine cmd_slha_execute

@ %def cmd_slha_execute
@ 
\subsubsection{Show values}
This command shows the current values of variables or other objects,
in a suitably condensed form.
<<Commands: types>>=
  type, extends (command_t) :: cmd_show_t
     private
     type(string_t), dimension(:), allocatable :: name
   contains
   <<Commands: cmd show: TBP>>
  end type cmd_show_t

@ %def cmd_show_t
@ Output: list the object names, not values.
<<Commands: cmd show: TBP>>=
  procedure :: write => cmd_show_write
<<Commands: procedures>>=
  subroutine cmd_show_write (cmd, unit, indent)
    class(cmd_show_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "show: "  
    if (allocated (cmd%name)) then
       do i = 1, size (cmd%name)
          write (u, "(1x,A)", advance="no")  char (cmd%name(i))
       end do
       write (u, *)
    else
       write (u, "(5x,A)")  "[undefined]"
    end if
  end subroutine cmd_show_write

@ %def cmd_show_write
@ Compile.  Allocate an array which is filled with the names of the
variables to show.
<<Commands: cmd show: TBP>>=
  procedure :: compile => cmd_show_compile
<<Commands: procedures>>=
  subroutine cmd_show_compile (cmd, global)
    class(cmd_show_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_var, pn_prefix, pn_name
    type(string_t) :: key
    integer :: i, n_args
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       select case (char (parse_node_get_rule_key (pn_arg)))
       case ("show_arg")
          cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
       case default
          cmd%pn_opt => pn_arg
          pn_arg => null ()
       end select
    end if
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_args = parse_node_get_n_sub (pn_arg)
       allocate (cmd%name (n_args))
       pn_var => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_var))
          i = i + 1
          select case (char (parse_node_get_rule_key (pn_var)))
          case ("model", "library", "beams", "iterations", &
                "cuts", "weight", "int", "real", "complex", &
                "scale", "factorization_scale", "renormalization_scale", &
                "selection", "reweight", "analysis", "pdg", &
                "stable", "unstable", "polarized", "unpolarized", &
                "results", "expect", "intrinsic", "string", "logical")
             cmd%name(i) = parse_node_get_key (pn_var)
          case ("result_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             if (associated (pn_name)) then
                cmd%name(i) = parse_node_get_key (pn_prefix) &
                     // "(" // parse_node_get_string (pn_name) // ")"
             else
                cmd%name(i) = parse_node_get_key (pn_prefix)
             end if
          case ("log_var", "string_var", "alias_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             key = parse_node_get_key (pn_prefix)
             if (associated (pn_name)) then
                select case (char (parse_node_get_rule_key (pn_name)))
                case ("var_name")
                   select case (char (key))
                   case ("?", "$")  ! $ sign
                      cmd%name(i) = key // parse_node_get_string (pn_name)
                   case ("alias")
                      cmd%name(i) = parse_node_get_string (pn_name)
                   end select
                case default
                   call parse_node_mismatch &
                        ("var_name",  pn_name)
                end select
             else
                cmd%name(i) = key
             end if
          case default
             cmd%name(i) = parse_node_get_string (pn_var)
          end select
          pn_var => parse_node_get_next_ptr (pn_var)
       end do
    else
       allocate (cmd%name (0))
    end if
  end subroutine cmd_show_compile

@ %def cmd_show_compile
@ Execute.  Scan the list of objects to show.
<<Commands: parameters>>=
  integer, parameter, public :: SHOW_BUFFER_SIZE = 4096
<<Commands: cmd show: TBP>>=
  procedure :: execute => cmd_show_execute
<<Commands: procedures>>=    
  subroutine cmd_show_execute (cmd, global)
    class(cmd_show_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(model_t), pointer :: model
    type(string_t) :: name
    integer :: n, pdg
    type(flavor_t) :: flv
    type(process_library_t), pointer :: prc_lib
    type(process_t), pointer :: process
    logical :: pacified
    character(SHOW_BUFFER_SIZE) :: buffer
    integer :: i, j, u, u_log, u_out
    u = free_unit ()
    pacified = var_list_get_lval (cmd%local%var_list, &
         var_str ("?pacify"))
    open (u, status = "scratch", action = "readwrite")
    if (associated (cmd%local%model)) then
       name = cmd%local%model%get_name ()
    end if
    if (size (cmd%name) == 0) then
       if (associated (cmd%local%model)) then
          call var_list_write (cmd%local%var_list, model_name = name, &
               unit = u, pacified = pacified)
       else
          call var_list_write (cmd%local%var_list, unit = u, pacified = pacified)
       end if
    else
       do i = 1, size (cmd%name)
          select case (char (cmd%name(i)))
          case ("model")
             if (associated (cmd%local%model)) then
                call cmd%local%model%show (u)
             else
                write (u, "(A)")  "Model: [undefined]"
             end if
          case ("library")
             if (associated (cmd%local%prclib)) then
                call cmd%local%prclib%show (u)
             else
                write (u, "(A)")  "Process library: [undefined]"
             end if
          case ("beams")
             call cmd%local%show_beams (u)
          case ("iterations")
             call cmd%local%it_list%write (u)
          case ("results")
             call cmd%local%process_stack%show (u)
          case ("stable")
             call cmd%local%model%show_stable (u)
          case ("polarized")
             call cmd%local%model%show_polarized (u)
          case ("unpolarized")
             call cmd%local%model%show_unpolarized (u)
          case ("unstable")
             model => cmd%local%model
             call model%show_unstable (u)
             n = model%get_n_field ()
             do j = 1, n
                pdg = model%get_pdg (j)
                call flavor_init (flv, pdg, model)
                if (.not. flavor_is_stable (flv)) &
                     call show_unstable (cmd%local, pdg, u)
                if (flavor_has_antiparticle (flv)) then
                   if (.not. flavor_is_stable (flavor_anti (flv))) &
                        call show_unstable (cmd%local, -pdg, u)
                end if
             end do
          case ("cuts", "weight", "scale", &
               "factorization_scale", "renormalization_scale", &
               "selection", "reweight", "analysis")
             call cmd%local%pn%show (cmd%name(i), u)
          case ("expect")
             call expect_summary (force = .true.)
          case ("logical")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_LOG, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, &
                     only_type=V_LOG, unit=u, pacified = pacified)
             end if
          case ("intrinsic")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, intrinsic=.true., &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, &
                     intrinsic=.true., unit=u, pacified = pacified)
             end if
          case ("int")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_INT, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, only_type=V_INT, &
                     unit=u, pacified = pacified)
             end if
          case ("real")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_REAL, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, only_type=V_REAL, &
                     unit=u, pacified = pacified)
             end if    
          case ("complex")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_CMPLX, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, only_type=V_CMPLX, &
                     unit=u, pacified = pacified)
             end if
          case ("pdg")
             if (associated (cmd%local%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_PDG, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, only_type=V_PDG, &
                     unit=u, pacified = pacified)
             end if
          case ("string") 
             if (associated (global%model)) then
                call var_list_write (cmd%local%var_list, only_type=V_STR, &
                     model_name = name, unit=u, pacified = pacified)
             else
                call var_list_write (cmd%local%var_list, only_type=V_STR, &
                     unit=u, pacified = pacified)
             end if            
          case default
             if (var_list_exists (cmd%local%var_list, cmd%name(i))) then
                call var_list_write_var (cmd%local%var_list, cmd%name(i), &
                     unit = u, pacified = pacified)
             else if (analysis_exists (cmd%name(i))) then
                call analysis_write (cmd%name(i), u)
             else if (cmd%local%process_stack%exists (cmd%name(i))) then
                process => cmd%local%process_stack%get_process_ptr (cmd%name(i))
                call process%show (u)
             else if (associated (cmd%local%prclib_stack%get_library_ptr &
                  (cmd%name(i)))) then
                prc_lib => cmd%local%prclib_stack%get_library_ptr (cmd%name(i))
                call prc_lib%show (u)
             else
                call msg_error ("show: object '" // char (cmd%name(i)) &
                     // "' not found")
             end if
          end select
       end do
    end if
    rewind (u)
    u_log = logfile_unit ()
    u_out = given_output_unit ()
    do
       read (u, "(A)", end = 1)  buffer
       if (u_log > 0)  write (u_log, "(A)")  trim (buffer)
       if (u_out > 0)  write (u_out, "(A)")  trim (buffer)
    end do
1   close (u)
    if (u_log > 0)  flush (u_log)
    if (u_out > 0)  flush (u_out)
  end subroutine cmd_show_execute

@ %def cmd_show_execute
@
\subsubsection{Clear values}
This command clears the current values of variables or other objects,
where this makes sense.  It parallels the [[show]] command.  The
objects are cleared, but not deleted.
<<Commands: types>>=
  type, extends (command_t) :: cmd_clear_t
     private
     type(string_t), dimension(:), allocatable :: name
   contains
   <<Commands: cmd clear: TBP>>
  end type cmd_clear_t
     
@ %def cmd_clear_t
@ Output: list the names of the objects to be cleared.
<<Commands: cmd clear: TBP>>=
  procedure :: write => cmd_clear_write
<<Commands: procedures>>=
  subroutine cmd_clear_write (cmd, unit, indent)
    class(cmd_clear_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "clear: "  
    if (allocated (cmd%name)) then
       do i = 1, size (cmd%name)
          write (u, "(1x,A)", advance="no")  char (cmd%name(i))
       end do
       write (u, *)
    else
       write (u, "(5x,A)")  "[undefined]"
    end if
  end subroutine cmd_clear_write

@ %def cmd_clear_write
@ Compile.  Allocate an array which is filled with the names of the
objects to be cleared.

Note: there is currently no need to account for options, but we
prepare for that possibility.
<<Commands: cmd clear: TBP>>=
  procedure :: compile => cmd_clear_compile
<<Commands: procedures>>=
  subroutine cmd_clear_compile (cmd, global)
    class(cmd_clear_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_var, pn_prefix, pn_name
    type(string_t) :: key
    integer :: i, n_args
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       select case (char (parse_node_get_rule_key (pn_arg)))
       case ("clear_arg")
          cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
       case default
          cmd%pn_opt => pn_arg
          pn_arg => null ()
       end select
    end if
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_args = parse_node_get_n_sub (pn_arg)
       allocate (cmd%name (n_args))
       pn_var => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_var))
          i = i + 1
          select case (char (parse_node_get_rule_key (pn_var)))
          case ("beams", "iterations", &
                "cuts", "weight", &
                "scale", "factorization_scale", "renormalization_scale", &
                "selection", "reweight", "analysis", &
                "unstable", "polarized", &
                "expect")
             cmd%name(i) = parse_node_get_key (pn_var)
          case ("log_var", "string_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             key = parse_node_get_key (pn_prefix)
             if (associated (pn_name)) then
                select case (char (parse_node_get_rule_key (pn_name)))
                case ("var_name")
                   select case (char (key))
                   case ("?", "$")  ! $ sign
                      cmd%name(i) = key // parse_node_get_string (pn_name)
                   end select
                case default
                   call parse_node_mismatch &
                        ("var_name",  pn_name)
                end select
             else
                cmd%name(i) = key
             end if
          case default
             cmd%name(i) = parse_node_get_string (pn_var)
          end select
          pn_var => parse_node_get_next_ptr (pn_var)
       end do
    else
       allocate (cmd%name (0))
    end if
  end subroutine cmd_clear_compile

@ %def cmd_clear_compile
@ Execute.  Scan the list of objects to clear.

Objects that can be shown but not cleared: model, library, results
<<Commands: cmd clear: TBP>>=
  procedure :: execute => cmd_clear_execute
<<Commands: procedures>>=    
  subroutine cmd_clear_execute (cmd, global)
    class(cmd_clear_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_entry_t), pointer :: var
    integer :: i
    logical :: success
    if (size (cmd%name) == 0) then
       call msg_warning ("clear: no object specified")
    else
       do i = 1, size (cmd%name)
          success = .true.
          select case (char (cmd%name(i)))
          case ("beams")
             call cmd%local%clear_beams ()
          case ("iterations")
             call cmd%local%it_list%clear ()
          case ("polarized")
             call cmd%local%model%clear_polarized ()
          case ("unstable")
             call cmd%local%model%clear_unstable ()
          case ("cuts", "weight", "scale", &
               "factorization_scale", "renormalization_scale", &
               "selection", "reweight", "analysis")
             call cmd%local%pn%clear (cmd%name(i))
          case ("expect")
             call expect_clear ()
          case default
             if (var_list_exists (cmd%local%var_list, cmd%name(i))) then
                var => var_list_get_var_ptr &
                     (cmd%local%var_list, cmd%name(i), follow_link=.true.)
                if (.not. var_entry_is_locked (var)) then
                   call var_entry_clear (var)
                else
                   call msg_error ("clear: variable '" // char (cmd%name(i)) &
                        // "' is locked and can't be cleared")
                   success = .false.
                end if
             else if (analysis_exists (cmd%name(i))) then
                call analysis_clear (cmd%name(i))
             else
                call msg_error ("clear: object '" // char (cmd%name(i)) &
                     // "' not found")
                success = .false.
             end if
          end select
          if (success)  call msg_message ("cleared: " // char (cmd%name(i)))
       end do
    end if
  end subroutine cmd_clear_execute

@ %def cmd_clear_execute
@ 
\subsubsection{Compare values of variables to expectation}
The implementation is similar to the [[show]] command.  There are just
two arguments: two values that should be compared.  For providing
local values for the numerical tolerance, the command has a local
argument list.

If the expectation fails, an error condition is recorded.
<<Commands: types>>=
  type, extends (command_t) :: cmd_expect_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd expect: TBP>>  
  end type cmd_expect_t

@ %def cmd_expect_t
@ Simply tell the status.
<<Commands: cmd expect: TBP>>=
  procedure :: write => cmd_expect_write
<<Commands: procedures>>=
  subroutine cmd_expect_write (cmd, unit, indent)
    class(cmd_expect_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    if (associated (cmd%pn_lexpr)) then
       write (u, "(1x,A)")  "expect: [expression associated]"
    else
       write (u, "(1x,A)")  "expect: [undefined]"       
    end if
  end subroutine cmd_expect_write

@ %def cmd_expect_write
@ Compile.  This merely assigns the parse node, the actual compilation is done
at execution.  This is necessary because the origin of variables
(local/global) may change during execution.
<<Commands: cmd expect: TBP>>=
  procedure :: compile => cmd_expect_compile
<<Commands: procedures>>=
  subroutine cmd_expect_compile (cmd, global)
    class(cmd_expect_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
    cmd%pn_lexpr => parse_node_get_sub_ptr (pn_arg)
    call cmd%compile_options (global)
  end subroutine cmd_expect_compile

@ %def cmd_expect_compile
@ Execute.  Evaluate both arguments, print them and their difference
(if numerical), and whether they agree.  Record the result.
<<Commands: cmd expect: TBP>>=
  procedure :: execute => cmd_expect_execute
<<Commands: procedures>>=    
  subroutine cmd_expect_execute (cmd, global)
    class(cmd_expect_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: success, is_known
    success = &
         eval_log (cmd%pn_lexpr, cmd%local%var_list, is_known=is_known)
    if (is_known) then
       if (success) then
          call msg_message ("expect: success")
       else
          call msg_error ("expect: failure")
       end if
    else
       call msg_error ("expect: undefined result")
       success = .false.
    end if
    call expect_record (success)
  end subroutine cmd_expect_execute

@ %def cmd_expect_execute
@ 
\subsubsection{Beams}
The beam command includes both beam and structure-function
definition.
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_t
     private
     integer :: n_in = 0
     type(parse_node_p), dimension(:), allocatable :: pn_pdg
     integer :: n_sf_record = 0
     integer, dimension(:), allocatable :: n_entry
     type(parse_node_p), dimension(:,:), allocatable :: pn_sf_entry
   contains
   <<Commands: cmd beams: TBP>>
  end type cmd_beams_t

@ %def cmd_beams_t
@ Output.  The particle expressions are not resolved.
<<Commands: cmd beams: TBP>>=
  procedure :: write => cmd_beams_write
<<Commands: procedures>>=
  subroutine cmd_beams_write (cmd, unit, indent)
    class(cmd_beams_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams: [undefined]"
    end select
    if (allocated (cmd%n_entry)) then
       if (cmd%n_sf_record > 0) then
          write (u, "(1x,A,99(1x,I0))")  "structure function entries:", &
               cmd%n_entry
       end if
    end if
  end subroutine cmd_beams_write

@ %def cmd_beams_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams: TBP>>=
  procedure :: compile => cmd_beams_compile
<<Commands: procedures>>=
  subroutine cmd_beams_compile (cmd, global)
    class(cmd_beams_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_beam_def, pn_beam_spec
    type(parse_node_t), pointer :: pn_beam_list
    type(parse_node_t), pointer :: pn_codes
    type(parse_node_t), pointer :: pn_strfun_seq, pn_strfun_pair
    type(parse_node_t), pointer :: pn_strfun_def
    integer :: i
    pn_beam_def => parse_node_get_sub_ptr (cmd%pn, 3)
    pn_beam_spec => parse_node_get_sub_ptr (pn_beam_def)
    pn_strfun_seq => parse_node_get_next_ptr (pn_beam_spec)
    pn_beam_list => parse_node_get_sub_ptr (pn_beam_spec)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_beam_list)
    allocate (cmd%pn_pdg (cmd%n_in))
    pn_codes => parse_node_get_sub_ptr (pn_beam_list)
    do i = 1, cmd%n_in
       cmd%pn_pdg(i)%ptr => pn_codes
       pn_codes => parse_node_get_next_ptr (pn_codes)
    end do
    if (associated (pn_strfun_seq)) then
       cmd%n_sf_record = parse_node_get_n_sub (pn_beam_def) - 1
       allocate (cmd%n_entry (cmd%n_sf_record), source = 1)
       allocate (cmd%pn_sf_entry (2, cmd%n_sf_record))
       do i = 1, cmd%n_sf_record
          pn_strfun_pair => parse_node_get_sub_ptr (pn_strfun_seq, 2)
          pn_strfun_def => parse_node_get_sub_ptr (pn_strfun_pair)
          cmd%pn_sf_entry(1,i)%ptr => pn_strfun_def
          pn_strfun_def => parse_node_get_next_ptr (pn_strfun_def)
          cmd%pn_sf_entry(2,i)%ptr => pn_strfun_def
          if (associated (pn_strfun_def))  cmd%n_entry(i) = 2
          pn_strfun_seq => parse_node_get_next_ptr (pn_strfun_seq)
       end do
    else
       allocate (cmd%n_entry (0))
       allocate (cmd%pn_sf_entry (0, 0))
    end if
  end subroutine cmd_beams_compile

@ %def cmd_beams_compile
@ Command execution: Determine beam particles and structure-function
names, if any.  The results are stored in the [[beam_structure]]
component of the [[global]] data block.
<<Commands: cmd beams: TBP>>=
  procedure :: execute => cmd_beams_execute
<<Commands: procedures>>=
  subroutine cmd_beams_execute (cmd, global)
    class(cmd_beams_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(pdg_array_t) :: pdg_array
    integer, dimension(:), allocatable :: pdg
    type(flavor_t), dimension(:), allocatable :: flv
    type(parse_node_t), pointer :: pn_key
    type(string_t) :: sf_name
    integer :: i, j
    call lhapdf_global_reset ()
    allocate (flv (cmd%n_in))
    do i = 1, cmd%n_in
       pdg_array = eval_pdg_array (cmd%pn_pdg(i)%ptr, cmd%local%var_list)
       pdg = pdg_array
       select case (size (pdg))
       case (1)
          call flavor_init (flv(i), pdg(1), cmd%local%model)
       case default
          call msg_fatal ("Beams: beam particles must be unique")
       end select
    end do
    select case (cmd%n_in)
    case (1)
       if (cmd%n_sf_record > 0) then
          call msg_fatal ("Beam setup: no structure functions allowed &
               &for decay")
       end if
       call global%beam_structure%init_sf (flavor_get_name (flv))
    case (2)
       call global%beam_structure%init_sf (flavor_get_name (flv), cmd%n_entry)
       do i = 1, cmd%n_sf_record
          do j = 1, cmd%n_entry(i)
             pn_key => parse_node_get_sub_ptr (cmd%pn_sf_entry(j,i)%ptr)
             sf_name = parse_node_get_key (pn_key)
             call global%beam_structure%set_sf (i, j, sf_name)
          end do
       end do
    end select
  end subroutine cmd_beams_execute

@ %def cmd_beams_execute 
@ 
\subsubsection{Density matrices for beam polarization}
For holding beam polarization, we define a notation and a data
structure for sparse matrices.  The entries (and the index
expressions) are numerical expressions, so we use evaluation trees.

Each entry in the sparse matrix is an n-tuple of expressions.  The first
tuple elements represent index values, the last one is an arbitrary
(complex) number.  Absent expressions are replaced by default-value rules.

Note: Here, and in some other commands, we would like to store an evaluation
tree, not just a parse node pointer.  However, the current expression handler
wants all variables defined, so the evaluation tree can only be built by
[[evaluate]], i.e., compiled just-in-time and evaluated immediately.
<<Commands: types>>=
  type :: sentry_expr_t
     type(parse_node_p), dimension(:), allocatable :: expr
   contains
   <<Commands: sentry expr: TBP>>
  end type sentry_expr_t

@ %def sentry_expr_t
@ Compile parse nodes into evaluation trees.
<<Commands: sentry expr: TBP>>=
  procedure :: compile => sentry_expr_compile
<<Commands: procedures>>=
  subroutine sentry_expr_compile (sentry, pn)
    class(sentry_expr_t), intent(out) :: sentry
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_expr, pn_extra
    integer :: n_expr, i
    n_expr = parse_node_get_n_sub (pn)
    allocate (sentry%expr (n_expr))
    if (n_expr > 0) then
       i = 0
       pn_expr => parse_node_get_sub_ptr (pn)
       pn_extra => parse_node_get_next_ptr (pn_expr)
       do i = 1, n_expr
          sentry%expr(i)%ptr => pn_expr
          if (associated (pn_extra)) then
             pn_expr => parse_node_get_sub_ptr (pn_extra, 2)
             pn_extra => parse_node_get_next_ptr (pn_extra)
          end if
       end do
    end if
  end subroutine sentry_expr_compile
    
@ %def sentry_expr_compile
@ Evaluate the expressions and return an index array of predefined
length together with a complex value.  If the value (as the last expression)
is undefined, set it to unity.  If index values are undefined, repeat
the previous index value.
<<Commands: sentry expr: TBP>>=
  procedure :: evaluate => sentry_expr_evaluate
<<Commands: procedures>>=
  subroutine sentry_expr_evaluate (sentry, index, value, global)
    class(sentry_expr_t), intent(inout) :: sentry
    integer, dimension(:), intent(out) :: index
    complex(default), intent(out) :: value
    type(rt_data_t), intent(in), target :: global
    integer :: i, n_expr, n_index
    type(eval_tree_t) :: eval_tree
    n_expr = size (sentry%expr) 
    n_index = size (index)
    if (n_expr <= n_index + 1) then
       do i = 1, min (n_expr, n_index)
          associate (expr => sentry%expr(i))
            call eval_tree_init_expr (eval_tree, expr%ptr, global%var_list)
            call eval_tree_evaluate (eval_tree)
            if (eval_tree_result_is_known (eval_tree)) then
               index(i) = eval_tree_get_int (eval_tree)
            else
               call msg_fatal ("Evaluating density matrix: undefined index")
            end if
          end associate
       end do
       do i = n_expr + 1, n_index
          index(i) = index(n_expr)
       end do
       if (n_expr == n_index + 1) then
          associate (expr => sentry%expr(n_expr))
            call eval_tree_init_expr (eval_tree, expr%ptr, global%var_list)
            call eval_tree_evaluate (eval_tree)
            if (eval_tree_result_is_known (eval_tree)) then
               value = eval_tree_get_cmplx (eval_tree)
            else
               call msg_fatal ("Evaluating density matrix: undefined index")
            end if
            call eval_tree_final (eval_tree)
          end associate
       else
          value = 1
       end if
    else
       call msg_fatal ("Evaluating density matrix: index expression too long")
    end if
  end subroutine sentry_expr_evaluate

@ %def sentry_expr_evaluate
@ The sparse matrix itself consists of an arbitrary number of entries.
<<Commands: types>>=
  type :: smatrix_expr_t
     type(sentry_expr_t), dimension(:), allocatable :: entry
   contains
   <<Commands: smatrix expr: TBP>>
  end type smatrix_expr_t
  
@ %def smatrix_expr_t
@ Compile: assign sub-nodes to sentry-expressions and compile those.
<<Commands: smatrix expr: TBP>>=
  procedure :: compile => smatrix_expr_compile
<<Commands: procedures>>=
  subroutine smatrix_expr_compile (smatrix_expr, pn)
    class(smatrix_expr_t), intent(out) :: smatrix_expr
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_arg, pn_entry
    integer :: n_entry, i
    pn_arg => parse_node_get_sub_ptr (pn, 2)
    if (associated (pn_arg)) then
       n_entry = parse_node_get_n_sub (pn_arg)
       allocate (smatrix_expr%entry (n_entry))
       pn_entry => parse_node_get_sub_ptr (pn_arg)
       do i = 1, n_entry
          call smatrix_expr%entry(i)%compile (pn_entry)
          pn_entry => parse_node_get_next_ptr (pn_entry)
       end do
    else
       allocate (smatrix_expr%entry (0))
    end if
  end subroutine smatrix_expr_compile

@ %def smatrix_expr_compile
@ Evaluate the entries and build a new [[smatrix]] object, which
contains just the numerical results.
<<Commands: smatrix expr: TBP>>=
  procedure :: evaluate => smatrix_expr_evaluate
<<Commands: procedures>>=
  subroutine smatrix_expr_evaluate (smatrix_expr, smatrix, global)
    class(smatrix_expr_t), intent(inout) :: smatrix_expr
    type(smatrix_t), intent(out) :: smatrix
    type(rt_data_t), intent(in), target :: global
    integer, dimension(2) :: idx
    complex(default) :: value
    integer :: i, n_entry
    n_entry = size (smatrix_expr%entry)
    call smatrix%init (2, n_entry)
    do i = 1, n_entry
       call smatrix_expr%entry(i)%evaluate (idx, value, global)
       call smatrix%set_entry (i, idx, value)
    end do
  end subroutine smatrix_expr_evaluate
    
@ %def smatrix_expr_evaluate
@ 
\subsubsection{Beam polarization density}

The beam polarization command defines spin density matrix for one or
two beams (scattering or decay).
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_pol_density_t
     private
     integer :: n_in = 0
     type(smatrix_expr_t), dimension(:), allocatable :: smatrix
   contains
   <<Commands: cmd beams pol density: TBP>>
  end type cmd_beams_pol_density_t

@ %def cmd_beams_pol_density_t
@ Output.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: write => cmd_beams_pol_density_write
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_write (cmd, unit, indent)
    class(cmd_beams_pol_density_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams polarization setup: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams polarization setup: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams polarization setup: [undefined]"
    end select
  end subroutine cmd_beams_pol_density_write

@ %def cmd_beams_pol_density_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: compile => cmd_beams_pol_density_compile
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_compile (cmd, global)
    class(cmd_beams_pol_density_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_pol_spec, pn_smatrix
    integer :: i
    pn_pol_spec => parse_node_get_sub_ptr (cmd%pn, 3)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_pol_spec)
    allocate (cmd%smatrix (cmd%n_in))
    pn_smatrix => parse_node_get_sub_ptr (pn_pol_spec)
    do i = 1, cmd%n_in
       call cmd%smatrix(i)%compile (pn_smatrix)
       pn_smatrix => parse_node_get_next_ptr (pn_smatrix)
    end do
  end subroutine cmd_beams_pol_density_compile

@ %def cmd_beams_pol_density_compile
@ Command execution: Fill polarization density matrices.  No check
yet, the matrices are checked and normalized when the actual beam
object is created, just before integration.  For intermediate storage,
we use the [[beam_structure]] object in the [[global]] data set.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: execute => cmd_beams_pol_density_execute
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_execute (cmd, global)
    class(cmd_beams_pol_density_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(smatrix_t) :: smatrix
    integer :: i
    call global%beam_structure%init_pol (cmd%n_in)
    do i = 1, cmd%n_in
       call cmd%smatrix(i)%evaluate (smatrix, global)
       call global%beam_structure%set_smatrix (i, smatrix)
    end do
  end subroutine cmd_beams_pol_density_execute

@ %def cmd_beams_pol_density_execute 
@ 
\subsubsection{Beam polarization fraction}
In addition to the polarization density matrix, we can independently
specify the polarization fraction for one or both beams.
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_pol_fraction_t
     private
     integer :: n_in = 0
     type(parse_node_p), dimension(:), allocatable :: expr
   contains
   <<Commands: cmd beams pol fraction: TBP>>
  end type cmd_beams_pol_fraction_t

@ %def cmd_beams_pol_fraction_t
@ Output.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: write => cmd_beams_pol_fraction_write
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_write (cmd, unit, indent)
    class(cmd_beams_pol_fraction_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams polarization fraction: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams polarization fraction: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams polarization fraction: [undefined]"
    end select
  end subroutine cmd_beams_pol_fraction_write

@ %def cmd_beams_pol_fraction_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: compile => cmd_beams_pol_fraction_compile
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_compile (cmd, global)
    class(cmd_beams_pol_fraction_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_frac_spec, pn_expr
    integer :: i
    pn_frac_spec => parse_node_get_sub_ptr (cmd%pn, 3)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_frac_spec)
    allocate (cmd%expr (cmd%n_in))
    pn_expr => parse_node_get_sub_ptr (pn_frac_spec)
    do i = 1, cmd%n_in
       cmd%expr(i)%ptr => pn_expr
       pn_expr => parse_node_get_next_ptr (pn_expr)
    end do
  end subroutine cmd_beams_pol_fraction_compile

@ %def cmd_beams_pol_fraction_compile
@ Command execution: Retrieve the numerical values of the beam
polarization fractions.  The results are stored in the
[[beam_structure]] component of the [[global]] data block.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: execute => cmd_beams_pol_fraction_execute
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_execute (cmd, global)
    class(cmd_beams_pol_fraction_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    real(default), dimension(:), allocatable :: pol_f
    type(eval_tree_t) :: expr
    integer :: i
    allocate (pol_f (cmd%n_in))
    do i = 1, cmd%n_in
       call eval_tree_init_expr (expr, cmd%expr(i)%ptr, global%var_list)
       call eval_tree_evaluate (expr)
       if (eval_tree_result_is_known (expr)) then
          pol_f(i) = eval_tree_get_real (expr)
       else
          call msg_fatal ("beams polarization fraction: undefined value")
       end if
       call eval_tree_final (expr)
    end do
    call global%beam_structure%set_pol_f (pol_f)
  end subroutine cmd_beams_pol_fraction_execute

@ %def cmd_beams_pol_fraction_execute 
@ 
\subsubsection{Beam momentum}
This is completely analogous to the previous command, hence we can use
inheritance.
<<Commands: types>>=
  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_momentum_t
   contains
   <<Commands: cmd beams momentum: TBP>>
  end type cmd_beams_momentum_t

@ %def cmd_beams_momentum_t
@ Output.
<<Commands: cmd beams momentum: TBP>>=
  procedure :: write => cmd_beams_momentum_write
<<Commands: procedures>>=
  subroutine cmd_beams_momentum_write (cmd, unit, indent)
    class(cmd_beams_momentum_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams momentum: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams momentum: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams momentum: [undefined]"
    end select
  end subroutine cmd_beams_momentum_write

@ %def cmd_beams_momentum_write
@ Compile: inherited.

Command execution: Not inherited, but just the error string and the final
command are changed.
<<Commands: cmd beams momentum: TBP>>=
  procedure :: execute => cmd_beams_momentum_execute
<<Commands: procedures>>=
  subroutine cmd_beams_momentum_execute (cmd, global)
    class(cmd_beams_momentum_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    real(default), dimension(:), allocatable :: p
    type(eval_tree_t) :: expr
    integer :: i
    allocate (p (cmd%n_in))
    do i = 1, cmd%n_in
       call eval_tree_init_expr (expr, cmd%expr(i)%ptr, global%var_list)
       call eval_tree_evaluate (expr)
       if (eval_tree_result_is_known (expr)) then
          p(i) = eval_tree_get_real (expr)
       else
          call msg_fatal ("beams momentum: undefined value")
       end if
       call eval_tree_final (expr)
    end do
    call global%beam_structure%set_momentum (p)
  end subroutine cmd_beams_momentum_execute

@ %def cmd_beams_momentum_execute 
@ 
\subsubsection{Beam angles}
Again, this is analogous.  There are two angles, polar angle $\theta$
and azimuthal angle $\phi$, which can be set independently for both beams.
<<Commands: types>>=
  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_theta_t
   contains
   <<Commands: cmd beams theta: TBP>>
  end type cmd_beams_theta_t

  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_phi_t
   contains
   <<Commands: cmd beams phi: TBP>>
  end type cmd_beams_phi_t

@ %def cmd_beams_theta_t
@ %def cmd_beams_phi_t
@ Output.
<<Commands: cmd beams theta: TBP>>=
  procedure :: write => cmd_beams_theta_write
<<Commands: cmd beams phi: TBP>>=
  procedure :: write => cmd_beams_phi_write
<<Commands: procedures>>=
  subroutine cmd_beams_theta_write (cmd, unit, indent)
    class(cmd_beams_theta_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams theta: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams theta: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams theta: [undefined]"
    end select
  end subroutine cmd_beams_theta_write

  subroutine cmd_beams_phi_write (cmd, unit, indent)
    class(cmd_beams_phi_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams phi: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams phi: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams phi: [undefined]"
    end select
  end subroutine cmd_beams_phi_write

@ %def cmd_beams_theta_write
@ %def cmd_beams_phi_write
@ Compile: inherited.

Command execution: Not inherited, but just the error string and the final
command are changed.
<<Commands: cmd beams theta: TBP>>=
  procedure :: execute => cmd_beams_theta_execute
<<Commands: cmd beams phi: TBP>>=
  procedure :: execute => cmd_beams_phi_execute
<<Commands: procedures>>=
  subroutine cmd_beams_theta_execute (cmd, global)
    class(cmd_beams_theta_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    real(default), dimension(:), allocatable :: theta
    type(eval_tree_t) :: expr
    integer :: i
    allocate (theta (cmd%n_in))
    do i = 1, cmd%n_in
       call eval_tree_init_expr (expr, cmd%expr(i)%ptr, global%var_list)
       call eval_tree_evaluate (expr)
       if (eval_tree_result_is_known (expr)) then
          theta(i) = eval_tree_get_real (expr)
       else
          call msg_fatal ("beams theta: undefined value")
       end if
       call eval_tree_final (expr)
    end do
    call global%beam_structure%set_theta (theta)
  end subroutine cmd_beams_theta_execute

  subroutine cmd_beams_phi_execute (cmd, global)
    class(cmd_beams_phi_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    real(default), dimension(:), allocatable :: phi
    type(eval_tree_t) :: expr
    integer :: i
    allocate (phi (cmd%n_in))
    do i = 1, cmd%n_in
       call eval_tree_init_expr (expr, cmd%expr(i)%ptr, global%var_list)
       call eval_tree_evaluate (expr)
       if (eval_tree_result_is_known (expr)) then
          phi(i) = eval_tree_get_real (expr)
       else
          call msg_fatal ("beams phi: undefined value")
       end if
       call eval_tree_final (expr)
    end do
    call global%beam_structure%set_phi (phi)
  end subroutine cmd_beams_phi_execute

@ %def cmd_beams_theta_execute 
@ %def cmd_beams_phi_execute 
@
\subsubsection{Cuts}
Define a cut expression.  We store the parse tree for the right-hand
side instead of compiling it.  Compilation is deferred to the process
environment where the cut expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_cuts_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd cuts: TBP>>
  end type cmd_cuts_t

@ %def cmd_cuts_t
@ Output.  Do not print the parse tree, since this may get cluttered.
Just a message that cuts have been defined.
<<Commands: cmd cuts: TBP>>=
  procedure :: write => cmd_cuts_write
<<Commands: procedures>>=
  subroutine cmd_cuts_write (cmd, unit, indent)
    class(cmd_cuts_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "cuts: [defined]"
  end subroutine cmd_cuts_write
  
@ %def cmd_cuts_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd cuts: TBP>>=
  procedure :: compile => cmd_cuts_compile
<<Commands: procedures>>=
  subroutine cmd_cuts_compile (cmd, global)
    class(cmd_cuts_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_cuts_compile

@ %def cmd_cuts_compile
@ Instead of evaluating the cut expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd cuts: TBP>>=
  procedure :: execute => cmd_cuts_execute
<<Commands: procedures>>=
  subroutine cmd_cuts_execute (cmd, global)
    class(cmd_cuts_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%cuts_lexpr => cmd%pn_lexpr
  end subroutine cmd_cuts_execute

@ %def cmd_cuts_execute
@ 
\subsubsection{General, Factorization and Renormalization Scales}
Define a scale expression for either the renormalization or the 
factorization scale.  We store the parse tree for the right-hand
side instead of compiling it.  Compilation is deferred to the process
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd scale: TBP>>   
  end type cmd_scale_t

@ %def cmd_scale_t
<<Commands: types>>=
  type, extends (command_t) :: cmd_fac_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd fac scale: TBP>>
  end type cmd_fac_scale_t

@ %def cmd_fac_scale_t
<<Commands: types>>=
  type, extends (command_t) :: cmd_ren_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd ren scale: TBP>>
  end type cmd_ren_scale_t

@ %def cmd_ren_scale_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd scale: TBP>>=
  procedure :: write => cmd_scale_write
<<Commands: procedures>>=
  subroutine cmd_scale_write (cmd, unit, indent)
    class(cmd_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "scale: [defined]"
  end subroutine cmd_scale_write
  
@ %def cmd_scale_write
@
<<Commands: cmd fac scale: TBP>>=
  procedure :: write => cmd_fac_scale_write
<<Commands: procedures>>=
  subroutine cmd_fac_scale_write (cmd, unit, indent)
    class(cmd_fac_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "factorization scale: [defined]"
  end subroutine cmd_fac_scale_write
  
@ %def cmd_fac_scale_write
@
<<Commands: cmd ren scale: TBP>>=
  procedure :: write => cmd_ren_scale_write
<<Commands: procedures>>=
  subroutine cmd_ren_scale_write (cmd, unit, indent)
    class(cmd_ren_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "renormalization scale: [defined]"
  end subroutine cmd_ren_scale_write
  
@ %def cmd_ren_scale_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd scale: TBP>>=
  procedure :: compile => cmd_scale_compile 
<<Commands: procedures>>=
  subroutine cmd_scale_compile (cmd, global)
    class(cmd_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_scale_compile

@ %def cmd_scale_compile
@
<<Commands: cmd fac scale: TBP>>=
  procedure :: compile => cmd_fac_scale_compile
<<Commands: procedures>>=
  subroutine cmd_fac_scale_compile (cmd, global)
    class(cmd_fac_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_fac_scale_compile

@ %def cmd_fac_scale_compile
@
<<Commands: cmd ren scale: TBP>>=
  procedure :: compile => cmd_ren_scale_compile
<<Commands: procedures>>=
  subroutine cmd_ren_scale_compile (cmd, global)
    class(cmd_ren_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_ren_scale_compile

@ %def cmd_ren_scale_compile
@ Instead of evaluating the scale expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd scale: TBP>>=
  procedure :: execute => cmd_scale_execute
<<Commands: procedures>>=
  subroutine cmd_scale_execute (cmd, global)
    class(cmd_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%scale_expr => cmd%pn_expr
  end subroutine cmd_scale_execute

@ %def cmd_scale_execute
@ 
<<Commands: cmd fac scale: TBP>>=
  procedure :: execute => cmd_fac_scale_execute
<<Commands: procedures>>=
  subroutine cmd_fac_scale_execute (cmd, global)
    class(cmd_fac_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%fac_scale_expr => cmd%pn_expr
  end subroutine cmd_fac_scale_execute

@ %def cmd_fac_scale_execute
@ 
<<Commands: cmd ren scale: TBP>>=
  procedure :: execute => cmd_ren_scale_execute
<<Commands: procedures>>=
  subroutine cmd_ren_scale_execute (cmd, global)
    class(cmd_ren_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%ren_scale_expr => cmd%pn_expr    
  end subroutine cmd_ren_scale_execute

@ %def cmd_ren_scale_execute
@ 
\subsubsection{Weight}
Define a weight expression. The weight is applied to a process to be
integrated, event by event. We store the parse tree for the right-hand
side instead of compiling it. Compilation is deferred to the process
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_weight_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd weight: TBP>>  
  end type cmd_weight_t

@ %def cmd_weight_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd weight: TBP>>=
  procedure :: write => cmd_weight_write
<<Commands: procedures>>=
  subroutine cmd_weight_write (cmd, unit, indent)
    class(cmd_weight_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "weight expression: [defined]"
  end subroutine cmd_weight_write
  
@ %def cmd_weight_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd weight: TBP>>=
  procedure :: compile => cmd_weight_compile
<<Commands: procedures>>=
  subroutine cmd_weight_compile (cmd, global)
    class(cmd_weight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_weight_compile

@ %def cmd_weight_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd weight: TBP>>=
  procedure :: execute => cmd_weight_execute
<<Commands: procedures>>=
  subroutine cmd_weight_execute (cmd, global)
    class(cmd_weight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%weight_expr => cmd%pn_expr
  end subroutine cmd_weight_execute

@ %def cmd_weight_execute
@ 
\subsubsection{Selection}
Define a selection expression.  This is to be applied upon simulation or
event-file rescanning, event by event.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to the
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_selection_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd selection: TBP>>
  end type cmd_selection_t

@ %def cmd_selection_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd selection: TBP>>=
  procedure :: write => cmd_selection_write
<<Commands: procedures>>=
  subroutine cmd_selection_write (cmd, unit, indent)
    class(cmd_selection_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "selection expression: [defined]"
  end subroutine cmd_selection_write
  
@ %def cmd_selection_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd selection: TBP>>=
  procedure :: compile => cmd_selection_compile
<<Commands: procedures>>=
  subroutine cmd_selection_compile (cmd, global)
    class(cmd_selection_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_selection_compile

@ %def cmd_selection_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd selection: TBP>>=
  procedure :: execute => cmd_selection_execute
<<Commands: procedures>>=
  subroutine cmd_selection_execute (cmd, global)
    class(cmd_selection_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%selection_lexpr => cmd%pn_expr
  end subroutine cmd_selection_execute

@ %def cmd_selection_execute
@ 
\subsubsection{Reweight}
Define a reweight expression.  This is to be applied upon simulation or
event-file rescanning, event by event.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to the
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_reweight_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd reweight: TBP>>  
  end type cmd_reweight_t

@ %def cmd_reweight_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd reweight: TBP>>=
  procedure :: write => cmd_reweight_write
<<Commands: procedures>>=
  subroutine cmd_reweight_write (cmd, unit, indent)
    class(cmd_reweight_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "reweight expression: [defined]"
  end subroutine cmd_reweight_write
  
@ %def cmd_reweight_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd reweight: TBP>>=
  procedure :: compile => cmd_reweight_compile
<<Commands: procedures>>=
  subroutine cmd_reweight_compile (cmd, global)
    class(cmd_reweight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_reweight_compile

@ %def cmd_reweight_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd reweight: TBP>>=
  procedure :: execute => cmd_reweight_execute
<<Commands: procedures>>=
  subroutine cmd_reweight_execute (cmd, global)
    class(cmd_reweight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%reweight_expr => cmd%pn_expr
  end subroutine cmd_reweight_execute

@ %def cmd_reweight_execute
@ 
\subsubsection{Alternative Simulation Setups}
Together with simulation, we can re-evaluate event weights in the context of
alternative setups.  The [[cmd_alt_setup_t]] object is designed to hold these
setups, which are brace-enclosed command lists.  Compilation is deferred to
the simulation environment where the setup expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_alt_setup_t
     private
     type(parse_node_p), dimension(:), allocatable :: setup
   contains
   <<Commands: cmd alt setup: TBP>>
  end type cmd_alt_setup_t

@ %def cmd_alt_setup_t
@ Output.  Print just a message that the alternative setup list has been
defined.
<<Commands: cmd alt setup: TBP>>=
  procedure :: write => cmd_alt_setup_write
<<Commands: procedures>>=
  subroutine cmd_alt_setup_write (cmd, unit, indent)
    class(cmd_alt_setup_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,I0,A)")  "alt_setup: ", size (cmd%setup), " entries"
  end subroutine cmd_alt_setup_write
  
@ %def cmd_alt_setup_write
@ Compile.  Store the parse sub-trees in an array.
<<Commands: cmd alt setup: TBP>>=
  procedure :: compile => cmd_alt_setup_compile
<<Commands: procedures>>=
  subroutine cmd_alt_setup_compile (cmd, global)
    class(cmd_alt_setup_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_setup
    integer :: i
    pn_list => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_list)) then
       allocate (cmd%setup (parse_node_get_n_sub (pn_list)))
       i = 1
       pn_setup => parse_node_get_sub_ptr (pn_list)
       do while (associated (pn_setup))
          cmd%setup(i)%ptr => pn_setup
          i = i + 1
          pn_setup => parse_node_get_next_ptr (pn_setup)
       end do
    else
       allocate (cmd%setup (0))
    end if
  end subroutine cmd_alt_setup_compile

@ %def cmd_alt_setup_compile
@ Execute.  Transfer the array of command lists to the global environment.
<<Commands: cmd alt setup: TBP>>=
  procedure :: execute => cmd_alt_setup_execute
<<Commands: procedures>>=
  subroutine cmd_alt_setup_execute (cmd, global)
    class(cmd_alt_setup_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (allocated (global%pn%alt_setup))  deallocate (global%pn%alt_setup)
    allocate (global%pn%alt_setup (size (cmd%setup)), source = cmd%setup)
  end subroutine cmd_alt_setup_execute

@ %def cmd_alt_setup_execute
@
\subsubsection{Integration}
Integrate several processes, consecutively with identical parameters.
<<Commands: types>>=
  type, extends (command_t) :: cmd_integrate_t
     private
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd integrate: TBP>>
  end type cmd_integrate_t
     
@ %def cmd_integrate_t
@ Output: we know the process IDs.
<<Commands: cmd integrate: TBP>>=
  procedure :: write => cmd_integrate_write
<<Commands: procedures>>=
  subroutine cmd_integrate_write (cmd, unit, indent)
    class(cmd_integrate_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "integrate ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_integrate_write

@ %def cmd_integrate_write
@ Compile.
<<Commands: cmd integrate: TBP>>=
  procedure :: compile => cmd_integrate_compile
<<Commands: procedures>>=
  subroutine cmd_integrate_compile (cmd, global)
    class(cmd_integrate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_proclist, pn_proc
    integer :: i
    pn_proclist => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       call global%process_stack%init_result_vars (cmd%process_id(i))
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_integrate_compile

@ %def cmd_integrate_compile
@ Command execution.  Integrate the process(es) with the predefined number
of passes, iterations and calls.  For structure functions, cuts,
weight and scale, use local definitions if present; by default, the local
definitions are initialized with the global ones.

The [[integrate]] procedure should take its input from the currently
active local environment, but produce a process record in the stack of
the global environment.

Since the process acquires a snapshot of the variable list, so if the global
list (or the local one) is deleted, this does no harm.  This implies that
later changes of the variable list do not affect the stored process.
<<Commands: cmd integrate: TBP>>=
  procedure :: execute => cmd_integrate_execute
<<Commands: procedures>>=
  subroutine cmd_integrate_execute (cmd, global)
    class(cmd_integrate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    integer :: i
    do i = 1, cmd%n_proc
       call integrate_process (cmd%process_id(i), global, cmd%local)
       call global%process_stack%fill_result_vars (cmd%process_id(i))
       if (signal_is_pending ())  return
    end do
  end subroutine cmd_integrate_execute

@ %def cmd_integrate_execute
@
\subsubsection{Observables}
Declare an observable.  After the declaration, it can be used to
record data, and at the end one can retrieve average and error.
<<Commands: types>>=
  type, extends (command_t) :: cmd_observable_t
     private
     type(string_t) :: id
   contains
   <<Commands: cmd observable: TBP>>
  end type cmd_observable_t
     
@ %def cmd_observable_t
@ Output.  We know the ID.
<<Commands: cmd observable: TBP>>=
  procedure :: write => cmd_observable_write
<<Commands: procedures>>=
  subroutine cmd_observable_write (cmd, unit, indent)
    class(cmd_observable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "observable: ", char (cmd%id)
  end subroutine cmd_observable_write
  
@ %def cmd_observable_write
@ Compile.  Just record the observable ID.
<<Commands: cmd observable: TBP>>=
  procedure :: compile => cmd_observable_compile
<<Commands: procedures>>=
  subroutine cmd_observable_compile (cmd, global)
    class(cmd_observable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_tag)) then
       cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    end if       
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("observable: name expression not implemented (yet)")
    end select
  end subroutine cmd_observable_compile

@ %def cmd_observable_compile
@ Command execution.  This declares the observable and allocates it in
the analysis store.
<<Commands: cmd observable: TBP>>=
  procedure :: execute => cmd_observable_execute
<<Commands: procedures>>=
  subroutine cmd_observable_execute (cmd, global)
    class(cmd_observable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(graph_options_t) :: graph_options
    type(string_t) :: label, unit
    label = var_list_get_sval &
         (cmd%local%var_list, var_str ("$obs_label"))
    unit = var_list_get_sval &
         (cmd%local%var_list, var_str ("$obs_unit"))
    call graph_options_init (graph_options)
    call set_graph_options (graph_options, cmd%local%var_list)
    call analysis_init_observable (cmd%id, label, unit, graph_options)
  end subroutine cmd_observable_execute

@ %def cmd_observable_execute
@
\subsubsection{Histograms}
Declare a histogram.  At minimum, we have to set lower and upper bound
and bin width.
<<Commands: types>>=
  type, extends (command_t) :: cmd_histogram_t
     private
     type(string_t) :: id
     type(parse_node_t), pointer :: pn_lower_bound => null ()
     type(parse_node_t), pointer :: pn_upper_bound => null ()
     type(parse_node_t), pointer :: pn_bin_width => null ()
   contains
   <<Commands: cmd histogram: TBP>>
  end type cmd_histogram_t
     
@ %def cmd_histogram_t
@ Output.  Just print the ID.
<<Commands: cmd histogram: TBP>>=
  procedure :: write => cmd_histogram_write
<<Commands: procedures>>=
  subroutine cmd_histogram_write (cmd, unit, indent)
    class(cmd_histogram_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "histogram: ", char (cmd%id)
  end subroutine cmd_histogram_write
  
@ %def cmd_histogram_write
@ Compile.  Record the histogram ID and initialize lower, upper bound
and bin width.
<<Commands: cmd histogram: TBP>>=
  procedure :: compile => cmd_histogram_compile
<<Commands: procedures>>=
  subroutine cmd_histogram_compile (cmd, global)
    class(cmd_histogram_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag, pn_args, pn_arg1, pn_arg2, pn_arg3
    character(*), parameter :: e_illegal_use = &
       "illegal usage of 'histogram': insufficient number of arguments"
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_args => parse_node_get_next_ptr (pn_tag)
    if (associated (pn_args)) then
       pn_arg1 => parse_node_get_sub_ptr (pn_args)
       if (.not. associated (pn_arg1)) call msg_fatal (e_illegal_use)
       pn_arg2 => parse_node_get_next_ptr (pn_arg1)
       if (.not. associated (pn_arg2)) call msg_fatal (e_illegal_use)
       pn_arg3 => parse_node_get_next_ptr (pn_arg2)
       cmd%pn_opt => parse_node_get_next_ptr (pn_args)
    end if       
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("histogram: name expression not implemented (yet)")
    end select
    cmd%pn_lower_bound => pn_arg1
    cmd%pn_upper_bound => pn_arg2
    cmd%pn_bin_width => pn_arg3
  end subroutine cmd_histogram_compile

@ %def cmd_histogram_compile
@ Command execution.  This declares the histogram and allocates it in
the analysis store.
<<Commands: cmd histogram: TBP>>=
  procedure :: execute => cmd_histogram_execute
<<Commands: procedures>>=
  subroutine cmd_histogram_execute (cmd, global)
    class(cmd_histogram_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    real(default) :: lower_bound, upper_bound, bin_width
    integer :: bin_number
    logical :: bin_width_is_used, normalize_bins
    type(string_t) :: obs_label, obs_unit
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options

    lower_bound = eval_real (cmd%pn_lower_bound, cmd%local%var_list)
    upper_bound = eval_real (cmd%pn_upper_bound, cmd%local%var_list)
    if (associated (cmd%pn_bin_width)) then
       bin_width = eval_real (cmd%pn_bin_width, cmd%local%var_list)
       bin_width_is_used = .true.
    else if (var_list_is_known &
         (cmd%local%var_list, var_str ("n_bins"))) then
       bin_number = var_list_get_ival &
            (cmd%local%var_list, var_str ("n_bins"))
       bin_width_is_used = .false.
    else
       call msg_error ("Cmd '" // char (cmd%id) // &
            "': neither bin width nor number is defined")
    end if
    normalize_bins = var_list_get_lval &
         (cmd%local%var_list, var_str ("?normalize_bins"))
    obs_label = var_list_get_sval &
         (cmd%local%var_list, var_str ("$obs_label"))
    obs_unit = var_list_get_sval &
         (cmd%local%var_list, var_str ("$obs_unit"))

    call graph_options_init (graph_options)
    call set_graph_options (graph_options, cmd%local%var_list)
    call drawing_options_init_histogram (drawing_options)
    call set_drawing_options (drawing_options, cmd%local%var_list)

    if (bin_width_is_used) then
       call analysis_init_histogram &
            (cmd%id, lower_bound, upper_bound, bin_width, &
             normalize_bins, &
             obs_label, obs_unit, &
             graph_options, drawing_options)
    else
       call analysis_init_histogram &
            (cmd%id, lower_bound, upper_bound, bin_number, &
             normalize_bins, &
             obs_label, obs_unit, &
             graph_options, drawing_options)
    end if
  end subroutine cmd_histogram_execute

@ %def cmd_histogram_execute
@ Set the graph options from a variable list.
<<Commands: procedures>>=
  subroutine set_graph_options (gro, var_list)
    type(graph_options_t), intent(inout) :: gro
    type(var_list_t), intent(in) :: var_list
    call graph_options_set (gro, title = &
         var_list_get_sval (var_list, var_str ("$title")))
    call graph_options_set (gro, description = &
         var_list_get_sval (var_list, var_str ("$description")))
    call graph_options_set (gro, x_label = &
         var_list_get_sval (var_list, var_str ("$x_label")))
    call graph_options_set (gro, y_label = &
         var_list_get_sval (var_list, var_str ("$y_label")))
    call graph_options_set (gro, width_mm = &
         var_list_get_ival (var_list, var_str ("graph_width_mm")))
    call graph_options_set (gro, height_mm = &
         var_list_get_ival (var_list, var_str ("graph_height_mm")))
    call graph_options_set (gro, x_log = &
         var_list_get_lval (var_list, var_str ("?x_log")))
    call graph_options_set (gro, y_log = &
         var_list_get_lval (var_list, var_str ("?y_log")))
    if (var_list_is_known (var_list, var_str ("x_min"))) &
         call graph_options_set (gro, x_min = &
         var_list_get_rval (var_list, var_str ("x_min")))
    if (var_list_is_known (var_list, var_str ("x_max"))) &
         call graph_options_set (gro, x_max = &
         var_list_get_rval (var_list, var_str ("x_max")))
    if (var_list_is_known (var_list, var_str ("y_min"))) &
         call graph_options_set (gro, y_min = &
         var_list_get_rval (var_list, var_str ("y_min")))
    if (var_list_is_known (var_list, var_str ("y_max"))) &
         call graph_options_set (gro, y_max = &
         var_list_get_rval (var_list, var_str ("y_max")))
    call graph_options_set (gro, gmlcode_bg = &
         var_list_get_sval (var_list, var_str ("$gmlcode_bg")))
    call graph_options_set (gro, gmlcode_fg = &
         var_list_get_sval (var_list, var_str ("$gmlcode_fg")))
  end subroutine set_graph_options

@ %def set_graph_options
@ Set the drawing options from a variable list.
<<Commands: procedures>>=
  subroutine set_drawing_options (dro, var_list)
    type(drawing_options_t), intent(inout) :: dro
    type(var_list_t), intent(in) :: var_list
    if (var_list_is_known (var_list, var_str ("?draw_histogram"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_histogram"))) then
          call drawing_options_set (dro, with_hbars = .true.)
       else
          call drawing_options_set (dro, with_hbars = .false., &
               with_base = .false., fill = .false., piecewise = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?draw_base"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_base"))) then
          call drawing_options_set (dro, with_base = .true.)
       else
          call drawing_options_set (dro, with_base = .false., fill = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?draw_piecewise"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_piecewise"))) then
          call drawing_options_set (dro, piecewise = .true.)
       else
          call drawing_options_set (dro, piecewise = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?fill_curve"))) then
       if (var_list_get_lval (var_list, var_str ("?fill_curve"))) then
          call drawing_options_set (dro, fill = .true., with_base = .true.)
       else
          call drawing_options_set (dro, fill = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?draw_curve"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_curve"))) then
          call drawing_options_set (dro, draw = .true.)
       else
          call drawing_options_set (dro, draw = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?draw_errors"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_errors"))) then
          call drawing_options_set (dro, err = .true.)
       else
          call drawing_options_set (dro, err = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("?draw_symbols"))) then
       if (var_list_get_lval (var_list, var_str ("?draw_symbols"))) then
          call drawing_options_set (dro, symbols = .true.)
       else
          call drawing_options_set (dro, symbols = .false.)
       end if
    end if
    if (var_list_is_known (var_list, var_str ("$fill_options"))) then
       call drawing_options_set (dro, fill_options = &
            var_list_get_sval (var_list, var_str ("$fill_options")))
    end if
    if (var_list_is_known (var_list, var_str ("$draw_options"))) then
       call drawing_options_set (dro, draw_options = &
            var_list_get_sval (var_list, var_str ("$draw_options")))
    end if
    if (var_list_is_known (var_list, var_str ("$err_options"))) then
       call drawing_options_set (dro, err_options = &
            var_list_get_sval (var_list, var_str ("$err_options")))
    end if
    if (var_list_is_known (var_list, var_str ("$symbol"))) then
       call drawing_options_set (dro, symbol = &
            var_list_get_sval (var_list, var_str ("$symbol")))
    end if
    if (var_list_is_known (var_list, var_str ("$gmlcode_bg"))) then
       call drawing_options_set (dro, gmlcode_bg = &
            var_list_get_sval (var_list, var_str ("$gmlcode_bg")))
    end if
    if (var_list_is_known (var_list, var_str ("$gmlcode_fg"))) then
       call drawing_options_set (dro, gmlcode_fg = &
            var_list_get_sval (var_list, var_str ("$gmlcode_fg")))
    end if
  end subroutine set_drawing_options

@ %def set_drawing_options
@
\subsubsection{Plots}
Declare a plot.  No mandatory arguments, just options.
<<Commands: types>>=
  type, extends (command_t) :: cmd_plot_t
     private
     type(string_t) :: id
   contains
   <<Commands: cmd plot: TBP>>
  end type cmd_plot_t
     
@ %def cmd_plot_t
@ Output.  Just print the ID.
<<Commands: cmd plot: TBP>>=
  procedure :: write => cmd_plot_write
<<Commands: procedures>>=
  subroutine cmd_plot_write (cmd, unit, indent)
    class(cmd_plot_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "plot: ", char (cmd%id)
  end subroutine cmd_plot_write
  
@ %def cmd_plot_write
@ Compile.  Record the plot ID and initialize lower, upper bound
and bin width.
<<Commands: cmd plot: TBP>>=
  procedure :: compile => cmd_plot_compile
<<Commands: procedures>>=
  subroutine cmd_plot_compile (cmd, global)
    class(cmd_plot_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%init (pn_tag, global)
  end subroutine cmd_plot_compile

@ %def cmd_plot_compile
@ This init routine is separated because it is reused below for graph
initialization. 
<<Commands: cmd plot: TBP>>=
  procedure :: init => cmd_plot_init
<<Commands: procedures>>=
  subroutine cmd_plot_init (plot, pn_tag, global)
    class(cmd_plot_t), intent(inout) :: plot
    type(parse_node_t), intent(in), pointer :: pn_tag
    type(rt_data_t), intent(inout), target :: global
    call plot%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       plot%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("plot: name expression not implemented (yet)")
    end select
  end subroutine cmd_plot_init

@ %def cmd_plot_init
@ Command execution.  This declares the plot and allocates it in
the analysis store.
<<Commands: cmd plot: TBP>>=
  procedure :: execute => cmd_plot_execute
<<Commands: procedures>>=
  subroutine cmd_plot_execute (cmd, global)
    class(cmd_plot_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options

    call graph_options_init (graph_options)
    call set_graph_options (graph_options, cmd%local%var_list)
    call drawing_options_init_plot (drawing_options)
    call set_drawing_options (drawing_options, cmd%local%var_list)

    call analysis_init_plot (cmd%id, graph_options, drawing_options)
  end subroutine cmd_plot_execute

@ %def cmd_plot_execute
@
\subsubsection{Graphs}
Declare a graph.  The graph is defined in terms of its contents.  Both the
graph and its contents may carry options.

The graph object contains its own ID as well as the IDs of its elements.  For
the elements, we reuse the [[cmd_plot_t]] defined above.
<<Commands: types>>=
  type, extends (command_t) :: cmd_graph_t
     private
     type(string_t) :: id
     integer :: n_elements = 0
     type(cmd_plot_t), dimension(:), allocatable :: el
     type(string_t), dimension(:), allocatable :: element_id
   contains
   <<Commands: cmd graph: TBP>>
  end type cmd_graph_t
     
@ %def cmd_graph_t
@ Output.  Just print the ID.
<<Commands: cmd graph: TBP>>=
  procedure :: write => cmd_graph_write
<<Commands: procedures>>=
  subroutine cmd_graph_write (cmd, unit, indent)
    class(cmd_graph_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A,I0,A)")  "graph: ", char (cmd%id), &
         " (", cmd%n_elements, " entries)"
  end subroutine cmd_graph_write
  
@ %def cmd_graph_write
@ Compile.  Record the graph ID and initialize lower, upper bound
and bin width.  For compiling the graph element syntax, we use part of the
[[cmd_plot_t]] compiler.

Note: currently, we do not respect options, therefore just IDs on the RHS.
<<Commands: cmd graph: TBP>>=
  procedure :: compile => cmd_graph_compile
<<Commands: procedures>>=
  subroutine cmd_graph_compile (cmd, global)
    class(cmd_graph_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_term, pn_tag, pn_def, pn_app
    integer :: i

    pn_term => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_tag => parse_node_get_sub_ptr (pn_term)
    cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("graph: name expression not implemented (yet)")
    end select
    pn_def => parse_node_get_next_ptr (pn_term, 2)
    cmd%n_elements = parse_node_get_n_sub (pn_def)
    allocate (cmd%element_id (cmd%n_elements))
    allocate (cmd%el (cmd%n_elements))
    pn_term => parse_node_get_sub_ptr (pn_def)
    pn_tag => parse_node_get_sub_ptr (pn_term)
    cmd%el(1)%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%el(1)%init (pn_tag, global)
    cmd%element_id(1) = parse_node_get_string (pn_tag)
    pn_app => parse_node_get_next_ptr (pn_term)
    do i = 2, cmd%n_elements
       pn_term => parse_node_get_sub_ptr (pn_app, 2)
       pn_tag => parse_node_get_sub_ptr (pn_term)
       cmd%el(i)%pn_opt => parse_node_get_next_ptr (pn_tag)
       call cmd%el(i)%init (pn_tag, global)
       cmd%element_id(i) = parse_node_get_string (pn_tag)
       pn_app => parse_node_get_next_ptr (pn_app)
    end do

  end subroutine cmd_graph_compile

@ %def cmd_graph_compile
@ Command execution.  This declares the graph, allocates it in
the analysis store, and copies the graph elements.

For the graph, we set graph and default drawing options.  For the elements, we
reset individual drawing options.

This accesses internals of the contained elements of type [[cmd_plot_t]], see
above.  We might disentangle such an interdependency when this code is
rewritten using proper type extension.
<<Commands: cmd graph: TBP>>=
  procedure :: execute => cmd_graph_execute
<<Commands: procedures>>=
  subroutine cmd_graph_execute (cmd, global)
    class(cmd_graph_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options
    integer :: i, type

    call graph_options_init (graph_options)
    call set_graph_options (graph_options, cmd%local%var_list)
    call analysis_init_graph (cmd%id, cmd%n_elements, graph_options)

    do i = 1, cmd%n_elements
       if (associated (cmd%el(i)%options)) then
          call cmd%el(i)%options%execute (cmd%el(i)%local)
       end if
       type = analysis_store_get_object_type (cmd%element_id(i))
       select case (type)
       case (AN_HISTOGRAM)
          call drawing_options_init_histogram (drawing_options)
       case (AN_PLOT)
          call drawing_options_init_plot (drawing_options)
       end select
       call set_drawing_options (drawing_options, cmd%local%var_list)
       if (associated (cmd%el(i)%options)) then
          call set_drawing_options (drawing_options, cmd%el(i)%local%var_list)
       end if
       call analysis_fill_graph (cmd%id, i, cmd%element_id(i), drawing_options)
    end do
  end subroutine cmd_graph_execute

@ %def cmd_graph_execute
@ 
\subsubsection{Analysis}
Hold the analysis ID either as a string or as an expression:
<<Commands: types>>=
  type :: analysis_id_t
    type(string_t) :: tag
    type(parse_node_t), pointer :: pn_sexpr => null ()
  end type analysis_id_t

@ %def analysis_id_t
@ Define the analysis expression.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to
the process environment where the analysis expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_analysis_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd analysis: TBP>>
  end type cmd_analysis_t

@ %def cmd_analysis_t
@ Output.  Print just a message that analysis has been defined.
<<Commands: cmd analysis: TBP>>=
  procedure :: write => cmd_analysis_write
<<Commands: procedures>>=
  subroutine cmd_analysis_write (cmd, unit, indent)
    class(cmd_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "analysis: [defined]"
  end subroutine cmd_analysis_write
  
@ %def cmd_analysis_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd analysis: TBP>>=
  procedure :: compile => cmd_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_analysis_compile (cmd, global)
    class(cmd_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_analysis_compile

@ %def cmd_analysis_compile
@ Instead of evaluating the cut expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd analysis: TBP>>=
  procedure :: execute => cmd_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_analysis_execute (cmd, global)
    class(cmd_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%analysis_lexpr => cmd%pn_lexpr
  end subroutine cmd_analysis_execute

@ %def cmd_analysis_execute
@
\subsubsection{Write histograms and plots}
The data type encapsulating the command:
<<Commands: types>>=
  type, extends (command_t) :: cmd_write_analysis_t
     private
     type(analysis_id_t), dimension(:), allocatable :: id
     type(string_t), dimension(:), allocatable :: tag
   contains
   <<Commands: cmd write analysis: TBP>>
  end type cmd_write_analysis_t

@ %def analysis_id_t
@ %def cmd_write_analysis_t
@ Output.  Just the keyword.
<<Commands: cmd write analysis: TBP>>=
  procedure :: write => cmd_write_analysis_write
<<Commands: procedures>>=
  subroutine cmd_write_analysis_write (cmd, unit, indent)
    class(cmd_write_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "write_analysis"
  end subroutine cmd_write_analysis_write
  
@ %def cmd_write_analysis_write
@ Compile.
<<Commands: cmd write analysis: TBP>>=
  procedure :: compile => cmd_write_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_write_analysis_compile (cmd, global)
    class(cmd_write_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_clause, pn_args, pn_id
    integer :: n, i
    pn_clause => parse_node_get_sub_ptr (cmd%pn)
    pn_args => parse_node_get_sub_ptr (pn_clause, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_clause)
    call cmd%compile_options (global)
    if (associated (pn_args)) then
       n = parse_node_get_n_sub (pn_args)
       allocate (cmd%id (n))
       do i = 1, n
           pn_id => parse_node_get_sub_ptr (pn_args, i)
           if (char (parse_node_get_rule_key (pn_id)) == "analysis_id") then
              cmd%id(i)%tag = parse_node_get_string (pn_id)              
           else
              cmd%id(i)%pn_sexpr => pn_id
           end if
       end do
    else
       allocate (cmd%id (0))
    end if
  end subroutine cmd_write_analysis_compile

@ %def cmd_write_analysis_compile
@ The output format for real data values:
<<Commands: parameters>>=
  character(*), parameter, public :: &
       DEFAULT_ANALYSIS_FILENAME = "whizard_analysis.dat"
  character(len=1), dimension(2), parameter, public :: &
       FORBIDDEN_ENDINGS1 = [ "o", "a" ]
  character(len=2), dimension(5), parameter, public :: &       
       FORBIDDEN_ENDINGS2 = [ "mp", "ps", "vg", "lo", "la" ]
  character(len=3), dimension(14), parameter, public :: &
       FORBIDDEN_ENDINGS3 = [ "aux", "dvi", "evt", "evx", "f03", "f90", &
          "f95", "log", "ltp", "mpx", "pdf", "phs", "sin", "tex" ]
       
@ %def DEFAULT_ANALYSIS_FILENAME
@ %def FORBIDDEN_ENDINGS1
@ %def FORBIDDEN_ENDINGS2
@ %def FORBIDDEN_ENDINGS3
@ As this contains a lot of similar code to [[cmd_compile_analysis_execute]]
we outsource the main code to a subroutine.
<<Commands: cmd write analysis: TBP>>=
  procedure :: execute => cmd_write_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_write_analysis_execute (cmd, global)
    class(cmd_write_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    call write_analysis_wrap (cmd%local%var_list, global%out_files, &
         cmd%id, tag = cmd%tag)
  end subroutine cmd_write_analysis_execute

@ %def cmd_write_analysis_execute   
@ If the [[data_file]] optional argument is present, this is 
called from [[cmd_compile_analysis_execute]], which needs the file name for
further processing, and requires the default format.  For the moment, 
parameters and macros for custom data processing are disabled.
<<Commands: procedures>>=
  subroutine write_analysis_wrap (var_list, out_files, id, tag, data_file)
    type(var_list_t), intent(inout), target :: var_list
    type(file_list_t), intent(inout), target :: out_files
    type(analysis_id_t), dimension(:), intent(in), target :: id 
    type(string_t), dimension(:), allocatable, intent(out) :: tag
    type(string_t), intent(out), optional :: data_file
    type(string_t) :: defaultfile, file
    integer :: i   
    logical :: keep_open !, custom, header, columns    
    type(string_t) :: extension !, comment_prefix, separator 
!!! JRR: WK please check (#542)           
!     integer :: type
!     type(ifile_t) :: ifile
    logical :: one_file !, has_writer
!     type(analysis_iterator_t) :: iterator
!     type(rt_data_t), target :: sandbox
!     type(command_list_t) :: writer    
    defaultfile = var_list_get_sval (var_list, var_str ("$out_file"))
    if (present (data_file)) then
       if (defaultfile == "" .or. defaultfile == ".") then
          defaultfile = DEFAULT_ANALYSIS_FILENAME
       else
          if (scan (".", defaultfile) > 0) then
             call split (defaultfile, extension, ".", back=.true.)
             if (any (lower_case (char(extension)) == FORBIDDEN_ENDINGS1) .or. &
                 any (lower_case (char(extension)) == FORBIDDEN_ENDINGS2) .or. &
                 any (lower_case (char(extension)) == FORBIDDEN_ENDINGS3)) & 
                 call msg_fatal ("The ending " // char(extension) // &
                 " is internal and not allowed as data file.")
             if (extension /= "") then
                if (defaultfile /= "") then
                   defaultfile = defaultfile // "." // extension
                else
                   defaultfile = "whizard_analysis." // extension
                end if
             else
                defaultfile = defaultfile // ".dat"
             endif
          else
             defaultfile = defaultfile // ".dat"
          end if
       end if
       data_file = defaultfile
    end if
    one_file = defaultfile /= ""
    if (one_file) then
       file = defaultfile
       keep_open = file_list_is_open (out_files, file, &
            action = "write")
       if (keep_open) then
          if (present (data_file)) then
             call msg_fatal ("Compiling analysis: File '" &
                  // char (data_file) &
                   // "' can't be used, it is already open.")
          else
             call msg_message ("Appending analysis data to file '" &
                  // char (file) // "'")
          end if
       else
          call file_list_open (out_files, file, &
               action = "write", status = "replace", position = "asis")
          call msg_message ("Writing analysis data to file '" &
               // char (file) // "'")          
       end if
    end if    

!!! JRR: WK please check. Custom data output. Ticket #542
!     if (present (data_file)) then
!        custom = .false.
!     else
!        custom = var_list_get_lval (var_list, &
!            var_str ("?out_custom"))
!     end if
!     comment_prefix = var_list_get_sval (var_list, &
!          var_str ("$out_comment"))
!     header = var_list_get_lval (var_list, &
!          var_str ("?out_header"))
!     write_yerr = var_list_get_lval (var_list, &
!          var_str ("?out_yerr"))
!     write_xerr = var_list_get_lval (var_list, &
!          var_str ("?out_xerr"))

    call get_analysis_tags (tag, id, var_list)       
    do i = 1, size (tag)
       call file_list_write_analysis &
            (out_files, file, tag(i))
    end do
    if (one_file .and. .not. keep_open) then
       call file_list_close (out_files, file)
    end if       

  contains
    
    subroutine get_analysis_tags (analysis_tag, id, var_list)
      type(string_t), dimension(:), intent(out), allocatable :: analysis_tag
      type(analysis_id_t), dimension(:), intent(in) :: id
      type(var_list_t), intent(in), target :: var_list
      if (size (id) /= 0) then
         allocate (analysis_tag (size (id)))
         do i = 1, size (id)
            if (associated (id(i)%pn_sexpr)) then
               analysis_tag(i) = eval_string (id(i)%pn_sexpr, var_list)
            else
               analysis_tag(i) = id(i)%tag
            end if
         end do
      else
         call analysis_store_get_ids (tag)                
      end if
    end subroutine get_analysis_tags
    
  end subroutine write_analysis_wrap
  
@ %def write_analysis_wrap
\subsubsection{Compile analysis results}
This command writes files in a form suitable for GAMELAN and executes the
appropriate commands to compile them.  The first part is identical to
[[cmd_write_analysis]].
<<Commands: types>>= 
  type, extends (command_t) :: cmd_compile_analysis_t
     private
     type(analysis_id_t), dimension(:), allocatable :: id
     type(string_t), dimension(:), allocatable :: tag
   contains
   <<Commands: cmd compile analysis: TBP>>
  end type cmd_compile_analysis_t

@ %def cmd_compile_analysis_t
@ Output.  Just the keyword.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: write => cmd_compile_analysis_write
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_write (cmd, unit, indent)
    class(cmd_compile_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "compile_analysis"
  end subroutine cmd_compile_analysis_write
  
@ %def cmd_compile_analysis_write
@ Compile.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: compile => cmd_compile_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_compile (cmd, global)
    class(cmd_compile_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_clause, pn_args, pn_id
    integer :: n, i
    pn_clause => parse_node_get_sub_ptr (cmd%pn)
    pn_args => parse_node_get_sub_ptr (pn_clause, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_clause)
    call cmd%compile_options (global)
    if (associated (pn_args)) then
       n = parse_node_get_n_sub (pn_args)
       allocate (cmd%id (n))
       do i = 1, n
           pn_id => parse_node_get_sub_ptr (pn_args, i)
           if (char (parse_node_get_rule_key (pn_id)) == "analysis_id") then
              cmd%id(i)%tag = parse_node_get_string (pn_id)
           else
              cmd%id(i)%pn_sexpr => pn_id
           end if
       end do
    else
       allocate (cmd%id (0))       
    end if
  end subroutine cmd_compile_analysis_compile

@ %def cmd_compile_analysis_compile
@ First write the analysis data to file, then write a GAMELAN driver and
produce MetaPost and \TeX\ output.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: execute => cmd_compile_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_execute (cmd, global)
    class(cmd_compile_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t) :: file, basename, extension, driver_file
    integer :: u_driver
    logical :: has_gmlcode
    call write_analysis_wrap (cmd%local%var_list, &
         global%out_files, cmd%id, tag = cmd%tag, &
            data_file = file)
    basename = file    
    if (scan (".", basename) > 0) then
      call split (basename, extension, ".", back=.true.)
    else
      extension = ""
    end if
    driver_file = basename // ".tex"
    u_driver = free_unit ()
    open (unit=u_driver, file=char(driver_file), &
          action="write", status="replace")
    if (allocated (cmd%tag)) then
       call analysis_write_driver (file, cmd%tag, unit=u_driver)
       has_gmlcode = analysis_has_plots (cmd%tag)
    else
       call analysis_write_driver (file, unit=u_driver)
       has_gmlcode = analysis_has_plots ()
    end if
    close (u_driver)
    call msg_message ("Compiling analysis results display in '" &
         // char (driver_file) // "'")
    call analysis_compile_tex (basename, has_gmlcode, global%os_data)
  end subroutine cmd_compile_analysis_execute

@ %def cmd_compile_analysis_execute
@ 
\section{User-controlled output to data files}

\subsubsection{Open file (output)}
Open a file for output.
<<Commands: types>>=
  type, extends (command_t) :: cmd_open_out_t
     private
     type(parse_node_t), pointer :: file_expr => null ()
   contains
   <<Commands: cmd open out: TBP>>
  end type cmd_open_out_t

@ %def cmd_open_out
@ Finalizer for the embedded eval tree.
<<Commands: procedures>>=
  subroutine cmd_open_out_final (object)
    class(cmd_open_out_t), intent(inout) :: object
  end subroutine cmd_open_out_final
  
@ %def cmd_open_out_final
@ Output (trivial here).
<<Commands: cmd open out: TBP>>=
  procedure :: write => cmd_open_out_write
<<Commands: procedures>>=
  subroutine cmd_open_out_write (cmd, unit, indent)
    class(cmd_open_out_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "open_out: <filename>"  
  end subroutine cmd_open_out_write
  
@ %def cmd_open_out_write
@ Compile: create an eval tree for the filename expression.
<<Commands: cmd open out: TBP>>=
  procedure :: compile => cmd_open_out_compile
<<Commands: procedures>>=
  subroutine cmd_open_out_compile (cmd, global)
    class(cmd_open_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%file_expr => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (cmd%file_expr)) then
       cmd%pn_opt => parse_node_get_next_ptr (cmd%file_expr)
    end if
    call cmd%compile_options (global)
  end subroutine cmd_open_out_compile

@ %def cmd_open_out_compile
@ Execute: append the file to the global list of open files.
<<Commands: cmd open out: TBP>>=
  procedure :: execute => cmd_open_out_execute
<<Commands: procedures>>=
  subroutine cmd_open_out_execute (cmd, global)
    class(cmd_open_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(eval_tree_t) :: file_expr
    type(string_t) :: file
    call eval_tree_init_sexpr (file_expr, cmd%file_expr, cmd%local%var_list)
    call eval_tree_evaluate (file_expr)
    if (eval_tree_result_is_known (file_expr)) then
       file = eval_tree_get_string (file_expr)
       call file_list_open (global%out_files, file, &
            action = "write", status = "replace", position = "asis")
    else
       call msg_fatal ("open_out: file name argument evaluates to unknown")
    end if
    call eval_tree_final (file_expr)
  end subroutine cmd_open_out_execute

@ %def cmd_open_out_execute

\subsubsection{Open file (output)}
Close an output file.  Except for the [[execute]] method, everything is
analogous to the open command, so we can just inherit.
<<Commands: types>>=
  type, extends (cmd_open_out_t) :: cmd_close_out_t
     private
   contains
   <<Commands: cmd close out: TBP>>
  end type cmd_close_out_t

@ %def cmd_close_out
@ Execute: remove the file from the global list of output files.
<<Commands: cmd close out: TBP>>=
  procedure :: execute => cmd_close_out_execute
<<Commands: procedures>>=
  subroutine cmd_close_out_execute (cmd, global)
    class(cmd_close_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(eval_tree_t) :: file_expr
    type(string_t) :: file
    call eval_tree_init_sexpr (file_expr, cmd%file_expr, cmd%local%var_list)
    call eval_tree_evaluate (file_expr)
    if (eval_tree_result_is_known (file_expr)) then
       file = eval_tree_get_string (file_expr)
       call file_list_close (global%out_files, file)
    else
       call msg_fatal ("close_out: file name argument evaluates to unknown")
    end if
    call eval_tree_final (file_expr)
  end subroutine cmd_close_out_execute

@ %def cmd_close_out_execute
@ 
\subsection{Print custom-formatted values}
<<Commands: types>>=
  type, extends (command_t) :: cmd_printf_t
     private
     type(parse_node_t), pointer :: sexpr => null ()
     type(parse_node_t), pointer :: sprintf_fun => null ()
     type(parse_node_t), pointer :: sprintf_clause => null ()
     type(parse_node_t), pointer :: sprintf => null ()
   contains
   <<Commands: cmd printf: TBP>>
  end type cmd_printf_t

@ %def cmd_printf_t
@ Finalize.
<<Commands: cmd printf: TBP>>=
  procedure :: final => cmd_printf_final
<<Commands: procedures>>=
  subroutine cmd_printf_final (cmd)
    class(cmd_printf_t), intent(inout) :: cmd
    call parse_node_final (cmd%sexpr, recursive = .false.)
    deallocate (cmd%sexpr)
    call parse_node_final (cmd%sprintf_fun, recursive = .false.)
    deallocate (cmd%sprintf_fun)
    call parse_node_final (cmd%sprintf_clause, recursive = .false.)
    deallocate (cmd%sprintf_clause)
    call parse_node_final (cmd%sprintf, recursive = .false.)
    deallocate (cmd%sprintf)
  end subroutine cmd_printf_final

@ %def cmd_printf_final
@ Output.  Do not print the parse tree, since this may get cluttered.
Just a message that cuts have been defined.
<<Commands: cmd printf: TBP>>=
  procedure :: write => cmd_printf_write
<<Commands: procedures>>=
  subroutine cmd_printf_write (cmd, unit, indent)
    class(cmd_printf_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "printf:"
  end subroutine cmd_printf_write
  
@ %def cmd_printf_write
@ Compile.  We create a fake parse node (subtree) with a [[sprintf]] command
with identical arguments which can then be handled by the corresponding
evaluation procedure.
<<Commands: cmd printf: TBP>>=
  procedure :: compile => cmd_printf_compile
<<Commands: procedures>>=
  subroutine cmd_printf_compile (cmd, global)
    class(cmd_printf_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd, pn_clause, pn_args, pn_format
    pn_cmd => parse_node_get_sub_ptr (cmd%pn)
    pn_clause => parse_node_get_sub_ptr (pn_cmd)
    pn_format => parse_node_get_sub_ptr (pn_clause, 2)
    pn_args => parse_node_get_next_ptr (pn_clause)
    cmd%pn_opt => parse_node_get_next_ptr (pn_cmd)
    call cmd%compile_options (global)
    allocate (cmd%sexpr)
    call parse_node_create_branch (cmd%sexpr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sexpr")))
    allocate (cmd%sprintf_fun)
    call parse_node_create_branch (cmd%sprintf_fun, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf_fun")))
    allocate (cmd%sprintf_clause)
    call parse_node_create_branch (cmd%sprintf_clause, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf_clause")))
    allocate (cmd%sprintf)
    call parse_node_create_key (cmd%sprintf, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf")))
    call parse_node_append_sub (cmd%sprintf_clause, cmd%sprintf)
    call parse_node_append_sub (cmd%sprintf_clause, pn_format)
    call parse_node_freeze_branch (cmd%sprintf_clause)
    call parse_node_append_sub (cmd%sprintf_fun, cmd%sprintf_clause)
    if (associated (pn_args)) then
       call parse_node_append_sub (cmd%sprintf_fun, pn_args)
    end if
    call parse_node_freeze_branch (cmd%sprintf_fun)
    call parse_node_append_sub (cmd%sexpr, cmd%sprintf_fun)
    call parse_node_freeze_branch (cmd%sexpr)
  end subroutine cmd_printf_compile

@ %def cmd_printf_compile
@ Execute.  Evaluate the string (pretending this is a [[sprintf]] expression)
and print it.
<<Commands: cmd printf: TBP>>=
  procedure :: execute => cmd_printf_execute
<<Commands: procedures>>=    
  subroutine cmd_printf_execute (cmd, global)
    class(cmd_printf_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t) :: string, file
    type(eval_tree_t) :: sprintf_expr
    logical :: advance
    advance = var_list_get_lval (cmd%local%var_list, &
         var_str ("?out_advance"))
    file = var_list_get_sval (cmd%local%var_list, &
         var_str ("$out_file"))
    call eval_tree_init_sexpr (sprintf_expr, cmd%sexpr, cmd%local%var_list)
    call eval_tree_evaluate (sprintf_expr)
    if (eval_tree_result_is_known (sprintf_expr)) then
       string = eval_tree_get_string (sprintf_expr)
       if (len (file) == 0) then
          call msg_result (char (string))
       else
          call file_list_write (global%out_files, file, string, advance)
       end if
    end if
  end subroutine cmd_printf_execute

@ %def cmd_printf_execute
@
\subsubsection{Record data}
The expression syntax already contains a [[record]] keyword; this evaluates to
a logical which is always true, but it has the side-effect of recording data
into analysis objects.  Here we define a command as an interface to this
construct.
<<Commands: types>>=
  type, extends (command_t) :: cmd_record_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd record: TBP>>
  end type cmd_record_t
     
@ %def cmd_record_t
@ Output.  With the compile hack below, there is nothing of interest
to print here.
<<Commands: cmd record: TBP>>=
  procedure :: write => cmd_record_write
<<Commands: procedures>>=
  subroutine cmd_record_write (cmd, unit, indent)
    class(cmd_record_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "record"
  end subroutine cmd_record_write
  
@ %def cmd_record_write
@ Compile.  This is a hack which transforms the [[record]] command
into a [[record]] expression, which we handle in the [[expressions]]
module.
<<Commands: cmd record: TBP>>=
  procedure :: compile => cmd_record_compile
<<Commands: procedures>>=
  subroutine cmd_record_compile (cmd, global)
    class(cmd_record_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_lexpr, pn_lsinglet, pn_lterm, pn_record
    call parse_node_create_branch (pn_lexpr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lexpr")))
    call parse_node_create_branch (pn_lsinglet, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lsinglet")))
    call parse_node_append_sub (pn_lexpr, pn_lsinglet)
    call parse_node_create_branch (pn_lterm, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lterm")))
    call parse_node_append_sub (pn_lsinglet, pn_lterm)
    pn_record => parse_node_get_sub_ptr (cmd%pn)
    call parse_node_append_sub (pn_lterm, pn_record)
    cmd%pn_lexpr => pn_lexpr
  end subroutine cmd_record_compile

@ %def cmd_record_compile
@ Command execution.  Again, transfer this to the embedded expression
and just forget the logical result.
<<Commands: cmd record: TBP>>=
  procedure :: execute => cmd_record_execute
<<Commands: procedures>>=
  subroutine cmd_record_execute (cmd, global)
    class(cmd_record_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: lval
    lval = eval_log (cmd%pn_lexpr, global%var_list)
  end subroutine cmd_record_execute

@ %def cmd_record_execute
@
\subsubsection{Unstable particles}
Mark a particle as unstable.  For each unstable particle, we store a
number of decay channels and compute their respective BRs.
<<Commands: types>>=
  type, extends (command_t) :: cmd_unstable_t
     private
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
     type(parse_node_t), pointer :: pn_prt_in => null ()
   contains
   <<Commands: cmd unstable: TBP>>
  end type cmd_unstable_t
     
@ %def cmd_unstable_t
@ Output: we know the process IDs.
<<Commands: cmd unstable: TBP>>=
  procedure :: write => cmd_unstable_write
<<Commands: procedures>>=
  subroutine cmd_unstable_write (cmd, unit, indent)
    class(cmd_unstable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0,1x,A)", advance="no")  &
         "unstable:", 1, "("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_unstable_write

@ %def cmd_unstable_write
@ Compile.  Initiate an eval tree for the decaying particle and
determine the decay channel process IDs.
<<Commands: cmd unstable: TBP>>=
  procedure :: compile => cmd_unstable_compile
<<Commands: procedures>>=
  subroutine cmd_unstable_compile (cmd, global)
    class(cmd_unstable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_proc
    integer :: i
    cmd%pn_prt_in => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_list => parse_node_get_next_ptr (cmd%pn_prt_in)
    if (associated (pn_list)) then
       select case (char (parse_node_get_rule_key (pn_list)))
       case ("unstable_arg")
          cmd%n_proc = parse_node_get_n_sub (pn_list)
          cmd%pn_opt => parse_node_get_next_ptr (pn_list)
       case default
          cmd%n_proc = 0
          cmd%pn_opt => pn_list
          pn_list => null ()
       end select
    end if       
    call cmd%compile_options (global)
    if (associated (pn_list)) then
       allocate (cmd%process_id (cmd%n_proc))
       pn_proc => parse_node_get_sub_ptr (pn_list)
       do i = 1, cmd%n_proc
          cmd%process_id(i) = parse_node_get_string (pn_proc)
          call cmd%local%process_stack%init_result_vars (cmd%process_id(i))
          pn_proc => parse_node_get_next_ptr (pn_proc)
       end do
    else
       allocate (cmd%process_id (0))
    end if
  end subroutine cmd_unstable_compile

@ %def cmd_unstable_compile
@ Command execution.  Evaluate the decaying particle and mark the decays in
the current model object.
<<Commands: cmd unstable: TBP>>=
  procedure :: execute => cmd_unstable_execute
<<Commands: procedures>>=
  subroutine cmd_unstable_execute (cmd, global)
    class(cmd_unstable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: auto_decays, auto_decays_radiative
    integer :: auto_decays_multiplicity
    logical :: isotropic_decay, diagonal_decay
    type(pdg_array_t) :: pa_in
    integer :: pdg_in
    type(string_t) :: libname_cur, libname_dec
    type(string_t), dimension(:), allocatable :: auto_id, tmp_id
    integer :: n_proc_user
    integer :: i, u_tmp
    character(80) :: buffer
    associate (var_list => cmd%local%var_list)
      auto_decays = &
           var_list_get_lval (var_list, var_str ("?auto_decays"))
      if (auto_decays) then
         auto_decays_multiplicity = &
              var_list_get_ival (var_list, var_str ("auto_decays_multiplicity"))
         auto_decays_radiative = &
              var_list_get_lval (var_list, var_str ("?auto_decays_radiative"))
      end if
      isotropic_decay = &
           var_list_get_lval (var_list, var_str ("?isotropic_decay"))
      if (.not. isotropic_decay) then
         diagonal_decay = &
              var_list_get_lval (var_list, var_str ("?diagonal_decay"))
      else
         diagonal_decay = .false.
      end if
    end associate
    pa_in = eval_pdg_array (cmd%pn_prt_in, cmd%local%var_list)
    if (pdg_array_get_length (pa_in) /= 1) &
         call msg_fatal ("Unstable: decaying particle must be unique")
    pdg_in = pdg_array_get (pa_in, 1)
    n_proc_user = cmd%n_proc
    if (auto_decays) then
       call create_auto_decays (pdg_in, &
            auto_decays_multiplicity, auto_decays_radiative, &
            libname_dec, auto_id, cmd%local)
       allocate (tmp_id (cmd%n_proc + size (auto_id)))
       tmp_id(:cmd%n_proc) = cmd%process_id
       tmp_id(cmd%n_proc+1:) = auto_id
       call move_alloc (from = tmp_id, to = cmd%process_id)
       cmd%n_proc = size (cmd%process_id)
    end if
    libname_cur = cmd%local%prclib%get_name ()
    do i = 1, cmd%n_proc
       if (i == n_proc_user + 1) then
          call cmd%local%update_prclib &
               (cmd%local%prclib_stack%get_library_ptr (libname_dec))
       end if
       if (.not. cmd%local%process_stack%exists (cmd%process_id(i))) then
          call var_list_set_log (cmd%local%var_list, &
               var_str ("?decay_rest_frame"), .false., is_known = .true.)
          call integrate_process (cmd%process_id(i), cmd%local)
          call cmd%local%process_stack%fill_result_vars (cmd%process_id(i))
       end if
    end do
    call cmd%local%update_prclib &
         (cmd%local%prclib_stack%get_library_ptr (libname_cur))
    call cmd%local%modify_particle (pdg_in, stable = .false., &
         decay = cmd%process_id, &
         isotropic_decay = isotropic_decay, &
         diagonal_decay = diagonal_decay, &
         polarized = .false.)
    u_tmp = free_unit ()
    open (u_tmp, status = "scratch", action = "readwrite")
    call show_unstable (cmd%local, pdg_in, u_tmp)
    rewind (u_tmp)
    do
       read (u_tmp, "(A)", end = 1)  buffer
       write (msg_buffer, "(A)")  trim (buffer)
       call msg_message ()
    end do
1   continue
    close (u_tmp)
  end subroutine cmd_unstable_execute

@ %def cmd_unstable_execute
@ Show data for the current unstable particle.  This is called both by
the [[unstable]] and by the [[show]] command.
<<Commands: procedures>>=
  subroutine show_unstable (global, pdg, u)
    type(rt_data_t), intent(in), target :: global
    integer, intent(in) :: pdg, u
    type(flavor_t) :: flv
    type(string_t), dimension(:), allocatable :: decay
    real(default), dimension(:), allocatable :: br
    real(default) :: width
    type(process_t), pointer :: process
    type(process_component_def_t), pointer :: prc_def
    type(string_t), dimension(:), allocatable :: prt_out, prt_out_str
    integer :: i, j
    call flavor_init (flv, pdg, global%model)
    call flavor_get_decays (flv, decay)
    if (.not. allocated (decay))  return
    allocate (prt_out_str (size (decay)))
    allocate (br (size (decay)))
    do i = 1, size (br)
       process => global%process_stack%get_process_ptr (decay(i))
       prc_def => process%get_component_def_ptr (1)
       call prc_def%get_prt_out (prt_out)
       prt_out_str(i) = prt_out(1)
       do j = 2, size (prt_out)
          prt_out_str(i) = prt_out_str(i) // ", " // prt_out(j)
       end do
       br(i) = process%get_integral ()
    end do
    if (all (br >= 0)) then
       if (any (br > 0)) then
          width = sum (br)
          br = br / sum (br)
          write (u, "(A)") "Unstable particle " &
               // char (flavor_get_name (flv)) &
               // ": computed branching ratios:"
          do i = 1, size (br)
             write (u, "(2x,A,':'," // FMT_14 // ",3x,A)") &
                  char (decay(i)), br(i), char (prt_out_str(i))
          end do
          write (u, "(2x,'Total width ='," // FMT_14 // ",' GeV (computed)')")  width
          write (u, "(2x,'            ='," // FMT_14 // ",' GeV (preset)')") &
               flavor_get_width (flv)
          if (flavor_decays_isotropically (flv)) then
             write (u, "(2x,A)")  "Decay options: isotropic"
          else if (flavor_decays_diagonal (flv)) then
             write (u, "(2x,A)")  "Decay options: &
                  &projection on diagonal helicity states"
          else
             write (u, "(2x,A)")  "Decay options: helicity treated exactly"
          end if
       else
          call msg_fatal ("Unstable particle " &
               // char (flavor_get_name (flv)) &
               // ": partial width vanishes for all decay channels")
       end if
    else
       call msg_fatal ("Unstable particle " &
               // char (flavor_get_name (flv)) &
               // ": partial width is negative")
    end if
  end subroutine show_unstable
    
@ %def show_unstable
@ Auto decays: create process IDs and make up process
configurations, using the PDG codes generated by the [[ds_table]] make
method.

We allocate and use a self-contained process library that contains only the
decay processes of the current particle.  When done, we revert the global
library pointer to the original library but return the name of the new one.
The new library becomes part of the global library stack and can thus be
referred to at any time.
<<Commands: procedures>>=
  subroutine create_auto_decays &
       (pdg_in, mult, rad, libname_dec, process_id, global)
    integer, intent(in) :: pdg_in
    integer, intent(in) :: mult
    logical, intent(in) :: rad
    type(string_t), intent(out) :: libname_dec
    type(string_t), dimension(:), allocatable, intent(out) :: process_id
    type(rt_data_t), intent(inout) :: global
    type(prclib_entry_t), pointer :: lib_entry
    type(process_library_t), pointer :: lib
    type(ds_table_t) :: ds_table
    type(split_constraints_t) :: constraints
    type(pdg_array_t), dimension(:), allocatable :: pa_out
    character(80) :: buffer
    character :: p_or_a
    type(string_t) :: process_string, libname_cur
    type(flavor_t) :: flv_in, flv_out
    type(string_t) :: prt_in
    type(string_t), dimension(:), allocatable :: prt_out
    type(process_configuration_t) :: prc_config
    integer :: i, j, k, n
    call flavor_init (flv_in, pdg_in, global%model)
    if (rad) then
       call constraints%init (2)
    else
       call constraints%init (3)
       call constraints%set (3, constrain_radiation ())
    end if
    call constraints%set (1, constrain_n_tot (mult))
    call constraints%set (2, constrain_mass_sum (flavor_get_mass (flv_in)))
    call ds_table%make (global%model, pdg_in, constraints)
    prt_in = flavor_get_name (flv_in)
    if (pdg_in > 0) then
       p_or_a = "p"
    else
       p_or_a = "a"
    end if
    call msg_message ("Creating decay process library for particle " &
         // char (prt_in))
    libname_cur = global%prclib%get_name () 
    write (buffer, "(A,A,I0)")  "_d", p_or_a, abs (pdg_in)
    libname_dec = libname_cur // trim (buffer)
    lib => global%prclib_stack%get_library_ptr (libname_dec)
    if (.not. (associated (lib))) then
       allocate (lib_entry)
       call lib_entry%init (libname_dec)
       lib => lib_entry%process_library_t
       call global%add_prclib (lib_entry)
    else
       call global%update_prclib (lib)
    end if
    allocate (process_id (ds_table%get_length ()))
    do i = 1, size (process_id)
       write (buffer, "(A,'_',A,I0,'_',I0)")  "decay", p_or_a, abs (pdg_in), i
       process_id(i) = trim (buffer)
       process_string = process_id(i) // ": " // prt_in // " =>"
       call ds_table%get_pdg_out (i, pa_out)
       allocate (prt_out (size (pa_out)))
       do j = 1, size (pa_out)
          do k = 1, pa_out(j)%get_length ()
             call flavor_init (flv_out, pa_out(j)%get (k), global%model)
             if (k == 1) then
                prt_out(j) = flavor_get_name (flv_out)
             else
                prt_out(j) = prt_out(j) // ":" // flavor_get_name (flv_out)
             end if
          end do
          process_string = process_string // " " // prt_out(j)
       end do
       call msg_message (char (process_string))
       call prc_config%init (process_id(i), 1, 1, global)
       !!! Causes runtime error with gfortran 4.9.1 
       ! call prc_config%setup_component (1, &
       !      new_prt_spec ([prt_in]), new_prt_spec (prt_out), global)
       !!! Workaround:
       call prc_config%setup_component (1, &
            [new_prt_spec (prt_in)], new_prt_spec (prt_out), global)       
       call prc_config%record (global)
       deallocate (prt_out)
       deallocate (pa_out)
    end do
    call ds_table%final ()
    lib => global%prclib_stack%get_library_ptr (libname_cur)
    call global%update_prclib (lib)
  end subroutine create_auto_decays
    
@ %def create_auto_decays
@ 
\subsubsection{(Stable particles}
Revert the unstable declaration for a list of particles.
<<Commands: types>>=
  type, extends (command_t) :: cmd_stable_t
     private
     type(parse_node_p), dimension(:), allocatable :: pn_pdg
   contains
   <<Commands: cmd stable: TBP>>
  end type cmd_stable_t
  
@ %def cmd_stable_t
@ Output: we know only the number of particles.
<<Commands: cmd stable: TBP>>=
  procedure :: write => cmd_stable_write
<<Commands: procedures>>=
  subroutine cmd_stable_write (cmd, unit, indent)
    class(cmd_stable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "stable:", size (cmd%pn_pdg)
  end subroutine cmd_stable_write

@ %def cmd_stable_write
@ Compile.  Assign parse nodes for the particle IDs.
<<Commands: cmd stable: TBP>>=
  procedure :: compile => cmd_stable_compile
<<Commands: procedures>>=
  subroutine cmd_stable_compile (cmd, global)
    class(cmd_stable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_prt
    integer :: n, i
    pn_list => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_list)
    call cmd%compile_options (global)
    n = parse_node_get_n_sub (pn_list)
    allocate (cmd%pn_pdg (n))
    pn_prt => parse_node_get_sub_ptr (pn_list)
    i = 1
    do while (associated (pn_prt))
       cmd%pn_pdg(i)%ptr => pn_prt
       pn_prt  => parse_node_get_next_ptr (pn_prt)
       i = i + 1
    end do
  end subroutine cmd_stable_compile

@ %def cmd_stable_compile
@ Execute: apply the modifications to the current model.
<<Commands: cmd stable: TBP>>=
  procedure :: execute => cmd_stable_execute
<<Commands: procedures>>=
  subroutine cmd_stable_execute (cmd, global)
    class(cmd_stable_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, cmd%local%var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Stable: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call cmd%local%modify_particle (pdg, stable = .true., &
         isotropic_decay = .false., &
         diagonal_decay = .false., &
         polarized = .false.)
       call flavor_init (flv, pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flavor_get_name (flv)) &
            // " declared as stable")
    end do
  end subroutine cmd_stable_execute
  
@ %def cmd_stable_execute
@ 
\subsubsection{Polarized particles}
These commands mark particles as (un)polarized, to be applied in
subsequent simulation passes.  Since this is technically the same as
the [[stable]] command, we take a shortcut and make this an extension,
just overriding methods.
<<Commands: types>>=
  type, extends (cmd_stable_t) :: cmd_polarized_t
   contains
   <<Commands: cmd polarized: TBP>>
  end type cmd_polarized_t
  
  type, extends (cmd_stable_t) :: cmd_unpolarized_t
   contains
   <<Commands: cmd unpolarized: TBP>>
  end type cmd_unpolarized_t
  
@ %def cmd_polarized_t cmd_unpolarized_t
@ Output: we know only the number of particles.
<<Commands: cmd polarized: TBP>>=
  procedure :: write => cmd_polarized_write
<<Commands: cmd unpolarized: TBP>>=
  procedure :: write => cmd_unpolarized_write
<<Commands: procedures>>=
  subroutine cmd_polarized_write (cmd, unit, indent)
    class(cmd_polarized_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "polarized:", size (cmd%pn_pdg)
  end subroutine cmd_polarized_write

  subroutine cmd_unpolarized_write (cmd, unit, indent)
    class(cmd_unpolarized_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "unpolarized:", size (cmd%pn_pdg)
  end subroutine cmd_unpolarized_write

@ %def cmd_polarized_write
@ %def cmd_unpolarized_write
@ Compile: accounted for by the base command.

Execute: apply the modifications to the current model.
<<Commands: cmd polarized: TBP>>=
  procedure :: execute => cmd_polarized_execute
<<Commands: cmd unpolarized: TBP>>=
  procedure :: execute => cmd_unpolarized_execute
<<Commands: procedures>>=
  subroutine cmd_polarized_execute (cmd, global)
    class(cmd_polarized_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, cmd%local%var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Polarized: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call cmd%local%modify_particle (pdg, polarized = .true., &
            stable = .true., &
            isotropic_decay = .false., &
            diagonal_decay = .false.)
       call flavor_init (flv, pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flavor_get_name (flv)) &
            // " declared as polarized")
    end do
  end subroutine cmd_polarized_execute
  
  subroutine cmd_unpolarized_execute (cmd, global)
    class(cmd_unpolarized_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, cmd%local%var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Unpolarized: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call cmd%local%modify_particle (pdg, polarized = .false., &
            stable = .true., &
            isotropic_decay = .false., &
            diagonal_decay = .false.)
       call flavor_init (flv, pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flavor_get_name (flv)) &
            // " declared as unpolarized")
    end do
  end subroutine cmd_unpolarized_execute
  
@ %def cmd_polarized_execute
@ %def cmd_unpolarized_execute
@
\subsubsection{Parameters: formats for event-sample output}
Specify all event formats that are to be used for output files in the
subsequent simulation run.  (The raw format is on by default and can be turned
off here.)
<<Commands: types>>=
  type, extends (command_t) :: cmd_sample_format_t
     private
     type(string_t), dimension(:), allocatable :: format
   contains
   <<Commands: cmd sample format: TBP>>
  end type cmd_sample_format_t

@ %def cmd_sample_format_t
@ Output: here, everything is known.
<<Commands: cmd sample format: TBP>>=
  procedure :: write => cmd_sample_format_write
<<Commands: procedures>>=
  subroutine cmd_sample_format_write (cmd, unit, indent)
    class(cmd_sample_format_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "sample_format = "
    do i = 1, size (cmd%format)
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%format(i))
    end do
    write (u, "(A)")
  end subroutine cmd_sample_format_write
  
@ %def cmd_sample_format_write
@ Compile.  Initialize evaluation trees.
<<Commands: cmd sample format: TBP>>=
  procedure :: compile => cmd_sample_format_compile
<<Commands: procedures>>=
  subroutine cmd_sample_format_compile (cmd, global)
    class(cmd_sample_format_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    type(parse_node_t), pointer :: pn_format
    integer :: i, n_format
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_arg)) then
       n_format = parse_node_get_n_sub (pn_arg)
       allocate (cmd%format (n_format))
       pn_format => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_format))
          i = i + 1
          cmd%format(i) = parse_node_get_string (pn_format)
          pn_format => parse_node_get_next_ptr (pn_format)
       end do
    else
       allocate (cmd%format (0))
    end if
  end subroutine cmd_sample_format_compile

@ %def cmd_sample_format_compile
@ Execute.  Transfer the list of format specifications to the
corresponding array in the runtime data set.
<<Commands: cmd sample format: TBP>>=
  procedure :: execute => cmd_sample_format_execute
<<Commands: procedures>>=
  subroutine cmd_sample_format_execute (cmd, global)
    class(cmd_sample_format_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (allocated (global%sample_fmt))  deallocate (global%sample_fmt)
    allocate (global%sample_fmt (size (cmd%format)), source = cmd%format)
  end subroutine cmd_sample_format_execute

@ %def cmd_sample_format_execute
@
\subsubsection{The simulate command}
This is the actual SINDARIN command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_simulate_t
     ! not private anymore as required by the whizard-c-interface
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd simulate: TBP>>
  end type cmd_simulate_t

@ %def cmd_simulate_t
@ Output: we know the process IDs.
<<Commands: cmd simulate: TBP>>=
  procedure :: write => cmd_simulate_write
<<Commands: procedures>>=
  subroutine cmd_simulate_write (cmd, unit, indent)
    class(cmd_simulate_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "simulate ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_simulate_write

@ %def cmd_simulate_write
@ Compile. In contrast to WHIZARD 1 the confusing option to give the
number of unweighted events for weighted events as if unweighting were
to take place has been abandoned. (We both use [[n_events]] for
weighted and unweighted events, the variable [[n_calls]] from WHIZARD
1 has been discarded.
<<Commands: cmd simulate: TBP>>=
  procedure :: compile => cmd_simulate_compile
<<Commands: procedures>>=
  subroutine cmd_simulate_compile (cmd, global)
    class(cmd_simulate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_proclist, pn_proc
    integer :: i
    pn_proclist => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       call global%process_stack%init_result_vars (cmd%process_id(i))
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_simulate_compile

@ %def cmd_simulate_compile
@ Execute command:  Simulate events.  This is done via a [[simulation_t]]
object and its associated methods.

Signal handling: the [[generate]] method may exit abnormally if there is a
pending signal.  The current logic ensures that the [[es_array]] output
channels are closed before the [[execute]] routine returns.  The program will
terminate then in [[command_list_execute]].
<<Commands: cmd simulate: TBP>>=
  procedure :: execute => cmd_simulate_execute
<<Commands: procedures>>=
  subroutine cmd_simulate_execute (cmd, global)
    class(cmd_simulate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), dimension(:), allocatable, target :: alt_env
    integer :: n_events, n_fmt
    type(string_t) :: sample
    logical :: rebuild_events, read_raw, write_raw
    type(simulation_t), target :: sim
    type(string_t), dimension(:), allocatable :: sample_fmt
    type(event_stream_array_t) :: es_array
    type(event_sample_data_t) :: data
    integer :: i, checkpoint
    if (allocated (cmd%local%pn%alt_setup)) then
       allocate (alt_env (size (cmd%local%pn%alt_setup)))
       do i = 1, size (alt_env)
          call build_alt_setup (alt_env(i), cmd%local, &
               cmd%local%pn%alt_setup(i)%ptr)
       end do
       call sim%init (cmd%process_id, .true., .true., global, cmd%local, &
            alt_env)
    else
       call sim%init (cmd%process_id, .true., .true., global, cmd%local)
    end if
    if (signal_is_pending ())  return
    if (sim%is_valid ()) then
       call sim%init_process_selector ()    
       call openmp_set_num_threads_verbose &
            (var_list_get_ival (cmd%local%var_list, "openmp_num_threads"), &
            var_list_get_lval (cmd%local%var_list, "?openmp_logging"))
       call sim%compute_n_events (n_events, cmd%local%var_list)
       sample = var_list_get_sval (cmd%local%var_list, var_str ("$sample"))
       if (sample == "")  sample = sim%get_default_sample_name ()
       rebuild_events = &
            var_list_get_lval (cmd%local%var_list, var_str ("?rebuild_events"))
       read_raw = &
            var_list_get_lval (cmd%local%var_list, var_str ("?read_raw")) &
            .and. .not. rebuild_events
       write_raw = &
            var_list_get_lval (cmd%local%var_list, var_str ("?write_raw"))
       checkpoint = &
            var_list_get_ival (cmd%local%var_list, var_str ("checkpoint"))
       if (read_raw) then
          inquire (file = char (sample) // ".evx", exist = read_raw)
       end if
       if (allocated (cmd%local%sample_fmt)) then
          n_fmt = size (cmd%local%sample_fmt)
       else
          n_fmt = 0
       end if
       data = sim%get_data ()
       data%n_evt = n_events
       if (read_raw) then
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
          call es_array%init (sample, &
               sample_fmt, sim%get_process_ptr (), cmd%local, &
               data = data, &
               input = var_str ("raw"), &
               allow_switch = write_raw, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else if (write_raw) then
          allocate (sample_fmt (n_fmt + 1))
          if (n_fmt > 0)  sample_fmt(:n_fmt) = cmd%local%sample_fmt
          sample_fmt(n_fmt+1) = var_str ("raw")
          call es_array%init (sample, &
               sample_fmt, sim%get_process_ptr (), cmd%local, &
               data = data, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else if (allocated (cmd%local%sample_fmt) .or. checkpoint > 0) then
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
          call es_array%init (sample, &
               sample_fmt, sim%get_process_ptr (), cmd%local, &
               data = data, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else
          call sim%generate (n_events)
       end if
       if (allocated (alt_env)) then
          do i = 1, size (alt_env)
             call alt_env(i)%local_final ()
          end do
       end if
    end if
    call sim%final ()
  end subroutine cmd_simulate_execute

@ %def cmd_simulate_execute
@ Build an alternative setup: the parse tree is stored in the global
environment.  We create a temporary command list to compile and execute this;
the result is an alternative local environment [[alt_env]] which we can hand
over to the [[simulate]] command.
<<Commands: procedures>>=
  recursive subroutine build_alt_setup (alt_env, global, pn)
    type(rt_data_t), intent(inout), target :: alt_env
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), intent(in), target :: pn
    type(command_list_t), allocatable :: alt_options
    allocate (alt_options)
    call alt_env%local_init (global)
    call alt_env%link (global)
    call alt_options%compile (pn, alt_env)
    call alt_options%execute (alt_env)
    call global%restore (alt_env, keep_local = .true.)
    call alt_options%final ()
  end subroutine build_alt_setup
            
@ %def build_alt_setup
@
\subsubsection{The rescan command}
This is the actual SINDARIN command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_rescan_t
     ! private
     type(parse_node_t), pointer :: pn_filename => null ()
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd rescan: TBP>>
  end type cmd_rescan_t

@ %def cmd_rescan_t
@ Output: we know the process IDs.
<<Commands: cmd rescan: TBP>>=
  procedure :: write => cmd_rescan_write
<<Commands: procedures>>=
  subroutine cmd_rescan_write (cmd, unit, indent)
    class(cmd_rescan_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "rescan ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_rescan_write

@ %def cmd_rescan_write
@ Compile.  The command takes a suffix argument, namely the file name
of requested event file.
<<Commands: cmd rescan: TBP>>=
  procedure :: compile => cmd_rescan_compile
<<Commands: procedures>>=
  subroutine cmd_rescan_compile (cmd, global)
    class(cmd_rescan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_filename, pn_proclist, pn_proc
    integer :: i
    pn_filename => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_proclist => parse_node_get_next_ptr (pn_filename)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%pn_filename => pn_filename
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_rescan_compile

@ %def cmd_rescan_compile
@ Execute command:  Rescan events.  This is done via a [[simulation_t]]
object and its associated methods.
<<Commands: cmd rescan: TBP>>=
  procedure :: execute => cmd_rescan_execute
<<Commands: procedures>>=
  subroutine cmd_rescan_execute (cmd, global)
    class(cmd_rescan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), dimension(:), allocatable, target :: alt_env
    type(string_t) :: sample
    logical :: exist, write_raw, update_event, update_sqme, update_weight
    logical :: recover_beams
    type(simulation_t), target :: sim
    type(event_sample_data_t) :: input_data, data
    type(string_t) :: input_sample
    integer :: n_fmt
    type(string_t), dimension(:), allocatable :: sample_fmt
    type(string_t) :: input_format, input_ext, input_file
    type(string_t) :: lhef_extension, extension_hepmc, extension_lcio
    type(event_stream_array_t) :: es_array
    integer :: i, n_events
    if (allocated (cmd%local%pn%alt_setup)) then
       allocate (alt_env (size (cmd%local%pn%alt_setup)))
       do i = 1, size (alt_env)
          call build_alt_setup (alt_env(i), cmd%local, &
               cmd%local%pn%alt_setup(i)%ptr)
       end do
       call sim%init (cmd%process_id, .false., .false., global, cmd%local, &
            alt_env)
    else
       call sim%init (cmd%process_id, .false., .false., global, cmd%local)
    end if
    call sim%compute_n_events (n_events, cmd%local%var_list)
    input_sample = eval_string (cmd%pn_filename, cmd%local%var_list)
    input_format = var_list_get_sval (cmd%local%var_list, &
         var_str ("$rescan_input_format"))
    sample = var_list_get_sval (cmd%local%var_list, var_str ("$sample"))
    if (sample == "")  sample = sim%get_default_sample_name ()
    write_raw = var_list_get_lval (cmd%local%var_list, var_str ("?write_raw"))
    if (allocated (cmd%local%sample_fmt)) then
       n_fmt = size (cmd%local%sample_fmt)
    else
       n_fmt = 0
    end if
    if (write_raw) then
       if (sample == input_sample) then
          call msg_error ("Rescan: ?write_raw = true: " &
               // "suppressing raw event output (filename clashes with input)")
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
       else
          allocate (sample_fmt (n_fmt + 1))
          if (n_fmt > 0)  sample_fmt(:n_fmt) = cmd%local%sample_fmt
          sample_fmt(n_fmt+1) = var_str ("raw")
       end if
    else
       allocate (sample_fmt (n_fmt))
       if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
    end if
    update_event = &
         var_list_get_lval (cmd%local%var_list, var_str ("?update_event"))
    update_sqme = &
         var_list_get_lval (cmd%local%var_list, var_str ("?update_sqme"))
    update_weight = &
         var_list_get_lval (cmd%local%var_list, var_str ("?update_weight"))
    recover_beams = &
         var_list_get_lval (cmd%local%var_list, var_str ("?recover_beams"))
    if (update_event .or. update_sqme) then
       call msg_message ("Recalculating observables")
       if (update_sqme) then
          call msg_message ("Recalculating squared matrix elements")
       end if
    end if
    lhef_extension = &
         var_list_get_sval (cmd%local%var_list, var_str ("$lhef_extension"))
    extension_hepmc = &
         var_list_get_sval (cmd%local%var_list, var_str ("$extension_hepmc"))
    extension_lcio = &
         var_list_get_sval (cmd%local%var_list, var_str ("$extension_lcio"))
    select case (char (input_format))
    case ("raw");  input_ext = "evx"
    case ("lhef"); input_ext = lhef_extension
    case ("hepmc"); input_ext = extension_hepmc
    case default
       call msg_fatal ("rescan: input sample format '" // char (input_format) &
            // "' not supported")
    end select
    input_file = input_sample // "." // input_ext
    inquire (file = char (input_file), exist = exist)
    if (exist) then
       input_data = sim%get_data (alt = .false.)
       input_data%n_evt = n_events
       data = sim%get_data ()
       data%n_evt = n_events
       input_data%md5sum_cfg = ""
       call es_array%init (sample, &
            sample_fmt, sim%get_process_ptr (), cmd%local, data, &
            input = input_format, input_sample = input_sample, &
            input_data = input_data, &
            allow_switch = .false.)
       call sim%rescan (n_events, es_array, &
            update_event = update_event, &
            update_sqme = update_sqme, &
            update_weight = update_weight, &
            recover_beams = recover_beams, &
            global = cmd%local)
       call es_array%final ()
    else
       call msg_fatal ("Rescan: event file '" &
            // char (input_file) // "' not found")
    end if
    if (allocated (alt_env)) then
       do i = 1, size (alt_env)
          call alt_env(i)%local_final ()
       end do
    end if
    call sim%final ()
  end subroutine cmd_rescan_execute

@ %def cmd_rescan_execute
@ 
\subsubsection{Parameters: number of iterations}
Specify number of iterations and number of calls for one integration pass.
<<Commands: types>>=
  type, extends (command_t) :: cmd_iterations_t
     private
     integer :: n_pass = 0
     type(parse_node_p), dimension(:), allocatable :: pn_expr_n_it
     type(parse_node_p), dimension(:), allocatable :: pn_expr_n_calls
     type(parse_node_p), dimension(:), allocatable :: pn_sexpr_adapt
   contains
   <<Commands: cmd iterations: TBP>>
  end type cmd_iterations_t

@ %def cmd_iterations_t
@ Output.  Display the number of passes, which is known after compilation.
<<Commands: cmd iterations: TBP>>=
  procedure :: write => cmd_iterations_write
<<Commands: procedures>>=
  subroutine cmd_iterations_write (cmd, unit, indent)
    class(cmd_iterations_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_pass)
    case (0)
       write (u, "(1x,A)")  "iterations: [empty]"
    case (1)
       write (u, "(1x,A,I0,A)")  "iterations: ", cmd%n_pass, " pass"
    case default
       write (u, "(1x,A,I0,A)")  "iterations: ", cmd%n_pass, " passes"
    end select
  end subroutine cmd_iterations_write

@ %def cmd_iterations_write
@ Compile.  Initialize evaluation trees.
<<Commands: cmd iterations: TBP>>=
  procedure :: compile => cmd_iterations_compile
<<Commands: procedures>>=
  subroutine cmd_iterations_compile (cmd, global)
    class(cmd_iterations_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_n_it, pn_n_calls, pn_adapt
    type(parse_node_t), pointer :: pn_it_spec, pn_calls_spec, pn_adapt_spec
    integer :: i
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_arg)) then
       cmd%n_pass = parse_node_get_n_sub (pn_arg)
       allocate (cmd%pn_expr_n_it (cmd%n_pass))
       allocate (cmd%pn_expr_n_calls (cmd%n_pass))
       allocate (cmd%pn_sexpr_adapt (cmd%n_pass))
       pn_it_spec => parse_node_get_sub_ptr (pn_arg)
       i = 1
       do while (associated (pn_it_spec))
          pn_n_it => parse_node_get_sub_ptr (pn_it_spec)
          pn_calls_spec => parse_node_get_next_ptr (pn_n_it)
          pn_n_calls => parse_node_get_sub_ptr (pn_calls_spec, 2)
          pn_adapt_spec => parse_node_get_next_ptr (pn_calls_spec)
          if (associated (pn_adapt_spec)) then
             pn_adapt => parse_node_get_sub_ptr (pn_adapt_spec, 2)
          else
             pn_adapt => null ()
          end if
          cmd%pn_expr_n_it(i)%ptr => pn_n_it
          cmd%pn_expr_n_calls(i)%ptr => pn_n_calls
          cmd%pn_sexpr_adapt(i)%ptr => pn_adapt
          i = i + 1
          pn_it_spec => parse_node_get_next_ptr (pn_it_spec)
       end do
    else
       allocate (cmd%pn_expr_n_it (0))
       allocate (cmd%pn_expr_n_calls (0))
    end if
  end subroutine cmd_iterations_compile

@ %def cmd_iterations_compile
@ Execute.  Evaluate the trees and transfer the results to the iteration
list in the runtime data set.
<<Commands: cmd iterations: TBP>>=
  procedure :: execute => cmd_iterations_execute
<<Commands: procedures>>=
  subroutine cmd_iterations_execute (cmd, global)
    class(cmd_iterations_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    integer, dimension(cmd%n_pass) :: n_it, n_calls
    logical, dimension(cmd%n_pass) :: custom_adapt
    type(string_t), dimension(cmd%n_pass) :: adapt_code
    integer :: i
    do i = 1, cmd%n_pass
       n_it(i) = eval_int (cmd%pn_expr_n_it(i)%ptr, global%var_list)
       n_calls(i) = &
            eval_int (cmd%pn_expr_n_calls(i)%ptr, global%var_list)
       if (associated (cmd%pn_sexpr_adapt(i)%ptr)) then
          adapt_code(i) = &
               eval_string (cmd%pn_sexpr_adapt(i)%ptr, &
                            global%var_list, is_known = custom_adapt(i))
       else
          custom_adapt(i) = .false.
       end if        
    end do
    call global%it_list%init (n_it, n_calls, custom_adapt, adapt_code)
  end subroutine cmd_iterations_execute

@ %def cmd_iterations_execute
@ 
\subsubsection{Range expressions}
We need a special type for storing and evaluating range expressions.
<<Commands: parameters>>=
  integer, parameter :: STEP_NONE = 0
  integer, parameter :: STEP_ADD = 1
  integer, parameter :: STEP_SUB = 2
  integer, parameter :: STEP_MUL = 3
  integer, parameter :: STEP_DIV = 4
  integer, parameter :: STEP_COMP_ADD = 11
  integer, parameter :: STEP_COMP_MUL = 13
@ 
There is an abstract base type and two implementations: scan over integers and
scan over reals.
<<Commands: types>>=
  type, abstract :: range_t
     type(parse_node_t), pointer :: pn_expr => null ()
     type(parse_node_t), pointer :: pn_term => null ()
     type(parse_node_t), pointer :: pn_factor => null ()
     type(parse_node_t), pointer :: pn_value => null ()
     type(parse_node_t), pointer :: pn_literal => null ()
     type(parse_node_t), pointer :: pn_beg => null ()
     type(parse_node_t), pointer :: pn_end => null ()
     type(parse_node_t), pointer :: pn_step => null ()
     type(eval_tree_t) :: expr_beg
     type(eval_tree_t) :: expr_end
     type(eval_tree_t) :: expr_step
     integer :: step_mode = 0
     integer :: n_step = 0
   contains
   <<Commands: range: TBP>>
  end type range_t
     
@ %def range_t
@ These are the implementations:
<<Commands: types>>=
  type, extends (range_t) :: range_int_t
     integer :: i_beg = 0
     integer :: i_end = 0
     integer :: i_step = 0
   contains
   <<Commands: range int: TBP>>
end type range_int_t
     
  type, extends (range_t) :: range_real_t
     real(default) :: r_beg = 0
     real(default) :: r_end = 0
     real(default) :: r_step = 0
     real(default) :: lr_beg  = 0
     real(default) :: lr_end  = 0
     real(default) :: lr_step = 0
   contains
   <<Commands: range real: TBP>>
end type range_real_t
     
@ %def range_int_t range_real_t
@ Finalize the allocated dummy node.  The other nodes are just pointers.
<<Commands: range: TBP>>=
  procedure :: final => range_final
<<Commands: procedures>>=
  subroutine range_final (object)
    class(range_t), intent(inout) :: object
    if (associated (object%pn_expr)) then
       call parse_node_final (object%pn_expr, recursive = .false.)
       call parse_node_final (object%pn_term, recursive = .false.)
       call parse_node_final (object%pn_factor, recursive = .false.)
       call parse_node_final (object%pn_value, recursive = .false.)
       call parse_node_final (object%pn_literal, recursive = .false.)
       deallocate (object%pn_expr)
       deallocate (object%pn_term)
       deallocate (object%pn_factor)
       deallocate (object%pn_value)
       deallocate (object%pn_literal)
    end if
  end subroutine range_final
  
@ %def range_final
@ Output.
<<Commands: range: TBP>>=
  procedure (range_write), deferred :: write
  procedure :: base_write => range_write
<<Commands: range int: TBP>>=
  procedure :: write => range_int_write
<<Commands: range real: TBP>>=
  procedure :: write => range_real_write
<<Commands: procedures>>=
  subroutine range_write (object, unit)
    class(range_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Range specification:"
    if (associated (object%pn_expr)) then
       write (u, "(1x,A)")  "Dummy value:"
       call parse_node_write_rec (object%pn_expr, u)
    end if
    if (associated (object%pn_beg)) then
       write (u, "(1x,A)")  "Initial value:"
       call parse_node_write_rec (object%pn_beg, u)
       call eval_tree_write (object%expr_beg, u)
       if (associated (object%pn_end)) then
          write (u, "(1x,A)")  "Final value:"
          call parse_node_write_rec (object%pn_end, u)
          call eval_tree_write (object%expr_end, u)
          if (associated (object%pn_step)) then
             write (u, "(1x,A)")  "Step value:"
             call parse_node_write_rec (object%pn_step, u)
             select case (object%step_mode)
             case (STEP_ADD);   write (u, "(1x,A)")  "Step mode: +"
             case (STEP_SUB);   write (u, "(1x,A)")  "Step mode: -"
             case (STEP_MUL);   write (u, "(1x,A)")  "Step mode: *"
             case (STEP_DIV);   write (u, "(1x,A)")  "Step mode: /"
             case (STEP_COMP_ADD);  write (u, "(1x,A)")  "Division mode: +"
             case (STEP_COMP_MUL);  write (u, "(1x,A)")  "Division mode: *"
             end select
          end if
       end if
    else
       write (u, "(1x,A)")  "Expressions: [undefined]"
    end if
  end subroutine range_write

  subroutine range_int_write (object, unit)
    class(range_int_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (unit)
    write (u, "(1x,A)")  "Range parameters:"
    write (u, "(3x,A,I0)")  "i_beg  = ", object%i_beg
    write (u, "(3x,A,I0)")  "i_end  = ", object%i_end
    write (u, "(3x,A,I0)")  "i_step = ", object%i_step
    write (u, "(3x,A,I0)")  "n_step = ", object%n_step
  end subroutine range_int_write
  
  subroutine range_real_write (object, unit)
    class(range_real_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (unit)
    write (u, "(1x,A)")  "Range parameters:"
    write (u, "(3x,A," // FMT_19 // ")")  "r_beg  = ", object%r_beg
    write (u, "(3x,A," // FMT_19 // ")")  "r_end  = ", object%r_end
    write (u, "(3x,A," // FMT_19 // ")")  "r_step = ", object%r_end
    write (u, "(3x,A,I0)")  "n_step = ", object%n_step
  end subroutine range_real_write
  
@ %def range_write
@ Initialize, given a range expression parse node.  This is common to the
implementations.
<<Commands: range: TBP>>=
  procedure :: init => range_init
<<Commands: procedures>>=
  subroutine range_init (range, pn)
    class(range_t), intent(out) :: range
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_spec, pn_end, pn_step_spec, pn_op
    select case (char (parse_node_get_rule_key (pn)))
    case ("expr")
    case ("range_expr")
       range%pn_beg => parse_node_get_sub_ptr (pn)
       pn_spec => parse_node_get_next_ptr (range%pn_beg)
       if (associated (pn_spec)) then
          pn_end => parse_node_get_sub_ptr (pn_spec, 2)
          range%pn_end => pn_end
          pn_step_spec => parse_node_get_next_ptr (pn_end)
          if (associated (pn_step_spec)) then
             pn_op => parse_node_get_sub_ptr (pn_step_spec)
             range%pn_step => parse_node_get_next_ptr (pn_op)
             select case (char (parse_node_get_rule_key (pn_op)))
             case ("/+");  range%step_mode = STEP_ADD
             case ("/-");  range%step_mode = STEP_SUB
             case ("/*");  range%step_mode = STEP_MUL
             case ("//");  range%step_mode = STEP_DIV
             case ("/+/");  range%step_mode = STEP_COMP_ADD
             case ("/*/");  range%step_mode = STEP_COMP_MUL
             case default
                call range%write ()
                call msg_bug ("Range: step mode not implemented")
             end select
          else
             range%step_mode = STEP_ADD
          end if
       else
          range%step_mode = STEP_NONE
       end if
       call range%create_value_node ()
    case default
       call msg_bug ("range expression: node type '" &
            // char (parse_node_get_rule_key (pn)) &
            // "' not implemented")
    end select
  end subroutine range_init
  
@ %def range_init
@ This method manually creates a parse node (actually, a cascade of parse
nodes) that hold a constant value as a literal.  The idea is that this node is
inserted as the right-hand side of a fake variable assignment, which is
prepended to each scan iteration.  Before the variable
assignment is compiled and executed, we can manually reset the value of the
literal and thus pretend that the loop variable is assigned this value.
<<Commands: range: TBP>>=
  procedure :: create_value_node => range_create_value_node
<<Commands: procedures>>=
  subroutine range_create_value_node (range)
    class(range_t), intent(inout) :: range
    allocate (range%pn_literal)
    allocate (range%pn_value)
    select type (range)
    type is (range_int_t)
       call parse_node_create_value (range%pn_literal, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("integer_literal")),&
            ival = 0)
       call parse_node_create_branch (range%pn_value, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("integer_value")))
    type is (range_real_t)
       call parse_node_create_value (range%pn_literal, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("real_literal")),&
            rval = 0._default)
       call parse_node_create_branch (range%pn_value, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("real_value")))
    class default
       call msg_bug ("range: create value node: type not implemented")
    end select
    call parse_node_append_sub (range%pn_value, range%pn_literal)
    call parse_node_freeze_branch (range%pn_value)
    allocate (range%pn_factor)
    call parse_node_create_branch (range%pn_factor, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("factor")))
    call parse_node_append_sub (range%pn_factor, range%pn_value)
    call parse_node_freeze_branch (range%pn_factor)
    allocate (range%pn_term)
    call parse_node_create_branch (range%pn_term, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("term")))
    call parse_node_append_sub (range%pn_term, range%pn_factor)
    call parse_node_freeze_branch (range%pn_term)
    allocate (range%pn_expr)
    call parse_node_create_branch (range%pn_expr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("expr")))
    call parse_node_append_sub (range%pn_expr, range%pn_term)
    call parse_node_freeze_branch (range%pn_expr)
  end subroutine range_create_value_node
  
@ %def range_create_value_node
@ Compile, given an environment.
<<Commands: range: TBP>>=
  procedure :: compile => range_compile
<<Commands: procedures>>=
  subroutine range_compile (range, global)
    class(range_t), intent(inout) :: range
    type(rt_data_t), intent(in), target :: global
    if (associated (range%pn_beg)) then
       call eval_tree_init_expr &
            (range%expr_beg, range%pn_beg, global%var_list)
       if (associated (range%pn_end)) then
          call eval_tree_init_expr &
               (range%expr_end, range%pn_end, global%var_list)
          if (associated (range%pn_step)) then
             call eval_tree_init_expr &
                  (range%expr_step, range%pn_step, global%var_list)
          end if
       end if
    end if
  end subroutine range_compile
  
@ %def range_compile
@ Evaluate: compute the actual bounds and parameters that determine the values
that we can iterate.

This is implementation-specific.
<<Commands: range: TBP>>=
  procedure (range_evaluate), deferred :: evaluate
<<Commands: interfaces>>=
  abstract interface
     subroutine range_evaluate (range)
       import
       class(range_t), intent(inout) :: range
     end subroutine range_evaluate
  end interface
  
@ %def range_evaluate
@ The version for an integer variable.  If the step is subtractive, we invert
the sign and treat it as an additive step.  For a multiplicative step, the
step must be greater than one, and the initial and final values must be of
same sign and strictly ordered.  Analogously for a division step.
<<Commands: range int: TBP>>=
  procedure :: evaluate => range_int_evaluate
<<Commands: procedures>>=
  subroutine range_int_evaluate (range)
    class(range_int_t), intent(inout) :: range
    integer :: ival
    if (associated (range%pn_beg)) then
       call eval_tree_evaluate (range%expr_beg)
       if (eval_tree_result_is_known (range%expr_beg)) then
          range%i_beg = eval_tree_get_int (range%expr_beg)
       else
          call range%write ()
          call msg_fatal &
               ("Range expression: initial value evaluates to unknown")
       end if
       if (associated (range%pn_end)) then
          call eval_tree_evaluate (range%expr_end)
          if (eval_tree_result_is_known (range%expr_end)) then
             range%i_end = eval_tree_get_int (range%expr_end)
             if (associated (range%pn_step)) then
                call eval_tree_evaluate (range%expr_step)
                if (eval_tree_result_is_known (range%expr_step)) then
                   range%i_step = eval_tree_get_int (range%expr_step)
                   select case (range%step_mode)
                   case (STEP_SUB);  range%i_step = - range%i_step
                   end select
                else
                   call range%write ()
                   call msg_fatal &
                        ("Range expression: step value evaluates to unknown")
                end if
             else
                range%i_step = 1
             end if
          else
             call range%write ()
             call msg_fatal &
                  ("Range expression: final value evaluates to unknown")
          end if
       else
          range%i_end = range%i_beg
          range%i_step = 1
       end if
       select case (range%step_mode)
       case (STEP_NONE)
          range%n_step = 1
       case (STEP_ADD, STEP_SUB)
          if (range%i_step /= 0) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (sign (1, range%i_end - range%i_beg) &
                  == sign (1, range%i_step)) then
                range%n_step = (range%i_end - range%i_beg) / range%i_step + 1
             else
                range%n_step = 0
             end if
          else
             call msg_fatal ("range evaluation (add): step value is zero")
          end if
       case (STEP_MUL)
          if (range%i_step > 1) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (range%i_beg == 0) then
                call msg_fatal ("range evaluation (mul): initial value is zero")
             else if (sign (1, range%i_beg) == sign (1, range%i_end) &
                  .and. abs (range%i_beg) < abs (range%i_end)) then
                range%n_step = 0
                ival = range%i_beg
                do while (abs (ival) <= abs (range%i_end))
                   range%n_step = range%n_step + 1
                   ival = ival * range%i_step
                end do
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_DIV)
          if (range%i_step > 1) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (sign (1, range%i_beg) == sign (1, range%i_end) &
                  .and. abs (range%i_beg) > abs (range%i_end)) then
                range%n_step = 0
                ival = range%i_beg
                do while (abs (ival) >= abs (range%i_end))
                   range%n_step = range%n_step + 1
                   if (ival == 0)  exit
                   ival = ival / range%i_step
                end do
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (div): step value is one or less")
          end if
       case (STEP_COMP_ADD)
          call msg_fatal ("range evaluation: &
               &step mode /+/ not allowed for integer variable")
       case (STEP_COMP_MUL)
          call msg_fatal ("range evaluation: &
               &step mode /*/ not allowed for integer variable")
       case default
          call range%write ()
          call msg_bug ("range evaluation: step mode not implemented")
       end select
    end if
  end subroutine range_int_evaluate

@ %def range_int_evaluate
@ The version for a real variable.
<<Commands: range real: TBP>>=
  procedure :: evaluate => range_real_evaluate
<<Commands: procedures>>=
  subroutine range_real_evaluate (range)
    class(range_real_t), intent(inout) :: range
    if (associated (range%pn_beg)) then
       call eval_tree_evaluate (range%expr_beg)
       if (eval_tree_result_is_known (range%expr_beg)) then
          range%r_beg = eval_tree_get_real (range%expr_beg)
       else
          call range%write ()
          call msg_fatal &
               ("Range expression: initial value evaluates to unknown")
       end if
       if (associated (range%pn_end)) then
          call eval_tree_evaluate (range%expr_end)
          if (eval_tree_result_is_known (range%expr_end)) then
             range%r_end = eval_tree_get_real (range%expr_end)
             if (associated (range%pn_step)) then
                if (eval_tree_result_is_known (range%expr_step)) then
                   select case (range%step_mode)
                   case (STEP_ADD, STEP_SUB, STEP_MUL, STEP_DIV)
                      call eval_tree_evaluate (range%expr_step)
                      range%r_step = eval_tree_get_real (range%expr_step)
                      select case (range%step_mode)
                      case (STEP_SUB);  range%r_step = - range%r_step
                      end select
                   case (STEP_COMP_ADD, STEP_COMP_MUL)
                      range%n_step = &
                           max (eval_tree_get_int (range%expr_step), 0)
                   end select
                else
                   call range%write ()
                   call msg_fatal &
                        ("Range expression: step value evaluates to unknown")
                end if
             else
                call range%write ()
                call msg_fatal &
                     ("Range expression (real): step value must be provided")
             end if
          else
             call range%write ()
             call msg_fatal &
                  ("Range expression: final value evaluates to unknown")
          end if
       else
          range%r_end = range%r_beg
          range%r_step = 1
       end if
       select case (range%step_mode)
       case (STEP_NONE)
          range%n_step = 1
       case (STEP_ADD, STEP_SUB)
          if (range%r_step /= 0) then
             if (sign (1._default, range%r_end - range%r_beg) &
                  == sign (1._default, range%r_step)) then
                range%n_step = &
                     nint ((range%r_end - range%r_beg) / range%r_step + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal ("range evaluation (add): step value is zero")
          end if
       case (STEP_MUL)
          if (range%r_step > 1) then
             if (range%r_beg == 0 .or. range%r_end == 0) then
                call msg_fatal ("range evaluation (mul): bound is zero")
             else if (sign (1._default, range%r_beg) &
                  == sign (1._default, range%r_end) &
                  .and. abs (range%r_beg) <= abs (range%r_end)) then
                range%lr_beg = log (abs (range%r_beg))
                range%lr_end = log (abs (range%r_end))
                range%lr_step = log (range%r_step)
                range%n_step = nint &
                     (abs ((range%lr_end - range%lr_beg) / range%lr_step) + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_DIV)
          if (range%r_step > 1) then
             if (range%r_beg == 0 .or. range%r_end == 0) then
                call msg_fatal ("range evaluation (div): bound is zero")
             else if (sign (1._default, range%r_beg) &
                  == sign (1._default, range%r_end) &
                  .and. abs (range%r_beg) >= abs (range%r_end)) then
                range%lr_beg = log (abs (range%r_beg))
                range%lr_end = log (abs (range%r_end))
                range%lr_step = -log (range%r_step)
                range%n_step = nint &
                     (abs ((range%lr_end - range%lr_beg) / range%lr_step) + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_COMP_ADD)
          ! Number of steps already known
       case (STEP_COMP_MUL)
          ! Number of steps already known
          if (range%r_beg == 0 .or. range%r_end == 0) then
             call msg_fatal ("range evaluation (mul): bound is zero")
          else if (sign (1._default, range%r_beg) &
               == sign (1._default, range%r_end)) then
             range%lr_beg = log (abs (range%r_beg))
             range%lr_end = log (abs (range%r_end))
          else
             range%n_step = 0
          end if
       case default
          call range%write ()
          call msg_bug ("range evaluation: step mode not implemented")
       end select
    end if
  end subroutine range_real_evaluate

@ %def range_real_evaluate
@ Return the number of iterations:
<<Commands: range: TBP>>=
  procedure :: get_n_iterations => range_get_n_iterations
<<Commands: procedures>>=
  function range_get_n_iterations (range) result (n)
    class(range_t), intent(in) :: range
    integer :: n
    n = range%n_step
  end function range_get_n_iterations
  
@ %def range_get_n_iterations
@ Compute the value for iteration [[i]] and store it in the embedded token.
<<Commands: range: TBP>>=
  procedure (range_set_value), deferred :: set_value
<<Commands: interfaces>>=
  abstract interface
     subroutine range_set_value (range, i)
       import
       class(range_t), intent(inout) :: range
       integer, intent(in) :: i
     end subroutine range_set_value
  end interface
  
@ %def range_set_value
@ In the integer case, we compute the value directly for additive step.  For
multiplicative step, we perform a loop in the same way as above, where the
number of iteration was determined.
<<Commands: range int: TBP>>=
  procedure :: set_value => range_int_set_value
<<Commands: procedures>>=
  subroutine range_int_set_value (range, i)
    class(range_int_t), intent(inout) :: range
    integer, intent(in) :: i
    integer :: k, ival
    select case (range%step_mode)
    case (STEP_NONE)
       ival = range%i_beg
    case (STEP_ADD, STEP_SUB)
       ival = range%i_beg + (i - 1) * range%i_step
    case (STEP_MUL)
       ival = range%i_beg
       do k = 1, i - 1
          ival = ival * range%i_step
       end do
    case (STEP_DIV)
       ival = range%i_beg
       do k = 1, i - 1
          ival = ival / range%i_step
       end do
    case default
       call range%write ()
       call msg_bug ("range iteration: step mode not implemented")
    end select
    call parse_node_set_value (range%pn_literal, ival = ival)
  end subroutine range_int_set_value
  
@ %def range_int_set_value
@ In the integer case, we compute the value directly for additive step.  For
multiplicative step, we perform a loop in the same way as above, where the
number of iteration was determined.
<<Commands: range real: TBP>>=
  procedure :: set_value => range_real_set_value
<<Commands: procedures>>=
  subroutine range_real_set_value (range, i)
    class(range_real_t), intent(inout) :: range
    integer, intent(in) :: i
    real(default) :: rval, x
    select case (range%step_mode)
    case (STEP_NONE)
       rval = range%r_beg
    case (STEP_ADD, STEP_SUB, STEP_COMP_ADD)
       if (range%n_step > 1) then
          x = real (i - 1, default) / (range%n_step - 1)
       else
          x = 1._default / 2
       end if
       rval = x * range%r_end + (1 - x) * range%r_beg
    case (STEP_MUL, STEP_DIV, STEP_COMP_MUL)
       if (range%n_step > 1) then
          x = real (i - 1, default) / (range%n_step - 1)
       else
          x = 1._default / 2
       end if
       rval = sign &
            (exp (x * range%lr_end + (1 - x) * range%lr_beg), range%r_beg)
    case default
       call range%write ()
       call msg_bug ("range iteration: step mode not implemented")
    end select
    call parse_node_set_value (range%pn_literal, rval = rval)
  end subroutine range_real_set_value
  
@ %def range_real_set_value
@ 
\subsubsection{Scan over parameters and other objects}
The scan command allocates a new parse node for the variable
assignment (the lhs).  The rhs of this parse node is assigned from the
available rhs expressions in the scan list, one at a time, so the
compiled parse node can be prepended to the scan body.

Note: for the integer/real range array, the obvious implementation as a
polymorphic array is suspended because in gfortran 4.7, polymorphic arrays are
apparently broken.
<<Commands: types>>=
  type, extends (command_t) :: cmd_scan_t
     private
     type(string_t) :: name
     integer :: n_values = 0
     type(parse_node_p), dimension(:), allocatable :: scan_cmd
     !!! !!! gfortran 4.7.x memory corruption
     !!!  class(range_t), dimension(:), allocatable :: range
     type(range_int_t), dimension(:), allocatable :: range_int
     type(range_real_t), dimension(:), allocatable :: range_real
   contains
   <<Commands: cmd scan: TBP>>  
  end type cmd_scan_t

@ %def cmd_scan_t
@ Finalizer.  

The auxiliary parse nodes that we have constructed have to be treated
carefully: the embedded pointers all point to persistent objects
somewhere else and should not be finalized, so we should not call the
finalizer recursively.
<<Commands: cmd scan: TBP>>=
  procedure :: final => cmd_scan_final
<<Commands: procedures>>=
  recursive subroutine cmd_scan_final (cmd)
    class(cmd_scan_t), intent(inout) :: cmd
    type(parse_node_t), pointer :: pn_var_single, pn_decl_single
    type(string_t) :: key
    integer :: i
    if (allocated (cmd%scan_cmd)) then
       do i = 1, size (cmd%scan_cmd)
          pn_var_single => parse_node_get_sub_ptr (cmd%scan_cmd(i)%ptr)
          key = parse_node_get_rule_key (pn_var_single)
          select case (char (key))
          case ("scan_string_decl", "scan_log_decl")
             pn_decl_single => parse_node_get_sub_ptr (pn_var_single, 2)
             call parse_node_final (pn_decl_single, recursive=.false.)
             deallocate (pn_decl_single)
          end select
          call parse_node_final (pn_var_single, recursive=.false.)
          deallocate (pn_var_single)
       end do
       deallocate (cmd%scan_cmd)
    end if
    !!! !!! gfortran 4.7.x memory corruption
    !!!  if (allocated (cmd%range)) then
    !!!     do i = 1, size (cmd%range)
    !!!        call cmd%range(i)%final ()
    !!!     end do
    !!!  end if
    if (allocated (cmd%range_int)) then
       do i = 1, size (cmd%range_int)
          call cmd%range_int(i)%final ()
       end do
    end if
    if (allocated (cmd%range_real)) then
       do i = 1, size (cmd%range_real)
          call cmd%range_real(i)%final ()
       end do
    end if
  end subroutine cmd_scan_final

@ %def cmd_scan_final
@ Output.
<<Commands: cmd scan: TBP>>=
  procedure :: write => cmd_scan_write
<<Commands: procedures>>=
  subroutine cmd_scan_write (cmd, unit, indent)
    class(cmd_scan_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,A,1x,'(',I0,')')")  "scan:", char (cmd%name), &
         cmd%n_values
  end subroutine cmd_scan_write

@ %def cmd_scan_write
@ Compile the scan command.  We construct a new parse node that
implements the variable assignment for a single element on the rhs,
instead of the whole list that we get from the original parse tree.
By simply copying the node, we copy all pointers and inherit the
targets from the original.  During execution, we should replace the
rhs by the stored rhs pointers (the list elements), one by one, then
(re)compile the redefined node.
<<Commands: cmd scan: TBP>>=
  procedure :: compile => cmd_scan_compile
<<Commands: procedures>>=
  recursive subroutine cmd_scan_compile (cmd, global)
    class(cmd_scan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_var, pn_body, pn_body_first
    type(parse_node_t), pointer :: pn_decl, pn_name
    type(parse_node_t), pointer :: pn_arg, pn_scan_cmd, pn_rhs
    type(parse_node_t), pointer :: pn_decl_single, pn_var_single
    type(syntax_rule_t), pointer :: var_rule_decl, var_rule
    type(string_t) :: key
    integer :: var_type
    integer :: i
    logical, parameter :: debug = .false.
    if (debug) then
       print *, "compile scan"
       call parse_node_write_rec (cmd%pn)
    end if
    pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_body => parse_node_get_next_ptr (pn_var)
    if (associated (pn_body)) then
       pn_body_first => parse_node_get_sub_ptr (pn_body)
    else
       pn_body_first => null ()
    end if
    key = parse_node_get_rule_key (pn_var)
    select case (char (key))
    case ("scan_num")
       pn_name => parse_node_get_sub_ptr (pn_var)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_num"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_int")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_int"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_real")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_real"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_complex")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str("cmd_complex"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_alias")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_alias"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_string_decl")
       pn_decl => parse_node_get_sub_ptr (pn_var, 2)
       pn_name => parse_node_get_sub_ptr (pn_decl, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule_decl => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_string"))
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_string_decl"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_log_decl")
       pn_decl => parse_node_get_sub_ptr (pn_var, 2)
       pn_name => parse_node_get_sub_ptr (pn_decl, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule_decl => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_log"))
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_log_decl"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_cuts")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_cuts"))
       cmd%name = "cuts"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_weight")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_weight"))
       cmd%name = "weight"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_scale"))
       cmd%name = "scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_ren_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_ren_scale"))
       cmd%name = "renormalization_scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_fac_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_fac_scale"))
       cmd%name = "factorization_scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_selection")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_selection"))
       cmd%name = "selection"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_reweight")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_reweight"))
       cmd%name = "reweight"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_analysis")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_analysis"))
       cmd%name = "analysis"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_model")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_model"))
       cmd%name = "model"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_library")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_library"))
       cmd%name = "library"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case default
       call msg_bug ("scan: case '" // char (key) // "' not implemented")
    end select
    if (associated (pn_arg)) then
       cmd%n_values = parse_node_get_n_sub (pn_arg)
    end if
    allocate (cmd%scan_cmd (cmd%n_values))
    select case (char (key))
    case ("scan_num")
       var_type = var_list_get_type (global%var_list, cmd%name)
       select case (var_type)
       case (V_INT)
          !!! !!! gfortran 4.7.x memory corruption
          !!!  allocate (range_int_t :: cmd%range (cmd%n_values))
          allocate (cmd%range_int (cmd%n_values))
       case (V_REAL)
          !!! !!! gfortran 4.7.x memory corruption          
          !!!  allocate (range_real_t :: cmd%range (cmd%n_values))
          allocate (cmd%range_real (cmd%n_values))
       case (V_CMPLX)
          call msg_fatal ("scan over complex variable not implemented")
       case (V_NONE)
          call msg_fatal ("scan: variable '" // char (cmd%name) //"' undefined")
       case default
          call msg_bug ("scan: impossible variable type")
       end select
    case ("scan_int")
       !!! !!! gfortran 4.7.x memory corruption       
       !!!  allocate (range_int_t :: cmd%range (cmd%n_values))
       allocate (cmd%range_int (cmd%n_values))
    case ("scan_real")
       !!! !!! gfortran 4.7.x memory corruption
       !!!  allocate (range_real_t :: cmd%range (cmd%n_values))
       allocate (cmd%range_real (cmd%n_values))
    case ("scan_complex")
       call msg_fatal ("scan over complex variable not implemented")
    end select
    i = 1
    if (associated (pn_arg)) then
       pn_rhs => parse_node_get_sub_ptr (pn_arg)
    else
       pn_rhs => null ()
    end if
    do while (associated (pn_rhs))
       allocate (pn_scan_cmd)
       call parse_node_create_branch (pn_scan_cmd, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("command_list")))
       allocate (pn_var_single)
       pn_var_single = pn_var
       call parse_node_replace_rule (pn_var_single, var_rule)
       select case (char (key))
       case ("scan_num", "scan_int", "scan_real", &
            "scan_complex", "scan_alias", &
            "scan_cuts", "scan_weight", &
            "scan_scale", "scan_ren_scale", "scan_fac_scale", &
            "scan_selection", "scan_reweight", "scan_analysis", &
            "scan_model", "scan_library")
          if (allocated (cmd%range_int)) then
             call cmd%range_int(i)%init (pn_rhs)
             !!! !!! gfortran 4.7.x memory corruption             
             !!!  call cmd%range_int(i)%compile (global)
             call parse_node_replace_last_sub &
                  (pn_var_single, cmd%range_int(i)%pn_expr)
          else if (allocated (cmd%range_real)) then
             call cmd%range_real(i)%init (pn_rhs)
             !!! !!! gfortran 4.7.x memory corruption 
             !!!  call cmd%range_real(i)%compile (global)
             call parse_node_replace_last_sub &
                  (pn_var_single, cmd%range_real(i)%pn_expr)
          else
             call parse_node_replace_last_sub (pn_var_single, pn_rhs)
          end if
       case ("scan_string_decl", "scan_log_decl")
          allocate (pn_decl_single)
          pn_decl_single = pn_decl
          call parse_node_replace_rule (pn_decl_single, var_rule_decl)
          call parse_node_replace_last_sub (pn_decl_single, pn_rhs)
          call parse_node_freeze_branch (pn_decl_single)
          call parse_node_replace_last_sub (pn_var_single, pn_decl_single)
       case default
          call msg_bug ("scan: case '" // char (key)  &
               // "' broken")
       end select
       call parse_node_freeze_branch (pn_var_single)
       call parse_node_append_sub (pn_scan_cmd, pn_var_single)
       call parse_node_append_sub (pn_scan_cmd, pn_body_first)
       call parse_node_freeze_branch (pn_scan_cmd)
       cmd%scan_cmd(i)%ptr => pn_scan_cmd
       i = i + 1
       pn_rhs => parse_node_get_next_ptr (pn_rhs)
    end do
    if (debug) then
       do i = 1, cmd%n_values
          print *, "scan command ", i
          call parse_node_write_rec (cmd%scan_cmd(i)%ptr)
          if (allocated (cmd%range_int))  call cmd%range_int(i)%write ()
          if (allocated (cmd%range_real))  call cmd%range_real(i)%write ()
       end do
       print *, "original"
       call parse_node_write_rec (cmd%pn)
    end if
  end subroutine cmd_scan_compile

@ %def cmd_scan_compile
@ Execute the loop for all values in the step list.  We use the
parse trees with single variable assignment that we have stored, to
iteratively create a local environment, execute the stored commands, and
destroy it again.  When we encounter a range object, we execute the commands
for each value that this object provides.  Computing this value has the side
effect of modifying the rhs of the variable assignment that heads the local
command list, directly in the local parse tree.
<<Commands: cmd scan: TBP>>=
  procedure :: execute => cmd_scan_execute
<<Commands: procedures>>=
  recursive subroutine cmd_scan_execute (cmd, global)
    class(cmd_scan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), allocatable :: local
    integer :: i, j
    do i = 1, cmd%n_values
       if (allocated (cmd%range_int)) then
          call cmd%range_int(i)%compile (global)
          call cmd%range_int(i)%evaluate ()
          do j = 1, cmd%range_int(i)%get_n_iterations ()
             call cmd%range_int(i)%set_value (j)
             allocate (local)
             call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
             call local%local_final ()
             deallocate (local)
          end do
       else if (allocated (cmd%range_real)) then
          call cmd%range_real(i)%compile (global)
          call cmd%range_real(i)%evaluate ()
          do j = 1, cmd%range_real(i)%get_n_iterations ()
             call cmd%range_real(i)%set_value (j)
             allocate (local)
             call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
             call local%local_final ()
             deallocate (local)
          end do
       else
          allocate (local)
          call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
          call local%local_final ()
          deallocate (local)
       end if
    end do
  end subroutine cmd_scan_execute

@ %def cmd_scan_execute
@ 
\subsubsection{Conditionals}
Conditionals are implemented as a list that is compiled and evaluated
recursively; this allows for a straightforward representation of
[[else if]] constructs.  A [[cmd_if_t]] object can hold either an
[[else_if]] clause which is another object of this type, or an
[[else_body]], but not both.

If- or else-bodies are no scoping units, so all data remain global and
no copy-in copy-out is needed.
<<Commands: types>>=
  type, extends (command_t) :: cmd_if_t
     private
     type(parse_node_t), pointer :: pn_if_lexpr => null ()
     type(command_list_t), pointer :: if_body => null ()
     type(cmd_if_t), dimension(:), pointer :: elsif_cmd => null ()
     type(command_list_t), pointer :: else_body => null ()
   contains
   <<Commands: cmd if: TBP>>
  end type cmd_if_t

@ %def cmd_if_t
@ Finalizer.  There are no local options, therefore we can simply override
the default finalizer.
<<Commands: cmd if: TBP>>=
  procedure :: final => cmd_if_final
<<Commands: procedures>>=
  recursive subroutine cmd_if_final (cmd)
    class(cmd_if_t), intent(inout) :: cmd
    integer :: i
    if (associated (cmd%if_body)) then
       call command_list_final (cmd%if_body)
       deallocate (cmd%if_body)
    end if
    if (associated (cmd%elsif_cmd)) then
       do i = 1, size (cmd%elsif_cmd)
          call cmd_if_final (cmd%elsif_cmd(i))
       end do
       deallocate (cmd%elsif_cmd)
    end if
    if (associated (cmd%else_body)) then
       call command_list_final (cmd%else_body)
       deallocate (cmd%else_body)
    end if
  end subroutine cmd_if_final

@ %def cmd_if_final
@ Output.  Recursively write the command lists.
<<Commands: cmd if: TBP>>=
  procedure :: write => cmd_if_write
<<Commands: procedures>>=
  subroutine cmd_if_write (cmd, unit, indent)
    class(cmd_if_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, ind, i
    u = given_output_unit (unit);  if (u < 0)  return
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, indent)
    write (u, "(A)")  "if <expr> then"
    if (associated (cmd%if_body)) then
       call cmd%if_body%write (unit, ind + 1)
    end if
    if (associated (cmd%elsif_cmd)) then
       do i = 1, size (cmd%elsif_cmd)
          call write_indent (u, indent)
          write (u, "(A)")  "elsif <expr> then"
          if (associated (cmd%elsif_cmd(i)%if_body)) then
             call cmd%elsif_cmd(i)%if_body%write (unit, ind + 1)
          end if
       end do
    end if
    if (associated (cmd%else_body)) then
       call write_indent (u, indent)
       write (u, "(A)")  "else"
       call cmd%else_body%write (unit, ind + 1)
    end if
  end subroutine cmd_if_write
  
@ %def cmd_if_write
@ Compile the conditional.
<<Commands: cmd if: TBP>>=
  procedure :: compile => cmd_if_compile
<<Commands: procedures>>=
  recursive subroutine cmd_if_compile (cmd, global)
    class(cmd_if_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_lexpr, pn_body
    type(parse_node_t), pointer :: pn_elsif_clauses, pn_cmd_elsif
    type(parse_node_t), pointer :: pn_else_clause, pn_cmd_else
    integer :: i, n_elsif
    pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_if_lexpr => pn_lexpr
    pn_body => parse_node_get_next_ptr (pn_lexpr, 2)
    select case (char (parse_node_get_rule_key (pn_body)))
    case ("command_list")
       allocate (cmd%if_body)
       call cmd%if_body%compile (pn_body, global)
       pn_elsif_clauses => parse_node_get_next_ptr (pn_body)
    case default
       pn_elsif_clauses => pn_body
    end select
    select case (char (parse_node_get_rule_key (pn_elsif_clauses)))
    case ("elsif_clauses")
       n_elsif = parse_node_get_n_sub (pn_elsif_clauses)
       allocate (cmd%elsif_cmd (n_elsif))
       pn_cmd_elsif => parse_node_get_sub_ptr (pn_elsif_clauses)
       do i = 1, n_elsif
          pn_lexpr => parse_node_get_sub_ptr (pn_cmd_elsif, 2)
          cmd%elsif_cmd(i)%pn_if_lexpr => pn_lexpr
          pn_body => parse_node_get_next_ptr (pn_lexpr, 2)
          if (associated (pn_body)) then
             allocate (cmd%elsif_cmd(i)%if_body)
             call cmd%elsif_cmd(i)%if_body%compile (pn_body, global)
          end if
          pn_cmd_elsif => parse_node_get_next_ptr (pn_cmd_elsif)
       end do
       pn_else_clause => parse_node_get_next_ptr (pn_elsif_clauses)
    case default
       pn_else_clause => pn_elsif_clauses
    end select
    select case (char (parse_node_get_rule_key (pn_else_clause)))
    case ("else_clause")
       pn_cmd_else => parse_node_get_sub_ptr (pn_else_clause)
       pn_body => parse_node_get_sub_ptr (pn_cmd_else, 2)
       if (associated (pn_body)) then
          allocate (cmd%else_body)
          call cmd%else_body%compile (pn_body, global)
       end if
    end select
  end subroutine cmd_if_compile

@ %def global
@ (Recursively) execute the condition.  Context remains global in all cases.
<<Commands: cmd if: TBP>>=
  procedure :: execute => cmd_if_execute
<<Commands: procedures>>=
  recursive subroutine cmd_if_execute (cmd, global)
    class(cmd_if_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: lval, is_known
    integer :: i
    lval = eval_log (cmd%pn_if_lexpr, global%var_list, is_known=is_known)
    if (is_known) then
       if (lval) then
          if (associated (cmd%if_body)) then
             call cmd%if_body%execute (global)
          end if
          return
       end if
    else
       call error_undecided ()
       return
    end if
    if (associated (cmd%elsif_cmd)) then
       SCAN_ELSIF: do i = 1, size (cmd%elsif_cmd)
          lval = eval_log (cmd%elsif_cmd(i)%pn_if_lexpr, global%var_list, &
                is_known=is_known)
          if (is_known) then
             if (lval) then
                if (associated (cmd%elsif_cmd(i)%if_body)) then
                   call cmd%elsif_cmd(i)%if_body%execute (global)
                end if
                return
             end if
          else
             call error_undecided ()
             return
          end if
       end do SCAN_ELSIF
    end if
    if (associated (cmd%else_body)) then
       call cmd%else_body%execute (global)
    end if
  contains
    subroutine error_undecided ()
      call msg_error ("Undefined result of cmditional expression: " &
           // "neither branch will be executed")
    end subroutine error_undecided
  end subroutine cmd_if_execute

@ %def cmd_if_execute
@
\subsubsection{Include another command-list file}
The include command allocates a local parse tree.  This must not be
deleted before the command object itself is deleted, since pointers
may point to subobjects of it.
<<Commands: types>>=
  type, extends (command_t) :: cmd_include_t
     private
     type(string_t) :: file
     type(command_list_t), pointer :: command_list => null ()
     type(parse_tree_t) :: parse_tree
   contains
   <<Commands: cmd include: TBP>>
  end type cmd_include_t

@ %def cmd_include_t
@ Finalizer: delete the command list.  No options, so we can simply override
the default finalizer.
<<Commands: cmd include: TBP>>=
  procedure :: final => cmd_include_final
<<Commands: procedures>>=
  subroutine cmd_include_final (cmd)
    class(cmd_include_t), intent(inout) :: cmd
    call parse_tree_final (cmd%parse_tree)
    if (associated (cmd%command_list)) then
       call cmd%command_list%final ()
       deallocate (cmd%command_list)
    end if
  end subroutine cmd_include_final

@ %def cmd_include_final
@ Write: display the command list as-is, if allocated.
<<Commands: cmd include: TBP>>=
  procedure :: write => cmd_include_write
<<Commands: procedures>>=
  subroutine cmd_include_write (cmd, unit, indent)
    class(cmd_include_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, indent)
    write (u, "(A,A,A,A)")  "include ", '"', char (cmd%file), '"'
    if (associated (cmd%command_list)) then
       call cmd%command_list%write (u, ind + 1)
    end if
  end subroutine cmd_include_write
  
@ %def cmd_include_write
@ Compile file contents: First parse the file, then immediately
compile its contents.  Use the global data set.
<<Commands: cmd include: TBP>>=
  procedure :: compile => cmd_include_compile
<<Commands: procedures>>=
  subroutine cmd_include_compile (cmd, global)
    class(cmd_include_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_file
    type(string_t) :: file
    logical :: exist
    integer :: u
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_file => parse_node_get_sub_ptr (pn_arg)
    file = parse_node_get_string (pn_file)
    inquire (file=char(file), exist=exist)
    if (exist) then
       cmd%file = file
    else
       cmd%file = global%os_data%whizard_cutspath // "/" // file
       inquire (file=char(cmd%file), exist=exist)
       if (.not. exist) then
          call msg_error ("Include file '" // char (file) // "' not found")
          return
       end if
    end if
    u = free_unit ()
    call lexer_init_cmd_list (lexer, global%lexer)
    call stream_init (stream, char (cmd%file))
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (cmd%parse_tree, syntax_cmd_list, lexer)
    call stream_final (stream)
    call lexer_final (lexer)
    close (u)
    allocate (cmd%command_list)
    call cmd%command_list%compile (parse_tree_get_root_ptr (cmd%parse_tree), &
         global)
  end subroutine cmd_include_compile

@ %def cmd_include_compile
@ Execute file contents in the global context.
<<Commands: cmd include: TBP>>=
  procedure :: execute => cmd_include_execute
<<Commands: procedures>>=
  subroutine cmd_include_execute (cmd, global)
    class(cmd_include_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%command_list)) then
       call msg_message &
            ("Including Sindarin from '" // char (cmd%file) // "'")
       call cmd%command_list%execute (global)
       call msg_message &
            ("End of included '" // char (cmd%file) // "'")
    end if
  end subroutine cmd_include_execute

@ %def cmd_include_execute
@ 
\subsubsection{Quit command execution}
The code is the return code of the whole program if it is terminated
by this command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_quit_t
     private
     logical :: has_code = .false.
     type(parse_node_t), pointer :: pn_code_expr => null ()
   contains
   <<Commands: cmd quit: TBP>>
  end type cmd_quit_t

@ %def cmd_quit_t
@ Output.
<<Commands: cmd quit: TBP>>=
  procedure :: write => cmd_quit_write
<<Commands: procedures>>=  
  subroutine cmd_quit_write (cmd, unit, indent)
    class(cmd_quit_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,L1)")  "quit: has_code = ", cmd%has_code
  end subroutine cmd_quit_write

@ %def cmd_quit_write
@ Compile: allocate a [[quit]] object which serves as a placeholder.
<<Commands: cmd quit: TBP>>=
  procedure :: compile => cmd_quit_compile
<<Commands: procedures>>=
  subroutine cmd_quit_compile (cmd, global)
    class(cmd_quit_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       cmd%pn_code_expr => parse_node_get_sub_ptr (pn_arg)
       cmd%has_code = .true.
    end if
  end subroutine cmd_quit_compile

@ %def cmd_quit_compile
@ Execute: The quit command does not execute anything, it just stops
command execution.  This is achieved by setting quit flag and quit
code in the global variable list.  However, the return code, if
present, is an expression which has to be evaluated.
<<Commands: cmd quit: TBP>>=
  procedure :: execute => cmd_quit_execute
<<Commands: procedures>>=
  subroutine cmd_quit_execute (cmd, global)
    class(cmd_quit_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: is_known
    if (cmd%has_code) then
       global%quit_code = eval_int (cmd%pn_code_expr, global%var_list, &
            is_known=is_known)
       if (.not. is_known) then
          call msg_error ("Undefined return code of quit/exit command")
       end if
    end if
    global%quit = .true.
  end subroutine cmd_quit_execute

@ %def cmd_quit_execute
@
\subsection{The command list}
The command list holds a list of commands and relevant global data.
<<Commands: public>>=
  public :: command_list_t
<<Commands: types>>=
  type :: command_list_t
     ! not private anymore as required by the whizard-c-interface
     class(command_t), pointer :: first => null ()
     class(command_t), pointer :: last => null ()
   contains
   <<Commands: command list: TBP>>
  end type command_list_t

@ %def command_list_t
@ Output.
<<Commands: command list: TBP>>=
  procedure :: write => command_list_write
<<Commands: procedures>>=
  recursive subroutine command_list_write (cmd_list, unit, indent)
    class(command_list_t), intent(in) :: cmd_list
    integer, intent(in), optional :: unit, indent
    class(command_t), pointer :: cmd
    cmd => cmd_list%first
    do while (associated (cmd))
       call cmd%write (unit, indent)
       cmd => cmd%next
    end do
  end subroutine command_list_write
  
@ %def command_list_write
@ Append a new command to the list and free the original pointer.
<<Commands: command list: TBP>>=
  procedure :: append => command_list_append
<<Commands: procedures>>=
  subroutine command_list_append (cmd_list, command)
    class(command_list_t), intent(inout) :: cmd_list
    class(command_t), intent(inout), pointer :: command
    if (associated (cmd_list%last)) then
       cmd_list%last%next => command
    else
       cmd_list%first => command
    end if
    cmd_list%last => command
    command => null ()
  end subroutine command_list_append

@ %def command_list_append
@ Finalize.
<<Commands: command list: TBP>>=
  procedure :: final => command_list_final
<<Commands: procedures>>=
  recursive subroutine command_list_final (cmd_list)
    class(command_list_t), intent(inout) :: cmd_list
    class(command_t), pointer :: command
    do while (associated (cmd_list%first))
       command => cmd_list%first
       cmd_list%first => cmd_list%first%next
       call command%final ()
       deallocate (command)
    end do
    cmd_list%last => null ()
  end subroutine command_list_final

@ %def command_list_final
@ 
\subsection{Compiling the parse tree}
Transform a parse tree into a command list.  Initialization is assumed
to be done.  

After each command, we set a breakpoint.
<<Commands: command list: TBP>>=
  procedure :: compile => command_list_compile
<<Commands: procedures>>=
  recursive subroutine command_list_compile (cmd_list, pn, global)
    class(command_list_t), intent(inout), target :: cmd_list
    type(parse_node_t), intent(in), target :: pn
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd
    class(command_t), pointer :: command
    integer :: i
    pn_cmd => parse_node_get_sub_ptr (pn)
    do i = 1, parse_node_get_n_sub (pn)
       call dispatch_command (command, pn_cmd)
       call command%compile (global)
       call cmd_list%append (command)
       call terminate_now_if_signal ()
       pn_cmd => parse_node_get_next_ptr (pn_cmd)
    end do
  end subroutine command_list_compile

@ %def command_list_compile
@
\subsection{Executing the command list}
Before executing a command we should execute its options (if any).  After
that, reset the options, i.e., remove temporary effects from the global
state.

Also here, after each command we set a breakpoint.
<<Commands: command list: TBP>>=
  procedure :: execute => command_list_execute
<<Commands: procedures>>=
  recursive subroutine command_list_execute (cmd_list, global)
    class(command_list_t), intent(in) :: cmd_list
    type(rt_data_t), intent(inout), target :: global
    class(command_t), pointer :: command
    command => cmd_list%first
    COMMAND_COND: do while (associated (command))
       call command%execute_options (global)
       call command%execute (global)
       call command%reset_options (global)
       call terminate_now_if_signal ()
       if (global%quit)  exit COMMAND_COND
       command => command%next
    end do COMMAND_COND
  end subroutine command_list_execute

@ %def command_list_execute
@
\subsection{Command list syntax}
<<Commands: public>>=
  public :: syntax_cmd_list
<<Commands: variables>>=
  type(syntax_t), target, save :: syntax_cmd_list

@ %def syntax_cmd_list
<<Commands: public>>=
  public :: syntax_cmd_list_init
<<Commands: procedures>>=
  subroutine syntax_cmd_list_init ()
    type(ifile_t) :: ifile
    call define_cmd_list_syntax (ifile)
    call syntax_init (syntax_cmd_list, ifile)
    call ifile_final (ifile)
  end subroutine syntax_cmd_list_init

@ %def syntax_cmd_list_init
<<Commands: public>>=
  public :: syntax_cmd_list_final
<<Commands: procedures>>=
  subroutine syntax_cmd_list_final ()
    call syntax_final (syntax_cmd_list)
  end subroutine syntax_cmd_list_final

@ %def syntax_cmd_list_final
<<Commands: public>>=
  public :: syntax_cmd_list_write
<<Commands: procedures>>=
  subroutine syntax_cmd_list_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_cmd_list, unit)
  end subroutine syntax_cmd_list_write

@ %def syntax_cmd_list_write
<<Commands: procedures>>=
  subroutine define_cmd_list_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ command_list = command*")
    call ifile_append (ifile, "ALT command = " &
         // "cmd_model | cmd_library | cmd_iterations | cmd_sample_format | " &
         // "cmd_var | cmd_slha | " &
         // "cmd_show | cmd_clear | " &
         // "cmd_expect | " &
         // "cmd_cuts | cmd_scale | cmd_fac_scale | cmd_ren_scale | " &
         // "cmd_weight | cmd_selection | cmd_reweight | " &
         // "cmd_beams | cmd_beams_pol_density | cmd_beams_pol_fraction | " &
         // "cmd_beams_momentum | cmd_beams_theta | cmd_beams_phi | " &
         // "cmd_integrate | " &
         // "cmd_observable | cmd_histogram | cmd_plot | cmd_graph | " &
         // "cmd_record | " &
         // "cmd_analysis | cmd_alt_setup | " &
         // "cmd_unstable | cmd_stable | cmd_simulate | cmd_rescan | " &
         // "cmd_process | cmd_compile | cmd_exec | " &
         // "cmd_scan | cmd_if | cmd_include | cmd_quit | " &
         // "cmd_polarized | cmd_unpolarized | " &
         // "cmd_open_out | cmd_close_out | cmd_printf | " &
         // "cmd_write_analysis | cmd_compile_analysis | cmd_nlo | cmd_components") 
    call ifile_append (ifile, "GRO options = '{' local_command_list '}'")
    call ifile_append (ifile, "SEQ local_command_list = local_command*")
    call ifile_append (ifile, "ALT local_command = " &
         // "cmd_model | cmd_library | cmd_iterations | cmd_sample_format | " &
         // "cmd_var | cmd_slha | " &
         // "cmd_show | " &
         // "cmd_expect | " &
         // "cmd_cuts | cmd_scale | cmd_fac_scale | cmd_ren_scale | " &
         // "cmd_weight | cmd_selection | cmd_reweight | " &
         // "cmd_beams | cmd_beams_pol_density | cmd_beams_pol_fraction | " &
         // "cmd_beams_momentum | cmd_beams_theta | cmd_beams_phi | " &
         // "cmd_observable | cmd_histogram | cmd_plot | cmd_graph | " &
         // "cmd_clear | cmd_record | " &
         // "cmd_analysis | cmd_alt_setup | " &
         // "cmd_open_out | cmd_close_out | cmd_printf | " &
         // "cmd_write_analysis | cmd_compile_analysis | cmd_nlo | cmd_components")
    call ifile_append (ifile, "SEQ cmd_model = model '=' model_name")
    call ifile_append (ifile, "KEY model")
    call ifile_append (ifile, "ALT model_name = model_id | string_literal")
    call ifile_append (ifile, "IDE model_id")
    call ifile_append (ifile, "SEQ cmd_library = library '=' lib_name")
    call ifile_append (ifile, "KEY library")
    call ifile_append (ifile, "ALT lib_name = lib_id | string_literal")
    call ifile_append (ifile, "IDE lib_id")
    call ifile_append (ifile, "ALT cmd_var = " &
         // "cmd_log_decl | cmd_log | " &
         // "cmd_int | cmd_real | cmd_complex | cmd_num | " &
         // "cmd_string_decl | cmd_string | cmd_alias | " &
         // "cmd_result")
    call ifile_append (ifile, "SEQ cmd_log_decl = logical cmd_log")
    call ifile_append (ifile, "SEQ cmd_log = '?' var_name '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_int = int var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_real = real var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_complex = complex var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_num = var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_string_decl = string cmd_string")
    call ifile_append (ifile, "SEQ cmd_string = " &
         // "'$' var_name '=' sexpr") ! $
    call ifile_append (ifile, "SEQ cmd_alias = alias var_name '=' cexpr")
    call ifile_append (ifile, "SEQ cmd_result = result '=' expr") 
    call ifile_append (ifile, "SEQ cmd_slha = slha_action slha_arg options?")
    call ifile_append (ifile, "ALT slha_action = " &
         // "read_slha | write_slha")
    call ifile_append (ifile, "KEY read_slha")
    call ifile_append (ifile, "KEY write_slha")
    call ifile_append (ifile, "ARG slha_arg = ( string_literal )")
    call ifile_append (ifile, "SEQ cmd_show = show show_arg options?")
    call ifile_append (ifile, "KEY show")
    call ifile_append (ifile, "ARG show_arg = ( showable* )")
    call ifile_append (ifile, "ALT showable = " &
         // "model | library | beams | iterations | " &
         // "cuts | weight | logical | string | pdg | " &
         // "scale | factorization_scale | renormalization_scale | " & 
	 // "selection | reweight | analysis | " &
         // "stable | unstable | polarized | unpolarized | " &
         // "expect | intrinsic | int | real | complex | " &
         // "alias_var | string | results | result_var | " &
         // "log_var | string_var | var_name")
    call ifile_append (ifile, "KEY results")
    call ifile_append (ifile, "KEY intrinsic")    
    call ifile_append (ifile, "SEQ alias_var = alias var_name")
    call ifile_append (ifile, "SEQ result_var = result_key result_arg?")
    call ifile_append (ifile, "SEQ log_var = '?' var_name")
    call ifile_append (ifile, "SEQ string_var = '$' var_name")  ! $
    call ifile_append (ifile, "SEQ cmd_clear = clear clear_arg options?")    
    call ifile_append (ifile, "KEY clear")
    call ifile_append (ifile, "ARG clear_arg = ( clearable* )")
    call ifile_append (ifile, "ALT clearable = " &
         // "beams | iterations | " &
         // "cuts | weight | " &
         // "scale | factorization_scale | renormalization_scale | " & 
	 // "selection | reweight | analysis | " &
         // "unstable | polarized | " &
         // "expect | " &
         // "log_var | string_var | var_name")
    call ifile_append (ifile, "SEQ cmd_expect = expect expect_arg options?")
    call ifile_append (ifile, "KEY expect")
    call ifile_append (ifile, "ARG expect_arg = ( lexpr )")
    call ifile_append (ifile, "SEQ cmd_cuts = cuts '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_scale = scale '=' expr")    
    call ifile_append (ifile, "SEQ cmd_fac_scale = " &
         // "factorization_scale '=' expr")
    call ifile_append (ifile, "SEQ cmd_ren_scale = " &
         // "renormalization_scale '=' expr")
    call ifile_append (ifile, "SEQ cmd_weight = weight '=' expr")
    call ifile_append (ifile, "SEQ cmd_selection = selection '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_reweight = reweight '=' expr")
    call ifile_append (ifile, "KEY cuts")
    call ifile_append (ifile, "KEY scale")    
    call ifile_append (ifile, "KEY factorization_scale")
    call ifile_append (ifile, "KEY renormalization_scale")    
    call ifile_append (ifile, "KEY weight")
    call ifile_append (ifile, "KEY selection")
    call ifile_append (ifile, "KEY reweight")
    call ifile_append (ifile, "SEQ cmd_process = process process_id '=' " &
         // "process_prt '=>' prt_state_list options?")
    call ifile_append (ifile, "KEY process")
    call ifile_append (ifile, "KEY '=>'")
    call ifile_append (ifile, "LIS process_prt = cexpr+")
    call ifile_append (ifile, "LIS prt_state_list = prt_state_sum+")
    call ifile_append (ifile, "SEQ prt_state_sum = " &
         // "prt_state prt_state_addition*")
    call ifile_append (ifile, "SEQ prt_state_addition = '+' prt_state")
    call ifile_append (ifile, "ALT prt_state = grouped_prt_state_list | cexpr")
    call ifile_append (ifile, "GRO grouped_prt_state_list = " &
         // "( prt_state_list )")
    call ifile_append (ifile, "SEQ cmd_compile = compile_cmd options?")
    call ifile_append (ifile, "SEQ compile_cmd = compile_clause compile_arg?")
    call ifile_append (ifile, "SEQ compile_clause = compile exec_name_spec?")
    call ifile_append (ifile, "KEY compile")
    call ifile_append (ifile, "SEQ exec_name_spec = as exec_name")
    call ifile_append (ifile, "KEY as")
    call ifile_append (ifile, "ALT exec_name = exec_id | string_literal")
    call ifile_append (ifile, "IDE exec_id")
    call ifile_append (ifile, "ARG compile_arg = ( lib_name* )")
    call ifile_append (ifile, "SEQ cmd_exec = exec exec_arg")
    call ifile_append (ifile, "KEY exec")
    call ifile_append (ifile, "ARG exec_arg = ( sexpr )")
    call ifile_append (ifile, "SEQ cmd_beams = beams '=' beam_def")
    call ifile_append (ifile, "KEY beams")
    call ifile_append (ifile, "SEQ beam_def = beam_spec strfun_seq*")
    call ifile_append (ifile, "SEQ beam_spec = beam_list")
    call ifile_append (ifile, "LIS beam_list = cexpr, cexpr?")
    call ifile_append (ifile, "SEQ cmd_beams_pol_density = " &
         // "beams_pol_density '=' beams_pol_spec")
    call ifile_append (ifile, "KEY beams_pol_density")
    call ifile_append (ifile, "LIS beams_pol_spec = smatrix, smatrix?")
    call ifile_append (ifile, "SEQ smatrix = '@' smatrix_arg")
    ! call ifile_append (ifile, "KEY '@'")     !!! Key already exists
    call ifile_append (ifile, "ARG smatrix_arg = ( sentry* )")
    call ifile_append (ifile, "SEQ sentry = expr extra_sentry*")
    call ifile_append (ifile, "SEQ extra_sentry = ':' expr")
    call ifile_append (ifile, "SEQ cmd_beams_pol_fraction = " &
         // "beams_pol_fraction '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_pol_fraction")
    call ifile_append (ifile, "SEQ cmd_beams_momentum = " &
         // "beams_momentum '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_momentum")
    call ifile_append (ifile, "SEQ cmd_beams_theta = " &
         // "beams_theta '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_theta")
    call ifile_append (ifile, "SEQ cmd_beams_phi = " &
         // "beams_phi '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_phi")
    call ifile_append (ifile, "LIS beams_par_spec = expr, expr?")
    call ifile_append (ifile, "SEQ strfun_seq = '=>' strfun_pair")
    call ifile_append (ifile, "LIS strfun_pair = strfun_def, strfun_def?")
    call ifile_append (ifile, "SEQ strfun_def = strfun_id")
    call ifile_append (ifile, "ALT strfun_id = " &
          // "none | lhapdf | lhapdf_photon | pdf_builtin | pdf_builtin_photon | " &
          // "isr | epa | ewa | circe1 | circe2 | energy_scan | " &
          // "beam_events | user_sf_spec")
    call ifile_append (ifile, "KEY none")
    call ifile_append (ifile, "KEY lhapdf")
    call ifile_append (ifile, "KEY lhapdf_photon")    
    call ifile_append (ifile, "KEY pdf_builtin")    
    call ifile_append (ifile, "KEY pdf_builtin_photon")        
    call ifile_append (ifile, "KEY isr")
    call ifile_append (ifile, "KEY epa")
    call ifile_append (ifile, "KEY ewa")    
    call ifile_append (ifile, "KEY circe1")        
    call ifile_append (ifile, "KEY circe2")
    call ifile_append (ifile, "KEY energy_scan")
    call ifile_append (ifile, "KEY beam_events")
    call ifile_append (ifile, "SEQ user_sf_spec = user_strfun user_arg")
    call ifile_append (ifile, "KEY user_strfun")
    call ifile_append (ifile, "SEQ cmd_integrate = " &
         // "integrate proc_arg options?") 
    call ifile_append (ifile, "KEY integrate")
    call ifile_append (ifile, "ARG proc_arg = ( proc_id* )")
    call ifile_append (ifile, "IDE proc_id")
    call ifile_append (ifile, "SEQ cmd_iterations = " &
         // "iterations '=' iterations_list")
    call ifile_append (ifile, "KEY iterations")
    call ifile_append (ifile, "LIS iterations_list = iterations_spec+")
    call ifile_append (ifile, "ALT iterations_spec = it_spec")
    call ifile_append (ifile, "SEQ it_spec = expr calls_spec adapt_spec?")
    call ifile_append (ifile, "SEQ calls_spec = ':' expr")
    call ifile_append (ifile, "SEQ adapt_spec = ':' sexpr")
    call ifile_append (ifile, "SEQ cmd_components = " &
         // "active '=' component_list")
    call ifile_append (ifile, "KEY active")
    call ifile_append (ifile, "LIS component_list = sexpr+")
    call ifile_append (ifile, "SEQ cmd_sample_format = " &
         // "sample_format '=' event_format_list")
    call ifile_append (ifile, "KEY sample_format")
    call ifile_append (ifile, "LIS event_format_list = event_format+")
    call ifile_append (ifile, "IDE event_format")
    call ifile_append (ifile, "SEQ cmd_observable = " &
         // "observable analysis_tag options?")
    call ifile_append (ifile, "KEY observable")
    call ifile_append (ifile, "SEQ cmd_histogram = " &
         // "histogram analysis_tag histogram_arg " & 
         // "options?")
    call ifile_append (ifile, "KEY histogram")
    call ifile_append (ifile, "ARG histogram_arg = (expr, expr, expr?)")
    call ifile_append (ifile, "SEQ cmd_plot = plot analysis_tag options?")
    call ifile_append (ifile, "KEY plot")
    call ifile_append (ifile, "SEQ cmd_graph = graph graph_term '=' graph_def")
    call ifile_append (ifile, "KEY graph")
    call ifile_append (ifile, "SEQ graph_term = analysis_tag options?")
    call ifile_append (ifile, "SEQ graph_def = graph_term graph_append*")
    call ifile_append (ifile, "SEQ graph_append = '&' graph_term")
    call ifile_append (ifile, "SEQ cmd_analysis = analysis '=' lexpr")
    call ifile_append (ifile, "KEY analysis")
    call ifile_append (ifile, "SEQ cmd_alt_setup = " &
         // "alt_setup '=' option_list_expr")
    call ifile_append (ifile, "KEY alt_setup")
    call ifile_append (ifile, "ALT option_list_expr = " &
         // "grouped_option_list | option_list")
    call ifile_append (ifile, "GRO grouped_option_list = ( option_list_expr )")
    call ifile_append (ifile, "LIS option_list = options+")
    call ifile_append (ifile, "SEQ cmd_open_out = open_out open_arg options?")
    call ifile_append (ifile, "SEQ cmd_close_out = close_out open_arg options?")
    call ifile_append (ifile, "KEY open_out")
    call ifile_append (ifile, "KEY close_out")
    call ifile_append (ifile, "ARG open_arg = (sexpr)")
    call ifile_append (ifile, "SEQ cmd_printf = printf_cmd options?")
    call ifile_append (ifile, "SEQ printf_cmd = printf_clause sprintf_args?")
    call ifile_append (ifile, "SEQ printf_clause = printf sexpr")
    call ifile_append (ifile, "KEY printf")
    call ifile_append (ifile, "SEQ cmd_record = record_cmd")
    call ifile_append (ifile, "SEQ cmd_unstable = " &
         // "unstable cexpr unstable_arg options?")
    call ifile_append (ifile, "KEY unstable")
    call ifile_append (ifile, "ARG unstable_arg = ( proc_id* )")
    call ifile_append (ifile, "SEQ cmd_stable = stable stable_list options?")
    call ifile_append (ifile, "KEY stable")
    call ifile_append (ifile, "LIS stable_list = cexpr+")
    call ifile_append (ifile, "KEY polarized")
    call ifile_append (ifile, "SEQ cmd_polarized = polarized polarized_list options?")
    call ifile_append (ifile, "LIS polarized_list = cexpr+")
    call ifile_append (ifile, "KEY unpolarized")
    call ifile_append (ifile, "SEQ cmd_unpolarized = unpolarized unpolarized_list options?")
    call ifile_append (ifile, "LIS unpolarized_list = cexpr+")
    call ifile_append (ifile, "SEQ cmd_simulate = " &
         // "simulate proc_arg options?")
    call ifile_append (ifile, "KEY simulate")
    call ifile_append (ifile, "SEQ cmd_rescan = " &
         // "rescan sexpr proc_arg options?")
    call ifile_append (ifile, "KEY rescan")
    call ifile_append (ifile, "SEQ cmd_scan = scan scan_var scan_body?")
    call ifile_append (ifile, "KEY scan")
    call ifile_append (ifile, "ALT scan_var = " &
         // "scan_log_decl | scan_log | " &
         // "scan_int | scan_real | scan_complex | scan_num | " &
         // "scan_string_decl | scan_string | scan_alias | " &
         // "scan_cuts | scan_weight | " &
         // "scan_scale | scan_ren_scale | scan_fac_scale | " &
         // "scan_selection | scan_reweight | scan_analysis | " &
         // "scan_model | scan_library")
    call ifile_append (ifile, "SEQ scan_log_decl = logical scan_log")
    call ifile_append (ifile, "SEQ scan_log = '?' var_name '=' scan_log_arg")
    call ifile_append (ifile, "ARG scan_log_arg = ( lexpr* )")
    call ifile_append (ifile, "SEQ scan_int = int var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_real = real var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_complex = " &
         // "complex var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_num = var_name '=' scan_num_arg")
    call ifile_append (ifile, "ARG scan_num_arg = ( range* )")
    call ifile_append (ifile, "ALT range = grouped_range | range_expr")
    call ifile_append (ifile, "GRO grouped_range = ( range_expr )")
    call ifile_append (ifile, "SEQ range_expr = expr range_spec?")
    call ifile_append (ifile, "SEQ range_spec = '=>' expr step_spec?")
    call ifile_append (ifile, "SEQ step_spec = step_op expr")
    call ifile_append (ifile, "ALT step_op = " &
         // "'/+' | '/-' | '/*' | '//' | '/+/' | '/*/'")
    call ifile_append (ifile, "KEY '/+'")
    call ifile_append (ifile, "KEY '/-'")
    call ifile_append (ifile, "KEY '/*'")
    call ifile_append (ifile, "KEY '//'")
    call ifile_append (ifile, "KEY '/+/'")
    call ifile_append (ifile, "KEY '/*/'")
    call ifile_append (ifile, "SEQ scan_string_decl = string scan_string")
    call ifile_append (ifile, "SEQ scan_string = " &
         // "'$' var_name '=' scan_string_arg")
    call ifile_append (ifile, "ARG scan_string_arg = ( sexpr* )")
    call ifile_append (ifile, "SEQ scan_alias = " &
         // "alias var_name '=' scan_alias_arg")
    call ifile_append (ifile, "ARG scan_alias_arg = ( cexpr* )")
    call ifile_append (ifile, "SEQ scan_cuts = cuts '=' scan_lexpr_arg")
    call ifile_append (ifile, "ARG scan_lexpr_arg = ( lexpr* )")
    call ifile_append (ifile, "SEQ scan_scale = scale '=' scan_expr_arg")
    call ifile_append (ifile, "ARG scan_expr_arg = ( expr* )")
    call ifile_append (ifile, "SEQ scan_fac_scale = " &
         // "factorization_scale '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_ren_scale = " &
         // "renormalization_scale '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_weight = weight '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_selection = selection '=' scan_lexpr_arg")
    call ifile_append (ifile, "SEQ scan_reweight = reweight '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_analysis = analysis '=' scan_lexpr_arg")
    call ifile_append (ifile, "SEQ scan_model = model '=' scan_model_arg")
    call ifile_append (ifile, "ARG scan_model_arg = ( model_name* )")
    call ifile_append (ifile, "SEQ scan_library = library '=' scan_library_arg")
    call ifile_append (ifile, "ARG scan_library_arg = ( lib_name* )")
    call ifile_append (ifile, "GRO scan_body = '{' command_list '}'")
    call ifile_append (ifile, "SEQ cmd_if = " &
         // "if lexpr then command_list elsif_clauses else_clause endif")
    call ifile_append (ifile, "SEQ elsif_clauses = cmd_elsif*")
    call ifile_append (ifile, "SEQ cmd_elsif = elsif lexpr then command_list")
    call ifile_append (ifile, "SEQ else_clause = cmd_else?")
    call ifile_append (ifile, "SEQ cmd_else = else command_list")
    call ifile_append (ifile, "SEQ cmd_include = include include_arg")
    call ifile_append (ifile, "KEY include")
    call ifile_append (ifile, "ARG include_arg = ( string_literal )")
    call ifile_append (ifile, "SEQ cmd_quit = quit_cmd quit_arg?")
    call ifile_append (ifile, "ALT quit_cmd = quit | exit")
    call ifile_append (ifile, "KEY quit")
    call ifile_append (ifile, "KEY exit")
    call ifile_append (ifile, "ARG quit_arg = ( expr )")
    call ifile_append (ifile, "SEQ cmd_write_analysis = " &
         // "write_analysis_clause options?")
    call ifile_append (ifile, "SEQ cmd_compile_analysis = " &
         // "compile_analysis_clause options?")
    call ifile_append (ifile, "SEQ write_analysis_clause = " &
         // "write_analysis write_analysis_arg?")
    call ifile_append (ifile, "SEQ compile_analysis_clause = " &
         // "compile_analysis write_analysis_arg?")
    call ifile_append (ifile, "KEY write_analysis")
    call ifile_append (ifile, "KEY compile_analysis")
    call ifile_append (ifile, "ARG write_analysis_arg = ( analysis_tag* )")
    call ifile_append (ifile, "SEQ cmd_nlo = " &
                       // "nlo_calculation '=' nlo_calculation_list")
    call ifile_append (ifile, "KEY nlo_calculation")
    call ifile_append (ifile, "LIS nlo_calculation_list = sexpr ',' sexpr ',' sexpr")
    call define_expr_syntax (ifile, particles=.true., analysis=.true.)
  end subroutine define_cmd_list_syntax

@ %def define_cmd_list_syntax
<<Commands: public>>=
  public :: lexer_init_cmd_list
<<Commands: procedures>>=
  subroutine lexer_init_cmd_list (lexer, parent_lexer)
    type(lexer_t), intent(out) :: lexer
    type(lexer_t), intent(in), optional, target :: parent_lexer
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "()[]{},;:&%?$@", &
         special_class = [ "+-*/^", "<>=~ " ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_cmd_list), &
         parent = parent_lexer)
  end subroutine lexer_init_cmd_list

@ %def lexer_init_cmd_list
@ 
\subsection{Unit Tests}
<<Commands: public>>=
  public :: commands_test
<<Commands: tests>>=
  subroutine commands_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Commands: execute tests>>
  end subroutine commands_test
  
@ %def commands_test
@
\subsubsection{Prepare Sindarin code}
This routine parses an internal file, prints the parse tree, and
returns a parse node to the root.  We use the routine in the tests
below.
<<Commands: tests>>=
  subroutine parse_ifile (ifile, pn_root, u)
    type(ifile_t), intent(in) :: ifile
    type(parse_node_t), pointer, intent(out) :: pn_root
    integer, intent(in), optional :: u
    type(stream_t), target :: stream
    type(lexer_t), target :: lexer
    type(parse_tree_t) :: parse_tree

    call lexer_init_cmd_list (lexer)
    call stream_init (stream, ifile)
    call lexer_assign_stream (lexer, stream)

    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    if (present (u))  call parse_tree_write (parse_tree, u)
    pn_root => parse_tree_get_root_ptr (parse_tree)

    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine parse_ifile

@ %def parse_ifile
@
\subsubsection{Empty command list}
Compile and execute an empty command list.  Should do nothing but
test the integrity of the workflow.
<<Commands: execute tests>>=
  call test (commands_1, "commands_1", &
       "empty command list", &
       u, results)
<<Commands: tests>>=
  subroutine commands_1 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_1"
    write (u, "(A)")  "*   Purpose: compile and execute empty command list"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Parse empty file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"

    if (associated (pn_root)) then
       call command_list%compile (pn_root, global)
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_1"

  end subroutine commands_1

@ %def commands_1
@
\subsubsection{Read model}
Execute a [[model]] assignment.
<<Commands: execute tests>>=
  call test (commands_2, "commands_2", &
       "model", &
       u, results)
<<Commands: tests>>=
  subroutine commands_2 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_2"
    write (u, "(A)")  "*   Purpose: set model"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    
    call ifile_write (ifile, u)

    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)
    write (u, "(A)")  "global model = '" &
         //  char (global%model%get_name ()) // "'"

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_2"

  end subroutine commands_2

@ %def commands_2
@
\subsubsection{Declare Process}
Read a model, then declare a process.  The process library is allocated
explicitly.  For the process definition, We take the default ([[omega]])
method.  Since we do not compile, \oMega\ is not actually called.
<<Commands: execute tests>>=
  call test (commands_3, "commands_3", &
       "process declaration", &
       u, results)
<<Commands: tests>>=
  subroutine commands_3 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_3"
    write (u, "(A)")  "*   Purpose: define process"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd3"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t3 = s, s => s, s')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_3"

  end subroutine commands_3

@ %def commands_3
@
\subsubsection{Compile Process}
Read a model, then declare a process and compile the library.  The process
library is allocated explicitly.  For the process definition, We take the
default ([[unit_test]]) method.  There is no external code, so compilation of
the library is merely a formal status change.
<<Commands: execute tests>>=
  call test (commands_4, "commands_4", &
       "compilation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_4 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_4"
    write (u, "(A)")  "*   Purpose: define process and compile library"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd4"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t4 = s, s => s, s')
    call ifile_append (ifile, 'compile ("lib_cmd4")')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_4"

  end subroutine commands_4

@ %def commands_4
@
\subsubsection{Integrate Process}
Read a model, then declare a process, compile the library, and
integrate over phase space.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.
<<Commands: execute tests>>=
  call test (commands_5, "commands_5", &
       "integration", &
       u, results)
<<Commands: tests>>=
  subroutine commands_5 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_5"
    write (u, "(A)")  "*   Purpose: define process, iterations, and integrate"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)
    
    allocate (lib)
    call lib%init (var_str ("lib_cmd5"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t5 = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (t5)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call reset_interaction_counter ()
    call command_list%execute (global)

    call global%it_list%write (u)
    write (u, "(A)")
    call global%process_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_5"

  end subroutine commands_5

@ %def commands_5
@
\subsubsection{Variables}
Set intrinsic and user-defined variables.
<<Commands: execute tests>>=
  call test (commands_6, "commands_6", &
       "variables", &
       u, results)
<<Commands: tests>>=
  subroutine commands_6 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_6"
    write (u, "(A)")  "*   Purpose: define and set variables"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    call global%write_vars (u, [ &
         var_str ("$run_id"), &
         var_str ("?unweighted"), &
         var_str ("sqrts")])

    write (u, "(A)")
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$run_id = "run1"')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'sqrts = 1000')
    call ifile_append (ifile, 'int j = 10')
    call ifile_append (ifile, 'real x = 1000.')
    call ifile_append (ifile, 'complex z = 5')
    call ifile_append (ifile, 'string $text = "abcd"')
    call ifile_append (ifile, 'logical ?flag = true')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_vars (u, [ &
         var_str ("$run_id"), &
         var_str ("?unweighted"), &
         var_str ("sqrts"), &
         var_str ("j"), &
         var_str ("x"), &
         var_str ("z"), &
         var_str ("$text"), &
         var_str ("?flag")])


    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_6"

  end subroutine commands_6

@ %def commands_6
@
\subsubsection{Process library}
Open process libraries explicitly.
<<Commands: execute tests>>=
  call test (commands_7, "commands_7", &
       "process library", &
       u, results)
<<Commands: tests>>=
  subroutine commands_7 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_7"
    write (u, "(A)")  "*   Purpose: declare process libraries"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    write (u, "(A)")
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'library = "lib_cmd7_1"')
    call ifile_append (ifile, 'library = "lib_cmd7_2"')
    call ifile_append (ifile, 'library = "lib_cmd7_1"')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_libraries (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_7"

  end subroutine commands_7

@ %def commands_7
@
\subsubsection{Generate events}
Read a model, then declare a process, compile the library, and
generate weighted events.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.
<<Commands: execute tests>>=
  call test (commands_8, "commands_8", &
       "event generation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_8 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_8"
    write (u, "(A)")  "*   Purpose: define process, integrate, generate events"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd8"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_8_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_8_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'simulate (commands_8_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_8"

  end subroutine commands_8

@ %def commands_8
@
\subsubsection{Define cuts}
Declare a cut expression.
<<Commands: execute tests>>=
  call test (commands_9, "commands_9", &
       "cuts", &
       u, results)
<<Commands: tests>>=
  subroutine commands_9 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(string_t), dimension(0) :: no_vars

    write (u, "(A)")  "* Test output: commands_9"
    write (u, "(A)")  "*   Purpose: define cuts"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'cuts = all Pt > 0 [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_9"

  end subroutine commands_9

@ %def commands_9
@
\subsubsection{Beams}
Define beam setup.
<<Commands: execute tests>>=
  call test (commands_10, "commands_10", &
       "beams", &
       u, results)
<<Commands: tests>>=
  subroutine commands_10 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_10"
    write (u, "(A)")  "*   Purpose: define beams"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = QCD')
    call ifile_append (ifile, 'sqrts = 1000')
    call ifile_append (ifile, 'beams = p, p')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_beams (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_10"

  end subroutine commands_10

@ %def commands_10
@
\subsubsection{Structure functions}
Define beam setup with structure functions
<<Commands: execute tests>>=
  call test (commands_11, "commands_11", &
       "structure functions", &
       u, results)
<<Commands: tests>>=
  subroutine commands_11 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_11"
    write (u, "(A)")  "*   Purpose: define beams with structure functions"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = QCD')
    call ifile_append (ifile, 'sqrts = 1100')
    call ifile_append (ifile, 'beams = p, p => lhapdf => pdf_builtin, isr')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_beams (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_11"

  end subroutine commands_11

@ %def commands_11
@
\subsubsection{Rescan events}
Read a model, then declare a process, compile the library, and
generate weighted events.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.  Then, rescan the
generated event sample.
<<Commands: execute tests>>=
  call test (commands_12, "commands_12", &
       "event rescanning", &
       u, results)
<<Commands: tests>>=
  subroutine commands_12 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_12"
    write (u, "(A)")  "*   Purpose: generate events and rescan"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd12"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_12_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_12_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'simulate (commands_12_p)')
    call ifile_append (ifile, '?write_raw = false')
    call ifile_append (ifile, 'rescan "commands_12_p" (commands_12_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_12"

  end subroutine commands_12

@ %def commands_12
@
\subsubsection{Event Files}
Set output formats for event files.
<<Commands: execute tests>>=
  call test (commands_13, "commands_13", &
       "event output formats", &
       u, results)
<<Commands: tests>>=
  subroutine commands_13 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib
    logical :: exist

    write (u, "(A)")  "* Test output: commands_13"
    write (u, "(A)")  "*   Purpose: generate events and rescan"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    allocate (lib)
    call lib%init (var_str ("lib_cmd13"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_13_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_13_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 1')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'sample_format = weight_stream')
    call ifile_append (ifile, 'simulate (commands_13_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Verify output files"
    write (u, "(A)")

    inquire (file = "commands_13_p.evx", exist = exist)
    if (exist)  write (u, "(1x,A)")  "raw"

    inquire (file = "commands_13_p.weights.dat", exist = exist)
    if (exist)  write (u, "(1x,A)")  "weight_stream"

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_13"

  end subroutine commands_13

@ %def commands_13
@
\subsubsection{Compile Empty Libraries}
(This is a regression test:)  Declare two empty libraries and compile them.
<<Commands: execute tests>>=
  call test (commands_14, "commands_14", &
       "empty libraries", &
       u, results)
<<Commands: tests>>=
  subroutine commands_14 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_14"
    write (u, "(A)")  "*   Purpose: define and compile empty libraries"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'library = "lib1"')
    call ifile_append (ifile, 'library = "lib2"')
    call ifile_append (ifile, 'compile ()')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_14"

  end subroutine commands_14

@ %def commands_14
@
\subsubsection{Compile Process}
Read a model, then declare a process and compile the library.  The process
library is allocated explicitly.  For the process definition, We take the
default ([[unit_test]]) method.  There is no external code, so compilation of
the library is merely a formal status change.
<<Commands: execute tests>>=
  call test (commands_15, "commands_15", &
       "compilation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_15 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_15"
    write (u, "(A)")  "*   Purpose: define process and compile library"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    allocate (lib)
    call lib%init (var_str ("lib_cmd15"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t15 = s, s => s, s')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (t15)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_15"

  end subroutine commands_15

@ %def commands_15
@
\subsubsection{Observable}
Declare an observable, fill it and display.
<<Commands: execute tests>>=
  call test (commands_16, "commands_16", &
       "observables", &
       u, results)
<<Commands: tests>>=
  subroutine commands_16 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_16"
    write (u, "(A)")  "*   Purpose: declare an observable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Observable foo"')
    call ifile_append (ifile, '$description = "This is observable foo"')
    call ifile_append (ifile, 'observable foo')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    call analysis_record_data (var_str ("foo"), 1._default)
    call analysis_record_data (var_str ("foo"), 3._default)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_16"

  end subroutine commands_16

@ %def commands_16
@
\subsubsection{Histogram}
Declare a histogram, fill it and display.
<<Commands: execute tests>>=
  call test (commands_17, "commands_17", &
       "histograms", &
       u, results)
<<Commands: tests>>=
  subroutine commands_17 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(string_t), dimension(3) :: name
    integer :: i

    write (u, "(A)")  "* Test output: commands_17"
    write (u, "(A)")  "*   Purpose: declare histograms"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Histogram foo"')
    call ifile_append (ifile, '$description = "This is histogram foo"')
    call ifile_append (ifile, 'histogram foo (0,5,1)')
    call ifile_append (ifile, '$title = "Histogram bar"')
    call ifile_append (ifile, '$description = "This is histogram bar"')
    call ifile_append (ifile, 'n_bins = 2')
    call ifile_append (ifile, 'histogram bar (0,5)')
    call ifile_append (ifile, '$title = "Histogram gee"')
    call ifile_append (ifile, '$description = "This is histogram gee"')
    call ifile_append (ifile, '?normalize_bins = true')
    call ifile_append (ifile, 'histogram gee (0,5)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    name(1) = "foo"
    name(2) = "bar"
    name(3) = "gee"
    
    do i = 1, 3
       call analysis_record_data (name(i), 0.1_default, &
            weight = 0.25_default)
       call analysis_record_data (name(i), 3.1_default)
       call analysis_record_data (name(i), 4.1_default, &
            excess = 0.5_default)
       call analysis_record_data (name(i), 7.1_default)
    end do

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_17"

  end subroutine commands_17

@ %def commands_17
@
\subsubsection{Plot}
Declare a plot, fill it and display contents.
<<Commands: execute tests>>=
  call test (commands_18, "commands_18", &
       "plots", &
       u, results)
<<Commands: tests>>=
  subroutine commands_18 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_18"
    write (u, "(A)")  "*   Purpose: declare a plot"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Plot foo"')
    call ifile_append (ifile, '$description = "This is plot foo"')
    call ifile_append (ifile, '$x_label = "x axis"')
    call ifile_append (ifile, '$y_label = "y axis"')
    call ifile_append (ifile, '?x_log = false')
    call ifile_append (ifile, '?y_log = true')
    call ifile_append (ifile, 'x_min = -1')
    call ifile_append (ifile, 'x_max = 1')
    call ifile_append (ifile, 'y_min = 0.1')
    call ifile_append (ifile, 'y_max = 1000')
    call ifile_append (ifile, 'plot foo')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    call analysis_record_data (var_str ("foo"), 0._default, 20._default, &
         xerr = 0.25_default)
    call analysis_record_data (var_str ("foo"), 0.5_default, 0.2_default, &
         yerr = 0.07_default)
    call analysis_record_data (var_str ("foo"), 3._default, 2._default)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_18"

  end subroutine commands_18

@ %def commands_18
@
\subsubsection{Graph}
Combine two (empty) plots to a graph.
<<Commands: execute tests>>=
  call test (commands_19, "commands_19", &
       "graphs", &
       u, results)
<<Commands: tests>>=
  subroutine commands_19 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_19"
    write (u, "(A)")  "*   Purpose: combine two plots to a graph"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'plot a')
    call ifile_append (ifile, 'plot b')
    call ifile_append (ifile, '$title = "Graph foo"')
    call ifile_append (ifile, '$description = "This is graph foo"')
    call ifile_append (ifile, 'graph foo = a & b')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (var_str ("foo"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_19"

  end subroutine commands_19

@ %def commands_19
@
\subsubsection{Record Data}
Record data in previously allocated analysis objects.
<<Commands: execute tests>>=
  call test (commands_20, "commands_20", &
       "record data", &
       u, results)
<<Commands: tests>>=
  subroutine commands_20 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_20"
    write (u, "(A)")  "*   Purpose: record data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable, histogram, plot"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call analysis_init_observable (var_str ("o"))
    call analysis_init_histogram (var_str ("h"), 0._default, 1._default, 3, &
         normalize_bins = .false.)
    call analysis_init_plot (var_str ("p"))
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'record o (1.234)')
    call ifile_append (ifile, 'record h (0.5)')
    call ifile_append (ifile, 'record p (1, 2)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_20"

  end subroutine commands_20

@ %def commands_20
@
\subsubsection{Analysis}
Declare an analysis expression and use it to fill an observable during
event generation.
<<Commands: execute tests>>=
  call test (commands_21, "commands_21", &
       "analysis expression", &
       u, results)
<<Commands: tests>>=
  subroutine commands_21 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_21"
    write (u, "(A)")  "*   Purpose: create and use analysis expression"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd8"))
    call global%add_prclib (lib)
    
    call analysis_init_observable (var_str ("m"))
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_21_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:100')
    call ifile_append (ifile, 'integrate (commands_21_p)')
    call ifile_append (ifile, '?unweighted = true')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'observable m')
    call ifile_append (ifile, 'analysis = record m (eval M [s])')
    call ifile_append (ifile, 'simulate (commands_21_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_21"

  end subroutine commands_21

@ %def commands_21
@
\subsubsection{Write Analysis}
Write accumulated analysis data to file.
<<Commands: execute tests>>=
  call test (commands_22, "commands_22", &
       "write analysis", &
       u, results)
<<Commands: tests>>=
  subroutine commands_22 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: commands_22"
    write (u, "(A)")  "*   Purpose: write analysis data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call analysis_init_observable (var_str ("m"))
    call analysis_record_data (var_str ("m"), 125._default)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$out_file = "commands_22.dat"')
    call ifile_append (ifile, 'write_analysis')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis data"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "commands_22.dat", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_22"

  end subroutine commands_22

@ %def commands_22
@
\subsubsection{Compile Analysis}
Write accumulated analysis data to file and compile.
<<Commands: execute tests>>=
  call test (commands_23, "commands_23", &
       "compile analysis", &
       u, results)
<<Commands: tests>>=
  subroutine commands_23 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    character(256) :: buffer
    logical :: exist
    type(graph_options_t) :: graph_options

    write (u, "(A)")  "* Test output: commands_23"
    write (u, "(A)")  "*   Purpose: write and compile analysis data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create and fill histogram"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call graph_options_init (graph_options)
    call graph_options_set (graph_options, &
         title = var_str ("Histogram for test: commands 23"), &
         description = var_str ("This is a test."), &
         width_mm = 125, height_mm = 85)
    call analysis_init_histogram (var_str ("h"), &
         0._default, 10._default, 2._default, .false., &
         graph_options = graph_options)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 5._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$out_file = "commands_23.dat"')
    call ifile_append (ifile, 'compile_analysis')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Delete Postscript output"
    write (u, "(A)")
    
    inquire (file = "commands_23.ps", exist = exist)
    if (exist) then
       u_file = free_unit ()
       open (u_file, file = "commands_23.ps", action = "write", status = "old")
       close (u_file, status = "delete")
    end if
    inquire (file = "commands_23.ps", exist = exist)
    write (u, "(1x,A,L1)")  "Postcript output exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* TeX file"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "commands_23.tex", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    write (u, *)
    
    inquire (file = "commands_23.ps", exist = exist)
    write (u, "(1x,A,L1)")  "Postcript output exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_23"

  end subroutine commands_23

@ %def commands_23
@
\subsubsection{Histogram}
Declare a histogram, fill it and display.
<<Commands: execute tests>>=
  call test (commands_24, "commands_24", &
       "drawing options", &
       u, results)
<<Commands: tests>>=
  subroutine commands_24 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_24"
    write (u, "(A)")  "*   Purpose: check graph and drawing options"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$title = "Title"')
    call ifile_append (ifile, '$description = "Description"')
    call ifile_append (ifile, '$x_label = "X Label"')
    call ifile_append (ifile, '$y_label = "Y Label"')
    call ifile_append (ifile, 'graph_width_mm = 111')
    call ifile_append (ifile, 'graph_height_mm = 222')
    call ifile_append (ifile, 'x_min = -11')
    call ifile_append (ifile, 'x_max = 22')
    call ifile_append (ifile, 'y_min = -33')
    call ifile_append (ifile, 'y_max = 44')
    call ifile_append (ifile, '$gmlcode_bg = "GML Code BG"')
    call ifile_append (ifile, '$gmlcode_fg = "GML Code FG"')
    call ifile_append (ifile, '$fill_options = "Fill Options"')
    call ifile_append (ifile, '$draw_options = "Draw Options"')
    call ifile_append (ifile, '$err_options = "Error Options"')
    call ifile_append (ifile, '$symbol = "Symbol"')
    call ifile_append (ifile, 'histogram foo (0,1)')
    call ifile_append (ifile, 'plot bar')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_24"

  end subroutine commands_24

@ %def commands_24
@
\subsubsection{Local Environment}
Declare a local environment.
<<Commands: execute tests>>=
  call test (commands_25, "commands_25", &
       "local process environment", &
       u, results)
<<Commands: tests>>=
  subroutine commands_25 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_25"
    write (u, "(A)")  "*   Purpose: declare local environment for process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_cmd_list_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'library = "commands_25_lib"')
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_25_p1 = g, g => g, g &
         &{ model = "QCD" }')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)
    call global%write_libraries (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_25"

  end subroutine commands_25

@ %def commands_25
@
\subsubsection{Alternative Setups}
Declare a list of alternative setups.
<<Commands: execute tests>>=
  call test (commands_26, "commands_26", &
       "alternative setups", &
       u, results)
<<Commands: tests>>=
  subroutine commands_26 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_26"
    write (u, "(A)")  "*   Purpose: declare alternative setups for simulation"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'int i = 0')
    call ifile_append (ifile, 'alt_setup = ({ i = 1 }, { i = 2 })')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_26"

  end subroutine commands_26

@ %def commands_26
@
\subsubsection{Unstable Particle}
Define decay processes and declare a particle as unstable.  Also check
the commands stable, polarized, unpolarized.
<<Commands: execute tests>>=
  call test (commands_27, "commands_27", &
       "unstable and polarized particles", &
       u, results)
<<Commands: tests>>=
  subroutine commands_27 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_27"
    write (u, "(A)")  "*   Purpose: modify particle properties"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    allocate (lib)
    call lib%init (var_str ("commands_27_lib"))
    call global%add_prclib (lib)

    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'ff = 0.4')
    call ifile_append (ifile, 'process d1 = s => f, fbar')
    call ifile_append (ifile, 'unstable s (d1)')
    call ifile_append (ifile, 'polarized f, fbar')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, '?diagonal_decay = true')
    call ifile_append (ifile, 'unstable s (d1)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, '?isotropic_decay = true')
    call ifile_append (ifile, 'unstable s (d1)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, 'stable s')
    call ifile_append (ifile, 'unpolarized f')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_model_file_init ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_27"

  end subroutine commands_27

@ %def commands_27
@ 
\subsubsection{Quit the program}
Quit the program.
<<Commands: execute tests>>=
  call test (commands_28, "commands_28", &
       "quit", &
       u, results)
<<Commands: tests>>=
  subroutine commands_28 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root1, pn_root2
    type(string_t), dimension(0) :: no_vars

    write (u, "(A)")  "* Test output: commands_28"
    write (u, "(A)")  "*   Purpose: quit the program"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()    
    
    write (u, "(A)")  "*  Input file: quit without code"
    write (u, "(A)")
    
    call ifile_append (ifile, 'quit')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root1, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root1, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "*  Input file: quit with code"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call command_list%final ()
    call ifile_append (ifile, 'quit ( 3 + 4 )')        
   
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root2, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root2, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_28"

  end subroutine commands_28

@ %def commands_28
@
@ 
\subsubsection{SLHA interface}
Testing commands steering the SLHA interface.
<<Commands: execute tests>>=
  call test (commands_29, "commands_29", &
       "SLHA interface", &
       u, results)
<<Commands: tests>>=
  subroutine commands_29 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_29"
    write (u, "(A)")  "*   Purpose: test SLHA interface"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call syntax_slha_init ()
    call global%global_init ()
    
    write (u, "(A)")  "*  Model MSSM, read SLHA file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "MSSM"')
    call ifile_append (ifile, '?slha_read_decays = true')    
    call ifile_append (ifile, 'read_slha ("sps1ap_decays.slha")')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)
           
    write (u, "(A)")
    write (u, "(A)")  "* Model MSSM, default values:"
    write (u, "(A)")    
        
    call global%model%write (u, verbose = .false., &
         show_vertices = .false., show_particles = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Selected global variables"
    write (u, "(A)")

    call var_list_write_var (global%var_list, var_str ("mch1"), u)
    call var_list_write_var (global%var_list, var_str ("wch1"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Model MSSM, values from SLHA file"
    write (u, "(A)")
        
    call global%model%write (u, verbose = .false., &
         show_vertices = .false., show_particles = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Selected global variables"
    write (u, "(A)")

    call var_list_write_var (global%var_list, var_str ("mch1"), u)
    call var_list_write_var (global%var_list, var_str ("wch1"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_slha_final ()
    call syntax_model_file_final ()
    call syntax_cmd_list_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_29"

  end subroutine commands_29

@ %def commands_29
@
\subsubsection{Expressions for scales}
Declare a scale, factorization scale or factorization scale expression.
<<Commands: execute tests>>=
  call test (commands_30, "commands_30", &
       "scales", &
       u, results)
<<Commands: tests>>=
  subroutine commands_30 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_30"
    write (u, "(A)")  "*   Purpose: define scales"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'scale = 200 GeV')
    call ifile_append (ifile, &
         'factorization_scale = eval Pt [particle]')
    call ifile_append (ifile, &
         'renormalization_scale = eval E [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_30"

  end subroutine commands_30

@ %def commands_30
@
\subsubsection{Weight and reweight expressions}
Declare an expression for event weights and reweighting.
<<Commands: execute tests>>=
  call test (commands_31, "commands_31", &
       "event weights/reweighting", &
       u, results)
<<Commands: tests>>=
  subroutine commands_31 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_31"
    write (u, "(A)")  "*   Purpose: define weight/reweight"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'weight = eval Pz [particle]')
    call ifile_append (ifile, 'reweight = eval M2 [particle]')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_31"

  end subroutine commands_31

@ %def commands_31
@
\subsubsection{Selecting events}
Declare an expression for selecting events in an analysis.
<<Commands: execute tests>>=
  call test (commands_32, "commands_32", &
       "event selection", &
       u, results)
<<Commands: tests>>=
  subroutine commands_32 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_32"
    write (u, "(A)")  "*   Purpose: define selection"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'selection = any PDG == 13 [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_32"

  end subroutine commands_32

@ %def commands_32
@
\subsubsection{Executing shell commands}
Execute a shell command.
<<Commands: execute tests>>=
  call test (commands_33, "commands_33", &
       "execute shell command", &
       u, results)
<<Commands: tests>>=
  subroutine commands_33 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    character(3) :: buffer

    write (u, "(A)")  "* Test output: commands_33"
    write (u, "(A)")  "*   Purpose: execute shell command"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'exec ("echo foo >> bar")')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)
    u_file = free_unit ()
    open (u_file, file = "bar", &
         action = "read", status = "old")
    do 
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0) exit        
    end do
    write (u, "(A,A)")  "should be 'foo': ", trim (buffer)           
    close (u_file)
        
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_33"

  end subroutine commands_33

@ %def commands_33
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Toplevel module WHIZARD}
<<[[whizard.f90]]>>=
<<File header>>

module whizard

  use io_units
<<Use strings>>
  use unit_tests
  use system_defs, only: VERSION_STRING
  use system_defs, only: EOF, BACKSLASH
  use diagnostics
  use os_interface
  use formats
  use md5
  use sorting
  use cputime
  use sm_qcd
  use ifiles
  use lexers
  use parser
  use xml
  use colors
  use state_matrices
  use analysis
  use variables
  use user_code_interface
  use eval_trees
  use particles
  use models
  use auto_components
  use evaluators
  use phs_forests
  use beams
  use polarizations
  use sf_aux
  use sf_mappings
  use sf_base
  use sf_pdf_builtin
  use sf_lhapdf
  use sf_circe1
  use sf_circe2
  use sf_isr
  use sf_epa
  use sf_ewa
  use sf_escan
  use sf_beam_events
  use sf_user
  use phs_base
  use phs_single
  use phs_wood
  use rng_base
  use rng_tao
  use selectors
  use mci_base
  use mci_midpoint
  use mci_vamp
  use prclib_interfaces
  use particle_specifiers
  use process_libraries
  use prclib_stacks
  use hepmc_interface
  use jets
  use pdg_arrays
  use interactions
  use slha_interface
  use cascades
  use blha_driver
  use blha_config
  use prc_test
  use prc_template_me
  use prc_omega
  use subevt_expr
  use processes
  use process_stacks
  use event_transforms
  use decays
  use shower
  use events

  use eio_data
  use eio_base
  use eio_raw
  use eio_checkpoints
  use eio_lhef
  use eio_hepmc
  use eio_lcio
  use eio_stdhep
  use eio_ascii
  use eio_weights

  use iterations
  use beam_structures
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams
  use simulations
  use fks_calculation

  use expr_tests

  use commands

<<Standard module head>>

<<WHIZARD: public>>

<<WHIZARD: types>>

  save

contains

<<WHIZARD: procedures>>

end module whizard
@ %def whizard
@
\subsection{Options}
Here we introduce a wrapper that holds various user options, so they
can transparently be passed from the main program to the [[whizard]]
object.  Most parameters are used for initializing the [[global]]
state.
<<WHIZARD: public>>=
  public :: whizard_options_t
<<WHIZARD: types>>=
  type :: whizard_options_t
     type(string_t) :: preload_model
     type(string_t) :: default_lib
     type(string_t) :: preload_libraries
     logical :: rebuild_library = .false.
     logical :: recompile_library = .false.
     logical :: rebuild_user
     logical :: rebuild_phs = .false.
     logical :: rebuild_grids = .false.
     logical :: rebuild_events = .false.
  end type whizard_options_t
  
@ %def whizard_options_t
@
\subsection{Parse tree stack}
We collect all parse trees that we generate in the [[whizard]] object.  To
this end, we create a stack of parse trees.  They must not be finalized before
the [[global]] object is finalized, because items such as a cut definition may
contain references to the parse tree from which they were generated.
<<WHIZARD: types>>=
  type, extends (parse_tree_t) :: pt_entry_t
     type(pt_entry_t), pointer :: previous => null ()
  end type pt_entry_t
  
@ %def pt_entry_t
@ This is the stack.  Since we always prepend, we just need the [[last]]
pointer.
<<WHIZARD: types>>=
  type :: pt_stack_t
     type(pt_entry_t), pointer :: last => null ()
   contains
   <<WHIZARD: pt stack: TBP>>
  end type pt_stack_t
  
@ %def pt_stack_t
@ The finalizer is called at the very end.
<<WHIZARD: pt stack: TBP>>=
  procedure :: final => pt_stack_final
<<WHIZARD: procedures>>=
  subroutine pt_stack_final (pt_stack)
    class(pt_stack_t), intent(inout) :: pt_stack
    type(pt_entry_t), pointer :: current
    do while (associated (pt_stack%last))
       current => pt_stack%last
       pt_stack%last => current%previous
       call parse_tree_final (current%parse_tree_t)
       deallocate (current)
    end do
  end subroutine pt_stack_final

@ %def pt_stack_final
@ Create and push a new entry, keeping the previous ones.
<<WHIZARD: pt stack: TBP>>=
  procedure :: push => pt_stack_push
<<WHIZARD: procedures>>=
  subroutine pt_stack_push (pt_stack, parse_tree)
    class(pt_stack_t), intent(inout) :: pt_stack
    type(parse_tree_t), intent(out), pointer :: parse_tree
    type(pt_entry_t), pointer :: current
    allocate (current)
    parse_tree => current%parse_tree_t
    current%previous => pt_stack%last
    pt_stack%last => current
  end subroutine pt_stack_push
  
@ %def pt_stack_push
@
\subsection{The [[whizard]] object}
An object of type [[whizard_t]] is the top-level wrapper for a
\whizard\ instance.  The object holds various default
settings and the current state of the generator, the [[global]] object
of type [[rt_data_t]].  This object contains, for instance, the list
of variables and the process libraries.

Since components of the [[global]] subobject are frequently used as
targets, the [[whizard]] object should also consistently carry the
[[target]] attribute.

The various self-tests do no not use this object.  They initialize
only specific subsets of the system, according to their needs.

Note: we intend to allow several concurrent instances.  In the current
implementation, there are still a few obstacles to this: the model
library and the syntax tables are global variables, and the error
handling uses global state.  This should be improved.
<<WHIZARD: public>>=
  public :: whizard_t
<<WHIZARD: types>>=
  type :: whizard_t
     type(whizard_options_t) :: options
     type(rt_data_t) :: global
     type(pt_stack_t) :: pt_stack
   contains
   <<WHIZARD: whizard: TBP>>
  end type whizard_t
  
@ %def whizard_t
@ 
\subsection{Initialization and finalization}
<<WHIZARD: whizard: TBP>>=
  procedure :: init => whizard_init
<<WHIZARD: procedures>>=
  subroutine whizard_init (whizard, options, paths, logfile)
    class(whizard_t), intent(out), target :: whizard
    type(whizard_options_t), intent(in) :: options    
    type(paths_t), intent(in), optional :: paths
    type(string_t), intent(in), optional :: logfile
    call init_syntax_tables ()
    whizard%options = options
    call whizard%global%global_init (paths, logfile)
    call whizard%init_rebuild_flags ()
    call whizard%preload_model ()
    call whizard%preload_library ()
    call whizard%global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
  end subroutine whizard_init
  
@ %def whizard_init
@ Apart from the global data which have been initialized above, the
process and model lists need to be finalized.
<<WHIZARD: whizard: TBP>>=
  procedure :: final => whizard_final
<<WHIZARD: procedures>>=
  subroutine whizard_final (whizard)
    class(whizard_t), intent(inout), target :: whizard
    call whizard%global%final ()
    call whizard%pt_stack%final ()
!!! JRR: WK please check (#529)
    !    call user_code_final ()
    call final_syntax_tables () 
  end subroutine whizard_final
  
@ %def whizard_final
@
Set the rebuild flags.  They can be specified on the command line and
set the initial value for the associated logical variables.
<<WHIZARD: whizard: TBP>>=
  procedure :: init_rebuild_flags => whizard_init_rebuild_flags
<<WHIZARD: procedures>>=
  subroutine whizard_init_rebuild_flags (whizard)
    class(whizard_t), intent(inout), target :: whizard
    associate (var_list => whizard%global%var_list, options => whizard%options) 
      call var_list_append_log &
           (var_list, var_str ("?rebuild_library"), options%rebuild_library, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?recompile_library"), &
           options%recompile_library, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_phase_space"), options%rebuild_phs, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_grids"), options%rebuild_grids, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_events"), options%rebuild_events, &
           intrinsic=.true.)
    end associate
  end subroutine whizard_init_rebuild_flags

@ %def whizard_init_rebuild_flags
@
This procedure preloads a model, if a model name is given.
<<WHIZARD: whizard: TBP>>=
  procedure :: preload_model => whizard_preload_model
<<WHIZARD: procedures>>=
  subroutine whizard_preload_model (whizard)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t) :: model_name, filename
    model_name = whizard%options%preload_model
    if (model_name /= "") then
       filename = model_name // ".mdl"
       call whizard%global%read_model (model_name, filename)
       if (associated (whizard%global%model)) then
          call msg_message ("Preloaded model: " &
               // char (model_name))
       else
          call msg_fatal ("Preloading model " // char (model_name) &
               // " failed")
       end if
    else
       call msg_message ("No model preloaded")
    end if
  end subroutine whizard_preload_model
    
@ %def whizard_preload_model
@
This procedure preloads a library, if a library name is given.

Note: This version just opens a new library with that name.  It does not load
(yet) an existing library on file, as previous \whizard\ versions would do.
<<WHIZARD: whizard: TBP>>=
  procedure :: preload_library => whizard_preload_library
<<WHIZARD: procedures>>=
  subroutine whizard_preload_library (whizard)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t) :: library_name, libs
    type(string_t), dimension(:), allocatable :: libname_static
    type(prclib_entry_t), pointer :: lib_entry
    integer :: i
    call get_prclib_static (libname_static)
    do i = 1, size (libname_static)
       allocate (lib_entry)
       call lib_entry%init_static (libname_static(i))
       call whizard%global%add_prclib (lib_entry)
    end do
    libs = adjustl (whizard%options%preload_libraries)
    if (libs == "" .and. whizard%options%default_lib /= "") then
          allocate (lib_entry)
          call lib_entry%init (whizard%options%default_lib)
          call whizard%global%add_prclib (lib_entry)
          call msg_message ("Preloaded library: " // &
               char (whizard%options%default_lib))    
       end if    
    SCAN_LIBS: do while (libs /= "")
       call split (libs, library_name, " ")      
       if (library_name /= "") then
          allocate (lib_entry)
          call lib_entry%init (library_name)
          call whizard%global%add_prclib (lib_entry)
          call msg_message ("Preloaded library: " // char (library_name))
       end if
    end do SCAN_LIBS    
  end subroutine whizard_preload_library
    
@ %def whizard_preload_library
@ 
\subsection{Initialization and finalization (old version)}
These procedures initialize and finalize global variables.  Most of
them are collected in the [[global]] data record located here, the
others are syntax tables located in various modules, which do not
change during program execution.  Furthermore, there is a global model
list and a global process store, which get filled during program
execution but are finalized here.

During initialization, we can preload a default model and initialize a
default library for setting up processes.  The default library is
loaded if requested by the setup.  Further libraries can be loaded as
specified by command-line flags.
@ Initialize/finalize the syntax tables used by WHIZARD:
<<WHIZARD: public>>=
  public :: init_syntax_tables
  public :: final_syntax_tables
<<WHIZARD: procedures>>=
  subroutine init_syntax_tables ()
    call syntax_model_file_init ()
    call syntax_phs_forest_init ()
    call syntax_pexpr_init ()
    call syntax_slha_init ()
    call syntax_blha_contract_init ()    
    call syntax_cmd_list_init ()
  end subroutine init_syntax_tables

  subroutine final_syntax_tables ()
    call syntax_model_file_final ()
    call syntax_phs_forest_final ()
    call syntax_pexpr_final ()
    call syntax_slha_final ()
    call syntax_blha_contract_final ()    
    call syntax_cmd_list_final ()
  end subroutine final_syntax_tables

@ %def init_syntax_tables
@ %def final_syntax_tables
@ Write the syntax tables to external files.
<<WHIZARD: public>>=
  public :: write_syntax_tables
<<WHIZARD: procedures>>=
  subroutine write_syntax_tables ()
    integer :: unit
    character(*), parameter :: file_model = "whizard.model_file.syntax"
    character(*), parameter :: file_phs = "whizard.phase_space_file.syntax"
    character(*), parameter :: file_pexpr = "whizard.prt_expressions.syntax"
    character(*), parameter :: file_slha = "whizard.slha.syntax"
    character(*), parameter :: file_sindarin = "whizard.sindarin.syntax"
    unit = free_unit ()
    print *, "Writing file '" // file_model // "'"
    open (unit=unit, file=file_model, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_model
    call syntax_model_file_write (unit)
    close (unit)
    print *, "Writing file '" // file_phs // "'"
    open (unit=unit, file=file_phs, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_phs
    call syntax_phs_forest_write (unit)
    close (unit)
    print *, "Writing file '" // file_pexpr // "'"
    open (unit=unit, file=file_pexpr, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_pexpr
    call syntax_pexpr_write (unit)
    close (unit)
    print *, "Writing file '" // file_slha // "'"
    open (unit=unit, file=file_slha, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_slha
    call syntax_slha_write (unit)
    close (unit)
    print *, "Writing file '" // file_sindarin // "'"
    open (unit=unit, file=file_sindarin, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_sindarin
    call syntax_cmd_list_write (unit)
    close (unit)
  end subroutine write_syntax_tables

@ %def write_syntax_tables
@ 
\subsection{Execute command lists}
Process commands given on the command line, stored as an [[ifile]].  The whole
input is read, compiled and executed as a whole.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_ifile => whizard_process_ifile
<<WHIZARD: procedures>>=
  subroutine whizard_process_ifile (whizard, ifile, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(ifile_t), intent(in) :: ifile
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    call msg_message ("Reading commands given on the command line")
    call lexer_init_cmd_list (lexer)
    call stream_init (stream, ifile)
    call whizard%process_stream (stream, lexer, quit, quit_code)
    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine whizard_process_ifile

@ %def whizard_process_ifile
@ Process standard input as a command list.  The whole input is read,
compiled and executed as a whole.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_stdin => whizard_process_stdin
<<WHIZARD: procedures>>=
  subroutine whizard_process_stdin (whizard, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    call msg_message ("Reading commands from standard input")
    call lexer_init_cmd_list (lexer)
    call stream_init (stream, 5)
    call whizard%process_stream (stream, lexer, quit, quit_code)
    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine whizard_process_stdin

@ %def whizard_process_stdin
@ Process a file as a command list.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_file => whizard_process_file
<<WHIZARD: procedures>>=
  subroutine whizard_process_file (whizard, file, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t), intent(in) :: file
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    logical :: exist
    call msg_message ("Reading commands from file '" // char (file) // "'")
    inquire (file=char(file), exist=exist)
    if (exist) then
       call lexer_init_cmd_list (lexer)
       call stream_init (stream, char (file))
       call whizard%process_stream (stream, lexer, quit, quit_code)
       call stream_final (stream)
       call lexer_final (lexer)
    else
       call msg_error ("File '" // char (file) // "' not found")
    end if
  end subroutine whizard_process_file

@ %def whizard_process_file
@
<<WHIZARD: whizard: TBP>>=
  procedure :: process_stream => whizard_process_stream
<<WHIZARD: procedures>>=
  subroutine whizard_process_stream (whizard, stream, lexer, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(stream_t), intent(inout), target :: stream
    type(lexer_t), intent(inout), target :: lexer
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(parse_tree_t), pointer :: parse_tree
    type(command_list_t), target :: command_list
    call lexer_assign_stream (lexer, stream)
    call whizard%pt_stack%push (parse_tree)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    if (associated (parse_tree_get_root_ptr (parse_tree))) then
       whizard%global%lexer => lexer
       call command_list%compile (parse_tree_get_root_ptr (parse_tree), &
            whizard%global)
    end if
    call command_list%execute (whizard%global)
    call command_list%final ()
    quit = whizard%global%quit
    quit_code = whizard%global%quit_code
  end subroutine whizard_process_stream

@ %def whizard_process_stream
@ 
\subsection{The WHIZARD shell}
This procedure implements interactive mode.  One line is processed at
a time.
<<WHIZARD: whizard: TBP>>=
  procedure :: shell => whizard_shell
<<WHIZARD: procedures>>=
  subroutine whizard_shell (whizard, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    type(string_t) :: prompt1
    type(string_t) :: prompt2
    type(string_t) :: input
    type(string_t) :: extra
    integer :: last
    integer :: iostat
    logical :: mask_tmp
    logical :: quit
    call msg_message ("Launching interactive shell")
    call lexer_init_cmd_list (lexer)
    prompt1 = "whish? "
    prompt2 = "     > "
    COMMAND_LOOP: do
       call put (6, prompt1)
       call get (5, input, iostat=iostat)
       if (iostat > 0 .or. iostat == EOF) exit COMMAND_LOOP
       CONTINUE_INPUT: do
          last = len_trim (input)
          if (extract (input, last, last) /= BACKSLASH)  exit CONTINUE_INPUT
          call put (6, prompt2)
          call get (5, extra, iostat=iostat)
          if (iostat > 0) exit COMMAND_LOOP
          input = replace (input, last, extra)
       end do CONTINUE_INPUT
       call stream_init (stream, input)
       mask_tmp = mask_fatal_errors
       mask_fatal_errors = .true.
       call whizard%process_stream (stream, lexer, quit, quit_code)
       msg_count = 0
       mask_fatal_errors = mask_tmp
       call stream_final (stream)
       if (quit)  exit COMMAND_LOOP
    end do COMMAND_LOOP
    print *
    call lexer_final (lexer)
  end subroutine whizard_shell

@ %def whizard_shell
@ 
\subsection{Self-tests}
This is for developers only, but needs a well-defined interface.
<<WHIZARD: public>>=
  public :: whizard_check
<<WHIZARD: procedures>>=
  subroutine whizard_check (check, results)
    type(string_t), intent(in) :: check
    type(test_results_t), intent(inout) :: results
    type(os_data_t) :: os_data
    integer :: u
    call os_data_init (os_data)
    u = free_unit ()
    open (u, file="whizard_check." // char (check) // ".log", &
         action="write", status="replace")
    call msg_message (repeat ('=', 76), 0)
    call msg_message ("Running self-test: " // char (check), 0)
    call msg_message (repeat ('-', 76), 0)
    select case (char (check))
    case ("analysis")
       call analysis_test (u, results)
    case ("beams")
       call beam_test (u, results)
    case ("cascades")
       call cascade_test (u, results)
    case ("colors")
       call color_test (u, results)
    case ("evaluators")
      call evaluator_test (u, results)
    case ("expressions")
       call expressions_test (u, results)
    case ("formats")
       call format_test (u, results)
    case ("hepmc")
       call hepmc_test (u, results)
    case ("jets")
       call jets_test (u, results)
    case ("pdg_arrays")
       call pdg_arrays_test (u, results)
    case ("interactions")
       call interaction_test (u, results)
    case ("lexers")
       call lexer_test (u, results)
    case ("os_interface") 
       call os_interface_test (u, results)
    case ("cputime") 
       call cputime_test (u, results)
    case ("parser")
       call parse_test (u, results)       
    case ("sorting")
       call sorting_test (u, results)
    case ("md5")       
       call md5_test (u, results)       
    case ("xml")
       call xml_test (u, results)
    case ("sm_qcd")
       call sm_qcd_test (u, results)
    case ("models")
       call models_test (u, results)
    case ("auto_components")
       call auto_components_test (u, results)
    case ("particles")
       call particles_test (u, results)
    case ("polarizations")
       call polarization_test (u, results)
    case ("sf_aux")
       call sf_aux_test (u, results)
    case ("sf_mappings")
       call sf_mappings_test (u, results)
    case ("sf_base")
       call sf_base_test (u, results)
    case ("sf_pdf_builtin")
       call sf_pdf_builtin_test (u, results)
    case ("sf_lhapdf")
       call sf_lhapdf_test (u, results)
    case ("sf_isr")
       call sf_isr_test (u, results)
    case ("sf_epa")
       call sf_epa_test (u, results)
    case ("sf_ewa")
       call sf_ewa_test (u, results)
    case ("sf_circe1")
       call sf_circe1_test (u, results)
    case ("sf_circe2")
       call sf_circe2_test (u, results)
    case ("sf_beam_events")
       call sf_beam_events_test (u, results)
    case ("sf_escan")
       call sf_escan_test (u, results)
    case ("phs_base")
       call phs_base_test (u, results)
    case ("phs_single")
       call phs_single_test (u, results)
    case ("phs_forests")
       call phs_forest_test (u, results)       
    case ("phs_wood")
       call phs_wood_test (u, results)
    case ("phs_wood_vis")
       call phs_wood_vis_test (u, results)
    case ("mci_base")
       call mci_base_test (u, results)
    case ("rng_base")
       call rng_base_test (u, results)
    case ("rng_tao")
       call rng_tao_test (u, results)
    case ("selectors")
       call selectors_test (u, results)
    case ("mci_midpoint")
       call mci_midpoint_test (u, results)
    case ("mci_vamp")
       call mci_vamp_test (u, results)
    case ("prclib_interfaces")
       call prclib_interfaces_test (u, results)
    case ("particle_specifiers")
       call particle_specifiers_test (u, results)
    case ("process_libraries")
       call process_libraries_test (u, results)
    case ("prclib_stacks")
       call prclib_stacks_test (u, results)
    case ("slha_interface")
       call slha_test (u, results)
    case ("state_matrices")
       call state_matrix_test (u, results)
    case ("prc_test")
       call prc_test_test (u, results)
    case ("subevt_expr")
       call subevt_expr_test (u, results)
    case ("processes")
       call processes_test (u, results)       
    case ("process_stacks")
       call process_stacks_test (u, results)   
    case ("fks_calculation")
       call fks_calculation_test (u, results)    
    case ("event_transforms")
       call event_transforms_test (u, results)       
    case ("decays")
       call decays_test (u, results)       
    case ("shower")
       call shower_test (u, results)       
    case ("events")
       call events_test (u, results)
    case ("prc_template_me")
       call prc_template_me_test (u, results)              
    case ("prc_omega")
       call prc_omega_test (u, results)
    case ("prc_omega_diags")
       call prc_omega_diags_test (u, results)       
    case ("eio_data")
       call eio_data_test (u, results)
    case ("eio_base")
       call eio_base_test (u, results)
    case ("eio_raw")
       call eio_raw_test (u, results)
    case ("eio_checkpoints")
       call eio_checkpoints_test (u, results)
    case ("eio_lhef")
       call eio_lhef_test (u, results)
    case ("eio_hepmc")
       call eio_hepmc_test (u, results)
    case ("eio_lcio")
       call eio_lcio_test (u, results)
    case ("eio_stdhep")
       call eio_stdhep_test (u, results)
    case ("eio_ascii")
       call eio_ascii_test (u, results)       
    case ("eio_weights")
       call eio_weights_test (u, results)
    case ("iterations")
       call iterations_test (u, results)
    case ("beam_structures")
       call beam_structures_test (u, results)
    case ("rt_data")
       call rt_data_test (u, results)
    case ("dispatch")
       call dispatch_test (u, results)
    case ("process_configurations")
       call process_configurations_test (u, results)
    case ("compilations")
       call compilations_test (u, results)
    case ("compilations_static")
       call compilations_static_test (u, results)
    case ("integrations")
       call integrations_test (u, results)
    case ("integrations_history")
       call integrations_history_test (u, results)
    case ("event_streams")
       call event_streams_test (u, results)
    case ("simulations")
       call simulations_test (u, results)
    case ("commands")
       call commands_test (u, results)
    case ("all")
       call analysis_test (u, results)
       call beam_test (u, results)
       call md5_test (u, results)
       call lexer_test (u, results)
       call sorting_test (u, results)
       call parse_test (u, results)
       call color_test (u, results)
       call evaluator_test (u, results)
       call expressions_test (u, results)
       call format_test (u, results)
       call hepmc_test (u, results)
       call jets_test (u, results)
       call os_interface_test (u, results)
       call cputime_test (u, results)
       call interaction_test (u, results)
       call xml_test (u, results)
       call sm_qcd_test (u, results)
       call models_test (u, results)
       call auto_components_test (u, results)
       call particles_test (u, results)
       call polarization_test (u, results)
       call sf_aux_test (u, results)
       call sf_mappings_test (u, results)
       call sf_base_test (u, results)
       call sf_pdf_builtin_test (u, results)
       call sf_lhapdf_test (u, results)
       call sf_isr_test (u, results)
       call sf_epa_test (u, results)
       call sf_ewa_test (u, results)
       call sf_circe1_test (u, results)
       call sf_circe2_test (u, results)
       call sf_beam_events_test (u, results)
       call sf_escan_test (u, results)
       call phs_base_test (u, results)
       call phs_single_test (u, results)
       call phs_forest_test (u, results)
       call phs_wood_test (u, results)
       call phs_wood_vis_test (u, results)
       call rng_base_test (u, results)
       call cascade_test (u, results)
       call rng_tao_test (u, results)
       call selectors_test (u, results)
       call mci_base_test (u, results)
       call mci_midpoint_test (u, results)
       call mci_vamp_test (u, results)
       call prclib_interfaces_test (u, results)
       call particle_specifiers_test (u, results)
       call process_libraries_test (u, results)
       call prclib_stacks_test (u, results)
       call slha_test (u, results)
       call state_matrix_test (u, results)
       call prc_test_test (u, results)
       call subevt_expr_test (u, results)
       call processes_test (u, results)
       call process_stacks_test (u, results)   
       call fks_calculation_test (u, results)    
       call event_transforms_test (u, results)
       call decays_test (u, results)
       call shower_test (u, results)
       call events_test (u, results)
       call prc_omega_test (u, results)
       call prc_omega_diags_test (u, results)
       call prc_template_me_test (u, results)
       call eio_data_test (u, results)
       call eio_base_test (u, results)
       call eio_raw_test (u, results)
       call eio_checkpoints_test (u, results)
       call eio_lhef_test (u, results)
       call eio_hepmc_test (u, results)
       call eio_lcio_test (u, results)
       call eio_stdhep_test (u, results)
       call eio_ascii_test (u, results)
       call eio_weights_test (u, results)
       call iterations_test (u, results)
       call beam_structures_test (u, results)
       call rt_data_test (u, results)
       call dispatch_test (u, results)
       call process_configurations_test (u, results)
       call compilations_test (u, results)
       call compilations_static_test (u, results)
       call integrations_test (u, results)
       call integrations_history_test (u, results)       
       call event_streams_test (u, results)
       call simulations_test (u, results)
       call commands_test (u, results)
    case default
       call msg_fatal ("Self-test '" // char (check) // "' not implemented.")
    end select
    close (u)
  end subroutine whizard_check

@ %def whizard_check
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Driver program}
The main program handles command options, initializes the environment,
and runs WHIZARD in a particular mode (interactive, file, standard
input).

This is also used in the C interface:
<<Main: cmdline arg len declaration>>=
  integer, parameter :: CMDLINE_ARG_LEN = 1000
@ %def CMDLINE_ARG_LEN
@ 
The actual main program:
<<[[main.f90]]>>=
<<File header>>

program main

<<Use strings>>
  use unit_tests
  use system_dependencies
  use diagnostics
  use ifiles
  use os_interface
  use whizard

  implicit none

<<Main: cmdline arg len declaration>>

  ! Main program variable declarations
  character(CMDLINE_ARG_LEN) :: arg
  character(2) :: option
  type(string_t) :: long_option, value
  integer :: i, j, arg_len, arg_status
  logical :: look_for_options
  logical :: interactive
  logical :: banner
  type(string_t) :: files, this, model, default_lib, library, libraries
  type(string_t) :: check, checks, logfile
  type(test_results_t) :: test_results
  logical :: success
  logical :: user_code_enable = .false.
  integer :: n_user_src = 0, n_user_lib = 0
  type(string_t) :: user_src, user_lib, user_target
  type(paths_t) :: paths
  logical :: rebuild_library, rebuild_user
  logical :: rebuild_phs, rebuild_grids, rebuild_events
  logical :: recompile_library
  type(ifile_t) :: commands
  type(string_t) :: command

  type(whizard_options_t), allocatable :: options
  type(whizard_t), allocatable, target :: whizard_instance

  ! Exit status
  logical :: quit = .false.
  integer :: quit_code = 0

  ! Initial values
  look_for_options = .true.
  interactive = .false.
  files = ""
  model = "SM"
  default_lib = "default_lib"
  library = ""
  libraries = ""  
  banner = .true.
  logging = .true.
  logfile = "whizard.log"
  check = ""
  checks = ""
  user_src = ""
  user_lib = ""
  user_target = ""
  rebuild_library = .false.
  rebuild_user = .false.
  rebuild_phs = .false.
  rebuild_grids = .false.
  rebuild_events = .false.
  recompile_library = .false.
  call paths_init (paths)

  ! Read and process options
  i = 0
  SCAN_CMDLINE: do
     i = i + 1
     call get_command_argument (i, arg, arg_len, arg_status)
     select case (arg_status)
     case (0)
     case (-1)
        call msg_error (" Command argument truncated: '" // arg // "'")
     case default
        exit SCAN_CMDLINE
     end select
     if (look_for_options) then
        select case (arg(1:2))
        case ("--")
           value = trim (arg)
           call split (value, long_option, "=")
           select case (char (long_option))
           case ("--version")
              call no_option_value (long_option, value)
              call print_version (); stop
           case ("--help")
              call no_option_value (long_option, value)
              call print_usage (); stop
           case ("--prefix")
              paths%prefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--exec-prefix")
              paths%exec_prefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--bindir")
              paths%bindir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--libdir")
              paths%libdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--includedir")
              paths%includedir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--datarootdir")
              paths%datarootdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--libtool")
              paths%libtool = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--lhapdfdir")
              paths%lhapdfdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--check")
              check = get_option_value (i, long_option, value)
              checks = checks // " " // check
              cycle SCAN_CMDLINE
           case ("--execute")
              command = get_option_value (i, long_option, value)
	      call ifile_append (commands, command)
              cycle SCAN_CMDLINE
           case ("--interactive")
              call no_option_value (long_option, value)
              interactive = .true.
              cycle SCAN_CMDLINE
           case ("--library")
              library = get_option_value (i, long_option, value)
              libraries = libraries // " " // library
              cycle SCAN_CMDLINE
           case ("--no-library")
              call no_option_value (long_option, value)
              default_lib = ""
              library = ""              
              libraries = ""
              cycle SCAN_CMDLINE
           case ("--localprefix")
              paths%localprefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--logfile")
              logfile = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--no-logfile")
              call no_option_value (long_option, value)
              logfile = ""
              cycle SCAN_CMDLINE
           case ("--logging")
              call no_option_value (long_option, value)
              logging = .true.
              cycle SCAN_CMDLINE
           case ("--no-logging")
              call no_option_value (long_option, value)
              logging = .false.
              cycle SCAN_CMDLINE
           case ("--banner")
              call no_option_value (long_option, value)
              banner = .true.
              cycle SCAN_CMDLINE
           case ("--no-banner")
              call no_option_value (long_option, value)
              banner = .false.
              cycle SCAN_CMDLINE
           case ("--model")
              model = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--no-model")
              call no_option_value (long_option, value)
              model = ""
              cycle SCAN_CMDLINE
           case ("--rebuild")
              call no_option_value (long_option, value)
              rebuild_library = .true.
              rebuild_user = .true.
              rebuild_phs = .true.
              rebuild_grids = .true.
              rebuild_events = .true.
              cycle SCAN_CMDLINE
           case ("--no-rebuild")
              call no_option_value (long_option, value)
              rebuild_library = .false.
              recompile_library = .false.
              rebuild_user = .false.
              rebuild_phs = .false.
              rebuild_grids = .false.
              rebuild_events = .false.
              cycle SCAN_CMDLINE
           case ("--rebuild-library")
              call no_option_value (long_option, value)
              rebuild_library = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-user")
              call no_option_value (long_option, value)
              rebuild_user = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-phase-space")
              call no_option_value (long_option, value)
              rebuild_phs = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-grids")
              call no_option_value (long_option, value)
              rebuild_grids = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-events")
              call no_option_value (long_option, value)
              rebuild_events = .true.
              cycle SCAN_CMDLINE
           case ("--recompile")
              call no_option_value (long_option, value)
              recompile_library = .true.
	      rebuild_grids = .true.
              cycle SCAN_CMDLINE
           case ("--user")
              user_code_enable = .true.
              cycle SCAN_CMDLINE
           case ("--user-src")
              if (user_src == "") then
                 user_src = get_option_value (i, long_option, value)
              else
                 user_src = user_src // " " &
                      // get_option_value (i, long_option, value)
              end if
              n_user_src = n_user_src + 1
              cycle SCAN_CMDLINE
           case ("--user-lib")
              if (user_lib == "") then
                 user_lib = get_option_value (i, long_option, value)
              else
                 user_lib = user_lib // " " &
                      // get_option_value (i, long_option, value)
              end if
              n_user_lib = n_user_lib + 1
              cycle SCAN_CMDLINE
           case ("--user-target")
              user_target = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--write-syntax-tables")
              call no_option_value (long_option, value)
	      call init_syntax_tables ()
              call write_syntax_tables ()
              call final_syntax_tables ()
              stop
              cycle SCAN_CMDLINE
           case default
              call print_usage ()
              call msg_fatal ("Option '" // trim (arg) // "' not recognized")
           end select
        end select
        select case (arg(1:1))
        case ("-")
           j = 1
           if (len_trim (arg) == 1) then
              look_for_options = .false.
           else
              SCAN_SHORT_OPTIONS: do
                 j = j + 1
                 if (j > len_trim (arg)) exit SCAN_SHORT_OPTIONS
                 option = "-" // arg(j:j)
                 select case (option)
                 case ("-V")
                    call print_version (); stop
                 case ("-?", "-h")
                    call print_usage (); stop
                 case ("-e")
                    command = get_option_value (i, var_str (option))
                    call ifile_append (commands, command)
                    cycle SCAN_CMDLINE
                 case ("-i")
                    interactive = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case ("-l")
                    if (j == len_trim (arg)) then
                       library = get_option_value (i, var_str (option))
                    else
                       library = trim (arg(j+1:))
                    end if
                    libraries = libraries // " " // library                    
                    cycle SCAN_CMDLINE
                 case ("-L")
                    if (j == len_trim (arg)) then
                       logfile = get_option_value (i, var_str (option))
                    else
                       logfile = trim (arg(j+1:))
                    end if
                    cycle SCAN_CMDLINE
                 case ("-m")
                    if (j < len_trim (arg))  call msg_fatal &
                         ("Option '" // option // "' needs a value")
                    model = get_option_value (i, var_str (option))
                    cycle SCAN_CMDLINE
                 case ("-r")
                    rebuild_library = .true.
                    rebuild_user = .true.
                    rebuild_phs = .true.
                    rebuild_grids = .true.
                    rebuild_events = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case ("-u")
                    user_code_enable = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case default
                    call print_usage ()
                    call msg_fatal &
                         ("Option '" // option // "' not recognized")
                 end select
              end do SCAN_SHORT_OPTIONS
           end if
        case default
           files = files // " " // trim (arg)
        end select
     else
        files = files // " " // trim (arg)
     end if
  end do SCAN_CMDLINE

  ! Overall initialization
  if (logfile /= "")  call logfile_init (logfile)
  if (banner)  call msg_banner ()
  
   ! Run any self-checks (and no commands)
   if (checks /= "") then
      checks = trim (adjustl (checks))
      RUN_CHECKS: do while (checks /= "")
         call split (checks, check, " ")
         call whizard_check (check, test_results)
      end do RUN_CHECKS
      call test_results%wrapup (6, success)
      if (.not. success)  quit_code = 7
      quit = .true.
   end if
   
   ! Set options and initialize the whizard object
   allocate (options)
   options%preload_model = model
   options%default_lib = default_lib
   options%preload_libraries = libraries
   options%rebuild_library = rebuild_library
   options%recompile_library = recompile_library
   options%rebuild_user = rebuild_user 
   options%rebuild_phs = rebuild_phs
   options%rebuild_grids = rebuild_grids
   options%rebuild_events = rebuild_events
  
   allocate (whizard_instance)
   call whizard_instance%init (options, paths, logfile)

   call mask_term_signals ()

   ! Run commands given on the command line
   if (.not. quit .and. ifile_get_length (commands) > 0) then
      call whizard_instance%process_ifile (commands, quit, quit_code)
   end if

   if (.not. quit) then
      ! Process commands from standard input
      if (.not. interactive .and. files == "") then
         call whizard_instance%process_stdin (quit, quit_code)

         ! ... or process commands from file
      else
         files = trim (adjustl (files))
         SCAN_FILES: do while (files /= "")
            call split (files, this, " ")
            call whizard_instance%process_file (this, quit, quit_code)
            if (quit)  exit SCAN_FILES
         end do SCAN_FILES

      end if
  end if
 
  ! Enter an interactive shell if requested
  if (.not. quit .and. interactive) then
     call whizard_instance%shell (quit_code)
  end if

  ! Overall finalization
  call ifile_final (commands)

  deallocate (options)

  call whizard_instance%final ()
  deallocate (whizard_instance)
  
  call terminate_now_if_signal ()
  call release_term_signals ()
  call msg_terminate (quit_code = quit_code)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains

  subroutine no_option_value (option, value)
    type(string_t), intent(in) :: option, value
    if (value /= "") then
       call msg_error (" Option '" // char (option) // "' should have no value")
    end if
  end subroutine no_option_value

  function get_option_value (i, option, value) result (string)
    type(string_t) :: string
    integer, intent(inout) :: i
    type(string_t), intent(in) :: option
    type(string_t), intent(in), optional :: value
    character(CMDLINE_ARG_LEN) :: arg
    character(CMDLINE_ARG_LEN) :: arg_value
    integer :: arg_len, arg_status
    logical :: has_value
    if (present (value)) then
       has_value = value /= ""
    else
       has_value = .false.
    end if
    if (has_value) then
       string = value
    else
       i = i + 1 
       call get_command_argument (i, arg_value, arg_len, arg_status)
       select case (arg_status)
       case (0)
       case (-1)
          call msg_error (" Option value truncated: '" // arg // "'")
       case default
          call print_usage ()
          call msg_fatal (" Option '" // char (option) // "' needs a value")
       end select
       select case (arg(1:1))
       case ("-")
          call print_usage ()
          call msg_fatal (" Option '" // char (option) // "' needs a value")
       end select
       string = trim (arg_value)
    end if
  end function get_option_value

  subroutine print_version ()
    print "(A)", "WHIZARD " // WHIZARD_VERSION 
    print "(A)", "Copyright (C) 1999-2014 Wolfgang Kilian, Thorsten Ohl, Juergen Reuter"
    print "(A)", "              ---------------------------------------                "
    print "(A)", "This is free software; see the source for copying conditions.  There is NO"
    print "(A)", "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    print *
  end subroutine print_version

  subroutine print_usage ()
    print "(A)", "WHIZARD " // WHIZARD_VERSION
    print "(A)", "Usage: whizard [OPTIONS] [FILE]"
    print "(A)", "Run WHIZARD with the command list taken from FILE(s)"
    print "(A)", "Options for resetting default directories and tools" &
            // "(GNU naming conventions):"
    print "(A)", "    --prefix DIR"
    print "(A)", "    --exec_prefix DIR"
    print "(A)", "    --bindir DIR"
    print "(A)", "    --libdir DIR"
    print "(A)", "    --includedir DIR"
    print "(A)", "    --datarootdir DIR"
    print "(A)", "    --libtool LOCAL_LIBTOOL"
    print "(A)", "    --lhapdfdir DIR   (PDF sets directory)"
    print "(A)", "Other options:"
    print "(A)", "-h, --help            display this help and exit"
    print "(A)", "    --banner          display banner at startup (default)"
    print "(A)", "-e, --execute CMDS    execute SINDARIN CMDS before reading FILE(s)"
    print "(A)", "-i, --interactive     run interactively after reading FILE(s)"
    print "(A)", "-l, --library         preload process library NAME"
    print "(A)", "    --localprefix DIR"
    print "(A)", "                      search in DIR for local models (default: ~/.whizard)"
    print "(A)", "-L, --logfile FILE    write log to FILE (default: 'whizard.log'"
    print "(A)", "    --logging         switch on logging at startup (default)"
    print "(A)", "-m, --model NAME      preload model NAME (default: 'SM')"
    print "(A)", "    --no-banner       do not display banner at startup"
    print "(A)", "    --no-library      do not preload process library"
    print "(A)", "    --no-logfile      do not write a logfile"
    print "(A)", "    --no-logging      switch off logging at startup"
    print "(A)", "    --no-model        do not preload a model"
    print "(A)", "    --no-rebuild      do not force rebuilding"
    print "(A)", "-r, --rebuild         rebuild all (see below)"
    print "(A)", "    --rebuild-library"
    print "(A)", "                      rebuild process code library"
    print "(A)", "    --rebuild-user    rebuild user-provided code"
    print "(A)", "    --rebuild-phase-space"
    print "(A)", "                      rebuild phase-space configuration"
    print "(A)", "    --rebuild-grids   rebuild integration grids"
    print "(A)", "    --rebuild-events  rebuild event samples"
    print "(A)", "    --recompile       recompile process code"
    print "(A)", "-u  --user            enable user-provided code"
    print "(A)", "    --user-src FILE   user-provided source file"
    print "(A)", "    --user-lib FILE   user-provided library file"
    print "(A)", "    --user-target BN  basename of created user library (default: user)"
    print "(A)", "-V, --version         output version information and exit"
    print "(A)", "    --write-syntax-tables"
    print "(A)", "                      write the internal syntax tables to files and exit"
    print "(A)", "-                     further options are taken as filenames"
    print *
    print "(A)", "With no FILE, read standard input."
  end subroutine print_usage

end program main
@ %def main
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Whizard-C-Interface}
<<[[whizard-c-interface.f90]]>>=
<<File header>>

<<Whizard-C-Interface: Internals>>
<<Whizard-C-Interface: Init and Finalize>>
<<Whizard-C-Interface: Interfaced Commads>>
<<Whizard-C-Interface: HepMC>>

@
<<Whizard-C-Interface: Internals>>=
  subroutine c_whizard_convert_string (c_string, f_string)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    character(kind=c_char), intent(in) :: c_string(*)
    type(string_t), intent(inout) :: f_string
    character(len=1) :: dummy_char
    integer :: dummy_i = 1
  
    f_string = ""
    do
       if (c_string(dummy_i) == c_null_char) then
          exit
       else if (c_string(dummy_i) == c_new_line) then
          dummy_char = CHAR(13)
          f_string = f_string // dummy_char
          dummy_char = CHAR(10)
       else
          dummy_char = c_string (dummy_i)
       end if
       f_string = f_string // dummy_char
       dummy_i = dummy_i + 1
    end do
    dummy_i = 1
  end subroutine c_whizard_convert_string
  
  subroutine c_whizard_commands (w_c_instance, cmds)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use commands
    use diagnostics
    use lexers
    use models
    use parser
    use whizard

    type(c_ptr), intent(inout) :: w_c_instance
    type(whizard_t), pointer :: whizard_instance
    type(string_t) :: cmds
    type(parse_tree_t) :: parse_tree
    type(parse_node_t), pointer :: pn_root
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    type(command_list_t), target :: cmd_list

    call c_f_pointer (w_c_instance, whizard_instance)
    call lexer_init_cmd_list (lexer)
    call syntax_cmd_list_init ()
  
    call stream_init (stream, cmds)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    pn_root => parse_tree_get_root_ptr (parse_tree)
  
    if (associated (pn_root)) then
       call cmd_list%compile (pn_root, whizard_instance%global)
    end if
    call cmd_list%execute (whizard_instance%global)
    call cmd_list%final ()
  
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call lexer_final (lexer)
    call syntax_cmd_list_final ()
  end subroutine c_whizard_commands

@
<<Whizard-C-Interface: Init and Finalize>>=
  subroutine c_whizard_init (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!    
    use system_dependencies
    use diagnostics
    use unit_tests
    use ifiles
    use os_interface
    use whizard
  
    implicit none
  
  <<Main: cmdline arg len declaration>>

    type(c_ptr), intent(out) :: w_c_instance    
    character(CMDLINE_ARG_LEN) :: arg
    character(2) :: option
    type(string_t) :: long_option, value
    integer :: i, j, arg_len, arg_status
    logical :: look_for_options
    logical :: interactive
    logical :: banner
    type(string_t) :: files, this, model, default_lib, library, libraries
    type(string_t) :: check, checks, logfile
    type(test_results_t) :: test_results
    logical :: success
    logical :: user_code_enable = .false.
    integer :: n_user_src = 0, n_user_lib = 0
    type(string_t) :: user_src, user_lib
    type(paths_t) :: paths
    logical :: rebuild_library, rebuild_user
    logical :: rebuild_phs, rebuild_grids, rebuild_events
    logical :: recompile_library
    type(ifile_t) :: commands
    type(string_t) :: command

    type(whizard_options_t), allocatable :: options
    type(whizard_t), pointer :: whizard_instance
    
    ! Exit status
    logical :: quit = .false.
    integer :: quit_code = 0
  
    ! Initial values
    look_for_options = .true.
    interactive = .false.
    files = ""
    model = "SM"
    default_lib = "default_lib"
    library = ""
    libraries = ""    
    banner = .true.
    logging = .true.
    logfile = "whizard.log"
    check = ""
    checks = ""
    user_src = ""
    user_lib = ""
    rebuild_library = .false.
    recompile_library = .false.
    rebuild_user = .false.
    rebuild_phs = .false.
    rebuild_grids = .false.
    rebuild_events = .false.
    call paths_init (paths)
  
    ! Overall initialization
    if (logfile /= "")  call logfile_init (logfile)
    call mask_term_signals ()
    if (banner)  call msg_banner ()
    
    ! Set options and initialize the whizard object
    allocate (options)
    options%preload_model = model
    options%default_lib = default_lib
    options%preload_libraries = libraries
    options%rebuild_library = rebuild_library
    options%rebuild_user = rebuild_user
    options%rebuild_phs = rebuild_phs
    options%rebuild_grids = rebuild_grids
    options%rebuild_events = rebuild_events
    
    allocate (whizard_instance)
    call whizard_instance%init (options, paths)
      
    if (checks /= "") then
       checks = trim (adjustl (checks))
       RUN_CHECKS: do while (checks /= "")
          call split (checks, check, " ")
          call whizard_check (check, test_results)
       end do RUN_CHECKS
       call test_results%wrapup (6, success)
       if (.not. success)  quit_code = 7
       quit = .true.
    end if
    
    w_c_instance = c_loc (whizard_instance)
              
  end subroutine c_whizard_init
  
  subroutine c_whizard_finalize (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use system_dependencies
    use diagnostics
    use ifiles
    use os_interface
    use whizard
    
    type(c_ptr), intent(in) :: w_c_instance
    type(whizard_t), pointer :: whizard_instance
    logical :: quit = .false.
    integer :: quit_code = 0
      
    call c_f_pointer (w_c_instance, whizard_instance)
    call whizard_instance%final ()
    deallocate (whizard_instance)
    call terminate_now_if_signal ()
    call release_term_signals ()
    call msg_terminate (quit_code = quit_code)
  end subroutine c_whizard_finalize
  
  subroutine c_whizard_process_string (w_c_instance, c_cmds_in) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_cmds_in(*)
    type(string_t) :: f_cmds
  
    call c_whizard_convert_string (c_cmds_in, f_cmds)
    call c_whizard_commands (w_c_instance, f_cmds)
  end subroutine c_whizard_process_string

@
<<Whizard-C-Interface: Interfaced Commads>>=
  subroutine c_whizard_model (w_c_instance, c_model) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_model(*)
    type(string_t) :: model, mdl_str
  
    call c_whizard_convert_string (c_model, model)
    mdl_str = "model = " // model
    call c_whizard_commands (w_c_instance, mdl_str)
  end subroutine c_whizard_model
  
  subroutine c_whizard_library (w_c_instance, c_library) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_library(*)
    type(string_t) :: library, lib_str
  
    call c_whizard_convert_string(c_library, library)
    lib_str = "library = " // library
    call c_whizard_commands (w_c_instance, lib_str)
  end subroutine c_whizard_library
  
  subroutine c_whizard_process (w_c_instance, c_id, c_in, c_out) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_id(*), c_in(*), c_out(*)
    type(string_t) :: proc_str, id, in, out
  
    call c_whizard_convert_string (c_id, id)
    call c_whizard_convert_string (c_in, in)
    call c_whizard_convert_string (c_out, out)
    proc_str = "process " // id // " = " // in // " => " // out
    call c_whizard_commands (w_c_instance, proc_str)
  end subroutine c_whizard_process
  
  subroutine c_whizard_compile (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    type(c_ptr), intent(inout) :: w_c_instance
    type(string_t) :: cmp_str
    cmp_str = "compile"
    call c_whizard_commands (w_c_instance, cmp_str)
  end subroutine c_whizard_compile
    
  subroutine c_whizard_beams (w_c_instance, c_specs) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_specs(*)
    type(string_t) :: specs, beam_str
  
    call c_whizard_convert_string (c_specs, specs)
    beam_str = "beams = " // specs
    call c_whizard_commands (w_c_instance, beam_str)
  end subroutine c_whizard_beams
  
  subroutine c_whizard_integrate (w_c_instance, c_process) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_process(*)
    type(string_t) :: process, int_str
  
    call c_whizard_convert_string (c_process, process)
    int_str = "integrate (" // process //")"
    call c_whizard_commands (w_c_instance, int_str)
  end subroutine c_whizard_integrate
  
  subroutine c_whizard_matrix_element_test &
       (w_c_instance, c_process, n_calls) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance
    integer(kind=c_int) :: n_calls
    character(kind=c_char) :: c_process(*)
    type(string_t) :: process, me_str
    character(len=8) :: buffer
  
    call c_whizard_convert_string (c_process, process)
    write (buffer, "(I0)")  n_calls
    me_str = "integrate (" // process // ") { ?phs_only = true" // &
         "  n_calls_test = " // trim (buffer) 
    call c_whizard_commands (w_c_instance, me_str)
  end subroutine c_whizard_matrix_element_test
  
  subroutine c_whizard_simulate (w_c_instance, c_id) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_id(*)
    type(string_t) :: sim_str, id
  
    call c_whizard_convert_string(c_id, id)
    sim_str = "simulate (" // id // ")"
    call c_whizard_commands (w_c_instance, sim_str)
  end subroutine c_whizard_simulate
  
  subroutine c_whizard_sqrts (w_c_instance, c_value, c_unit) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_unit(*)
    integer(kind=c_int) :: c_value
    integer :: f_value
    character(len=8) :: f_val
    type(string_t) :: val, unit, sqrts_str
  
    f_value = c_value
    write (f_val,'(i8)') f_value
    val = f_val
    call c_whizard_convert_string (c_unit, unit)
    sqrts_str = "sqrts =" // val // unit
    call c_whizard_commands (w_c_instance, sqrts_str)
  end subroutine c_whizard_sqrts
  
@
<<Whizard-C-Interface: HepMC>>=
  type(c_ptr) function c_whizard_hepmc_test &
       (w_c_instance, c_id, c_proc_id, c_event_id) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use commands
    use diagnostics
    use events
    use hepmc_interface
    use lexers
    use models
    use parser
    use processes
    use rt_data
    use simulations
    use whizard
    use os_interface
   
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance    
    type(string_t) :: sim_str
    type(parse_tree_t) :: parse_tree
    type(parse_node_t), pointer :: pn_root
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    type(command_list_t), pointer :: cmd_list
    type(whizard_t), pointer :: whizard_instance
   
    integer :: i_evt
    type(simulation_t), target :: sim
   
    character(kind=c_char), intent(in) :: c_id(*)
    type(string_t) :: id
    integer(kind=c_int), value :: c_proc_id, c_event_id
    integer :: proc_id, event_id
  
    type(hepmc_event_t), pointer :: hepmc_event
   
    type(process_t), pointer :: process
    integer :: proc
   
    integer :: factorization_mode, try
   
    call c_f_pointer (w_c_instance, whizard_instance)        
    
    call c_whizard_convert_string (c_id, id)
    sim_str = "simulate (" // id // ")" 
  
    proc_id = c_proc_id
    event_id = c_event_id
  
    allocate (hepmc_event)
    call hepmc_event_init (hepmc_event, c_proc_id, c_event_id)
  
    call syntax_cmd_list_init ()
    call lexer_init_cmd_list (lexer)
   
    call stream_init (stream, sim_str)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    pn_root => parse_tree_get_root_ptr (parse_tree)
   
    allocate (cmd_list)
    if (associated (pn_root)) then
       call cmd_list%compile (pn_root, whizard_instance%global)
    end if   
  
    call sim%init ([id], .true., .true., whizard_instance%global)

    !!! This should generate a HepMC event as hepmc_event_t type
    call msg_message ("Not enabled for the moment.")
  
    call sim%final ()

    call cmd_list%final ()
   
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call lexer_final (lexer)
    call syntax_cmd_list_final ()
  
    c_whizard_hepmc_test = c_loc(hepmc_event)
    return
  end function c_whizard_hepmc_test
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
