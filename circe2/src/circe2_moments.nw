% src/circe2_moments.nw -
\providecommand{\dd}{\mathrm{d}}
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \appendix
@ \section{Random Number Generator Objects}
<<[[circe2_moments.f90]]>>=
module tao_random_objects
  use kinds
  use tao_random_numbers
  use circe2
  implicit none
  private
  <<[[tao_random_objects]] declarations>>
contains
  <<[[tao_random_objects]] implementation>>
end module tao_random_objects
@ 
<<[[tao_random_objects]] declarations>>=
public :: rng_tao
type, extends (rng_type) :: rng_tao
   integer :: seed = 0
   integer :: n_calls = 0
   type(tao_random_state) :: state
 contains
   procedure :: generate => rng_tao_generate
   procedure :: init => rng_tao_init
end type rng_tao
@ 
<<[[tao_random_objects]] implementation>>=
subroutine rng_tao_generate (rng_obj, u)
  class(rng_tao), intent(inout) :: rng_obj
  real(default), intent(out) :: u
  call tao_random_number (rng_obj%state, u)
  rng_obj%n_calls = rng_obj%n_calls + 1
end subroutine rng_tao_generate
@ 
<<[[tao_random_objects]] implementation>>=
subroutine rng_tao_init (rng_obj, seed)
  class(rng_tao), intent(inout) :: rng_obj
  integer, intent(in) :: seed
  rng_obj%seed = seed
  call tao_random_create (rng_obj%state, seed)
end subroutine rng_tao_init
@  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \section{$\beta$-distribitions}
@ We need a fast generator of $\beta$-distribitions:
\begin{equation}
  \beta_{x_{\text{min}},x_{\text{max}}}^{a,b}(x)
    = x^{a-1}(1-x)^{b-1}\cdot
        \frac{\Theta(x_{\text{max}}-x)\Theta(x-x_{\text{min}})}%
             {I(x_{\text{min}},a,b)-I(x_{\text{max}},a,b)}
\end{equation}
with the \emph{incomplete Beta-function~$I$:}
\begin{align}
  I(x,a,b) & = \int_x^1\!d\xi\, \xi^{a-1}(1-\xi)^{b-1} \\
  I(0,a,b) & = B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}
\end{align}
This problem has been studied
extensively~\cite{Devroye:1986:random_deviates} and we can use 
an algorithm~\cite{Atkinson/Whittaker:1979:beta_distribution} that is
very fast for~$0<a\le1\le b$, 
which turns out to be the case in our application.
<<[[circe2_moments_library]] declarations>>=
  public :: generate_beta
@
<<[[circe2_moments_library]] implementation>>=
  subroutine generate_beta (rng, x, xmin, xmax, a, b)
    class(rng_type), intent(inout) :: rng
    real(kind=default), intent(out) :: x
    real(kind=default), intent(in) :: xmin, xmax, a, b
    real(kind=default) :: t, p, u, umin, umax, w
    <<Check [[a]] and [[b]]>>
    <<Set up [[generate_beta]] parameters>>
    do 
       <<Generate a trial [[x]] and calculate its weight [[w]]>>
       call rng%generate (u)
       if (w > u) exit
    end do
  end subroutine generate_beta
@ %def generate_beta
@ In fact, this algorithm works for~$0<a\le1\le b$ only:
<<Check [[a]] and [[b]]>>=
      if (a >= 1 .or. b <= 1) then
         x = -1
         print *, 'ERROR: beta-distribution expects a<1<b'
         return
      end if
@ The trick is to split the interval~$[0,1]$ into two parts~$[0,t]$
and~$[t,1]$.  In these intervals we obviously have
\begin{equation}
    x^{a-1} (1-x)^{b-1} \le
      \begin{cases}
        x^{a-1}             & \text{for}\; x \le t\\
        t^{a-1} (1-x)^{b-1} & \text{for}\; x \ge t
      \end{cases}
\end{equation}
because we have assumed that~$0<a<1<b$.
The integrals of the two dominating distributions are~$t^a/a$
and~$t^{a-1}(1-t)^b/b$ respectively and therefore the probability for
picking a random number from the first interval is
\begin{equation}
   P(x\le t) = \frac{bt}{bt+a(1- t)^b}
\end{equation}
We postpone the discussion of the choice of~$t$ until later:
<<Set up [[generate_beta]] parameters>>=
      <<Set up best value for $t$>>
      p = b*t / (b*t + a * (1 - t)**b)
@ The dominating distributions can be generated by simple mappings
\begin{align}
  \phi: [0,1] & \to [0,1] \\
            u & \mapsto
    \begin{cases}
      t\left(\frac{u}{p}\right)^\frac{1}{a}             &<t\;\text{for}\;u<p\\
      t                                                 &=t\;\text{for}\;u=p\\
      1 - (1-t)\left(\frac{1-u}{1-p}\right)^\frac{1}{b} &>t\;\text{for}\;u>p
    \end{cases}
\end{align}
The beauty of the algorithm is that we can use a single uniform
deviate~$u$ for both intervals:
<<Generate a trial [[x]] and calculate its weight [[w]]>>=
      call rng%generate (u)
      u = umin + (umax - umin) * u
      if (u <= p) then
         x = t * (u/p)**(1/a)
         w = (1 - x)**(b-1)
      else
         x = 1 - (1 - t) * ((1 - u)/(1 - p))**(1/b)
         w = (x/t)**(a-1)
      end if
@ The weights that are derived by dividing the distribution by the
dominating distributions are already normalized correctly:
\begin{align}
     w: [0,1] & \to [0,1] \\
            x & \mapsto
    \begin{cases}
      (1-x)^{b-1}                     &\in[(1-t)^{b-1},1]\;\text{for}\;x\le t\\
      \left(\frac{x}{t}\right)^{a-1}  &\in[t^{1-a},1]    \;\text{for}\;x\ge t
    \end{cases}
\end{align}
@ To derive~$u_{\text{min},\text{max}}$
from~$x_{\text{min},\text{max}}$ we can use~$\phi^{-1}$:
\begin{align}
  \phi^{-1}: [0,1] & \to [0,1] \\
                 x & \mapsto
    \begin{cases}
      p\left(\frac{x}{t}\right)^a             &<p\;\text{for}\;x<t\\
      p                                       &=p\;\text{for}\;x=t\\
      1 - (1-p)\left(\frac{1-x}{1-t}\right)^b &>p\;\text{for}\;x>t
    \end{cases}
\end{align}
We start with~$u_{\text{min}}$. For efficiency, we handle the most
common cases (small~$x_{\text{min}}$) first:
<<Set up [[generate_beta]] parameters>>=
      if (xmin <= 0) then
         umin = 0
      elseif (xmin < t) then
         umin = p * (xmin/t)**a
      elseif (xmin == t) then
         umin = p
      elseif (xmin < 1) then
         umin = 1 - (1 - p) * ((1 - xmin)/(1 - t))**b
      else
         umin = 1
      endif
@ Same procedure for~$u_{\text{max}}$; again, handle the most common
cases (large~$x_{\text{max}}$) first: 
<<Set up [[generate_beta]] parameters>>=
      if (xmax >= 1) then
         umax = 1
      elseif (xmax > t) then
         umax = 1 - (1 - p) * ((1 - xmax)/(1 - t))**b
      elseif (xmax == t) then
         umax = p
      elseif (xmax > 0) then
         umax = p * (xmax/t)**a
      else
         umax = 0
      endif
@ Check for absurd cases.
<<Set up [[generate_beta]] parameters>>=
      if (umax < umin) then
         x = -1
         return
      endif
@ It remains to choose he best value for~$t$.
The rejection efficiency~$\epsilon$ of the algorithm is given by the
ratio of the dominating distribution and the distribution
\begin{equation}
  \frac{1}{\epsilon(t)}
    = \frac{B(a,b)}{ab} \left(bt^{a} + at^{a-1}(1-t)^b\right).
\end{equation}
It is maximized for
\begin{equation}
   bt - bt(1-t)^{b-1} + (a-1)(1-t)^b = 0
\end{equation}
This equation has a solution which can be determined numerically.
While this determination is far too expensive compared to a moderate
loss in efficiency, we could perform it once after fitting the
coefficients~$a$, $b$.  Nevertheless, it has been
shown,\cite{Atkinson/Whittaker:1979:beta_distribution}
that
\begin{equation}
   t = \frac{1-a}{b+1-a}
\end{equation}
results in non-vanishing efficiency for all values~$1<a\le1\le b$.
Empirically we have found efficiencies of at least 80\%{} for this
choice, which is enough for our needs.
<<Set up best value for $t$>>=
      t = (1 - a) / (b + 1 - a)
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \section{Sampling}
<<[[circe2_moments.f90]]>>=
module sampling
  use kinds
  implicit none
  private
  <<[[sampling]] declarations>>
contains
  <<[[sampling]] implementation>>
end module sampling
@ 
<<[[sampling]] declarations>>=
type sample
  integer :: n = 0
  real(kind=default) :: w = 0
  real(kind=default) :: w2 = 0
end type sample
public :: sample
@ 
<<[[sampling]] declarations>>=
public :: reset, record
@
<<[[sampling]] implementation>>=
elemental subroutine reset (s)
  type(sample), intent(inout) :: s
  s%n = 0
  s%w = 0
  s%w2 = 0
end subroutine reset
@
<<[[sampling]] implementation>>=
elemental subroutine record (s, w)
  type(sample), intent(inout) :: s
  real(kind=default), intent(in), optional :: w
  s%n = s%n + 1
  if (present (w)) then
    s%w = s%w + w
    s%w2 = s%w2 + w*w
  else
    s%w = s%w + 1
    s%w2 = s%w2 + 1
  endif
end subroutine record
@ 
<<[[sampling]] declarations>>=
public :: mean, variance
@
<<[[sampling]] implementation>>=
elemental function mean (s)
  type(sample), intent(in) :: s
  real(kind=default) :: mean
  mean = s%w / s%n
end function mean
@
<<[[sampling]] implementation>>=
elemental function variance (s)
  type(sample), intent(in) :: s
  real(kind=default) :: variance
  variance = (s%w2 / s%n - mean(s)**2) / s%n
  variance = max (variance, epsilon (variance))
end function variance
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \section{Moments}
This would probably be a good place for inheritance
<<[[circe2_moments_library]] declarations>>=
type moment
  integer, dimension(2) :: n, m
  type(sample) :: sample = sample (0, 0.0_default, 0.0_default)
end type moment
public :: moment
@
<<[[circe2_moments_library]] declarations>>=
public :: init_moments
@
<<[[circe2_moments_library]] implementation>>=
subroutine init_moments (moments)
  type(moment), dimension(0:,0:,0:,0:), intent(inout) :: moments
  integer :: nx, mx, ny, my
  forall (nx = lbound(moments,1):ubound(moments,1), &
          mx = lbound(moments,2):ubound(moments,2), &
          ny = lbound(moments,3):ubound(moments,3), &
          my = lbound(moments,4):ubound(moments,4))
     moments(nx,mx,ny,my) = moment([nx,ny],[mx,my])
  end forall
  call reset_moment (moments)
end subroutine init_moments
@
<<[[circe2_moments_library]] declarations>>=
public :: reset_moment, record_moment
@
<<[[circe2_moments_library]] implementation>>=
elemental subroutine reset_moment (m)
  type(moment), intent(inout) :: m
  call reset (m%sample)
end subroutine reset_moment
@ If we were pressed for time, we would compute the moments
by iterative multiplications instead by powers, of course.
In any case, we would like to combine [[x1]] and [[x2]] into an array.
Unfortunately this is not possible for [[elemental]] procedures.
NB: the NAG compiler appears to want a more careful evaluation of
the powers.  We enforce [[0.0**0 == 0]].
<<[[circe2_moments_library]] implementation>>=
elemental subroutine record_moment (m, x1, x2, w)
  type(moment), intent(inout) :: m
  real(kind=default), intent(in) :: x1, x2
  real(kind=default), intent(in), optional :: w
  real(kind=default) :: p
  p = pwr (x1, m%n(1)) * pwr (1-x1, m%m(1)) &
    * pwr (x2, m%n(2)) * pwr (1-x2, m%m(2))
  if (present (w)) p = p*w
  call record (m%sample, p)
contains
  pure function pwr (x, n)
    real(kind=default), intent(in) :: x
    integer, intent(in) :: n
    real(kind=default) :: pwr
    if (n == 0) then
       pwr = 1
    else 
       pwr = x**n
    end if
  end function pwr
end subroutine record_moment
@
<<[[circe2_moments_library]] declarations>>=
public :: mean_moment, variance_moment
@
<<[[circe2_moments_library]] implementation>>=
elemental function mean_moment (m)
  type(moment), intent(in) :: m
  real(kind=default) :: mean_moment
  mean_moment = mean (m%sample)
end function mean_moment
@
<<[[circe2_moments_library]] implementation>>=
elemental function variance_moment (m)
  type(moment), intent(in) :: m
  real(kind=default) :: variance_moment
  variance_moment = variance (m%sample)
end function variance_moment
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{Moments of $\beta$-distributions}
<<[[circe2_moments_library]] declarations>>=
public :: beta_moment
@
\begin{multline}
  M_{n,m}(a,b)
    = \int_0^1\!\dd x\, x^n(1-x)^m \beta_{0,1}^{a,b}(x)
    = \int_0^1\!\dd x\, x^n(1-x)^m \frac{x^{a-1}(1-x)^{b-1}}{B(a,b)} \\
    = \frac{1}{B(a,b)} \int_0^1\!\dd x\, x^{n+a-1}(1-x)^{m+b-1}
    = \frac{B(n+a,m+b)}{B(a,b)} \\
    = \frac{\Gamma(n+a)\Gamma(m+b)\Gamma(a+b)}%
           {\Gamma(n+a+m+b)\Gamma(a)\Gamma(b)}
    = \frac{\Gamma(n+a)}{\Gamma(a)} \frac{\Gamma(m+b)}{\Gamma(b)}
      \frac{\Gamma(n+m+a+b)}{\Gamma(a+b)} \\
    = \frac{(a+n)(a+n-1)\cdots(a+1)a(b+m)(b+m-1)\cdots(b+1)b}%
           {(a+b+n+m)(a+b+n+m-1)\cdots(a+b+1)(a+b)}
\end{multline}
<<[[circe2_moments_library]] implementation>>=
elemental function beta_moment (n, m, a, b)
  integer, intent(in) :: n, m
  real(kind=default), intent(in) :: a, b
  real(kind=default) :: beta_moment
  beta_moment = &
    gamma_ratio (a, n) * gamma_ratio (b, m) / gamma_ratio (a+b, n+m)
end function beta_moment
@
\begin{equation}
  \frac{\Gamma(x+n)}{\Gamma(x)}
    = (x+n)(x+n-1)\cdots(x+1)x
\end{equation}
<<[[circe2_moments_library]] implementation>>=
elemental function gamma_ratio (x, n)
  real(kind=default), intent(in) :: x
  integer, intent(in) :: n
  real(kind=default) :: gamma_ratio
  integer :: i
  gamma_ratio = 1
  do i = 0, n - 1
    gamma_ratio = gamma_ratio * (x + i)
  end do
end function gamma_ratio
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{Channels}
<<[[circe2_moments_library]] declarations>>=
type channel
  real(kind=default) :: w = 1
  real(kind=default), dimension(2) :: a = 1, b = 1
  logical, dimension(2) :: delta = .false.
end type channel
public :: channel
@
<<[[circe2_moments_library]] declarations>>=
public :: generate_beta_multi, beta_moments_multi
@
<<[[circe2_moments_library]] implementation>>=
subroutine generate_beta_multi (rng, x, channels)
  class(rng_type), intent(inout) :: rng
  real(kind=default), dimension(:), intent(out) :: x
  type(channel), dimension(:), intent(in) :: channels
  real(kind=default) :: u, accum
  integer :: i, n
  <<Select [[n]] according to the weight [[channels(n)%w]]>>
  do i = 1, size (x)
    if (channels(n)%delta(i)) then
      x(i) = 1
    else
      if (channels(n)%a(i) == 1 .and. channels(n)%b(i) == 1) then
        call rng%generate (x(i))
      else if (channels(n)%b(i) < channels(n)%a(i)) then
        call generate_beta (rng, x(i), 0.0_default, 1.0_default, &
                            channels(n)%b(i), channels(n)%a(i))
        x(i) = 1 - x(i)
      else
        call generate_beta (rng, x(i), 0.0_default, 1.0_default, &
                            channels(n)%a(i), channels(n)%b(i))
      end if
    end if
  end do
end subroutine generate_beta_multi
@ Subtlety: if the upper limit of the do loop where
[[size(channels)]], we could end up with [[n]] set to
[[size(channels)+1]] when rounding errors produce
$[[accum]]>[[sum(channels%w)]]$.
<<Select [[n]] according to the weight [[channels(n)%w]]>>=
call rng%generate (u)
u = u * sum (channels%w)
accum = 0
scan: do n = 1, size (channels) - 1
  accum = accum + channels(n)%w
  if (accum >= u) exit scan
end do scan
@
<<[[circe2_moments_library]] implementation>>=
pure function beta_moments_multi (n, m, channels)
  integer, intent(in), dimension(2) :: n, m
  type(channel), dimension(:), intent(in) :: channels
  real(kind=default) :: beta_moments_multi
  real(kind=default) :: w
  integer :: c, i
  beta_moments_multi = 0
  do c = 1, size (channels)
    w = channels(c)%w
    do i = 1, 2
      if (channels(c)%delta(i)) then
        if (m(i) > 0) w = 0
      else
        w = w * beta_moment (n(i), m(i), channels(c)%a(i), channels(c)%b(i))
      end if
    end do
    beta_moments_multi = beta_moments_multi + w
  end do
  beta_moments_multi = beta_moments_multi / sum (channels%w)
end function beta_moments_multi
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{Selftest}
@
<<[[circe2_moments_library]] declarations>>=
public :: selftest
@
<<[[circe2_moments_library]] implementation>>=
subroutine selftest (rng, nevents)
  class(rng_type), intent(inout) :: rng
  integer, intent(in) :: nevents
  integer, parameter :: N = 1
  type(moment), dimension(0:N,0:N,0:N,0:N) :: moments
  integer :: i
  real(kind=default), dimension(2) :: x
  type(channel), dimension(:), allocatable :: channels
  call read_channels (channels)
  call init_moments (moments)
  do i = 1, nevents
     call generate_beta_multi (rng, x, channels)
     call record_moment (moments, x(1), x(2))
  end do
  call report_results (moments, channels)
end subroutine selftest
@
<<[[circe2_moments_library]] declarations>>=
public :: random2_seed
@
<<[[circe2_moments_library]] implementation>>=
subroutine random2_seed (rng, seed)
  class(rng_tao), intent(inout) :: rng
  integer, intent(in), optional:: seed
  integer, dimension(8) :: date_time
  integer :: seed_value
  if (present (seed)) then
     seed_value = seed
  else
     call date_and_time (values = date_time)
     seed_value = product (date_time)
  endif
  call rng%init (seed_value)
end subroutine random2_seed
@
<<[[circe2_moments_library]] declarations>>=
public :: read_channels
@
<<[[circe2_moments_library]] implementation>>=
subroutine read_channels (channels)
  type(channel), dimension(:), allocatable, intent(out) :: channels
  type(channel), dimension(100) :: buffer
  real(kind=default) :: w
  real(kind=default), dimension(2) :: a, b
  logical, dimension(2) :: delta
  integer :: n, status
  do n = 1, size (buffer)
    read (*, *, iostat = status) w, a(1), b(1), a(2), b(2), delta
    if (status == 0) then
      buffer(n) = channel (w, a, b, delta)
    else
      exit
    end if
  end do
  allocate (channels(n-1))
  channels = buffer(1:n-1)
end subroutine read_channels
@
<<[[circe2_moments_library]] declarations>>=
public :: report_results
@
<<[[circe2_moments_library]] implementation>>=
subroutine report_results (moments, channels)
  type(moment), dimension(0:,0:,0:,0:), intent(in) :: moments
  type(channel), dimension(:), intent(in) :: channels
  integer :: nx, mx, ny, my
  real(kind=default) :: truth, estimate, sigma, pull
  do nx = lbound(moments,1), ubound(moments,1)
     do mx = lbound(moments,2), ubound(moments,2)
        do ny = lbound(moments,3), ubound(moments,3)
           do my = lbound(moments,4), ubound(moments,4)
              truth = beta_moments_multi ([nx, ny], [mx, my], channels)
              estimate = mean_moment (moments(nx,mx,ny,my))
              sigma = sqrt (variance_moment (moments(nx,mx,ny,my)))
              pull = estimate - truth
              if (pull /= 0.0_default) pull = pull / sigma
              write (*, "(' x^', I1, ' (1-x)^', I1, &
                         &' y^', I1, ' (1-y)^', I1, &
                         &': ', F8.5, ': est = ', F8.5, &
                         &' +/- ', F8.5,&
                         &', pull = ', F5.2)") &
                   nx, mx, ny, my, truth, estimate, sigma, pull
           end do
        end do
     end do
  end do
end subroutine report_results
@
<<[[circe2_moments_library]] declarations>>=
public :: results_ok
@
<<[[circe2_moments_library]] implementation>>=
function results_ok (moments, channels, threshold, fraction)
  ! use, intrinsic :: ieee_arithmetic
  type(moment), dimension(0:,0:,0:,0:), intent(in) :: moments
  type(channel), dimension(:), intent(in) :: channels
  real(kind=default), intent(in), optional :: threshold, fraction
  logical :: results_ok
  integer :: nx, mx, ny, my, failures
  real(kind=default) :: thr, frac
  real(kind=default) :: truth, estimate, sigma
  if (present(threshold)) then
     thr = threshold
  else
     thr = 5
  end if
  if (present(fraction)) then
     frac = fraction
  else
     frac = 0.01_default
  end if
  failures = 0
  do nx = lbound(moments,1), ubound(moments,1)
     do mx = lbound(moments,2), ubound(moments,2)
        do ny = lbound(moments,3), ubound(moments,3)
           do my = lbound(moments,4), ubound(moments,4)
              truth = beta_moments_multi ([nx, ny], [mx, my], channels)
              estimate = mean_moment (moments(nx,mx,ny,my))
              sigma = sqrt (variance_moment (moments(nx,mx,ny,my)))
              if (.not. (      ieee_is_normal (truth) &
                         .and. ieee_is_normal (estimate) &
                         .and. ieee_is_normal (sigma)) &
                  .or. abs (estimate - truth) > thr * sigma) then
                 failures = failures + 1
              end if
           end do
        end do
     end do
  end do
  if (failures >= frac * size (moments)) then
    results_ok = .false.
  else
    results_ok = .true.
  end if
contains
  <<The old [[ieee_is_normal]] kludge>>
end function results_ok
@ gfortran doesn't have the intrinsic [[ieee_arithmetic]] module
yet \ldots
<<The old [[ieee_is_normal]] kludge>>=
function ieee_is_normal (x)
  real(kind=default), intent(in) :: x
  logical :: ieee_is_normal
  ieee_is_normal = .not. (x /= x)
end function ieee_is_normal
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{Generate Sample}
@
<<[[circe2_moments_library]] declarations>>=
public :: generate
@
<<[[circe2_moments_library]] implementation>>=
subroutine generate (rng, nevents)
  class(rng_type), intent(inout) :: rng
  integer, intent(in) :: nevents
  type(channel), dimension(:), allocatable :: channels
  real(kind=default), dimension(2) :: x
  integer :: i
  call read_channels (channels)
  do i = 1, nevents
     call generate_beta_multi (rng, x, channels)
     print *, x, 1.0_default
  end do
end subroutine generate
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{List Moments}
@
<<[[circe2_moments_library]] declarations>>=
public :: compare
@
<<[[circe2_moments_library]] implementation>>=
subroutine compare (rng, nevents, file)
  class(rng_type), intent(inout) :: rng
  integer, intent(in) :: nevents
  character(len=*), intent(in) :: file
  type(channel), dimension(:), allocatable :: channels
  integer, parameter :: N = 1
  type(moment), dimension(0:N,0:N,0:N,0:N) :: moments
  real(kind=default), dimension(2) :: x
  character(len=128) :: design
  real(kind=default) :: roots
  integer :: ierror
  integer, dimension(2) :: p, h
  integer :: i
  type(circe2_state) :: c2s
  call read_channels (channels)
  call init_moments (moments)
  design = "CIRCE2/TEST"
  roots = 42
  p = [11, -11]
  h = 0
  call circe2_load (c2s, trim(file), trim(design), roots, ierror)
  do i = 1, nevents
     call circe2_generate (c2s, rng, x, p, h)
     call record_moment (moments, x(1), x(2))
  end do
  call report_results (moments, channels)
end subroutine compare
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \subsection{Check Generator}
@
<<[[circe2_moments_library]] declarations>>=
public :: check
@
<<[[circe2_moments_library]] implementation>>=
subroutine check (rng, nevents, file, distributions, fail)
  class(rng_type), intent(inout) :: rng
  integer, intent(in) :: nevents
  character(len=*), intent(in) :: file
  logical, intent(in), optional :: distributions, fail
  type(channel), dimension(:), allocatable :: channels
  type(channel), dimension(1) :: unit_channel
  integer, parameter :: N = 1
  type(moment), dimension(0:N,0:N,0:N,0:N) :: moments, unit_moments
  real(kind=default), dimension(2) :: x
  character(len=128) :: design
  real(kind=default) :: roots, weight
  integer :: ierror
  integer, dimension(2) :: p, h
  integer :: i
  logical :: generation_ok, distributions_ok
  logical :: check_distributions, expect_failure
  type(circe2_state) :: c2s
  if (present (distributions)) then
     check_distributions = distributions
  else
     check_distributions = .true.
  end if
  if (present (fail)) then
     expect_failure = fail
  else
     expect_failure = .false.
  end if
  call read_channels (channels)
  call init_moments (moments)
  if (check_distributions) call init_moments (unit_moments)
  design = "CIRCE2/TEST"
  roots = 42
  p = [11, -11]
  h =   0
  call circe2_load (c2s, trim(file), trim(design), roots, ierror)
  do i = 1, nevents
     call circe2_generate (c2s, rng, x, p, h)
     call record_moment (moments, x(1), x(2))
     if (check_distributions) then
        weight = circe2_distribution (c2s, p, h, x)
        call record_moment (unit_moments, x(1), x(2), w = 1 / weight)
     end if
  end do
  generation_ok = results_ok (moments, channels)
  if (check_distributions) then
     distributions_ok = results_ok (unit_moments, unit_channel)
  else
     distributions_ok = .not. expect_failure
  end if
  if (expect_failure) then
     if (generation_ok .and. distributions_ok) then
        print *, "FAIL: unexpected success"
     else
        if (.not. generation_ok) then
           print *, "OK: expected failure in generation"
        end if
        if (.not. distributions_ok) then
           print *, "OK: expected failure in distributions"
        end if
     end if
     call report_results (moments, channels)
  else
     if (generation_ok .and. distributions_ok) then
        print *, "OK"
     else
        if (.not. generation_ok) then
           print *, "FAIL: generation"
           call report_results (moments, channels)
        end if
        if (.not. distributions_ok) then
           print *, "FAIL: distributions"
           call report_results (unit_moments, unit_channel)
        end if
     end if
  end if
end subroutine check
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ \section{Main Program}
<<Main program>>=
program circe2_moments
  use circe2
  use circe2_moments_library !NODEP!
  use tao_random_objects !NODEP!
  implicit none
  type(rng_tao), save :: rng
  character(len=1024) :: mode, filename, buffer
  integer :: status, nevents, seed
  call get_command_argument (1, value = mode, status = status)
  if (status /= 0) mode = ""
  call get_command_argument (2, value = filename, status = status)
  if (status /= 0) filename = ""
  call get_command_argument (3, value = buffer, status = status)
  if (status == 0) then
     read (buffer, *, iostat = status) nevents
     if (status /= 0) nevents = 1000
  else
     nevents = 1000
  end if
  call get_command_argument (4, value = buffer, status = status)
  if (status == 0) then
     read (buffer, *, iostat = status) seed
     if (status == 0) then
        call random2_seed (rng, seed)
     else
        call random2_seed (rng)
     end if
  else
     call random2_seed (rng)
  end if
  select case (trim (mode))
  case ("check")
     call check (rng, nevents, trim (filename))
  case ("!check")
     call check (rng, nevents, trim (filename), fail = .true.)
  case ("check_generation")
     call check (rng, nevents, trim (filename), distributions = .false.)
  case ("!check_generation")
     call check (rng, nevents, trim (filename), fail = .true., &
                                                distributions = .false.)
  case ("compare")
     call compare (rng, nevents, trim (filename))
  case ("generate")
     call generate (rng, nevents)
  case ("selftest")
     call selftest (rng, nevents)
  case default
     print *, &
      "usage: circe2_moments " // &
      "[check|check_generation|generate|selftest] " // &
      "filename [events] [seed]"
  end select
end program circe2_moments
@
<<[[circe2_moments.f90]]>>=
module circe2_moments_library
  use kinds
  use tao_random_objects !NODEP!
  use sampling !NODEP!
  use circe2
  implicit none
  private
  <<[[circe2_moments_library]] declarations>>
contains
  <<[[circe2_moments_library]] implementation>>
end module circe2_moments_library
@
<<[[circe2_moments.f90]]>>=
<<Main program>>
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{10}
\bibitem{Atkinson/Whittaker:1979:beta_distribution}
  A. Atkinson and J. Whittaker, Appl.\ Stat.\ {\bf 28},  90  (1979).
\end{thebibliography}
% \end{document}
% Local Variables:
% mode:noweb
% noweb-doc-mode:latex-mode
% noweb-code-mode:f90-mode
% indent-tabs-mode:nil
% page-delimiter:"^@ %%%.*\n"
% End:
