Process interface:
------------------------------------------------------------------------

Example: replace 'n1n1h_m' by appropriate process tag
	    (must be valid Fortran90 names, lower case only)
         replace 'mad' by appropriate method tag

Lines in processes.conf

Tag	 In	Out		Method		Options
n1n1h_m	 e1,E1	n1,N1,H		mad		s

Optional: Diagram selection file  n1n1h_m.sel

-> In directory 'mad-src': There should be a script/program 'make_proc'
   which takes these as args:

   ./mad-src/make_proc  n1n1h_m  e1,E1  n1,N1,H  ./conf/diag_n1n1h_m.sel

   and generates  n1n1h_m_const.f90,  n1n1h_m.f90  (+ aux files if needed)

     (all generated filenames must begin with 'n1n1h_m'.  Files
     with extension '.f' or '.f90' will be compiled and included in the
     'processes.a' archive file.  Other generated files will just be copied
     into the 'processes' subdir.)
   
   [If files are already existing: make_proc should copy them
   into the working dir.]


-> Each process (e.g. n1n1h_m):
   After executing 'make_proc', there should at least be the following files:

- File n1n1h_m_const.f90

   module n1n1h_m_const

     use kinds, only: PREC           !NODEP! defines default REAL kind 'PREC'

     implicit none
     public

     ! Declare as global variables:
     !   all constants needed for this process
     !   (masses, couplings etc.)

   end module n1n1h_m_const

   [This construct eliminates the need for COMMON blocks.  If COMMON
   blocks are absolutely necessary, repeat their definition within
   this module.]


- File n1n1h_m.f90

   module n1n1h_m

     use kinds,      only: PREC      !NODEP! defines default REAL kind 'PREC'
     use file_utils, only: free_unit !NODEP! useful for I/O

     use parameters                  !NODEP! defines type parameter_set
     use n1n1h_m_const

     implicit none
     private

     public :: allow_hel
     public :: n_in, n_out
     public :: code
     public :: set_const, sqme

   contains

     function allow_hel ()
       logical :: allow_hel
       ! Return .true. if helicity amplitudes are supported, .false. otherwise
     end function allow_hel

     function n_in ()
       integer :: n_in
       ! Return number of incoming particles (1 or 2)
     end function n_in

     function n_out ()
       integer :: n_out
       ! Return number of outgoing particles
     end function n_out

     function code (i)
       integer, intent(in) :: i
       integer :: code
       ! Scattering process:
       !   i= -2   return PDG code of 2nd incoming particle
       !   i= -1   return PDG code of 1st incoming particle
       !   i=  0   return 99 [= composite particle]
       !   i>= 1   return PDG code of outgoing particle
       !   i<-2 or i>n_out   return 0
       ! Decay process:
       !   i=  0   return PDG code of incoming particle
       !   i>= 1   return PDG code of outgoing particle
       !   i<0 or i>n_out   return 0
     end function code

     subroutine set_const (par)
       type(parameter_set), intent(in) :: par
       ! set contents of module n1n1h_m_const from par
     end subroutine set_const

     function sqme (p, h)
       real(kind=PREC), dimension(0:3, -2:), intent(in) :: p
       integer, dimension(-2:), intent(in), optional :: h
       real(kind=PREC) :: sqme
       ! calculate sqme from p, h
       ! p: four-momenta, where p(0, :) = energy, 
       !    p(:, -2:-1) = in-momenta for scattering process
       !    p(:, 0)     = sum of all out-momenta (= sum of all in_momenta)
       !    p(:, 1:)    = out-momenta
       ! h: helicities, for in- and out particles i=-2,..,n_out
       !    scalar:  h(i)=0
       !    fermion: h(i)=0,1   : L, R
       !    vector:  h(i)=0,1,2 : -, 0, +
       ! If h is absent, sum over outgoing and average over incoming helicities
     end function sqme

   end module n1n1h_m


------------------------------------------------------------------------
-> Main script: write include files:

   include_use:
	use n1n1h_m, only: &
          & n1n1h_m_allow_hel => allow_hel,  &
          & n1n1h_m_n_in      => n_in,  &
	  & n1n1h_m_n_out     => n_out, &
	  & n1n1h_m_code      => code, &
	  & n1n1h_m_set_const => set_const, &
	  & n1n1h_m_sqme      => sqme

   include_prc:
        character(len=*), parameter, public :: prc_n1n1h_m = "n1n1h_m"

   include_n_in:
	case(prc_n1n1h_m)
	    n_in = n1n1h_m_n_in()

   include_hel:
	case(prc_n1n1h_m)
	    allow_hel = n1n1h_m_allow_hel()

   include_n_out:
	case(prc_n1n1h_m)
	    n_in = n1n1h_m_n_out()

   include_code:
        case(prc_n1n1h_m)
	    code = n1n1h_m_code(i)

   include_set_const:
        case(prc_n1n1h_m)
	    call n1n1h_m_set_const(par)

   include_sqme:
        case(prc_n1n1h_m)
	    s = n1n1h_m_sqme(p)

   include_sqme_pol:
        case(prc_n1n1h_m)
	    s = n1n1h_m_sqme(p, h)

