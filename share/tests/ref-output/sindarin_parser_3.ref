* Test output: sindarin_parser_3
*   Purpose: parse a simple script

* Create script

logical a
logical b = true
a = b and not false
b = (a or true) and (not b)

* Parse script

* Setup decoder

Parse-tree decoder state:
Prototype names:
 1 logical
 2 not
 3 and
 4 or
 5 assignment
Parse tree:
+  <script>  =  <declaration> <declaration> <assignment> <assignment>
|  +  <declaration>  =  logical <var_name>
|  |  +  logical  = [keyword] logical
|  |  +  <var_name>  = a
|  +  <declaration>  =  logical <var_name> <assignment_clause>
|  |  +  logical  = [keyword] logical
|  |  +  <var_name>  = b
|  |  +  <assignment_clause>  =  '=' <logical_expr>
|  |  |  +  '='  = [keyword] =
|  |  |  +  <logical_expr>  =  <logical_term>
|  |  |  |  +  <logical_term>  =  true
|  |  |  |  |  +  true  = [keyword] true
|  +  <assignment>  =  <var_name> <assignment_clause>
|  |  +  <var_name>  = a
|  |  +  <assignment_clause>  =  '=' <logical_expr>
|  |  |  +  '='  = [keyword] =
|  |  |  +  <logical_expr>  =  <logical_term>
|  |  |  |  +  <logical_term>  =  <atom> <and_clause>
|  |  |  |  |  +  <atom>  = b
|  |  |  |  |  +  <and_clause>  =  and <not_clause>
|  |  |  |  |  |  +  and  = [keyword] and
|  |  |  |  |  |  +  <not_clause>  =  not false
|  |  |  |  |  |  |  +  not  = [keyword] not
|  |  |  |  |  |  |  +  false  = [keyword] false
|  +  <assignment>  =  <var_name> <assignment_clause>
|  |  +  <var_name>  = b
|  |  +  <assignment_clause>  =  '=' <logical_expr>
|  |  |  +  '='  = [keyword] =
|  |  |  +  <logical_expr>  =  <logical_term>
|  |  |  |  +  <logical_term>  =  <logical_expr> <and_clause>
|  |  |  |  |  +  <logical_expr>  =  <logical_term> <or_clause>
|  |  |  |  |  |  +  <logical_term>  =  <atom>
|  |  |  |  |  |  |  +  <atom>  = a
|  |  |  |  |  |  +  <or_clause>  =  or <logical_term>
|  |  |  |  |  |  |  +  or  = [keyword] or
|  |  |  |  |  |  |  +  <logical_term>  =  true
|  |  |  |  |  |  |  |  +  true  = [keyword] true
|  |  |  |  |  +  <and_clause>  =  and <logical_expr>
|  |  |  |  |  |  +  and  = [keyword] and
|  |  |  |  |  |  +  <logical_expr>  =  <logical_term>
|  |  |  |  |  |  |  +  <logical_term>  =  <not_clause>
|  |  |  |  |  |  |  |  +  <not_clause>  =  not <atom>
|  |  |  |  |  |  |  |  |  +  not  = [keyword] not
|  |  |  |  |  |  |  |  |  +  <atom>  = b
Node handler stack:
   <script>:  H

* Decode (see 'sindarin_parser_3.dat')

* Create object tree

object script ||abstract|| {
   M1: logical a ||variable|| = ???
   M2: logical b ||variable|| = ???
   P1: b = true
   P2: a = b and not false
   P3: b = (a or true) and not b
 }

* Cleanup

* Test output end: sindarin_parser_3
