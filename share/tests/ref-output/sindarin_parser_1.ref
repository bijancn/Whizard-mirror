* Test output: sindarin_parser_1
*   Purpose: build syntax table

Syntax table:
 SEQUENCE    <script> = <command>*
 ALTERNATIVE <command> = <declaration> | <assignment>
 SEQUENCE    <declaration> = <builtin_type> <var_name> <assignment_clause>?
 SEQUENCE    <assignment> = <var_name> <assignment_clause>
 ALTERNATIVE <builtin_type> = logical | integer
 KEYWORD     logical
 KEYWORD     integer
 IDENTIFIER  <var_name>
 SEQUENCE    <assignment_clause> = '=' <expr>
 KEYWORD     '='
 ALTERNATIVE <expr> = <logical_expr>
 SEQUENCE    <logical_expr> = <logical_term> <or_clause>*
 SEQUENCE    <logical_term> = <logical_value> <and_clause>*
 ALTERNATIVE <logical_value> = <not_clause> | <logical_literal> | <integer_expr>
 SEQUENCE    <or_clause> = or <logical_term>
 SEQUENCE    <and_clause> = and <logical_value>
 SEQUENCE    <not_clause> = not <logical_value>
 ALTERNATIVE <logical_literal> = true | false
 KEYWORD     or
 KEYWORD     and
 KEYWORD     not
 KEYWORD     true
 KEYWORD     false
 SEQUENCE    <integer_expr> = <integer_term> <add_clause>*
 SEQUENCE    <integer_term> = <signed_integer_value> <mult_clause>*
 ALTERNATIVE <signed_integer_value> = <sign_clause> | <integer_value>
 ALTERNATIVE <integer_value> = <integer_literal> | <group> | <atom>
 SEQUENCE    <add_clause> = <add_op> <integer_term>
 SEQUENCE    <mult_clause> = <mult_op> <integer_value>
 SEQUENCE    <sign_clause> = <sign_op> <integer_value>
 ALTERNATIVE <add_op> = '+' | '-'
 ALTERNATIVE <mult_op> = '*' | '/'
 ALTERNATIVE <sign_op> = '+' | '-'
 KEYWORD     '+'
 KEYWORD     '-'
 KEYWORD     '*'
 KEYWORD     '/'
 INTEGER     <integer_literal>
 GROUP       <group> = ( <expr> )
 IDENTIFIER  <atom>
Keyword list:
 logical integer = not true false + - ( ) * / and or

* Test output end: sindarin_parser_1
