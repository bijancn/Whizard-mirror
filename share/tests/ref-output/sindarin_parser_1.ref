* Test output: sindarin_parser_1
*   Purpose: build syntax table

Syntax table:
 SEQUENCE    <script> = <command>*
 ALTERNATIVE <command> = <declaration> | <assignment>
 SEQUENCE    <declaration> = <builtin_type> <var_name> <assignment_clause>?
 SEQUENCE    <assignment> = <var_name> <assignment_clause>
 ALTERNATIVE <builtin_type> = logical | integer
 KEYWORD     logical
 KEYWORD     integer
 IDENTIFIER  <var_name>
 SEQUENCE    <assignment_clause> = '=' <generic_expr>
 KEYWORD     '='
 ALTERNATIVE <generic_expr> = <signed_expr> | <expr>
 SEQUENCE    <signed_expr> = <sign> <expr>
 ALTERNATIVE <sign> = '+' | '-'
 SEQUENCE    <expr> = <term> <operator_clause>*
 ALTERNATIVE <operator_clause> = <separator_clause> | <logical_operation> | <comparison> | <arithmetic_operation>
 SEQUENCE    <separator_clause> = <separator> <term>
 ALTERNATIVE <separator> = ':' | , | '=>'
 KEYWORD     ':'
 KEYWORD     ,
 KEYWORD     '=>'
 SEQUENCE    <logical_operation> = <logical_operator> <term>
 ALTERNATIVE <logical_operator> = or | and
 KEYWORD     or
 KEYWORD     and
 SEQUENCE    <comparison> = <comparison_operator> <term>
 ALTERNATIVE <comparison_operator> = '==' | '<>' | '<' | '>' | '<=' | '>='
 KEYWORD     '=='
 KEYWORD     '<>'
 KEYWORD     '<'
 KEYWORD     '>'
 KEYWORD     '<='
 KEYWORD     '>='
 SEQUENCE    <arithmetic_operation> = <arithmetic_operator> <term>
 ALTERNATIVE <arithmetic_operator> = '+' | '-' | '*' | '/' | '^'
 KEYWORD     '+'
 KEYWORD     '-'
 KEYWORD     '*'
 KEYWORD     '/'
 KEYWORD     '^'
 ALTERNATIVE <term> = <not_clause> | <logical_literal> | <integer_literal> | <conditional_expr> | <group> | <atom>
 SEQUENCE    <not_clause> = not <logical_expr>
 ALTERNATIVE <logical_expr> = <term> | '*'
 ALTERNATIVE <logical_literal> = true | false
 KEYWORD     not
 KEYWORD     true
 KEYWORD     false
 INTEGER     <integer_literal>
 SEQUENCE    <conditional_expr> = <if_expr> <elsif_expr_part> <else_expr_part> endif
 SEQUENCE    <if_expr> = if <expr> then <expr>
 SEQUENCE    <elsif_expr_part> = <elsif_expr>*
 SEQUENCE    <elsif_expr> = elsif <expr> then <expr>
 SEQUENCE    <else_expr_part> = <else_expr>?
 SEQUENCE    <else_expr> = else <expr>
 KEYWORD     if
 KEYWORD     then
 KEYWORD     elsif
 KEYWORD     else
 KEYWORD     endif
 GROUP       <group> = ( <expr> )
 IDENTIFIER  <atom>
Keyword list:
 logical integer = + - not * true false if then elsif else endif ( ) : , => or and == <> < > <= >= / ^

* Test output end: sindarin_parser_1
