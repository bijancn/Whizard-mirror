%  $Id: omegalib.nw 4662 2013-09-23 13:21:34Z msekulla $
%
%  Copyright (C) 1999-2013 by 
%      Wolfgang Kilian <kilian@physik.uni-siegen.de>
%      Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
%      Juergen Reuter <juergen.reuter@desy.de>
%      Christian Speckner <cnspeckn@googlemail.com>
%
%  WHIZARD is free software; you can redistribute it and/or modify it
%  under the terms of the GNU General Public License as published by 
%  the Free Software Foundation; either version 2, or (at your option)
%  any later version.
%
%  WHIZARD is distributed in the hope that it will be useful, but
%  WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with this program; if not, write to the Free Software
%  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@
\section{Trivia}
<<[[omega_spinors.f90]]>>=
<<Copyleft>>
module omega_spinors
  use kinds
  use constants
  implicit none
  private
  public :: operator (*), operator (+), operator (-)
  public :: abs
  <<[[intrinsic :: abs]]>>
  type, public :: conjspinor
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default), dimension(4) :: a
  end type conjspinor
  type, public :: spinor
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default), dimension(4) :: a
  end type spinor
  <<Declaration of operations for spinors>>
  integer, parameter, public :: omega_spinors_2010_01_A = 0
contains
  <<Implementation of operations for spinors>>
end module omega_spinors
@
<<[[intrinsic :: abs]] (if working)>>=
intrinsic :: abs
@
<<[[intrinsic :: conjg]] (if working)>>=
intrinsic :: conjg
@ well, the Intel Fortran Compiler chokes on these with an internal error:
<<[[intrinsic :: abs]]>>=
@
<<[[intrinsic :: conjg]]>>=
@
\subsection{Inner Product}
<<Declaration of operations for spinors>>=
interface operator (*)
   module procedure conjspinor_spinor
end interface
private :: conjspinor_spinor
@
\begin{equation}
  \bar\psi\psi'
\end{equation}
NB: [[dot_product]] conjugates its first argument, we can either
cancel this or inline [[dot_product]]:
<<Implementation of operations for spinors>>=
pure function conjspinor_spinor (psibar, psi) result (psibarpsi)
  complex(kind=default) :: psibarpsi
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  psibarpsi = psibar%a(1)*psi%a(1) + psibar%a(2)*psi%a(2) &
            + psibar%a(3)*psi%a(3) + psibar%a(4)*psi%a(4)
end function conjspinor_spinor
@
\subsection{Spinor Vector Space}
\subsubsection{Scalar Multiplication}
<<Declaration of operations for spinors>>=
interface operator (*)
   module procedure integer_spinor, spinor_integer, &
        real_spinor, double_spinor, &
        complex_spinor, dcomplex_spinor, &
        spinor_real, spinor_double, &
        spinor_complex, spinor_dcomplex
end interface
private :: integer_spinor, spinor_integer, real_spinor, &
     double_spinor, complex_spinor, dcomplex_spinor, &
     spinor_real, spinor_double, spinor_complex, spinor_dcomplex
@
<<Implementation of operations for spinors>>=
pure function integer_spinor (x, y) result (xy)
  integer, intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function integer_spinor
@
<<Implementation of operations for spinors>>=
pure function real_spinor (x, y) result (xy)
  real(kind=single), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function real_spinor
pure function double_spinor (x, y) result (xy)
  real(kind=default), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function double_spinor
pure function complex_spinor (x, y) result (xy)
  complex(kind=single), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function complex_spinor
pure function dcomplex_spinor (x, y) result (xy)
  complex(kind=default), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function dcomplex_spinor
pure function spinor_integer (y, x) result (xy)
  integer, intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function spinor_integer
pure function spinor_real (y, x) result (xy)
  real(kind=single), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function spinor_real
pure function spinor_double (y, x) result (xy)
  real(kind=default), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function spinor_double
pure function spinor_complex (y, x) result (xy)
  complex(kind=single), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function spinor_complex
pure function spinor_dcomplex (y, x) result (xy)
  complex(kind=default), intent(in) :: x
  type(spinor), intent(in) :: y
  type(spinor) :: xy
  xy%a = x * y%a
end function spinor_dcomplex
@ 
<<Declaration of operations for spinors>>=
interface operator (*)
   module procedure integer_conjspinor, conjspinor_integer, &
        real_conjspinor, double_conjspinor, &
        complex_conjspinor, dcomplex_conjspinor, &
        conjspinor_real, conjspinor_double, &
        conjspinor_complex, conjspinor_dcomplex
end interface
private :: integer_conjspinor, conjspinor_integer, real_conjspinor, &
     double_conjspinor, complex_conjspinor, dcomplex_conjspinor, &
     conjspinor_real, conjspinor_double, conjspinor_complex, &
     conjspinor_dcomplex
@
<<Implementation of operations for spinors>>=
pure function integer_conjspinor (x, y) result (xy)
  integer, intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function integer_conjspinor
pure function real_conjspinor (x, y) result (xy)
  real(kind=single), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function real_conjspinor
pure function double_conjspinor (x, y) result (xy)
  real(kind=default), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function double_conjspinor
pure function complex_conjspinor (x, y) result (xy)
  complex(kind=single), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function complex_conjspinor
pure function dcomplex_conjspinor (x, y) result (xy)
  complex(kind=default), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function dcomplex_conjspinor
pure function conjspinor_integer (y, x) result (xy)
  integer, intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function conjspinor_integer
pure function conjspinor_real (y, x) result (xy)
  real(kind=single), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function conjspinor_real
pure function conjspinor_double (y, x) result (xy)
  real(kind=default), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function conjspinor_double
pure function conjspinor_complex (y, x) result (xy)
  complex(kind=single), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function conjspinor_complex
pure function conjspinor_dcomplex (y, x) result (xy)
  complex(kind=default), intent(in) :: x
  type(conjspinor), intent(in) :: y
  type(conjspinor) :: xy
  xy%a = x * y%a
end function conjspinor_dcomplex
@
\subsubsection{Unary Plus and Minus}
<<Declaration of operations for spinors>>=
interface operator (+)
   module procedure plus_spinor, plus_conjspinor
end interface
private :: plus_spinor, plus_conjspinor
interface operator (-)
   module procedure neg_spinor, neg_conjspinor
end interface
private :: neg_spinor, neg_conjspinor
@
<<Implementation of operations for spinors>>=
pure function plus_spinor (x) result (plus_x)
  type(spinor), intent(in) :: x
  type(spinor) :: plus_x
  plus_x%a = x%a
end function plus_spinor
pure function neg_spinor (x) result (neg_x)
  type(spinor), intent(in) :: x
  type(spinor) :: neg_x
  neg_x%a = - x%a
end function neg_spinor
@
<<Implementation of operations for spinors>>=
pure function plus_conjspinor (x) result (plus_x)
  type(conjspinor), intent(in) :: x
  type(conjspinor) :: plus_x
  plus_x%a = x%a
end function plus_conjspinor
pure function neg_conjspinor (x) result (neg_x)
  type(conjspinor), intent(in) :: x
  type(conjspinor) :: neg_x
  neg_x%a = - x%a
end function neg_conjspinor
@
\subsubsection{Addition and Subtraction}
<<Declaration of operations for spinors>>=
interface operator (+)
   module procedure add_spinor, add_conjspinor
end interface
private :: add_spinor, add_conjspinor
interface operator (-)
   module procedure sub_spinor, sub_conjspinor
end interface
private :: sub_spinor, sub_conjspinor
@
<<Implementation of operations for spinors>>=
pure function add_spinor (x, y) result (xy)
  type(spinor), intent(in) :: x, y
  type(spinor) :: xy
  xy%a = x%a + y%a
end function add_spinor
pure function sub_spinor (x, y) result (xy)
  type(spinor), intent(in) :: x, y
  type(spinor) :: xy
  xy%a = x%a - y%a
end function sub_spinor
@
<<Implementation of operations for spinors>>=
pure function add_conjspinor (x, y) result (xy)
  type(conjspinor), intent(in) :: x, y
  type(conjspinor) :: xy
  xy%a = x%a + y%a
end function add_conjspinor
pure function sub_conjspinor (x, y) result (xy)
  type(conjspinor), intent(in) :: x, y
  type(conjspinor) :: xy
  xy%a = x%a - y%a
end function sub_conjspinor
@
\subsection{Norm}
<<Declaration of operations for spinors>>=
interface abs
   module procedure abs_spinor, abs_conjspinor
end interface
private :: abs_spinor, abs_conjspinor
@
<<Implementation of operations for spinors>>=
pure function abs_spinor (psi) result (x)
  type(spinor), intent(in) :: psi
  real(kind=default) :: x
  x = sqrt (dot_product (psi%a, psi%a))
end function abs_spinor
@
<<Implementation of operations for spinors>>=
pure function abs_conjspinor (psibar) result (x)
  real(kind=default) :: x
  type(conjspinor), intent(in) :: psibar
  x = sqrt (dot_product (psibar%a, psibar%a))
end function abs_conjspinor
@ 
\section{Spinors Revisited}
<<[[omega_bispinors.f90]]>>=
<<Copyleft>>
module omega_bispinors
  use kinds
  use constants
  implicit none
  private
  public :: operator (*), operator (+), operator (-)
  public :: abs
  type, public :: bispinor
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default), dimension(4) :: a
  end type bispinor 
  <<Declaration of operations for bispinors>>
  integer, parameter, public :: omega_bispinors_2010_01_A = 0
contains
  <<Implementation of operations for bispinors>>
end module omega_bispinors                                      
@
<<Declaration of operations for bispinors>>=
interface operator (*)
  module procedure spinor_product
end interface
private :: spinor_product
@
\begin{equation}
  \bar\psi\psi'
\end{equation}
NB: [[dot_product]] conjugates its first argument, we have to cancel this.
<<Implementation of operations for bispinors>>=
pure function spinor_product (psil, psir) result (psilpsir)
  complex(kind=default) :: psilpsir
  type(bispinor), intent(in) :: psil, psir
  type(bispinor) :: psidum
  psidum%a(1) = psir%a(2)
  psidum%a(2) = - psir%a(1)
  psidum%a(3) = - psir%a(4)
  psidum%a(4) = psir%a(3)
  psilpsir = dot_product (conjg (psil%a), psidum%a)    
end function spinor_product
@
\subsection{Spinor Vector Space}
\subsubsection{Scalar Multiplication}
<<Declaration of operations for bispinors>>=
interface operator (*)
   module procedure integer_bispinor, bispinor_integer, &
          real_bispinor, double_bispinor, &
          complex_bispinor, dcomplex_bispinor, &
          bispinor_real, bispinor_double, &
          bispinor_complex, bispinor_dcomplex 
end interface
private :: integer_bispinor, bispinor_integer, real_bispinor, &
     double_bispinor, complex_bispinor, dcomplex_bispinor, &
     bispinor_real, bispinor_double, bispinor_complex, bispinor_dcomplex
@
<<Implementation of operations for bispinors>>=
pure function integer_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  integer, intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function integer_bispinor
@
<<Implementation of operations for bispinors>>=
pure function real_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  real(kind=single), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function real_bispinor
@
<<Implementation of operations for bispinors>>=
pure function double_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  real(kind=default), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function double_bispinor      
@
<<Implementation of operations for bispinors>>=
pure function complex_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  complex(kind=single), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function complex_bispinor
@
<<Implementation of operations for bispinors>>=
pure function dcomplex_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  complex(kind=default), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function dcomplex_bispinor   
@
<<Implementation of operations for bispinors>>=
pure function bispinor_integer (y, x) result (xy)
  type(bispinor) :: xy
  integer, intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function bispinor_integer
@
<<Implementation of operations for bispinors>>=
pure function bispinor_real (y, x) result (xy)
  type(bispinor) :: xy
  real(kind=single), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function bispinor_real
@
<<Implementation of operations for bispinors>>=
pure function bispinor_double (y, x) result (xy)
  type(bispinor) :: xy
  real(kind=default), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function bispinor_double         
@
<<Implementation of operations for bispinors>>=
pure function bispinor_complex (y, x) result (xy)
  type(bispinor) :: xy
  complex(kind=single), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function bispinor_complex
@
<<Implementation of operations for bispinors>>=
pure function bispinor_dcomplex (y, x) result (xy)
  type(bispinor) :: xy
  complex(kind=default), intent(in) :: x
  type(bispinor), intent(in) :: y
  xy%a = x * y%a
end function bispinor_dcomplex         
@
\subsubsection{Unary Plus and Minus}
<<Declaration of operations for bispinors>>=
interface operator (+)
   module procedure plus_bispinor
end interface
private :: plus_bispinor
interface operator (-)
   module procedure neg_bispinor
end interface
private :: neg_bispinor
@
<<Implementation of operations for bispinors>>=
pure function plus_bispinor (x) result (plus_x)
  type(bispinor) :: plus_x
  type(bispinor), intent(in) :: x
  plus_x%a = x%a
end function plus_bispinor
@
<<Implementation of operations for bispinors>>=
pure function neg_bispinor (x) result (neg_x)
  type(bispinor) :: neg_x
  type(bispinor), intent(in) :: x
  neg_x%a = - x%a
end function neg_bispinor
@
\subsubsection{Addition and Subtraction}
<<Declaration of operations for bispinors>>=
interface operator (+)
   module procedure add_bispinor
end interface
private :: add_bispinor
interface operator (-)
   module procedure sub_bispinor
end interface
private :: sub_bispinor
@
<<Implementation of operations for bispinors>>=
pure function add_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  type(bispinor), intent(in) :: x, y
  xy%a = x%a + y%a
end function add_bispinor
@
<<Implementation of operations for bispinors>>=
pure function sub_bispinor (x, y) result (xy)
  type(bispinor) :: xy
  type(bispinor), intent(in) :: x, y
  xy%a = x%a - y%a
end function sub_bispinor
@
\subsection{Norm}
<<Declaration of operations for bispinors>>=
interface abs
   module procedure abs_bispinor
end interface
private :: abs_bispinor
@
<<Implementation of operations for bispinors>>=
pure function abs_bispinor (psi) result (x)
  real(kind=default) :: x
  type(bispinor), intent(in) :: psi
  x = sqrt (dot_product (psi%a, psi%a))
end function abs_bispinor
@
\section{Vectorspinors}
<<[[omega_vectorspinors.f90]]>>=
<<Copyleft>>
module omega_vectorspinors
  use kinds
  use constants
  use omega_bispinors
  use omega_vectors
  implicit none
  private
  public :: operator (*), operator (+), operator (-)
  public :: abs
  type, public :: vectorspinor
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     type(bispinor), dimension(4) :: psi
  end type vectorspinor 
  <<Declaration of operations for vectorspinors>>
  integer, parameter, public :: omega_vectorspinors_2010_01_A = 0
contains
  <<Implementation of operations for vectorspinors>>
end module omega_vectorspinors                                      
@
<<Declaration of operations for vectorspinors>>=
interface operator (*)
  module procedure vspinor_product
end interface
private :: vspinor_product
@
\begin{equation}
  \bar\psi^\mu\psi'_\mu
\end{equation}
<<Implementation of operations for vectorspinors>>= 
pure function vspinor_product (psil, psir) result (psilpsir)
  complex(kind=default) :: psilpsir
  type(vectorspinor), intent(in) :: psil, psir
  psilpsir =   psil%psi(1) * psir%psi(1) &
	     - psil%psi(2) * psir%psi(2) &
	     - psil%psi(3) * psir%psi(3) &
	     - psil%psi(4) * psir%psi(4) 
end function vspinor_product
@
\subsection{Vectorspinor Vector Space}
\subsubsection{Scalar Multiplication}
<<Declaration of operations for vectorspinors>>=
interface operator (*)
   module procedure integer_vectorspinor, vectorspinor_integer, &
          real_vectorspinor, double_vectorspinor, &
          complex_vectorspinor, dcomplex_vectorspinor, &
          vectorspinor_real, vectorspinor_double, &
          vectorspinor_complex, vectorspinor_dcomplex, &
          momentum_vectorspinor, vectorspinor_momentum
end interface
private :: integer_vectorspinor, vectorspinor_integer, real_vectorspinor, &
     double_vectorspinor, complex_vectorspinor, dcomplex_vectorspinor, &
     vectorspinor_real, vectorspinor_double, vectorspinor_complex, & 
     vectorspinor_dcomplex
@
<<Implementation of operations for vectorspinors>>=
pure function integer_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  integer, intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4 
    xy%psi(k) = x * y%psi(k)
  end do
end function integer_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function real_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  real(kind=single), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = x * y%psi(k)
  end do 
end function real_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function double_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  real(kind=default), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = x * y%psi(k)
  end do
end function double_vectorspinor      
@
<<Implementation of operations for vectorspinors>>=
pure function complex_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  complex(kind=single), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = x * y%psi(k)
  end do
end function complex_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function dcomplex_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  complex(kind=default), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = x * y%psi(k)
  end do
end function dcomplex_vectorspinor   
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_integer (y, x) result (xy)
  type(vectorspinor) :: xy
  integer, intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = y%psi(k) * x
  end do
end function vectorspinor_integer
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_real (y, x) result (xy)
  type(vectorspinor) :: xy
  real(kind=single), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = y%psi(k) * x
  end do
end function vectorspinor_real
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_double (y, x) result (xy)
  type(vectorspinor) :: xy
  real(kind=default), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = y%psi(k) * x
  end do
end function vectorspinor_double         
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_complex (y, x) result (xy)
  type(vectorspinor) :: xy
  complex(kind=single), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = y%psi(k) * x
  end do
end function vectorspinor_complex
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_dcomplex (y, x) result (xy)
  type(vectorspinor) :: xy
  complex(kind=default), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%psi(k) = y%psi(k) * x
  end do
end function vectorspinor_dcomplex         
@
<<Implementation of operations for vectorspinors>>=
pure function momentum_vectorspinor (y, x) result (xy)
  type(bispinor) :: xy
  type(momentum), intent(in) :: y
  type(vectorspinor), intent(in) :: x
  integer :: k
  do k = 1,4
  xy%a(k) = y%t    * x%psi(1)%a(k) - y%x(1) * x%psi(2)%a(k) - &
          y%x(2) * x%psi(3)%a(k) - y%x(3) * x%psi(4)%a(k)
  end do
end function momentum_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function vectorspinor_momentum (y, x) result (xy)
  type(bispinor) :: xy
  type(momentum), intent(in) :: x
  type(vectorspinor), intent(in) :: y
  integer :: k
  do k = 1,4
  xy%a(k) = x%t    * y%psi(1)%a(k) - x%x(1) * y%psi(2)%a(k) - &
          x%x(2) * y%psi(3)%a(k) - x%x(3) * y%psi(4)%a(k)
  end do
end function vectorspinor_momentum
@   
\subsubsection{Unary Plus and Minus}
<<Declaration of operations for vectorspinors>>=
interface operator (+)
   module procedure plus_vectorspinor
end interface
private :: plus_vectorspinor
interface operator (-)
   module procedure neg_vectorspinor
end interface
private :: neg_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function plus_vectorspinor (x) result (plus_x)
  type(vectorspinor) :: plus_x
  type(vectorspinor), intent(in) :: x
  integer :: k
  do k = 1,4
  plus_x%psi(k) = + x%psi(k)
  end do
end function plus_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function neg_vectorspinor (x) result (neg_x)
  type(vectorspinor) :: neg_x
  type(vectorspinor), intent(in) :: x
  integer :: k
  do k = 1,4
  neg_x%psi(k) = - x%psi(k)
  end do
end function neg_vectorspinor
@
\subsubsection{Addition and Subtraction}
<<Declaration of operations for vectorspinors>>=
interface operator (+)
   module procedure add_vectorspinor
end interface
private :: add_vectorspinor
interface operator (-)
   module procedure sub_vectorspinor
end interface
private :: sub_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function add_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  type(vectorspinor), intent(in) :: x, y
  integer :: k
  do k = 1,4
  xy%psi(k) = x%psi(k) + y%psi(k)
  end do
end function add_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function sub_vectorspinor (x, y) result (xy)
  type(vectorspinor) :: xy
  type(vectorspinor), intent(in) :: x, y
  integer :: k
  do k = 1,4
  xy%psi(k) = x%psi(k) - y%psi(k)
  end do
end function sub_vectorspinor
@
\subsection{Norm}
<<Declaration of operations for vectorspinors>>=
interface abs
   module procedure abs_vectorspinor
end interface
private :: abs_vectorspinor
@
<<Implementation of operations for vectorspinors>>=
pure function abs_vectorspinor (psi) result (x)
  real(kind=default) :: x
  type(vectorspinor), intent(in) :: psi
  x = sqrt (dot_product (psi%psi(1)%a, psi%psi(1)%a) &
	- dot_product (psi%psi(2)%a, psi%psi(2)%a)   &
	- dot_product (psi%psi(3)%a, psi%psi(3)%a)   &
	- dot_product (psi%psi(4)%a, psi%psi(4)%a))
end function abs_vectorspinor
@
\section{Vectors and Tensors}
Condensed representation of antisymmetric rank-2 tensors:
\begin{equation}
   \begin{pmatrix}
     T^{00} & T^{01} & T^{02} & T^{03} \\
     T^{10} & T^{11} & T^{12} & T^{13} \\
     T^{20} & T^{21} & T^{22} & T^{23} \\
     T^{30} & T^{31} & T^{32} & T^{33}
   \end{pmatrix}
    =
   \begin{pmatrix}
      0      &  T_e^1  &  T_e^2  &  T_e^3  \\
     -T_e^1  &  0      &  T_b^3  & -T_b^2  \\
     -T_e^2  & -T_b^3  &  0      &  T_b^1  \\
     -T_e^3  &  T_b^2  & -T_b^1  &  0
   \end{pmatrix}
\end{equation}
<<[[omega_vectors.f90]]>>=
<<Copyleft>>
module omega_vectors
  use kinds
  use constants
  implicit none
  private
  public :: assignment (=)
  public :: operator (*), operator (+), operator (-), operator (.wedge.)
  public :: abs, conjg
  public :: random_momentum
  <<[[intrinsic :: abs]]>>
  <<[[intrinsic :: conjg]]>>
  type, public :: momentum
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     real(kind=default) :: t
     real(kind=default), dimension(3) :: x
  end type momentum
  type, public :: vector
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default) :: t
     complex(kind=default), dimension(3) :: x
  end type vector
  type, public :: tensor2odd
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default), dimension(3) :: e
     complex(kind=default), dimension(3) :: b
  end type tensor2odd
  <<Declaration of operations for vectors>>
  integer, parameter, public :: omega_vectors_2010_01_A = 0
contains
  <<Implementation of operations for vectors>>
end module omega_vectors
@
\subsection{Constructors}
<<Declaration of operations for vectors>>=
interface assignment (=)
   module procedure momentum_of_array, vector_of_momentum, &
        vector_of_array, vector_of_double_array, &
        array_of_momentum, array_of_vector
end interface
private :: momentum_of_array, vector_of_momentum, vector_of_array, &
     vector_of_double_array, array_of_momentum, array_of_vector
@
<<Implementation of operations for vectors>>=
pure subroutine momentum_of_array (m, p)
  type(momentum), intent(out) :: m
  real(kind=default), dimension(0:), intent(in) :: p
  m%t = p(0)
  m%x = p(1:3)
end subroutine momentum_of_array
pure subroutine array_of_momentum (p, v)
  real(kind=default), dimension(0:), intent(out) :: p
  type(momentum), intent(in) :: v
  p(0) = v%t
  p(1:3) = v%x
end subroutine array_of_momentum
@
<<Implementation of operations for vectors>>=
pure subroutine vector_of_array (v, p)
  type(vector), intent(out) :: v
  complex(kind=default), dimension(0:), intent(in) :: p
  v%t = p(0)
  v%x = p(1:3)
end subroutine vector_of_array
pure subroutine vector_of_double_array (v, p)
  type(vector), intent(out) :: v
  real(kind=default), dimension(0:), intent(in) :: p
  v%t = p(0)
  v%x = p(1:3)
end subroutine vector_of_double_array
pure subroutine array_of_vector (p, v)
  complex(kind=default), dimension(0:), intent(out) :: p
  type(vector), intent(in) :: v
  p(0) = v%t
  p(1:3) = v%x
end subroutine array_of_vector
@
<<Implementation of operations for vectors>>=
pure subroutine vector_of_momentum (v, p)
  type(vector), intent(out) :: v
  type(momentum), intent(in) :: p
  v%t = p%t
  v%x = p%x
end subroutine vector_of_momentum
@
\subsection{Inner Products}
<<Declaration of operations for vectors>>=
interface operator (*)
   module procedure momentum_momentum, vector_vector, &
        vector_momentum, momentum_vector, tensor2odd_tensor2odd
end interface
private :: momentum_momentum, vector_vector, vector_momentum, &
     momentum_vector, tensor2odd_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function momentum_momentum (x, y) result (xy)
  type(momentum), intent(in) :: x
  type(momentum), intent(in) :: y
  real(kind=default) :: xy
  xy = x%t*y%t - x%x(1)*y%x(1) - x%x(2)*y%x(2) - x%x(3)*y%x(3)
end function momentum_momentum
pure function momentum_vector (x, y) result (xy)
  type(momentum), intent(in) :: x
  type(vector), intent(in) :: y
  complex(kind=default) :: xy
  xy = x%t*y%t - x%x(1)*y%x(1) - x%x(2)*y%x(2) - x%x(3)*y%x(3)
end function momentum_vector
pure function vector_momentum (x, y) result (xy)
  type(vector), intent(in) :: x
  type(momentum), intent(in) :: y
  complex(kind=default) :: xy
  xy = x%t*y%t - x%x(1)*y%x(1) - x%x(2)*y%x(2) - x%x(3)*y%x(3)
end function vector_momentum
pure function vector_vector (x, y) result (xy)
  type(vector), intent(in) :: x
  type(vector), intent(in) :: y
  complex(kind=default) :: xy
  xy = x%t*y%t - x%x(1)*y%x(1) - x%x(2)*y%x(2) - x%x(3)*y%x(3)
end function vector_vector
@
Just like classical electrodynamics:
\begin{equation}
   \frac{1}{2} T_{\mu\nu} U^{\mu\nu}
     = \frac{1}{2} \left( - T^{0i} U^{0i} - T^{i0} U^{i0} + T^{ij} U^{ij} \right)
     = T_b^k U_b^k - T_e^k U_e^k
\end{equation}
<<Implementation of operations for vectors>>=
pure function tensor2odd_tensor2odd (x, y) result (xy)
  type(tensor2odd), intent(in) :: x
  type(tensor2odd), intent(in) :: y
  complex(kind=default) :: xy
  xy = x%b(1)*y%b(1) + x%b(2)*y%b(2) + x%b(3)*y%b(3) &
     - x%e(1)*y%e(1) - x%e(2)*y%e(2) - x%e(3)*y%e(3)
end function tensor2odd_tensor2odd
@
\subsection{Not Entirely Inner Products}
<<Declaration of operations for vectors>>=
interface operator (*)
   module procedure momentum_tensor2odd, tensor2odd_momentum, &
        vector_tensor2odd, tensor2odd_vector
end interface
private :: momentum_tensor2odd, tensor2odd_momentum, vector_tensor2odd, &
     tensor2odd_vector
@
\begin{subequations}
\begin{align}
   y^\nu = x_\mu T^{\mu\nu}:
     & y^0 = - x^i T^{i0} = x^i T^{0i} \\
     & y^1 = x^0 T^{01} - x^2 T^{21} - x^3 T^{31} \\
     & y^2 = x^0 T^{02} - x^1 T^{12} - x^3 T^{32} \\
     & y^3 = x^0 T^{03} - x^1 T^{13} - x^2 T^{23}
\end{align}
\end{subequations}
<<Implementation of operations for vectors>>=
pure function vector_tensor2odd (x, t2) result (xt2)
  type(vector), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(vector) :: xt2
  xt2%t = x%x(1)*t2%e(1) + x%x(2)*t2%e(2) + x%x(3)*t2%e(3)
  xt2%x(1) = x%t*t2%e(1) + x%x(2)*t2%b(3) - x%x(3)*t2%b(2)
  xt2%x(2) = x%t*t2%e(2) + x%x(3)*t2%b(1) - x%x(1)*t2%b(3)
  xt2%x(3) = x%t*t2%e(3) + x%x(1)*t2%b(2) - x%x(2)*t2%b(1)
end function vector_tensor2odd
pure function momentum_tensor2odd (x, t2) result (xt2)
  type(momentum), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(vector) :: xt2
  xt2%t = x%x(1)*t2%e(1) + x%x(2)*t2%e(2) + x%x(3)*t2%e(3)
  xt2%x(1) = x%t*t2%e(1) + x%x(2)*t2%b(3) - x%x(3)*t2%b(2)
  xt2%x(2) = x%t*t2%e(2) + x%x(3)*t2%b(1) - x%x(1)*t2%b(3)
  xt2%x(3) = x%t*t2%e(3) + x%x(1)*t2%b(2) - x%x(2)*t2%b(1)
end function momentum_tensor2odd
@
\begin{subequations}
\begin{align}
   y^\mu = T^{\mu\nu} x_\nu :
     & y^0 = - T^{0i} x^i \\
     & y^1 = T^{10} x^0 - T^{12} x^2 - T^{13} x^3 \\
     & y^2 = T^{20} x^0 - T^{21} x^1 - T^{23} x^3 \\
     & y^3 = T^{30} x^0 - T^{31} x^1 - T^{32} x^2
\end{align}
\end{subequations}
<<Implementation of operations for vectors>>=
pure function tensor2odd_vector (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  type(vector), intent(in) :: x
  type(vector) :: t2x
  t2x%t = - t2%e(1)*x%x(1) - t2%e(2)*x%x(2) - t2%e(3)*x%x(3)
  t2x%x(1) = - t2%e(1)*x%t + t2%b(2)*x%x(3) - t2%b(3)*x%x(2)
  t2x%x(2) = - t2%e(2)*x%t + t2%b(3)*x%x(1) - t2%b(1)*x%x(3)
  t2x%x(3) = - t2%e(3)*x%t + t2%b(1)*x%x(2) - t2%b(2)*x%x(1)
end function tensor2odd_vector
pure function tensor2odd_momentum (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  type(momentum), intent(in) :: x
  type(vector) :: t2x
  t2x%t = - t2%e(1)*x%x(1) - t2%e(2)*x%x(2) - t2%e(3)*x%x(3)
  t2x%x(1) = - t2%e(1)*x%t + t2%b(2)*x%x(3) - t2%b(3)*x%x(2)
  t2x%x(2) = - t2%e(2)*x%t + t2%b(3)*x%x(1) - t2%b(1)*x%x(3)
  t2x%x(3) = - t2%e(3)*x%t + t2%b(1)*x%x(2) - t2%b(2)*x%x(1)
end function tensor2odd_momentum
@
\subsection{Outer Products}
<<Declaration of operations for vectors>>=
interface operator (.wedge.)
   module procedure momentum_wedge_momentum, &
        momentum_wedge_vector, vector_wedge_momentum, vector_wedge_vector
end interface
private :: momentum_wedge_momentum, momentum_wedge_vector, &
     vector_wedge_momentum, vector_wedge_vector
@
<<Implementation of operations for vectors>>=
pure function momentum_wedge_momentum (x, y) result (t2)
  type(momentum), intent(in) :: x
  type(momentum), intent(in) :: y
  type(tensor2odd) :: t2
  t2%e = x%t * y%x - x%x * y%t
  t2%b(1) = x%x(2) * y%x(3) - x%x(3) * y%x(2)
  t2%b(2) = x%x(3) * y%x(1) - x%x(1) * y%x(3)
  t2%b(3) = x%x(1) * y%x(2) - x%x(2) * y%x(1)
end function momentum_wedge_momentum
pure function momentum_wedge_vector (x, y) result (t2)
  type(momentum), intent(in) :: x
  type(vector), intent(in) :: y
  type(tensor2odd) :: t2
  t2%e = x%t * y%x - x%x * y%t
  t2%b(1) = x%x(2) * y%x(3) - x%x(3) * y%x(2)
  t2%b(2) = x%x(3) * y%x(1) - x%x(1) * y%x(3)
  t2%b(3) = x%x(1) * y%x(2) - x%x(2) * y%x(1)
end function momentum_wedge_vector
pure function vector_wedge_momentum (x, y) result (t2)
  type(vector), intent(in) :: x
  type(momentum), intent(in) :: y
  type(tensor2odd) :: t2
  t2%e = x%t * y%x - x%x * y%t
  t2%b(1) = x%x(2) * y%x(3) - x%x(3) * y%x(2)
  t2%b(2) = x%x(3) * y%x(1) - x%x(1) * y%x(3)
  t2%b(3) = x%x(1) * y%x(2) - x%x(2) * y%x(1)
end function vector_wedge_momentum
pure function vector_wedge_vector (x, y) result (t2)
  type(vector), intent(in) :: x
  type(vector), intent(in) :: y
  type(tensor2odd) :: t2
  t2%e = x%t * y%x - x%x * y%t
  t2%b(1) = x%x(2) * y%x(3) - x%x(3) * y%x(2)
  t2%b(2) = x%x(3) * y%x(1) - x%x(1) * y%x(3)
  t2%b(3) = x%x(1) * y%x(2) - x%x(2) * y%x(1)
end function vector_wedge_vector
@
\subsection{Vector Space}
\subsubsection{Scalar Multiplication}
<<Declaration of operations for vectors>>=
interface operator (*)
   module procedure integer_momentum, real_momentum, double_momentum, &
        complex_momentum, dcomplex_momentum, &
        integer_vector, real_vector, double_vector, &
        complex_vector, dcomplex_vector, &
        integer_tensor2odd, real_tensor2odd, double_tensor2odd, &
        complex_tensor2odd, dcomplex_tensor2odd, &
        momentum_integer, momentum_real, momentum_double, &
        momentum_complex, momentum_dcomplex, &
        vector_integer, vector_real, vector_double, &
        vector_complex, vector_dcomplex, &
        tensor2odd_integer, tensor2odd_real, tensor2odd_double, &
        tensor2odd_complex, tensor2odd_dcomplex
end interface
private :: integer_momentum, real_momentum, double_momentum, &
     complex_momentum, dcomplex_momentum, integer_vector, real_vector, &
     double_vector, complex_vector, dcomplex_vector, &
     integer_tensor2odd, real_tensor2odd, double_tensor2odd, &
     complex_tensor2odd, dcomplex_tensor2odd, momentum_integer, &
     momentum_real, momentum_double, momentum_complex, &
     momentum_dcomplex, vector_integer, vector_real, vector_double, &
     vector_complex, vector_dcomplex, tensor2odd_integer, &
     tensor2odd_real, tensor2odd_double, tensor2odd_complex, &
     tensor2odd_dcomplex
@
<<Implementation of operations for vectors>>=
pure function integer_momentum (x, y) result (xy)
  integer, intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function integer_momentum
pure function real_momentum (x, y) result (xy)
  real(kind=single), intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function real_momentum
pure function double_momentum (x, y) result (xy)
  real(kind=default), intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function double_momentum
pure function complex_momentum (x, y) result (xy)
  complex(kind=single), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function complex_momentum
pure function dcomplex_momentum (x, y) result (xy)
  complex(kind=default), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function dcomplex_momentum
@
<<Implementation of operations for vectors>>=
pure function integer_vector (x, y) result (xy)
  integer, intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function integer_vector
pure function real_vector (x, y) result (xy)
  real(kind=single), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function real_vector
pure function double_vector (x, y) result (xy)
  real(kind=default), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function double_vector
pure function complex_vector (x, y) result (xy)
  complex(kind=single), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function complex_vector
pure function dcomplex_vector (x, y) result (xy)
  complex(kind=default), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function dcomplex_vector
@
<<Implementation of operations for vectors>>=
pure function integer_tensor2odd (x, t2) result (xt2)
  integer, intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: xt2
  xt2%e = x * t2%e
  xt2%b = x * t2%b
end function integer_tensor2odd
pure function real_tensor2odd (x, t2) result (xt2)
  real(kind=single), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: xt2
  xt2%e = x * t2%e
  xt2%b = x * t2%b
end function real_tensor2odd
pure function double_tensor2odd (x, t2) result (xt2)
  real(kind=default), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: xt2
  xt2%e = x * t2%e
  xt2%b = x * t2%b
end function double_tensor2odd
pure function complex_tensor2odd (x, t2) result (xt2)
  complex(kind=single), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: xt2
  xt2%e = x * t2%e
  xt2%b = x * t2%b
end function complex_tensor2odd
pure function dcomplex_tensor2odd (x, t2) result (xt2)
  complex(kind=default), intent(in) :: x
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: xt2
  xt2%e = x * t2%e
  xt2%b = x * t2%b
end function dcomplex_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function momentum_integer (y, x) result (xy)
  integer, intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function momentum_integer
pure function momentum_real (y, x) result (xy)
  real(kind=single), intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function momentum_real
pure function momentum_double (y, x) result (xy)
  real(kind=default), intent(in) :: x
  type(momentum), intent(in) :: y
  type(momentum) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function momentum_double
pure function momentum_complex (y, x) result (xy)
  complex(kind=single), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function momentum_complex
pure function momentum_dcomplex (y, x) result (xy)
  complex(kind=default), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function momentum_dcomplex
@
<<Implementation of operations for vectors>>=
pure function vector_integer (y, x) result (xy)
  integer, intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function vector_integer
pure function vector_real (y, x) result (xy)
  real(kind=single), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function vector_real
pure function vector_double (y, x) result (xy)
  real(kind=default), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function vector_double
pure function vector_complex (y, x) result (xy)
  complex(kind=single), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function vector_complex
pure function vector_dcomplex (y, x) result (xy)
  complex(kind=default), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x * y%t
  xy%x = x * y%x
end function vector_dcomplex
@
<<Implementation of operations for vectors>>=
pure function tensor2odd_integer (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  integer, intent(in) :: x
  type(tensor2odd) :: t2x
  t2x%e = x * t2%e
  t2x%b = x * t2%b
end function tensor2odd_integer
pure function tensor2odd_real (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  real(kind=single), intent(in) :: x
  type(tensor2odd) :: t2x
  t2x%e = x * t2%e
  t2x%b = x * t2%b
end function tensor2odd_real
pure function tensor2odd_double (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  real(kind=default), intent(in) :: x
  type(tensor2odd) :: t2x
  t2x%e = x * t2%e
  t2x%b = x * t2%b
end function tensor2odd_double
pure function tensor2odd_complex (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  complex(kind=single), intent(in) :: x
  type(tensor2odd) :: t2x
  t2x%e = x * t2%e
  t2x%b = x * t2%b
end function tensor2odd_complex
pure function tensor2odd_dcomplex (t2, x) result (t2x)
  type(tensor2odd), intent(in) :: t2
  complex(kind=default), intent(in) :: x
  type(tensor2odd) :: t2x
  t2x%e = x * t2%e
  t2x%b = x * t2%b
end function tensor2odd_dcomplex
@
\subsubsection{Unary Plus and Minus}
<<Declaration of operations for vectors>>=
interface operator (+)
   module procedure plus_momentum, plus_vector, plus_tensor2odd
end interface
private :: plus_momentum, plus_vector, plus_tensor2odd
interface operator (-)
   module procedure neg_momentum, neg_vector, neg_tensor2odd
end interface
private :: neg_momentum, neg_vector, neg_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function plus_momentum (x) result (plus_x)
  type(momentum), intent(in) :: x
  type(momentum) :: plus_x
  plus_x = x
end function plus_momentum
pure function neg_momentum (x) result (neg_x)
  type(momentum), intent(in) :: x
  type(momentum) :: neg_x
  neg_x%t = - x%t
  neg_x%x = - x%x
end function neg_momentum
@
<<Implementation of operations for vectors>>=
pure function plus_vector (x) result (plus_x)
  type(vector), intent(in) :: x
  type(vector) :: plus_x
  plus_x = x
end function plus_vector
pure function neg_vector (x) result (neg_x)
  type(vector), intent(in) :: x
  type(vector) :: neg_x
  neg_x%t = - x%t
  neg_x%x = - x%x
end function neg_vector
@
<<Implementation of operations for vectors>>=
pure function plus_tensor2odd (x) result (plus_x)
  type(tensor2odd), intent(in) :: x
  type(tensor2odd) :: plus_x
  plus_x = x
end function plus_tensor2odd
pure function neg_tensor2odd (x) result (neg_x)
  type(tensor2odd), intent(in) :: x
  type(tensor2odd) :: neg_x
  neg_x%e = - x%e
  neg_x%b = - x%b
end function neg_tensor2odd
@
\subsubsection{Addition and Subtraction}
<<Declaration of operations for vectors>>=
interface operator (+)
   module procedure add_momentum, add_vector, &
        add_vector_momentum, add_momentum_vector, add_tensor2odd
end interface
private :: add_momentum, add_vector, add_vector_momentum, &
     add_momentum_vector, add_tensor2odd
interface operator (-)
   module procedure sub_momentum, sub_vector, &
        sub_vector_momentum, sub_momentum_vector, sub_tensor2odd
end interface
private :: sub_momentum, sub_vector, sub_vector_momentum, &
     sub_momentum_vector, sub_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function add_momentum (x, y) result (xy)
  type(momentum), intent(in) :: x, y
  type(momentum) :: xy
  xy%t = x%t + y%t
  xy%x = x%x + y%x
end function add_momentum
pure function add_vector (x, y) result (xy)
  type(vector), intent(in) :: x, y
  type(vector) :: xy
  xy%t = x%t + y%t
  xy%x = x%x + y%x
end function add_vector
pure function add_momentum_vector (x, y) result (xy)
  type(momentum), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x%t + y%t
  xy%x = x%x + y%x
end function add_momentum_vector
pure function add_vector_momentum (x, y) result (xy)
  type(vector), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x%t + y%t
  xy%x = x%x + y%x
end function add_vector_momentum
pure function add_tensor2odd (x, y) result (xy)
  type(tensor2odd), intent(in) :: x, y
  type(tensor2odd) :: xy
  xy%e = x%e + y%e
  xy%b = x%b + y%b
end function add_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function sub_momentum (x, y) result (xy)
  type(momentum), intent(in) :: x, y
  type(momentum) :: xy
  xy%t = x%t - y%t
  xy%x = x%x - y%x
end function sub_momentum
pure function sub_vector (x, y) result (xy)
  type(vector), intent(in) :: x, y
  type(vector) :: xy
  xy%t = x%t - y%t
  xy%x = x%x - y%x
end function sub_vector
pure function sub_momentum_vector (x, y) result (xy)
  type(momentum), intent(in) :: x
  type(vector), intent(in) :: y
  type(vector) :: xy
  xy%t = x%t - y%t
  xy%x = x%x - y%x
end function sub_momentum_vector
pure function sub_vector_momentum (x, y) result (xy)
  type(vector), intent(in) :: x
  type(momentum), intent(in) :: y
  type(vector) :: xy
  xy%t = x%t - y%t
  xy%x = x%x - y%x
end function sub_vector_momentum
pure function sub_tensor2odd (x, y) result (xy)
  type(tensor2odd), intent(in) :: x, y
  type(tensor2odd) :: xy
  xy%e = x%e - y%e
  xy%b = x%b - y%b
end function sub_tensor2odd
@
\subsection{Norm}
\emph{Not} the covariant length!
<<Declaration of operations for vectors>>=
interface abs
   module procedure abs_momentum, abs_vector, abs_tensor2odd
end interface
private :: abs_momentum, abs_vector, abs_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function abs_momentum (x) result (absx)
  type(momentum), intent(in) :: x
  real(kind=default) :: absx
  absx = sqrt (x%t*x%t + dot_product (x%x, x%x))
end function abs_momentum
pure function abs_vector (x) result (absx)
  type(vector), intent(in) :: x
  real(kind=default) :: absx
  absx = sqrt (conjg(x%t)*x%t + dot_product (x%x, x%x))
end function abs_vector
pure function abs_tensor2odd (x) result (absx)
  type(tensor2odd), intent(in) :: x
  real(kind=default) :: absx
  absx = sqrt (dot_product (x%e, x%e) + dot_product (x%b, x%b))
end function abs_tensor2odd
@
\subsection{Conjugation}
<<Declaration of operations for vectors>>=
interface conjg
   module procedure conjg_momentum, conjg_vector, conjg_tensor2odd
end interface
private :: conjg_momentum, conjg_vector, conjg_tensor2odd
@
<<Implementation of operations for vectors>>=
pure function conjg_momentum (x) result (conjg_x)
  type(momentum), intent(in) :: x
  type(momentum) :: conjg_x
  conjg_x = x
end function conjg_momentum
pure function conjg_vector (x) result (conjg_x)
  type(vector), intent(in) :: x
  type(vector) :: conjg_x
  conjg_x%t = conjg (x%t)
  conjg_x%x = conjg (x%x)
end function conjg_vector
pure function conjg_tensor2odd (t2) result (conjg_t2)
  type(tensor2odd), intent(in) :: t2
  type(tensor2odd) :: conjg_t2
  conjg_t2%e = conjg (t2%e)
  conjg_t2%b = conjg (t2%b)
end function conjg_tensor2odd
@
\subsection{$\epsilon$-Tensors}
\begin{equation}
  \epsilon_{0123} = 1 = - \epsilon^{0123}
\end{equation}
in particular
\begin{equation}
  \epsilon(p_1,p_2,p_3,p_4)
     = \epsilon_{\mu_1\mu_2\mu_3\mu_4}
         p_1^{\mu_1}p_2^{\mu_2}p_3^{\mu_3}p_4^{\mu_4}
     = p_1^0 p_2^1 p_3^2 p_4^3 \pm \ldots
\end{equation}
<<Declaration of operations for vectors>>=
interface pseudo_scalar
   module procedure pseudo_scalar_momentum, pseudo_scalar_vector, &
        pseudo_scalar_vec_mom
end interface
public :: pseudo_scalar
private :: pseudo_scalar_momentum, pseudo_scalar_vector
@
<<Implementation of operations for vectors>>=
pure function pseudo_scalar_momentum (p1, p2, p3, p4) result (eps1234)
  type(momentum), intent(in) :: p1, p2, p3, p4
  real(kind=default) :: eps1234
  eps1234 = &
       p1%t    * p2%x(1) * (p3%x(2) * p4%x(3) - p3%x(3) * p4%x(2)) &
     + p1%t    * p2%x(2) * (p3%x(3) * p4%x(1) - p3%x(1) * p4%x(3)) &
     + p1%t    * p2%x(3) * (p3%x(1) * p4%x(2) - p3%x(2) * p4%x(1)) &
     - p1%x(1) * p2%x(2) * (p3%x(3) * p4%t    - p3%t    * p4%x(3)) &
     - p1%x(1) * p2%x(3) * (p3%t    * p4%x(2) - p3%x(2) * p4%t   ) &
     - p1%x(1) * p2%t    * (p3%x(2) * p4%x(3) - p3%x(3) * p4%x(2)) &
     + p1%x(2) * p2%x(3) * (p3%t    * p4%x(1) - p3%x(1) * p4%t   ) &
     + p1%x(2) * p2%t    * (p3%x(1) * p4%x(3) - p3%x(3) * p4%x(1)) &
     + p1%x(2) * p2%x(1) * (p3%x(3) * p4%t    - p3%t    * p4%x(3)) &
     - p1%x(3) * p2%t    * (p3%x(1) * p4%x(2) - p3%x(2) * p4%x(1)) &
     - p1%x(3) * p2%x(1) * (p3%x(2) * p4%t    - p3%t    * p4%x(2)) &
     - p1%x(3) * p2%x(2) * (p3%t    * p4%x(1) - p3%x(1) * p4%t   )
end function pseudo_scalar_momentum
@ 
<<Implementation of operations for vectors>>=
pure function pseudo_scalar_vector (p1, p2, p3, p4) result (eps1234)
  type(vector), intent(in) :: p1, p2, p3, p4
  complex(kind=default) :: eps1234
  eps1234 = &
       p1%t    * p2%x(1) * (p3%x(2) * p4%x(3) - p3%x(3) * p4%x(2)) &
     + p1%t    * p2%x(2) * (p3%x(3) * p4%x(1) - p3%x(1) * p4%x(3)) &
     + p1%t    * p2%x(3) * (p3%x(1) * p4%x(2) - p3%x(2) * p4%x(1)) &
     - p1%x(1) * p2%x(2) * (p3%x(3) * p4%t    - p3%t    * p4%x(3)) &
     - p1%x(1) * p2%x(3) * (p3%t    * p4%x(2) - p3%x(2) * p4%t   ) &
     - p1%x(1) * p2%t    * (p3%x(2) * p4%x(3) - p3%x(3) * p4%x(2)) &
     + p1%x(2) * p2%x(3) * (p3%t    * p4%x(1) - p3%x(1) * p4%t   ) &
     + p1%x(2) * p2%t    * (p3%x(1) * p4%x(3) - p3%x(3) * p4%x(1)) &
     + p1%x(2) * p2%x(1) * (p3%x(3) * p4%t    - p3%t    * p4%x(3)) &
     - p1%x(3) * p2%t    * (p3%x(1) * p4%x(2) - p3%x(2) * p4%x(1)) &
     - p1%x(3) * p2%x(1) * (p3%x(2) * p4%t    - p3%t    * p4%x(2)) &
     - p1%x(3) * p2%x(2) * (p3%t    * p4%x(1) - p3%x(1) * p4%t   )
end function pseudo_scalar_vector
@ 
<<Implementation of operations for vectors>>=
pure function pseudo_scalar_vec_mom (p1, v1, p2, v2) result (eps1234)
  type(momentum), intent(in)   :: p1, p2
  type(vector), intent(in) :: v1, v2
  complex(kind=default) :: eps1234
  eps1234 = &
       p1%t    * v1%x(1) * (p2%x(2) * v2%x(3) - p2%x(3) * v2%x(2)) &
     + p1%t    * v1%x(2) * (p2%x(3) * v2%x(1) - p2%x(1) * v2%x(3)) &
     + p1%t    * v1%x(3) * (p2%x(1) * v2%x(2) - p2%x(2) * v2%x(1)) &
     - p1%x(1) * v1%x(2) * (p2%x(3) * v2%t    - p2%t    * v2%x(3)) &
     - p1%x(1) * v1%x(3) * (p2%t    * v2%x(2) - p2%x(2) * v2%t   ) &
     - p1%x(1) * v1%t    * (p2%x(2) * v2%x(3) - p2%x(3) * v2%x(2)) &
     + p1%x(2) * v1%x(3) * (p2%t    * v2%x(1) - p2%x(1) * v2%t   ) &
     + p1%x(2) * v1%t    * (p2%x(1) * v2%x(3) - p2%x(3) * v2%x(1)) &
     + p1%x(2) * v1%x(1) * (p2%x(3) * v2%t    - p2%t    * v2%x(3)) &
     - p1%x(3) * v1%t    * (p2%x(1) * v2%x(2) - p2%x(2) * v2%x(1)) &
     - p1%x(3) * v1%x(1) * (p2%x(2) * v2%t    - p2%t    * v2%x(2)) &
     - p1%x(3) * v1%x(2) * (p2%t    * v2%x(1) - p2%x(1) * v2%t   )
end function pseudo_scalar_vec_mom
@ 
\begin{equation}
  \epsilon_\mu(p_1,p_2,p_3)
     = \epsilon_{\mu\mu_1\mu_2\mu_3}
         p_1^{\mu_1}p_2^{\mu_2}p_3^{\mu_3}
\end{equation}
i.\,e.
\begin{subequations}
\begin{align}
  \epsilon_0(p_1,p_2,p_3) &= p_1^1 p_2^2 p_3^3 \pm \ldots \\
  \epsilon_1(p_1,p_2,p_3) &= p_1^2 p_2^3 p_3^0 \pm \ldots \\
  \epsilon_2(p_1,p_2,p_3) &= - p_1^3 p_2^0 p_3^1 \pm \ldots \\
  \epsilon_3(p_1,p_2,p_3) &= p_1^0 p_2^1 p_3^2 \pm \ldots
\end{align}
\end{subequations}
<<Declaration of operations for vectors>>=
interface pseudo_vector
   module procedure pseudo_vector_momentum, pseudo_vector_vector, &
        pseudo_vector_vec_mom
end interface
public :: pseudo_vector
private :: pseudo_vector_momentum, pseudo_vector_vector
@
<<Implementation of operations for vectors>>=
pure function pseudo_vector_momentum (p1, p2, p3) result (eps123)
  type(momentum), intent(in) :: p1, p2, p3
  type(momentum) :: eps123
  eps123%t = &
    + p1%x(1) * (p2%x(2) * p3%x(3) - p2%x(3) * p3%x(2)) &
    + p1%x(2) * (p2%x(3) * p3%x(1) - p2%x(1) * p3%x(3)) &
    + p1%x(3) * (p2%x(1) * p3%x(2) - p2%x(2) * p3%x(1))
  eps123%x(1) = &
    + p1%x(2) * (p2%x(3) * p3%t    - p2%t    * p3%x(3)) &
    + p1%x(3) * (p2%t    * p3%x(2) - p2%x(2) * p3%t   ) &
    + p1%t    * (p2%x(2) * p3%x(3) - p2%x(3) * p3%x(2))
  eps123%x(2) = &
    - p1%x(3) * (p2%t    * p3%x(1) - p2%x(1) * p3%t   ) &
    - p1%t    * (p2%x(1) * p3%x(3) - p2%x(3) * p3%x(1)) &
    - p1%x(1) * (p2%x(3) * p3%t    - p2%t    * p3%x(3))
  eps123%x(3) =  &
    + p1%t    * (p2%x(1) * p3%x(2) - p2%x(2) * p3%x(1)) &
    + p1%x(1) * (p2%x(2) * p3%t    - p2%t    * p3%x(2)) &
    + p1%x(2) * (p2%t    * p3%x(1) - p2%x(1) * p3%t   )
end function pseudo_vector_momentum
@
<<Implementation of operations for vectors>>=
pure function pseudo_vector_vector (p1, p2, p3) result (eps123)
  type(vector), intent(in) :: p1, p2, p3
  type(vector) :: eps123
  eps123%t = &
    + p1%x(1) * (p2%x(2) * p3%x(3) - p2%x(3) * p3%x(2)) &
    + p1%x(2) * (p2%x(3) * p3%x(1) - p2%x(1) * p3%x(3)) &
    + p1%x(3) * (p2%x(1) * p3%x(2) - p2%x(2) * p3%x(1))
  eps123%x(1) = &
    + p1%x(2) * (p2%x(3) * p3%t    - p2%t    * p3%x(3)) &
    + p1%x(3) * (p2%t    * p3%x(2) - p2%x(2) * p3%t   ) &
    + p1%t    * (p2%x(2) * p3%x(3) - p2%x(3) * p3%x(2))
  eps123%x(2) = &
    - p1%x(3) * (p2%t    * p3%x(1) - p2%x(1) * p3%t   ) &
    - p1%t    * (p2%x(1) * p3%x(3) - p2%x(3) * p3%x(1)) &
    - p1%x(1) * (p2%x(3) * p3%t    - p2%t    * p3%x(3))
  eps123%x(3) =  &
    + p1%t    * (p2%x(1) * p3%x(2) - p2%x(2) * p3%x(1)) &
    + p1%x(1) * (p2%x(2) * p3%t    - p2%t    * p3%x(2)) &
    + p1%x(2) * (p2%t    * p3%x(1) - p2%x(1) * p3%t   )
end function pseudo_vector_vector
@
<<Implementation of operations for vectors>>=
pure function pseudo_vector_vec_mom (p1, p2, v) result (eps123)
  type(momentum), intent(in) :: p1, p2
  type(vector), intent(in)   :: v
  type(vector) :: eps123
  eps123%t = &
    + p1%x(1) * (p2%x(2) * v%x(3) - p2%x(3) * v%x(2)) &
    + p1%x(2) * (p2%x(3) * v%x(1) - p2%x(1) * v%x(3)) &
    + p1%x(3) * (p2%x(1) * v%x(2) - p2%x(2) * v%x(1))
  eps123%x(1) = &
    + p1%x(2) * (p2%x(3) * v%t    - p2%t    * v%x(3)) &
    + p1%x(3) * (p2%t    * v%x(2) - p2%x(2) * v%t   ) &
    + p1%t    * (p2%x(2) * v%x(3) - p2%x(3) * v%x(2))
  eps123%x(2) = &
    - p1%x(3) * (p2%t    * v%x(1) - p2%x(1) * v%t   ) &
    - p1%t    * (p2%x(1) * v%x(3) - p2%x(3) * v%x(1)) &
    - p1%x(1) * (p2%x(3) * v%t    - p2%t    * v%x(3))
  eps123%x(3) =  &
    + p1%t    * (p2%x(1) * v%x(2) - p2%x(2) * v%x(1)) &
    + p1%x(1) * (p2%x(2) * v%t    - p2%t    * v%x(2)) &
    + p1%x(2) * (p2%t    * v%x(1) - p2%x(1) * v%t   )
end function pseudo_vector_vec_mom
@ 
\subsection{Utilities}
<<Declaration of operations for vectors>>=
@
<<Implementation of operations for vectors>>=
subroutine random_momentum (p, pabs, m)
  type(momentum), intent(out) :: p
  real(kind=default), intent(in) :: pabs, m
  real(kind=default), dimension(2) :: r
  real(kind=default) :: phi, cos_th
  call random_number (r)
  phi = 2*PI * r(1)
  cos_th = 2 * r(2) - 1
  p%t = sqrt (pabs**2 + m**2)
  p%x = pabs * (/ cos_th * cos(phi), cos_th * sin(phi), sqrt (1 - cos_th**2) /)
end subroutine random_momentum
@
\section{Polarization vectors}
<<[[omega_polarizations.f90]]>>=
<<Copyleft>>
module omega_polarizations
  use kinds
  use constants
  use omega_vectors
  implicit none
  private
  <<Declaration of polarization vectors>>
  integer, parameter, public :: omega_polarizations_2010_01_A = 0
contains
  <<Implementation of polarization vectors>>
end module omega_polarizations
@
Here we use a phase convention for the polarization vectors compatible
with the angular momentum coupling to spin 3/2 and spin 2.
\begin{subequations}
\begin{align}
  \epsilon^\mu_1(k) &=
    \frac{1}{|\vec k|\sqrt{k_x^2+k_y^2}}
      \left(0; k_z k_x, k_y k_z, - k_x^2 - k_y^2\right) \\
  \epsilon^\mu_2(k) &=
    \frac{1}{\sqrt{k_x^2+k_y^2}}
      \left(0; -k_y, k_x, 0\right) \\
  \epsilon^\mu_3(k) &=
    \frac{k_0}{m|\vec k|} \left({\vec k}^2/k_0; k_x, k_y, k_z\right)
\end{align}
\end{subequations}
and
\begin{subequations}
\begin{align}
  \epsilon^\mu_\pm(k) &=
     \frac{1}{\sqrt{2}} (\epsilon^\mu_1(k) \pm \ii\epsilon^\mu_2(k) ) \\
  \epsilon^\mu_0(k) &= \epsilon^\mu_3(k)
\end{align}
\end{subequations}
i.\,e.
\begin{subequations}
\begin{align}
  \epsilon^\mu_+(k) &=
     \frac{1}{\sqrt{2}\sqrt{k_x^2+k_y^2}}
        \left(0; \frac{k_zk_x}{|\vec k|} - \ii k_y,
                 \frac{k_yk_z}{|\vec k|} + \ii k_x,
                 - \frac{k_x^2+k_y^2}{|\vec k|}\right) \\
  \epsilon^\mu_-(k) &=
     \frac{1}{\sqrt{2}\sqrt{k_x^2+k_y^2}}
        \left(0;  \frac{k_zk_x}{|\vec k|} + \ii k_y,
                  \frac{k_yk_z}{|\vec k|} - \ii k_x,
                 -\frac{k_x^2+k_y^2}{|\vec k|}\right) \\
  \epsilon^\mu_0(k) &= 
     \frac{k_0}{m|\vec k|} \left({\vec k}^2/k_0; k_x, k_y, k_z\right)
\end{align}
\end{subequations}
Determining the mass from the momenta is a numerically haphazardous for
light particles.  Therefore, we accept some redundancy and pass the
mass explicitely.
<<Declaration of polarization vectors>>=
public :: eps
@
<<Implementation of polarization vectors>>=
pure function eps (m, k, s) result (e)
  type(vector) :: e
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  real(kind=default) :: kt, kabs, kabs2, sqrt2
  sqrt2 = sqrt (2.0_default)
  kabs2 = dot_product (k%x, k%x)
  e%t = 0
  e%x = 0
  if (kabs2 > 0) then
     kabs = sqrt (kabs2)
     select case (s)
     case (1)
        kt = sqrt (k%x(1)**2 + k%x(2)**2)
        if (abs(kt) <= epsilon(kt) * kabs) then 
           if (k%x(3) > 0) then           
              e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0,   1, kind=default) / sqrt2
           else
              e%x(1) = cmplx ( - 1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0,   1, kind=default) / sqrt2
           end if
        else
           e%x(1) = cmplx (   k%x(3)*k%x(1)/kabs, &
                - k%x(2), kind=default) / kt / sqrt2
           e%x(2) = cmplx (   k%x(2)*k%x(3)/kabs, &
                k%x(1), kind=default) / kt / sqrt2
           e%x(3) = - kt / kabs / sqrt2
        end if
     case (-1)
        kt = sqrt (k%x(1)**2 + k%x(2)**2)
        if (abs(kt) <= epsilon(kt) * kabs) then
           if (k%x(3) > 0) then
              e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2           
           else
              e%x(1) = cmplx (  -1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2           
           end if
        else
           e%x(1) = cmplx (   k%x(3)*k%x(1)/kabs, &
                k%x(2), kind=default) / kt / sqrt2
           e%x(2) = cmplx (   k%x(2)*k%x(3)/kabs, &
                - k%x(1), kind=default) / kt / sqrt2
           e%x(3) = - kt / kabs / sqrt2
        end if
     case (0)
        if (m > 0) then
           e%t = kabs / m
           e%x = k%t / (m*kabs) * k%x 
        end if
     case (3) 
        e = (0,1) * k
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  else   !!! for particles in their rest frame defined to be 
         !!! polarized along the 3-direction
     select case (s)
     case (1)
        e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0,   1, kind=default) / sqrt2
     case (-1)
        e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
     case (0)
        if (m > 0) then
           e%x(3) = 1
        end if
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  end if
end function eps
@
\section{Polarization vectors revisited}
<<[[omega_polarizations_madgraph.f90]]>>=
<<Copyleft>>
module omega_polarizations_madgraph
  use kinds
  use constants
  use omega_vectors
  implicit none
  private
  <<Declaration of polarization vectors for madgraph>>
  integer, parameter, public :: omega_pols_madgraph_2010_01_A = 0
contains
  <<Implementation of polarization vectors for madgraph>>
end module omega_polarizations_madgraph
@
This set of polarization vectors is compatible with HELAS~\cite{HELAS}:
\begin{subequations}
\begin{align}
  \epsilon^\mu_1(k) &=
    \frac{1}{|\vec k|\sqrt{k_x^2+k_y^2}}
      \left(0; k_z k_x, k_y k_z, - k_x^2 - k_y^2\right) \\
  \epsilon^\mu_2(k) &=
    \frac{1}{\sqrt{k_x^2+k_y^2}}
      \left(0; -k_y, k_x, 0\right) \\
  \epsilon^\mu_3(k) &=
    \frac{k_0}{m|\vec k|} \left({\vec k}^2/k_0; k_x, k_y, k_z\right)
\end{align}
\end{subequations}
and
\begin{subequations}
\begin{align}
  \epsilon^\mu_\pm(k) &=
     \frac{1}{\sqrt{2}} (\mp \epsilon^\mu_1(k) - \ii\epsilon^\mu_2(k) ) \\
  \epsilon^\mu_0(k) &= \epsilon^\mu_3(k)
\end{align}
\end{subequations}
i.\,e.
\begin{subequations}
\begin{align}
  \epsilon^\mu_+(k) &=
     \frac{1}{\sqrt{2}\sqrt{k_x^2+k_y^2}}
        \left(0; -\frac{k_zk_x}{|\vec k|} + \ii k_y,
                 -\frac{k_yk_z}{|\vec k|} - \ii k_x,
                 \frac{k_x^2+k_y^2}{|\vec k|}\right) \\
  \epsilon^\mu_-(k) &=
     \frac{1}{\sqrt{2}\sqrt{k_x^2+k_y^2}}
        \left(0;  \frac{k_zk_x}{|\vec k|} + \ii k_y,
                  \frac{k_yk_z}{|\vec k|} - \ii k_x,
                 -\frac{k_x^2+k_y^2}{|\vec k|}\right) \\
  \epsilon^\mu_0(k) &= 
     \frac{k_0}{m|\vec k|} \left({\vec k}^2/k_0; k_x, k_y, k_z\right)
\end{align}
\end{subequations}
Fortunately, for comparing with squared matrix generated by Madgraph
we can also use the modified version, since the difference is only a
phase and does \emph{not} mix helicity states.
@ Determining the mass from the momenta is a numerically haphazardous for
light particles.  Therefore, we accept some redundancy and pass the
mass explicitely.
<<Declaration of polarization vectors for madgraph>>=
public :: eps
@
<<Implementation of polarization vectors for madgraph>>=
pure function eps (m, k, s) result (e)
  type(vector) :: e
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  real(kind=default) :: kt, kabs, kabs2, sqrt2
  sqrt2 = sqrt (2.0_default)
  kabs2 = dot_product (k%x, k%x)
  e%t = 0
  e%x = 0
  if (kabs2 > 0) then
     kabs = sqrt (kabs2)
     select case (s)
     case (1)
        kt = sqrt (k%x(1)**2 + k%x(2)**2)
        if (abs(kt) <= epsilon(kt) * kabs) then
           if (k%x(3) > 0) then
              e%x(1) = cmplx ( - 1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
           else
              e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
           end if
        else           
           e%x(1) = cmplx ( - k%x(3)*k%x(1)/kabs, &
                k%x(2), kind=default) / kt / sqrt2
           e%x(2) = cmplx ( - k%x(2)*k%x(3)/kabs, &
                - k%x(1), kind=default) / kt / sqrt2
           e%x(3) = kt / kabs / sqrt2
        end if
     case (-1)
        kt = sqrt (k%x(1)**2 + k%x(2)**2)
        if (abs(kt) <= epsilon(kt) * kabs) then
           if (k%x(3) > 0) then
              e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
           else
              e%x(1) = cmplx (  -1,   0, kind=default) / sqrt2
              e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
           end if
        else           
           e%x(1) = cmplx (   k%x(3)*k%x(1)/kabs, &
                k%x(2), kind=default) / kt / sqrt2
           e%x(2) = cmplx (   k%x(2)*k%x(3)/kabs, &
                - k%x(1), kind=default) / kt / sqrt2
           e%x(3) = - kt / kabs / sqrt2
        end if
     case (0)
        if (m > 0) then
           e%t = kabs / m
           e%x = k%t / (m*kabs) * k%x 
        end if
     case (3) 
        e = (0,1) * k
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  else   !!! for particles in their rest frame defined to be
         !!! polarized along the 3-direction
     select case (s)
     case (1)
        e%x(1) = cmplx ( - 1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
     case (-1)
        e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0, - 1, kind=default) / sqrt2
     case (0)
        if (m > 0) then
           e%x(3) = 1
        end if
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  end if
end function eps
@
\section{Symmetric Tensors}
Spin-2 polarization tensors are symmetric, transversal and traceless
\begin{subequations}
\begin{align}
  \epsilon^{\mu\nu}_{m}(k) &= \epsilon^{\nu\mu}_{m}(k) \\
  k_\mu \epsilon^{\mu\nu}_{m}(k) &= k_\nu \epsilon^{\mu\nu}_{m}(k) = 0 \\
  \epsilon^{\mu}_{m,\mu}(k) &= 0
\end{align}
\end{subequations}
with $m=1,2,3,4,5$. Our current representation is redundant and does
\emph{not} enforce symmetry or tracelessness.
<<[[omega_tensors.f90]]>>=
<<Copyleft>>
module omega_tensors
  use kinds
  use constants
  use omega_vectors
  implicit none
  private
  public :: operator (*), operator (+), operator (-), &
       operator (.tprod.)
  public :: abs, conjg
  <<[[intrinsic :: abs]]>>
  <<[[intrinsic :: conjg]]>>
  type, public :: tensor
     ! private (omegalib needs access, but DON'T TOUCH IT!)
     complex(kind=default), dimension(0:3,0:3) :: t
  end type tensor
  <<Declaration of operations for tensors>>
  integer, parameter, public :: omega_tensors_2010_01_A = 0
contains
  <<Implementation of operations for tensors>>
end module omega_tensors
@
\subsection{Vector Space}
\subsubsection{Scalar Multliplication}
<<Declaration of operations for tensors>>=
interface operator (*)
   module procedure integer_tensor, real_tensor, double_tensor, &
        complex_tensor, dcomplex_tensor
end interface
private :: integer_tensor, real_tensor, double_tensor
private :: complex_tensor, dcomplex_tensor
@
<<Implementation of operations for tensors>>=
pure function integer_tensor (x, y) result (xy)
  integer, intent(in) :: x
  type(tensor), intent(in) :: y
  type(tensor) :: xy
  xy%t = x * y%t
end function integer_tensor
pure function real_tensor (x, y) result (xy)
  real(kind=single), intent(in) :: x
  type(tensor), intent(in) :: y
  type(tensor) :: xy
  xy%t = x * y%t
end function real_tensor
pure function double_tensor (x, y) result (xy)
  real(kind=default), intent(in) :: x
  type(tensor), intent(in) :: y
  type(tensor) :: xy
  xy%t = x * y%t
end function double_tensor
pure function complex_tensor (x, y) result (xy)
  complex(kind=single), intent(in) :: x
  type(tensor), intent(in) :: y
  type(tensor) :: xy
  xy%t = x * y%t
end function complex_tensor
pure function dcomplex_tensor (x, y) result (xy)
  complex(kind=default), intent(in) :: x
  type(tensor), intent(in) :: y
  type(tensor) :: xy
  xy%t = x * y%t
end function dcomplex_tensor
@
\subsubsection{Addition and Subtraction}
<<Declaration of operations for tensors>>=
interface operator (+)
   module procedure plus_tensor
end interface
private :: plus_tensor
interface operator (-)
  module procedure neg_tensor
end interface
private :: neg_tensor
@
<<Implementation of operations for tensors>>=
pure function plus_tensor (t1) result (t2)
  type(tensor), intent(in) :: t1
  type(tensor) :: t2
  t2 = t1
end function plus_tensor
pure function neg_tensor (t1) result (t2)
  type(tensor), intent(in) :: t1
  type(tensor) :: t2
  t2%t = - t1%t
end function neg_tensor
@ 
<<Declaration of operations for tensors>>=
interface operator (+)
   module procedure add_tensor
end interface
private :: add_tensor
interface operator (-)
   module procedure sub_tensor
end interface
private :: sub_tensor
@
<<Implementation of operations for tensors>>=
pure function add_tensor (x, y) result (xy)
  type(tensor), intent(in) :: x, y
  type(tensor) :: xy
  xy%t = x%t + y%t
end function add_tensor
pure function sub_tensor (x, y) result (xy)
  type(tensor), intent(in) :: x, y
  type(tensor) :: xy
  xy%t = x%t - y%t
end function sub_tensor
@ 
<<Declaration of operations for tensors>>=
interface operator (.tprod.)
   module procedure out_prod_vv, out_prod_vm, &
        out_prod_mv, out_prod_mm
end interface
private :: out_prod_vv, out_prod_vm, &
     out_prod_mv, out_prod_mm
@
<<Implementation of operations for tensors>>=
pure function out_prod_vv (v, w) result (t)
  type(tensor) :: t
  type(vector), intent(in) :: v, w
  integer :: i, j
  t%t(0,0) = v%t * w%t
  t%t(0,1:3) = v%t * w%x
  t%t(1:3,0) = v%x * w%t
  do i = 1, 3
     do j = 1, 3
        t%t(i,j) = v%x(i) * w%x(j)
     end do
  end do
end function out_prod_vv
@
<<Implementation of operations for tensors>>=
pure function out_prod_vm (v, m) result (t)
  type(tensor) :: t
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: m
  integer :: i, j
  t%t(0,0) = v%t * m%t
  t%t(0,1:3) = v%t * m%x
  t%t(1:3,0) = v%x * m%t
  do i = 1, 3
     do j = 1, 3
        t%t(i,j) = v%x(i) * m%x(j)
     end do
  end do
end function out_prod_vm
@
<<Implementation of operations for tensors>>=
pure function out_prod_mv (m, v) result (t)
  type(tensor) :: t
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: m
  integer :: i, j
  t%t(0,0) = m%t * v%t
  t%t(0,1:3) = m%t * v%x
  t%t(1:3,0) = m%x * v%t
  do i = 1, 3
     do j = 1, 3
        t%t(i,j) = m%x(i) * v%x(j)
     end do
  end do
end function out_prod_mv
@
<<Implementation of operations for tensors>>=
pure function out_prod_mm (m, n) result (t)
  type(tensor) :: t
  type(momentum), intent(in) :: m, n
  integer :: i, j
  t%t(0,0) = m%t * n%t
  t%t(0,1:3) = m%t * n%x
  t%t(1:3,0) = m%x * n%t
  do i = 1, 3
     do j = 1, 3
        t%t(i,j) = m%x(i) * n%x(j)
     end do
  end do
end function out_prod_mm
@ 
<<Declaration of operations for tensors>>=
interface abs
   module procedure abs_tensor
end interface
private :: abs_tensor
@
<<Implementation of operations for tensors>>=
pure function abs_tensor (t) result (abs_t)
  type(tensor), intent(in) :: t
  real(kind=default) :: abs_t
  abs_t = sqrt (sum ((abs (t%t))**2))
end function abs_tensor
@ 
<<Declaration of operations for tensors>>=
interface conjg
   module procedure conjg_tensor
end interface
private :: conjg_tensor
@
<<Implementation of operations for tensors>>=
pure function conjg_tensor (t) result (conjg_t)
  type(tensor), intent(in) :: t
  type(tensor) :: conjg_t
  conjg_t%t = conjg (t%t)
end function conjg_tensor
@ 
<<Declaration of operations for tensors>>=
interface operator (*)
   module procedure tensor_tensor, vector_tensor, tensor_vector, &
        momentum_tensor, tensor_momentum
end interface
private :: tensor_tensor, vector_tensor, tensor_vector, &
     momentum_tensor, tensor_momentum
@
<<Implementation of operations for tensors>>=
pure function tensor_tensor (t1, t2) result (t1t2)
  type(tensor), intent(in) :: t1
  type(tensor), intent(in) :: t2
  complex(kind=default) :: t1t2
  integer :: i1, i2
  t1t2 = t1%t(0,0)*t2%t(0,0) &
       - dot_product (conjg (t1%t(0,1:)), t2%t(0,1:)) &
       - dot_product (conjg (t1%t(1:,0)), t2%t(1:,0))
  do i1 = 1, 3
     do i2 = 1, 3
        t1t2 = t1t2 + t1%t(i1,i2)*t2%t(i1,i2)
     end do
  end do
end function tensor_tensor
@
<<Implementation of operations for tensors>>=
pure function tensor_vector (t, v) result (tv)
  type(tensor), intent(in) :: t
  type(vector), intent(in) :: v
  type(vector) :: tv
  tv%t =    t%t(0,0) * v%t - dot_product (conjg (t%t(0,1:)), v%x)
  tv%x(1) = t%t(0,1) * v%t - dot_product (conjg (t%t(1,1:)), v%x)
  tv%x(2) = t%t(0,2) * v%t - dot_product (conjg (t%t(2,1:)), v%x)
  tv%x(3) = t%t(0,3) * v%t - dot_product (conjg (t%t(3,1:)), v%x)
end function tensor_vector
@
<<Implementation of operations for tensors>>=
pure function vector_tensor (v, t) result (vt)
  type(vector), intent(in) :: v
  type(tensor), intent(in) :: t
  type(vector) :: vt
  vt%t =    v%t * t%t(0,0) - dot_product (conjg (v%x), t%t(1:,0))
  vt%x(1) = v%t * t%t(0,1) - dot_product (conjg (v%x), t%t(1:,1))
  vt%x(2) = v%t * t%t(0,2) - dot_product (conjg (v%x), t%t(1:,2))
  vt%x(3) = v%t * t%t(0,3) - dot_product (conjg (v%x), t%t(1:,3))
end function vector_tensor
@
<<Implementation of operations for tensors>>=
pure function tensor_momentum (t, p) result (tp)
  type(tensor), intent(in) :: t
  type(momentum), intent(in) :: p
  type(vector) :: tp
  tp%t =    t%t(0,0) * p%t - dot_product (conjg (t%t(0,1:)), p%x)
  tp%x(1) = t%t(0,1) * p%t - dot_product (conjg (t%t(1,1:)), p%x)
  tp%x(2) = t%t(0,2) * p%t - dot_product (conjg (t%t(2,1:)), p%x)
  tp%x(3) = t%t(0,3) * p%t - dot_product (conjg (t%t(3,1:)), p%x)
end function tensor_momentum
@
<<Implementation of operations for tensors>>=
pure function momentum_tensor (p, t) result (pt)
  type(momentum), intent(in) :: p
  type(tensor), intent(in) :: t
  type(vector) :: pt
  pt%t =    p%t * t%t(0,0) - dot_product (p%x, t%t(1:,0))
  pt%x(1) = p%t * t%t(0,1) - dot_product (p%x, t%t(1:,1))
  pt%x(2) = p%t * t%t(0,2) - dot_product (p%x, t%t(1:,2))
  pt%x(3) = p%t * t%t(0,3) - dot_product (p%x, t%t(1:,3))
end function momentum_tensor
@
\section{Symmetric Polarization Tensors}
\begin{subequations}
\begin{align}
  \epsilon^{\mu\nu}_{+2}(k) &= \epsilon^{\mu}_{+}(k)\epsilon^{\nu}_{+}(k) \\
  \epsilon^{\mu\nu}_{+1}(k) &= \frac{1}{\sqrt{2}}
     \left(   \epsilon^{\mu}_{+}(k)\epsilon^{\nu}_{0}(k)
            + \epsilon^{\mu}_{0}(k)\epsilon^{\nu}_{+}(k) \right) \\
  \epsilon^{\mu\nu}_{0}(k)  &= \frac{1}{\sqrt{6}}
     \left(   \epsilon^{\mu}_{+}(k)\epsilon^{\nu}_{-}(k)
            + \epsilon^{\mu}_{-}(k)\epsilon^{\nu}_{+}(k)
            - 2 \epsilon^{\mu}_{0}(k)\epsilon^{\nu}_{0}(k) \right) \\
  \epsilon^{\mu\nu}_{-1}(k) &=  \frac{1}{\sqrt{2}}
     \left(   \epsilon^{\mu}_{-}(k)\epsilon^{\nu}_{0}(k)
            + \epsilon^{\mu}_{0}(k)\epsilon^{\nu}_{-}(k) \right) \\
  \epsilon^{\mu\nu}_{-2}(k) &= \epsilon^{\mu}_{-}(k)\epsilon^{\nu}_{-}(k)
\end{align}
\end{subequations}
Note that~$\epsilon^{\mu}_{\pm2,\mu}(k) =
\epsilon^{\mu}_{\pm}(k)\epsilon_{\pm,\mu}(k) \propto
\epsilon^{\mu}_{\pm}(k)\epsilon_{\mp,\mu}^{*}(k) = 0$ and that the sign in
$\epsilon^{\mu\nu}_{0}(k)$ insures its tracelessness\footnote{
On the other hand, with the shift operator
$L_{-}\ket{+}=\ee^{\ii\phi}\ket{0}$ and 
$L_{-}\ket{0}=\ee^{\ii\chi}\ket{-}$, we find
\begin{equation*}
  L_{-}^{2}\ket{++} =
    2\ee^{2\ii\phi}\ket{00} + \ee^{\ii(\phi+\chi)}(\ket{+-}+\ket{-+})
\end{equation*}
i.\,e.~$\chi-\phi=\pi$, if we want to identify
$\epsilon^{\mu}_{-,0,+}$ with $\ket{-,0,+}$.}.
<<[[omega_tensor_polarizations.f90]]>>=
<<Copyleft>>
module omega_tensor_polarizations
  use kinds
  use constants
  use omega_vectors
  use omega_tensors
  use omega_polarizations
  implicit none
  private
  <<Declaration of polarization tensors>>
  integer, parameter, public :: omega_tensor_pols_2010_01_A = 0
contains
  <<Implementation of polarization tensors>>
end module omega_tensor_polarizations
@
<<Declaration of polarization tensors>>=
public :: eps2
@
<<Implementation of polarization tensors>>=
pure function eps2 (m, k, s) result (t)
  type(tensor) :: t
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  type(vector) :: ep, em, e0
  t%t = 0
  select case (s)
  case (2)
     ep = eps (m, k, 1)
     t = ep.tprod.ep
  case (1)
     ep = eps (m, k, 1)
     e0 = eps (m, k, 0)
     t = (1 / sqrt (2.0_default)) &
          * ((ep.tprod.e0) + (e0.tprod.ep))
  case (0)
     ep = eps (m, k, 1)
     e0 = eps (m, k, 0)
     em = eps (m, k, -1)
     t = (1 / sqrt (6.0_default)) &
           * ((ep.tprod.em) + (em.tprod.ep) - 2*(e0.tprod.e0))
  case (-1)
     e0 = eps (m, k, 0)
     em = eps (m, k, -1)
     t = (1 / sqrt (2.0_default)) &
           * ((em.tprod.e0) + (e0.tprod.em))
  case (-2)
     em = eps (m, k, -1)
     t = em.tprod.em
  end select
end function eps2
@ \section{Couplings}
<<[[omega_couplings.f90]]>>=
<<Copyleft>>
module omega_couplings
  use kinds
  use constants
  use omega_vectors
  use omega_tensors
  implicit none
  private
  <<Declaration of couplings>>
  <<Declaration of propagators>>
  integer, parameter, public :: omega_couplings_2010_01_A = 0
contains
  <<Implementation of couplings>>
  <<Implementation of propagators>>
end module omega_couplings
@
<<Declaration of propagators>>=
public :: wd_tl
@
<<Declaration of propagators>>=
public :: gauss
@
\begin{equation}
   \Theta(p^2)\Gamma
\end{equation}
<<Implementation of propagators>>=
pure function wd_tl (p, w) result (width)
  real(kind=default) :: width
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: w
  if (p*p > 0) then
     width = w
  else
     width = 0
  end if
end function wd_tl
@
<<Implementation of propagators>>=
pure function gauss (x, mu, w) result (gg)
  real(kind=default) :: gg
  real(kind=default), intent(in) :: x, mu, w
  if (w > 0) then
    gg = exp(-(x - mu**2)**2/4.0_default/mu**2/w**2) * &
         sqrt(sqrt(PI/2)) / w / mu
	  else
    gg = 1.0_default	
  end if
end function gauss
@
<<Declaration of propagators>>=
public :: pr_phi, pr_unitarity, pr_feynman, pr_gauge, pr_rxi
public :: pj_phi, pj_unitarity
public :: pg_phi, pg_unitarity
@
\begin{equation}
   \frac{\ii}{p^2-m^2+\ii m\Gamma}\phi
\end{equation}
<<Implementation of propagators>>=
pure function pr_phi (p, m, w, phi) result (pphi)
  complex(kind=default) :: pphi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  complex(kind=default), intent(in) :: phi
  pphi = (1 / cmplx (p*p - m**2, m*w, kind=default)) * phi 
end function pr_phi
@
\begin{equation}
  \sqrt{\frac{\pi}{M\Gamma}}
    \phi
\end{equation}
<<Implementation of propagators>>=
pure function pj_phi (m, w, phi) result (pphi)
  complex(kind=default) :: pphi
  real(kind=default), intent(in) :: m, w
  complex(kind=default), intent(in) :: phi
  pphi = (0, -1) * sqrt (PI / m / w) * phi 
end function pj_phi
@
<<Implementation of propagators>>=
pure function pg_phi (p, m, w, phi) result (pphi)
  complex(kind=default) :: pphi	
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  complex(kind=default), intent(in) :: phi
  pphi = ((0, 1) * gauss (p*p, m, w)) * phi
end function pg_phi  
@
\begin{equation}
   \frac{\ii}{p^2-m^2+\ii m\Gamma}
      \left( -g_{\mu\nu} + \frac{p_\mu p_\nu}{m^2} \right) \epsilon^\nu(p)
\end{equation}
NB: the explicit cast to [[vector]] is required here, because a specific
[[complex_momentum]] procedure for [[operator (*)]] would introduce
ambiguities.
NB: we used to use the constructor [[vector (p%t, p%x)]] instead of
the temporary variable, but the Intel Fortran Compiler choked on it.
<<Implementation of propagators>>=
pure function pr_unitarity (p, m, w, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(vector), intent(in) :: e
  type(vector) :: pv
  pv = p
  pe = - (1 / cmplx (p*p - m**2, m*w, kind=default)) &
       * (e - (p*e / m**2) * pv)
end function pr_unitarity
@
\begin{equation}
  \sqrt{\frac{\pi}{M\Gamma}}
    \left( -g_{\mu\nu} + \frac{p_\mu p_\nu}{m^2} \right) \epsilon^\nu(p)
\end{equation}
<<Implementation of propagators>>=
pure function pj_unitarity (p, m, w, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(vector), intent(in) :: e
  type(vector) :: pv
  pv = p
  pe = (0, 1) * sqrt (PI / m / w) * (e - (p*e / m**2) * pv)
end function pj_unitarity
@
<<Implementation of propagators>>=
pure function pg_unitarity (p, m, w, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(vector), intent(in) :: e
  type(vector) :: pv
  pv = p
  pe = - gauss (p*p, m, w) &
       * (e - (p*e / m**2) * pv)
end function pg_unitarity  
@
\begin{equation}
   \frac{-i}{p^2} \epsilon^\nu(p)
\end{equation}
<<Implementation of propagators>>=
pure function pr_feynman (p, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  type(vector), intent(in) :: e
  pe = - (1 / (p*p)) * e
end function pr_feynman
@
\begin{equation}
   \frac{\ii}{p^2}
      \left( -g_{\mu\nu} + (1-\xi)\frac{p_\mu p_\nu}{p^2} \right)
   \epsilon^\nu(p)
\end{equation}
<<Implementation of propagators>>=
pure function pr_gauge (p, xi, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: xi
  type(vector), intent(in) :: e
  real(kind=default) :: p2
  type(vector) :: pv
  p2 = p*p
  pv = p
  pe = - (1 / p2) * (e - ((1 - xi) * (p*e) / p2) * pv)
end function pr_gauge
@
\begin{equation}
   \frac{\ii}{p^2-m^2+\ii m\Gamma}
      \left( -g_{\mu\nu} + (1-\xi)\frac{p_\mu p_\nu}{p^2-\xi m^2} \right)
   \epsilon^\nu(p)
\end{equation}
<<Implementation of propagators>>=
pure function pr_rxi (p, m, w, xi, e) result (pe)
  type(vector) :: pe
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w, xi
  type(vector), intent(in) :: e
  real(kind=default) :: p2 
  type(vector) :: pv
  p2 = p*p
  pv = p
  pe = - (1 / cmplx (p2 - m**2, m*w, kind=default)) &
       * (e - ((1 - xi) * (p*e) / (p2 - xi * m**2)) * pv)
end function pr_rxi
@
<<Declaration of propagators>>=
public :: pr_tensor
@
\begin{subequations}
\begin{equation}
   \frac{\ii P^{\mu\nu,\rho\sigma}(p,m)}{p^2-m^2+\ii m\Gamma} T_{\rho\sigma}
\end{equation}
with
\begin{multline}
   P^{\mu\nu,\rho\sigma}(p,m)
    = \frac{1}{2} \left(g^{\mu\rho}-\frac{p^{\mu}p^{\nu}}{m^2}\right)
                  \left(g^{\nu\sigma}-\frac{p^{\nu}p^{\sigma}}{m^2}\right)
    + \frac{1}{2} \left(g^{\mu\sigma}-\frac{p^{\mu}p^{\sigma}}{m^2}\right)
                  \left(g^{\nu\rho}-\frac{p^{\nu}p^{\rho}}{m^2}\right) \\
    - \frac{1}{3} \left(g^{\mu\nu}-\frac{p^{\mu}p^{\nu}}{m^2}\right)
                  \left(g^{\rho\sigma}-\frac{p^{\rho}p^{\sigma}}{m^2}\right)
\end{multline}
\end{subequations}
Be careful with raising and lowering of indices:
\begin{subequations}
\begin{align}
  g^{\mu\nu}-\frac{k^{\mu}k^{\nu}}{m^2}
    &= \begin{pmatrix}
         1 - k^0k^0 / m^2 & - k^0 \vec k / m^2 \\
         - \vec k k^0 / m^2 & - \mathbf{1} - \vec k \otimes \vec k / m^2
       \end{pmatrix} \\
  g^{\mu}_{\hphantom{\mu}\nu}-\frac{k^{\mu}k_{\nu}}{m^2}
    &= \begin{pmatrix}
         1 - k^0k^0 / m^2 & k^0 \vec k / m^2 \\
         - \vec k k^0 / m^2 & \mathbf{1} + \vec k \otimes \vec k / m^2
       \end{pmatrix}
\end{align}
\end{subequations}
<<Implementation of propagators>>=
pure function pr_tensor (p, m, w, t) result (pt)
  type(tensor) :: pt
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(tensor), intent(in) :: t
  complex(kind=default) :: p_dd_t
  real(kind=default), dimension(0:3,0:3) :: p_uu, p_ud, p_du, p_dd
  integer :: i, j
  p_uu(0,0) = 1 - p%t * p%t / m**2
  p_uu(0,1:3) = - p%t * p%x / m**2
  p_uu(1:3,0) = p_uu(0,1:3)
  do i = 1, 3
     do j = 1, 3
        p_uu(i,j) = - p%x(i) * p%x(j) / m**2
     end do
  end do
  do i = 1, 3
     p_uu(i,i) = - 1 + p_uu(i,i)
  end do
  p_ud(:,0) = p_uu(:,0)
  p_ud(:,1:3) = - p_uu(:,1:3)
  p_du = transpose (p_ud)
  p_dd(:,0) = p_du(:,0)
  p_dd(:,1:3) = - p_du(:,1:3)
  p_dd_t = 0
  do i = 0, 3
     do j = 0, 3
        p_dd_t = p_dd_t + p_dd(i,j) * t%t(i,j)
     end do
  end do
  pt%t = matmul (p_ud, matmul (0.5_default * (t%t + transpose (t%t)), p_du)) &
       - (p_dd_t / 3.0_default) * p_uu
  pt%t = pt%t / cmplx (p*p - m**2, m*w, kind=default)
end function pr_tensor
@ \subsection{Triple Gauge Couplings}
<<Declaration of couplings>>=
public :: g_gg
@ According to~(\ref{eq:fuse-gauge})
\begin{multline}
  A^{a,\mu}(k_1+k_2) = - \ii g
     \bigl(   (k_1^{\mu}-k_2^{\mu})A^{a_1}(k_1) \cdot A^{a_2}(k_2) \\
            + (2k_2+k_1)\cdot A^{a_1}(k_1)A^{a_2,\mu}(k_2)
            - A^{a_1,\mu}(k_1)A^{a_2}(k_2)\cdot(2k_1+k_2) \bigr)
\end{multline}
<<Implementation of couplings>>=
pure function g_gg (g, a1, k1, a2, k2) result (a)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1, a2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: a
  a = (0, -1) * g * ((k1 - k2) * (a1 * a2) &
                      + ((2*k2 + k1) * a1) * a2 - a1 * ((2*k1 + k2) * a2))
end function g_gg
@ \subsection{Quadruple Gauge Couplings}
<<Declaration of couplings>>=
public :: x_gg, g_gx
@
\begin{equation}
  T^{a,\mu\nu}(k_1+k_2) = g
     \bigl( A^{a_1,\mu}(k_1) A^{a_2,\nu}(k_2) - A^{a_1,\nu}(k_1) A^{a_2,\mu}(k_2) \bigr)
\end{equation}
<<Implementation of couplings>>=
pure function x_gg (g, a1, a2) result (x)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1, a2
  type(tensor2odd) :: x
  x = g * (a1 .wedge. a2)
end function x_gg
@
\begin{equation}
  A^{a,\mu}(k_1+k_2) = g A^{a_1}_\nu(k_1) T^{a_2,\nu\mu}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function g_gx (g, a1, x) result (a)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1
  type(tensor2odd), intent(in) :: x
  type(vector) :: a
  a = g * (a1 * x)
end function g_gx
@ \subsection{Scalar Current}
<<Declaration of couplings>>=
public :: v_ss, s_vs
@
\begin{equation}
  V^\mu(k_1+k_2) = g(k_1^\mu - k_2^\mu)\phi_1(k_1)\phi_2(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function v_ss (g, phi1, k1, phi2, k2) result (v)
  complex(kind=default), intent(in) :: g, phi1, phi2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  v = (k1 - k2) * (g * phi1 * phi2)
end function v_ss
@
\begin{equation}
  \phi(k_1+k_2) = g(k_1^\mu + 2k_2^\mu)V_\mu(k_1)\phi(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function s_vs (g, v1, k1, phi2, k2) result (phi)
  complex(kind=default), intent(in) :: g, phi2
  type(vector), intent(in) :: v1
  type(momentum), intent(in) :: k1, k2
  complex(kind=default) :: phi
  phi = g * ((k1 + 2*k2) * v1) * phi2
end function s_vs
@ \subsection{Triple Vector Couplings}
<<Declaration of couplings>>=
public :: tkv_vv, lkv_vv, tv_kvv, lv_kvv, kg_kgkg
public :: t5kv_vv, l5kv_vv, t5v_kvv, l5v_kvv, kg5_kgkg, kg_kg5kg
@
\begin{equation}
  V^\mu(k_1+k_2) = \ii g(k_1-k_2)^\mu V_1^\nu(k_1)V_{2,\nu}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function tkv_vv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  v = (k1 - k2) * ((0, 1) * g * (v1*v2))
end function tkv_vv
@
\begin{equation}
  V^\mu(k_1+k_2) = \ii g \epsilon^{\mu\nu\rho\sigma}
     (k_1-k_2)_{\nu} V_{1,\rho}(k_1)V_{2,\sigma}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function t5kv_vv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  type(vector) :: k
  k = k1 - k2
  v = (0, 1) * g * pseudo_vector (k, v1, v2)
end function t5kv_vv
@
\begin{equation}
  V^\mu(k_1+k_2) = \ii g(k_1+k_2)^\mu V_1^\nu(k_1)V_{2,\nu}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function lkv_vv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  v = (k1 + k2) * ((0, 1) * g * (v1*v2))
end function lkv_vv
@
\begin{equation}
  V^\mu(k_1+k_2) = \ii g \epsilon^{\mu\nu\rho\sigma}
     (k_1+k_2)_{\nu} V_{1,\rho}(k_1)V_{2,\sigma}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function l5kv_vv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  type(vector) :: k
  k = k1 + k2
  v = (0, 1) * g * pseudo_vector (k, v1, v2)
end function l5kv_vv
@ 
\begin{equation}
  V^\mu(k_1+k_2) = \ii g (k_2-k)^\nu V_{1,\nu}(k_1)V_2^\mu(k_2)
       = \ii g (2k_2+k_1)^\nu V_{1,\nu}(k_1)V_2^\mu(k_2)
\end{equation}
using $k=-k_1-k_2$
<<Implementation of couplings>>=
pure function tv_kvv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  v = v2 * ((0, 1) * g * ((2*k2 + k1)*v1))
end function tv_kvv
@ 
\begin{equation}
  V^\mu(k_1+k_2) = \ii g \epsilon^{\mu\nu\rho\sigma}
      (2k_2+k_1)_{\nu} V_{1,\rho}(k_1)V_{2,\sigma}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function t5v_kvv (g, v1, k1, v2, k2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: v
  type(vector) :: k
  k = k1 + 2*k2
  v = (0, 1) * g * pseudo_vector (k, v1, v2)
end function t5v_kvv
@ 
\begin{equation}
  V^\mu(k_1+k_2) = - \ii g k_1^\nu V_{1,\nu}(k_1)V_2^\mu(k_2)
\end{equation}
using $k=-k_1-k_2$
<<Implementation of couplings>>=
pure function lv_kvv (g, v1, k1, v2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1
  type(vector) :: v
  v = v2 * ((0, -1) * g * (k1*v1))
end function lv_kvv
@ 
\begin{equation}
  V^\mu(k_1+k_2) = - \ii g \epsilon^{\mu\nu\rho\sigma}
      k_{1,\nu} V_{1,\rho}(k_1)V_{2,\sigma}(k_2)
\end{equation}
<<Implementation of couplings>>=
pure function l5v_kvv (g, v1, k1, v2) result (v)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1
  type(vector) :: v
  type(vector) :: k
  k = k1
  v = (0, -1) * g * pseudo_vector (k, v1, v2)
end function l5v_kvv
@ 
\begin{equation}
  A^\mu(k_1+k_2) = \ii g k^\nu
     \Bigl(   F_{1,\nu}^{\hphantom{1,\nu}\rho}(k_1)F_{2,\rho\mu}(k_2)
            - F_{1,\mu}^{\hphantom{1,\mu}\rho}(k_1)F_{2,\rho\nu}(k_2) \Bigr)
\end{equation}
with $k=-k_1-k_2$, i.\,e.
\begin{multline}
  A^\mu(k_1+k_2) = -\ii g
     \Bigl(  [(kk_2)(k_1A_2) - (k_1k_2)(kA_2)] A_1^\mu \\
           + [(k_1k_2)(kA_1) - (kk_1)(k_2A_1)] A_2^\mu \\
           + [(k_2A_1)(kA_2) - (kk_2)(A_1A_2)] k_1^\mu \\
           + [(kk_1)(A_1A_2) - (kA_1)(k_1A_2)] k_2^\mu \Bigr)
\end{multline}
<<Implementation of couplings>>=
pure function kg_kgkg (g, a1, k1, a2, k2) result (a)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1, a2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: a
  real(kind=default) :: k1k1, k2k2, k1k2, kk1, kk2
  complex(kind=default) :: a1a2, k2a1, ka1, k1a2, ka2
  k1k1 = k1 * k1
  k1k2 = k1 * k2
  k2k2 = k2 * k2
  kk1 = k1k1 + k1k2
  kk2 = k1k2 + k2k2
  k2a1 = k2 * a1
  ka1 = k2a1 + k1 * a1
  k1a2 = k1 * a2
  ka2 = k1a2 + k2 * a2
  a1a2 = a1 * a2
  a = (0, -1) * g * (   (kk2  * k1a2 - k1k2 * ka2 ) * a1 &
                      + (k1k2 * ka1  - kk1  * k2a1) * a2 &
                      + (ka2  * k2a1 - kk2  * a1a2) * k1 &
                      + (kk1  * a1a2 - ka1  * k1a2) * k2 )
end function kg_kgkg
@ 
\begin{equation}
  A^\mu(k_1+k_2) = \ii g \epsilon^{\mu\nu\rho\sigma} k_{\nu}
      F_{1,\rho}^{\hphantom{1,\rho}\lambda}(k_1)F_{2,\lambda\sigma}(k_2)
\end{equation}
with $k=-k_1-k_2$, i.\,e.
\begin{multline}
  A^\mu(k_1+k_2) = -2\ii g \epsilon^{\mu\nu\rho\sigma} k_{\nu}
     \Bigl(  (k_2A_1) k_{1,\rho} A_{2,\sigma}
           + (k_1A_2) A_{1,\rho} k_{2,\sigma} \\
           - (A_1A_2) k_{1,\rho} k_{2,\sigma}
           - (k_1k_2) A_{1,\rho} A_{2,\sigma} \Bigr)
\end{multline}
<<Implementation of couplings>>=
pure function kg5_kgkg (g, a1, k1, a2, k2) result (a)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1, a2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: a
  type(vector) :: kv, k1v, k2v
  kv = - k1 - k2
  k1v = k1
  k2v = k2
  a = (0, -2) * g * (   (k2*A1) * pseudo_vector (kv, k1v, a2 ) &
                      + (k1*A2) * pseudo_vector (kv, A1 , k2v) &
                      - (A1*A2) * pseudo_vector (kv, k1v, k2v) &
                      - (k1*k2) * pseudo_vector (kv, a1 , a2 ) )
end function kg5_kgkg
@
\begin{equation}
  A^\mu(k_1+k_2) = \ii g k_{\nu} \Bigl(
         \epsilon^{\mu\rho\lambda\sigma}
            F_{1,\hphantom{\nu}\rho}^{\hphantom{1,}\nu}
       - \epsilon^{\nu\rho\lambda\sigma}
            F_{1,\hphantom{\mu}\rho}^{\hphantom{1,}\mu} \Bigr)
              \frac{1}{2} F_{1,\lambda\sigma}
\end{equation}
with $k=-k_1-k_2$, i.\,e.
\begin{multline}
  A^\mu(k_1+k_2) = -\ii g \Bigl(
         \epsilon^{\mu\rho\lambda\sigma} (kk_2) A_{2,\rho} 
       - \epsilon^{\mu\rho\lambda\sigma} (kA_2) k_{2,\rho}
       - k_2^\mu \epsilon^{\nu\rho\lambda\sigma} k_nu A_{2,\rho}
       + A_2^\mu \epsilon^{\nu\rho\lambda\sigma} k_nu k_{2,\rho}
      \Bigr) k_{1,\lambda} A_{1,\sigma}
\end{multline}
\begin{dubious}
  This is not the most efficienct way of doing it:
  $\epsilon^{\mu\nu\rho\sigma}F_{1,\rho\sigma}$ should be cached!
\end{dubious}
<<Implementation of couplings>>=
pure function kg_kg5kg (g, a1, k1, a2, k2) result (a)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: a1, a2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: a
  type(vector) :: kv, k1v, k2v
  kv = - k1 - k2
  k1v = k1
  k2v = k2
  a = (0, -1) * g * (   (kv*k2v) * pseudo_vector (a2 , k1v, a1) &
                      - (kv*a2 ) * pseudo_vector (k2v, k1v, a1) &
                      -  k2v * pseudo_scalar (kv, a2,  k1v, a1) &
                      +  a2  * pseudo_scalar (kv, k2v, k1v, a1) )
end function kg_kg5kg
@ \section{Graviton Couplings}
<<Declaration of couplings>>=
public :: s_gravs, v_gravv, grav_ss, grav_vv
@
<<Implementation of couplings>>=
pure function s_gravs (g, m, k1, k2, t, s) result (phi)
  complex(kind=default), intent(in) :: g, s
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k1, k2
  type(tensor), intent(in) :: t
  complex(kind=default) :: phi, t_tr
  t_tr = t%t(0,0) - t%t(1,1) - t%t(2,2) - t%t(3,3)	
  phi = g * s * (((t*k1)*k2) + ((t*k2)*k1) & 
	- g * (m**2 + (k1*k2))*t_tr)/2.0_default
end function s_gravs
@
<<Implementation of couplings>>=
pure function grav_ss (g, m, k1, k2, s1, s2) result (t)
  complex(kind=default), intent(in) :: g, s1, s2
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k1, k2
  type(tensor) :: t_metric, t 
  t_metric%t = 0
  t_metric%t(0,0) = 1.0_default
  t_metric%t(1,1) = - 1.0_default
  t_metric%t(2,2) = - 1.0_default
  t_metric%t(3,3) = - 1.0_default
  t = g*s1*s2/2.0_default * (-(m**2 + (k1*k2)) * t_metric &
       + (k1.tprod.k2) + (k2.tprod.k1))
end function grav_ss
@
<<Implementation of couplings>>=
pure function v_gravv (g, m, k1, k2, t, v) result (vec)
  complex(kind=default), intent(in) :: g
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k1, k2
  type(vector), intent(in) :: v
  type(tensor), intent(in) :: t
  complex(kind=default) :: t_tr
  real(kind=default) :: xi
  type(vector) :: vec
  xi = 1.0_default
  t_tr = t%t(0,0) - t%t(1,1) - t%t(2,2) - t%t(3,3)	
  vec = (-g)/ 2.0_default * (((k1*k2) + m**2) * &
       (t*v + v*t - t_tr * v) + t_tr * (k1*v) * k2 &
       - (k1*v) * ((k2*t) + (t*k2)) &
       - ((k1*(t*v)) + (v*(t*k1))) * k2 &
       + ((k1*(t*k2)) + (k2*(t*k1))) * v)
!!!       Unitarity gauge: xi -> Infinity
!!!       + (1.0_default/xi) * (t_tr * ((k1*v)*k2) + &
!!!       (k2*v)*k2 + (k2*v)*k1 - (k1*(t*v))*k1 + &
!!!       (k2*v)*(k2*t) - (v*(t*k1))*k1 - (k2*v)*(t*k2)))
end function v_gravv
@
<<Implementation of couplings>>=
pure function grav_vv (g, m, k1, k2, v1, v2) result (t)
  complex(kind=default), intent(in) :: g
  type(momentum), intent(in) :: k1, k2
  real(kind=default), intent(in) :: m
  real(kind=default) :: xi
  type(vector), intent (in) :: v1, v2
  type(tensor) :: t_metric, t 
  xi = 0.00001_default
  t_metric%t = 0
  t_metric%t(0,0) = 1.0_default
  t_metric%t(1,1) = - 1.0_default
  t_metric%t(2,2) = - 1.0_default
  t_metric%t(3,3) = - 1.0_default
  t = (-g)/2.0_default * ( &
       ((k1*k2) + m**2) * ( &
       (v1.tprod.v2) +  (v2.tprod.v1) - (v1*v2) * t_metric) &
       + (v1*k2)*(v2*k1)*t_metric & 
       - (k2*v1)*((v2.tprod.k1) + (k1.tprod.v2)) &
       - (k1*v2)*((v1.tprod.k2) + (k2.tprod.v1)) &
       + (v1*v2)*((k1.tprod.k2) + (k2.tprod.k1)))
!!!       Unitarity gauge: xi -> Infinity
!!!       + (1.0_default/xi) * ( &
!!!       ((k1*v1)*(k1*v2) + (k2*v1)*(k2*v2) + (k1*v1)*(k2*v2))* &
!!!       t_metric) - (k1*v1) * ((k1.tprod.v2) + (v2.tprod.k1)) &
!!!       - (k2*v2) * ((k2.tprod.v1) + (v1.tprod.k2)))
end function grav_vv
@ \section{Tensor Couplings}
<<Declaration of couplings>>=
public :: t2_vv, v_t2v, t2_vv_1, v_t2v_1
@ \section{Scalar-Vector Dim-5 Couplings}
<<Declaration of couplings>>=
public :: phi_vv, v_phiv, phi_u_vv, v_u_phiv
@ 
<<Implementation of couplings>>=
pure function phi_vv (g, k1, k2, v1, v2) result (phi)
  complex(kind=default), intent(in) :: g
  type(momentum), intent(in) :: k1, k2
  type(vector), intent(in) :: v1, v2
  complex(kind=default) :: phi
  phi = g * pseudo_scalar (k1, v1, k2, v2)
end function phi_vv
@ 
<<Implementation of couplings>>=
pure function v_phiv (g, phi, k1, k2, v) result (w)
  complex(kind=default), intent(in) :: g, phi
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k1, k2
  type(vector) :: w
  w = g * phi * pseudo_vector (k1, k2, v)
end function v_phiv
@ 
<<Implementation of couplings>>=
pure function phi_u_vv (g, k1, k2, v1, v2) result (phi)
  complex(kind=default), intent(in) :: g
  type(momentum), intent(in) :: k1, k2
  type(vector), intent(in) :: v1, v2
  complex(kind=default) :: phi
  phi = g * ((k1*v2)*((-(k1+k2))*v1) + &
             (k2*v1)*((-(k1+k2))*v2) + &
             (((k1+k2)*(k1+k2)) * (v1*v2)))
end function phi_u_vv
@ 
<<Implementation of couplings>>=
pure function v_u_phiv (g, phi, k1, k2, v) result (w)
  complex(kind=default), intent(in) :: g, phi
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k1, k2
  type(vector) :: w
  w = g * phi * ((k1*v)*k2 + &
       ((-(k1+k2))*v)*k1 + &
       ((k1*k1)*v))
end function v_u_phiv
@ 
<<Implementation of couplings>>=
pure function t2_vv (g, v1, v2) result (t)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(tensor) :: t
  type(tensor) :: tmp
  tmp = v1.tprod.v2
  t%t = g * (tmp%t + transpose (tmp%t))
end function t2_vv
@ 
<<Implementation of couplings>>=
pure function v_t2v (g, t, v) result (tv)
  complex(kind=default), intent(in) :: g
  type(tensor), intent(in) :: t
  type(vector), intent(in) :: v
  type(vector) :: tv
  type(tensor) :: tmp
  tmp%t = t%t + transpose (t%t)
  tv = g * (tmp * v)
end function v_t2v
@
<<Implementation of couplings>>=
pure function t2_vv_1 (g, v1, v2) result (t)
  complex(kind=default), intent(in) :: g
  complex(kind=default) :: tmp_s
  type(vector), intent(in) :: v1, v2
  type(tensor) :: tmp
  type(tensor) :: t_metric, t 
  t_metric%t = 0
  t_metric%t(0,0) = 1.0_default
  t_metric%t(1,1) = - 1.0_default
  t_metric%t(2,2) = - 1.0_default
  t_metric%t(3,3) = - 1.0_default
  tmp = v1.tprod.v2
  tmp_s = v1 * v2
  t%t = g * (tmp%t + transpose (tmp%t) - tmp_s * t_metric%t )
end function t2_vv_1
@
<<Implementation of couplings>>=
pure function v_t2v_1 (g, t, v) result (tv)
  complex(kind=default), intent(in) :: g
  type(tensor), intent(in) :: t
  type(vector), intent(in) :: v
  type(vector) :: tv, tmp_tv
  type(tensor) :: tmp
  tmp_tv =  ( t%t(0,0)+t%t(1,1)+t%t(2,2)+t%t(3,3) ) * v
  tmp%t = t%t + transpose (t%t)
  tv = g * (tmp * v - tmp_tv)
end function v_t2v_1
@ 
<<Declaration of couplings>>=
public :: t2_vv_d5_1, v_t2v_d5_1
@ 
<<Implementation of couplings>>=
pure function t2_vv_d5_1 (g, v1, k1, v2, k2) result (t)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(tensor) :: t
  t = (g * (v1 * v2)) * (k1-k2).tprod.(k1-k2)
end function t2_vv_d5_1
@ 
<<Implementation of couplings>>=
pure function v_t2v_d5_1 (g, t1, k1, v2, k2) result (tv)
  complex(kind=default), intent(in) :: g
  type(tensor), intent(in) :: t1
  type(vector), intent(in) :: v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: tv
  tv = (g * ((k1+2*k2).tprod.(k1+2*k2) * t1)) * v2
end function v_t2v_d5_1
@ 
<<Declaration of couplings>>=
public :: t2_vv_d5_2, v_t2v_d5_2
@ 
<<Implementation of couplings>>=
pure function t2_vv_d5_2 (g, v1, k1, v2, k2) result (t)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(tensor) :: t
  t = (g * (k2 * v1)) * (k2-k1).tprod.v2
  t%t = t%t + transpose (t%t)
end function t2_vv_d5_2
@ 
<<Implementation of couplings>>=
pure function v_t2v_d5_2 (g, t1, k1, v2, k2) result (tv)
  complex(kind=default), intent(in) :: g
  type(tensor), intent(in) :: t1
  type(vector), intent(in) :: v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: tv
  type(tensor) :: tmp
  type(momentum) :: k1_k2, k1_2k2
  k1_k2 = k1 + k2
  k1_2k2 = k1_k2 + k2
  tmp%t = t1%t + transpose (t1%t)
  tv = (g * (k1_k2 * v2)) * (k1_2k2 * tmp)
end function v_t2v_d5_2
@ 
<<Declaration of couplings>>=
public :: t2_vv_d7, v_t2v_d7
@ 
<<Implementation of couplings>>=
pure function t2_vv_d7 (g, v1, k1, v2, k2) result (t)
  complex(kind=default), intent(in) :: g
  type(vector), intent(in) :: v1, v2
  type(momentum), intent(in) :: k1, k2
  type(tensor) :: t
  t = (g * (k2 * v1) * (k1 * v2)) * (k1-k2).tprod.(k1-k2)
end function t2_vv_d7
@ 
<<Implementation of couplings>>=
pure function v_t2v_d7 (g, t1, k1, v2, k2) result (tv)
  complex(kind=default), intent(in) :: g
  type(tensor), intent(in) :: t1
  type(vector), intent(in) :: v2
  type(momentum), intent(in) :: k1, k2
  type(vector) :: tv
  type(vector) :: k1_k2, k1_2k2
  k1_k2 = k1 + k2
  k1_2k2 = k1_k2 + k2
  tv = (- g * (k1_k2 * v2) * (k1_2k2.tprod.k1_2k2 * t1)) * k2
end function v_t2v_d7
@ \section{Spinor Couplings}
<<[[omega_spinor_couplings.f90]]>>=
<<Copyleft>>
module omega_spinor_couplings
  use kinds
  use constants
  use omega_spinors
  use omega_vectors
  use omega_tensors
  use omega_couplings
  implicit none
  private
  <<Declaration of spinor on shell wave functions>>
  <<Declaration of spinor off shell wave functions>>
  <<Declaration of spinor currents>>
  <<Declaration of spinor propagators>>
  integer, parameter, public :: omega_spinor_cpls_2010_01_A = 0
contains
  <<Implementation of spinor on shell wave functions>>
  <<Implementation of spinor off shell wave functions>>
  <<Implementation of spinor currents>>
  <<Implementation of spinor propagators>>
end module omega_spinor_couplings
@
See table~\ref{tab:fermionic-currents} for the names of Fortran
functions.  We could have used long names instead, but this would
increase the chance of running past continuation line limits without
adding much to the legibility.
@
\subsection{Fermionic Vector and Axial Couplings}
There's more than one chiral representation.  This one is compatible
with HELAS~\cite{HELAS}.
\begin{equation}
  \gamma^0 = \begin{pmatrix} 0 & \mathbf{1} \\ \mathbf{1} & 0 \end{pmatrix},\;
  \gamma^i = \begin{pmatrix} 0 & \sigma^i \\ -\sigma^i & 0 \end{pmatrix},\;
  \gamma_5 = i\gamma^0\gamma^1\gamma^2\gamma^3
           = \begin{pmatrix} -\mathbf{1} & 0 \\ 0 & \mathbf{1} \end{pmatrix}
\end{equation}
Therefore
\begin{subequations}
\begin{align}
  g_S + g_P\gamma_5 &=
    \begin{pmatrix}
      g_S - g_P & 0         & 0         & 0         \\
      0         & g_S - g_P & 0         & 0         \\
      0         & 0         & g_S + g_P & 0         \\
      0         & 0         & 0         & g_S + g_P
    \end{pmatrix} \\
  g_V\gamma^0 - g_A\gamma^0\gamma_5 &=
    \begin{pmatrix}
      0         & 0         & g_V - g_A & 0         \\
      0         & 0         & 0         & g_V - g_A \\
      g_V + g_A & 0         & 0         & 0         \\
      0         & g_V + g_A & 0         & 0
    \end{pmatrix} \\
  g_V\gamma^1 - g_A\gamma^1\gamma_5 &=
    \begin{pmatrix}
      0           & 0           & 0         & g_V - g_A \\
      0           & 0           & g_V - g_A & 0         \\
      0           & - g_V - g_A & 0         & 0         \\
      - g_V - g_A & 0           & 0         & 0
    \end{pmatrix} \\
  g_V\gamma^2 - g_A\gamma^2\gamma_5 &=
    \begin{pmatrix}
      0               & 0              & 0              & -\ii(g_V - g_A) \\
      0               & 0              & \ii(g_V - g_A) & 0               \\
      0               & \ii(g_V + g_A) & 0              & 0               \\
      -\ii(g_V + g_A) & 0              & 0              & 0
    \end{pmatrix} \\
  g_V\gamma^3 - g_A\gamma^3\gamma_5 &=
    \begin{pmatrix}
      0           & 0         & g_V - g_A & 0           \\
      0           & 0         & 0         & - g_V + g_A \\
      - g_V - g_A & 0         & 0         & 0           \\
      0           & g_V + g_A & 0         & 0
    \end{pmatrix}
\end{align}
\end{subequations}
\begin{table}
  \begin{center}
    \begin{tabular}{>{$}l<{$}|>{$}l<{$}}
       \bar\psi(g_V\gamma^\mu - g_A\gamma^\mu\gamma_5)\psi
         & \text{\texttt{va\_ff}}(g_V,g_A,\bar\psi,\psi) \\
       g_V\bar\psi\gamma^\mu\psi
         & \text{\texttt{v\_ff}}(g_V,\bar\psi,\psi) \\
       g_A\bar\psi\gamma_5\gamma^\mu\psi
         & \text{\texttt{a\_ff}}(g_A,\bar\psi,\psi) \\
       g_L\bar\psi\gamma^\mu(1-\gamma_5)\psi
         & \text{\texttt{vl\_ff}}(g_L,\bar\psi,\psi) \\
       g_R\bar\psi\gamma^\mu(1+\gamma_5)\psi
         & \text{\texttt{vr\_ff}}(g_R,\bar\psi,\psi) \\\hline
       \fmslash{V}(g_V - g_A\gamma_5)\psi
         & \text{\texttt{f\_vaf}}(g_V,g_A,V,\psi) \\
       g_V\fmslash{V}\psi
         & \text{\texttt{f\_vf}}(g_V,V,\psi) \\
       g_A\gamma_5\fmslash{V}\psi
         & \text{\texttt{f\_af}}(g_A,V,\psi) \\
       g_L\fmslash{V}(1-\gamma_5)\psi
         & \text{\texttt{f\_vlf}}(g_L,V,\psi) \\
       g_R\fmslash{V}(1+\gamma_5)\psi
         & \text{\texttt{f\_vrf}}(g_R,V,\psi) \\\hline
       \bar\psi\fmslash{V}(g_V - g_A\gamma_5)
         & \text{\texttt{f\_fva}}(g_V,g_A,\bar\psi,V) \\
       g_V\bar\psi\fmslash{V}
         & \text{\texttt{f\_fv}}(g_V,\bar\psi,V) \\
       g_A\bar\psi\gamma_5\fmslash{V}
         & \text{\texttt{f\_fa}}(g_A,\bar\psi,V) \\
       g_L\bar\psi\fmslash{V}(1-\gamma_5)
         & \text{\texttt{f\_fvl}}(g_L,\bar\psi,V) \\
       g_R\bar\psi\fmslash{V}(1+\gamma_5)
         & \text{\texttt{f\_fvr}}(g_R,\bar\psi,V)
    \end{tabular}
  \end{center}
  \caption{\label{tab:fermionic-currents}
    Mnemonically abbreviated names of Fortran functions implementing
    fermionic vector and axial currents.}
\end{table}
\begin{table}
  \begin{center}
    \begin{tabular}{>{$}l<{$}|>{$}l<{$}}
       \bar\psi(g_S + g_P\gamma_5)\psi
         & \text{\texttt{sp\_ff}}(g_S,g_P,\bar\psi,\psi) \\
       g_S\bar\psi\psi
         & \text{\texttt{s\_ff}}(g_S,\bar\psi,\psi) \\
       g_P\bar\psi\gamma_5\psi
         & \text{\texttt{p\_ff}}(g_P,\bar\psi,\psi) \\
       g_L\bar\psi(1-\gamma_5)\psi
         & \text{\texttt{sl\_ff}}(g_L,\bar\psi,\psi) \\
       g_R\bar\psi(1+\gamma_5)\psi
         & \text{\texttt{sr\_ff}}(g_R,\bar\psi,\psi) \\\hline
       \phi(g_S + g_P\gamma_5)\psi
         & \text{\texttt{f\_spf}}(g_S,g_P,\phi,\psi) \\
       g_S\phi\psi
         & \text{\texttt{f\_sf}}(g_S,\phi,\psi) \\
       g_P\phi\gamma_5\psi
         & \text{\texttt{f\_pf}}(g_P,\phi,\psi) \\
       g_L\phi(1-\gamma_5)\psi
         & \text{\texttt{f\_slf}}(g_L,\phi,\psi) \\
       g_R\phi(1+\gamma_5)\psi
         & \text{\texttt{f\_srf}}(g_R,\phi,\psi) \\\hline
       \bar\psi\phi(g_S + g_P\gamma_5)
         & \text{\texttt{f\_fsp}}(g_S,g_P,\bar\psi,\phi) \\
       g_S\bar\psi\phi
         & \text{\texttt{f\_fs}}(g_S,\bar\psi,\phi) \\
       g_P\bar\psi\phi\gamma_5
         & \text{\texttt{f\_fp}}(g_P,\bar\psi,\phi) \\
       g_L\bar\psi\phi(1-\gamma_5)
         & \text{\texttt{f\_fsl}}(g_L,\bar\psi,\phi) \\
       g_R\bar\psi\phi(1+\gamma_5)
         & \text{\texttt{f\_fsr}}(g_R,\bar\psi,\phi)
    \end{tabular}
  \end{center}
  \caption{\label{tab:fermionic-scalar currents}
    Mnemonically abbreviated names of Fortran functions implementing
    fermionic scalar and pseudo scalar ``currents''.}
\end{table}
<<Declaration of spinor currents>>=
public :: va_ff, v_ff, a_ff, vl_ff, vr_ff, vlr_ff, grav_ff, va2_ff, &
          tva_ff, tlr_ff, trl_ff, tvam_ff, tlrm_ff, trlm_ff
@ 
<<Implementation of spinor currents>>=
pure function va_ff (gv, ga, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  gl = gv + ga
  gr = gv - ga
  g13 = psibar%a(1)*psi%a(3)
  g14 = psibar%a(1)*psi%a(4)
  g23 = psibar%a(2)*psi%a(3)
  g24 = psibar%a(2)*psi%a(4)
  g31 = psibar%a(3)*psi%a(1)
  g32 = psibar%a(3)*psi%a(2)
  g41 = psibar%a(4)*psi%a(1)
  g42 = psibar%a(4)*psi%a(2)
  j%t    =  gr * (   g13 + g24) + gl * (   g31 + g42)
  j%x(1) =  gr * (   g14 + g23) - gl * (   g32 + g41)
  j%x(2) = (gr * ( - g14 + g23) + gl * (   g32 - g41)) * (0, 1)
  j%x(3) =  gr * (   g13 - g24) + gl * ( - g31 + g42)
end function va_ff
@
<<Implementation of spinor currents>>=
pure function va2_ff (gva, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in), dimension(2) :: gva
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  gl = gva(1) + gva(2)
  gr = gva(1) - gva(2)
  g13 = psibar%a(1)*psi%a(3)
  g14 = psibar%a(1)*psi%a(4)
  g23 = psibar%a(2)*psi%a(3)
  g24 = psibar%a(2)*psi%a(4)
  g31 = psibar%a(3)*psi%a(1)
  g32 = psibar%a(3)*psi%a(2)
  g41 = psibar%a(4)*psi%a(1)
  g42 = psibar%a(4)*psi%a(2)
  j%t    =  gr * (   g13 + g24) + gl * (   g31 + g42)
  j%x(1) =  gr * (   g14 + g23) - gl * (   g32 + g41)
  j%x(2) = (gr * ( - g14 + g23) + gl * (   g32 - g41)) * (0, 1)
  j%x(3) =  gr * (   g13 - g24) + gl * ( - g31 + g42)
end function va2_ff
@ 
<<Implementation of spinor currents>>=
pure function tva_ff (gv, ga, psibar, psi) result (t)
  type(tensor2odd) :: t
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: g12, g21, g1m2, g34, g43, g3m4
  gr     = gv + ga
  gl     = gv - ga
  g12    = psibar%a(1)*psi%a(2)
  g21    = psibar%a(2)*psi%a(1)
  g1m2   = psibar%a(1)*psi%a(1) - psibar%a(2)*psi%a(2)
  g34    = psibar%a(3)*psi%a(4)
  g43    = psibar%a(4)*psi%a(3)
  g3m4   = psibar%a(3)*psi%a(3) - psibar%a(4)*psi%a(4)
  t%e(1) = (gl * ( - g12 - g21) + gr * (   g34 + g43)) * (0, 1)
  t%e(2) =  gl * ( - g12 + g21) + gr * (   g34 - g43)
  t%e(3) = (gl * ( - g1m2     ) + gr * (   g3m4     )) * (0, 1)
  t%b(1) =  gl * (   g12 + g21) + gr * (   g34 + g43)
  t%b(2) = (gl * ( - g12 + g21) + gr * ( - g34 + g43)) * (0, 1)
  t%b(3) =  gl * (   g1m2     ) + gr * (   g3m4     )
end function tva_ff
@ 
<<Implementation of spinor currents>>=
pure function tlr_ff (gl, gr, psibar, psi) result (t)
  type(tensor2odd) :: t
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  t = tva_ff (gr+gl, gr-gl, psibar, psi)
end function tlr_ff
@ 
<<Implementation of spinor currents>>=
pure function trl_ff (gr, gl, psibar, psi) result (t)
  type(tensor2odd) :: t
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  t = tva_ff (gr+gl, gr-gl, psibar, psi)
end function trl_ff
@ 
<<Implementation of spinor currents>>=
pure function tvam_ff (gv, ga, psibar, psi, p) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: p
  j = (tva_ff(gv, ga, psibar, psi) * p) * (0,1)
end function tvam_ff
@ 
<<Implementation of spinor currents>>=
pure function tlrm_ff (gl, gr, psibar, psi, p) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: p
  j = tvam_ff (gr+gl, gr-gl, psibar, psi, p)
end function tlrm_ff
@ 
<<Implementation of spinor currents>>=
pure function trlm_ff (gr, gl, psibar, psi, p) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: p
  j = tvam_ff (gr+gl, gr-gl, psibar, psi, p)
end function trlm_ff
@ Special cases that avoid some multiplications
<<Implementation of spinor currents>>=
pure function v_ff (gv, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gv
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  g13 = psibar%a(1)*psi%a(3)
  g14 = psibar%a(1)*psi%a(4)
  g23 = psibar%a(2)*psi%a(3)
  g24 = psibar%a(2)*psi%a(4)
  g31 = psibar%a(3)*psi%a(1)
  g32 = psibar%a(3)*psi%a(2)
  g41 = psibar%a(4)*psi%a(1)
  g42 = psibar%a(4)*psi%a(2)
  j%t    =   gv * (   g13 + g24 + g31 + g42)
  j%x(1) =   gv * (   g14 + g23 - g32 - g41)
  j%x(2) =   gv * ( - g14 + g23 + g32 - g41) * (0, 1)
  j%x(3) =   gv * (   g13 - g24 - g31 + g42)
end function v_ff
@
<<Implementation of spinor currents>>=
pure function a_ff (ga, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: ga
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  g13 = psibar%a(1)*psi%a(3)
  g14 = psibar%a(1)*psi%a(4)
  g23 = psibar%a(2)*psi%a(3)
  g24 = psibar%a(2)*psi%a(4)
  g31 = psibar%a(3)*psi%a(1)
  g32 = psibar%a(3)*psi%a(2)
  g41 = psibar%a(4)*psi%a(1)
  g42 = psibar%a(4)*psi%a(2)
  j%t    =   ga * ( - g13 - g24 + g31 + g42)
  j%x(1) = - ga * (   g14 + g23 + g32 + g41)
  j%x(2) =   ga * (   g14 - g23 + g32 - g41) * (0, 1)
  j%x(3) =   ga * ( - g13 + g24 - g31 + g42)
end function a_ff
@ 
<<Implementation of spinor currents>>=
pure function vl_ff (gl, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl2
  complex(kind=default) :: g31, g32, g41, g42
  gl2 = 2 * gl
  g31 = psibar%a(3)*psi%a(1)
  g32 = psibar%a(3)*psi%a(2)
  g41 = psibar%a(4)*psi%a(1)
  g42 = psibar%a(4)*psi%a(2)
  j%t    =   gl2 * (   g31 + g42)
  j%x(1) = - gl2 * (   g32 + g41)
  j%x(2) =   gl2 * (   g32 - g41) * (0, 1)
  j%x(3) =   gl2 * ( - g31 + g42)
end function vl_ff
@ 
<<Implementation of spinor currents>>=
pure function vr_ff (gr, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gr2
  complex(kind=default) :: g13, g14, g23, g24
  gr2 = 2 * gr
  g13 = psibar%a(1)*psi%a(3)
  g14 = psibar%a(1)*psi%a(4)
  g23 = psibar%a(2)*psi%a(3)
  g24 = psibar%a(2)*psi%a(4)
  j%t    = gr2 * (   g13 + g24)
  j%x(1) = gr2 * (   g14 + g23)
  j%x(2) = gr2 * ( - g14 + g23) * (0, 1)
  j%x(3) = gr2 * (   g13 - g24)
end function vr_ff
@ 
<<Implementation of spinor currents>>=
pure function grav_ff (g, m, kb, k, psibar, psi) result (j)
  type(tensor) :: j
  complex(kind=default), intent(in) :: g
  real(kind=default), intent(in) :: m
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: kb, k  
  complex(kind=default) :: g2, g8, c_dum
  type(vector) :: v_dum
  type(tensor) :: t_metric
  t_metric%t = 0
  t_metric%t(0,0) = 1.0_default
  t_metric%t(1,1) = - 1.0_default
  t_metric%t(2,2) = - 1.0_default
  t_metric%t(3,3) = - 1.0_default
  g2 = g/2.0_default
  g8 = g/8.0_default
  v_dum = v_ff(g8, psibar, psi)
  c_dum = (- m) * s_ff (g2, psibar, psi) - (kb+k)*v_dum
  j = c_dum*t_metric - (((kb+k).tprod.v_dum) + &
       (v_dum.tprod.(kb+k)))
end function grav_ff
@
\begin{equation}
     g_L\gamma_\mu(1-\gamma_5) + g_R\gamma_\mu(1+\gamma_5)
   = (g_L+g_R)\gamma_\mu - (g_L-g_R)\gamma_\mu\gamma_5
   = g_V\gamma_\mu - g_A\gamma_\mu\gamma_5
\end{equation}
\ldots{} give the compiler the benefit of the doubt that it will
optimize the function all.  If not, we could inline it \ldots
<<Implementation of spinor currents>>=
pure function vlr_ff (gl, gr, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j = va_ff (gl+gr, gl-gr, psibar, psi)
end function vlr_ff
@ 
and
\begin{equation}
  \fmslash{v} - \fmslash{a}\gamma_5 =
    \begin{pmatrix}
      0         & 0         &   v_- - a_- & - v^* + a^* \\
      0         & 0         & - v   + a   &   v_+ - a_+ \\
      v_+ + a_+ & v^* + a^* & 0           & 0           \\
      v +   a   & v_- + a_- & 0           & 0
    \end{pmatrix}
\end{equation}
with $v_\pm=v_0\pm v_3$, $a_\pm=a_0\pm a_3$, $v=v_1+\ii v_2$,
$v^*=v_1-\ii v_2$, $a=a_1+\ii a_2$, and $a^*=a_1-\ii a_2$.  But note
that~$\cdot^*$ is \emph{not} complex conjugation for complex~$v_\mu$
or~$a_\mu$.
<<Declaration of spinor currents>>=
public :: f_vaf, f_vf, f_af, f_vlf, f_vrf, f_vlrf, f_va2f, &
          f_tvaf, f_tlrf, f_trlf, f_tvamf, f_tlrmf, f_trlmf
@ 
<<Implementation of spinor currents>>=
pure function f_vaf (gv, ga, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gv, ga
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gv + ga
  gr = gv - ga
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gl * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vaf
@
<<Implementation of spinor currents>>=
pure function f_va2f (gva, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in), dimension(2) :: gva
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gva(1) + gva(2)
  gr = gva(1) - gva(2)
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gl * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_va2f
@
<<Implementation of spinor currents>>=
pure function f_tvaf (gv, ga, t, psi) result (tpsi)
  type(spinor) :: tpsi
  complex(kind=default), intent(in) :: gv, ga
  type(tensor2odd), intent(in) :: t
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: e21, e21s, b12, b12s, be3, be3s
  gr   = gv + ga
  gl   = gv - ga
  e21  = t%e(2) + t%e(1)*(0,1)
  e21s = t%e(2) - t%e(1)*(0,1)
  b12  = t%b(1) + t%b(2)*(0,1)
  b12s = t%b(1) - t%b(2)*(0,1)
  be3  = t%b(3) + t%e(3)*(0,1)
  be3s = t%b(3) - t%e(3)*(0,1)
  tpsi%a(1) =   2*gl * (   psi%a(1) * be3  + psi%a(2) * ( e21 +b12s))
  tpsi%a(2) =   2*gl * ( - psi%a(2) * be3  + psi%a(1) * (-e21s+b12 ))
  tpsi%a(3) =   2*gr * (   psi%a(3) * be3s + psi%a(4) * (-e21 +b12s))
  tpsi%a(4) =   2*gr * ( - psi%a(4) * be3s + psi%a(3) * ( e21s+b12 ))
end function f_tvaf
@
<<Implementation of spinor currents>>=
pure function f_tlrf (gl, gr, t, psi) result (tpsi)
  type(spinor) :: tpsi
  complex(kind=default), intent(in) :: gl, gr
  type(tensor2odd), intent(in) :: t
  type(spinor), intent(in) :: psi
  tpsi = f_tvaf (gr+gl, gr-gl, t, psi)
end function f_tlrf
@
<<Implementation of spinor currents>>=
pure function f_trlf (gr, gl, t, psi) result (tpsi)
  type(spinor) :: tpsi
  complex(kind=default), intent(in) :: gl, gr
  type(tensor2odd), intent(in) :: t
  type(spinor), intent(in) :: psi
  tpsi = f_tvaf (gr+gl, gr-gl, t, psi)
end function f_trlf
@
<<Implementation of spinor currents>>=
pure function f_tvamf (gv, ga, v, psi, k) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gv, ga
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  type(tensor2odd) :: t
  t = (v.wedge.k) * (0, 0.5)
  vpsi = f_tvaf(gv, ga, t, psi)
end function f_tvamf
@
<<Implementation of spinor currents>>=
pure function f_tlrmf (gl, gr, v, psi, k) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gl, gr
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  vpsi = f_tvamf (gr+gl, gr-gl, v, psi, k)
end function f_tlrmf
@
<<Implementation of spinor currents>>=
pure function f_trlmf (gr, gl, v, psi, k) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gl, gr
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  vpsi = f_tvamf (gr+gl, gr-gl, v, psi, k)
end function f_trlmf
@
<<Implementation of spinor currents>>=
pure function f_vf (gv, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gv
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gv * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gv * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gv * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gv * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vf
@ 
<<Implementation of spinor currents>>=
pure function f_af (ga, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: ga
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = ga * ( - vm  * psi%a(3) + v12s * psi%a(4))
  vpsi%a(2) = ga * (   v12 * psi%a(3) - vp   * psi%a(4))
  vpsi%a(3) = ga * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = ga * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_af
@ 
<<Implementation of spinor currents>>=
pure function f_vlf (gl, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gl
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gl2
  complex(kind=default) :: vp, vm, v12, v12s
  gl2 = 2 * gl
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = 0
  vpsi%a(2) = 0
  vpsi%a(3) = gl2 * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl2 * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vlf
@ 
<<Implementation of spinor currents>>=
pure function f_vrf (gr, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gr
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  complex(kind=default) :: gr2
  complex(kind=default) :: vp, vm, v12, v12s
  gr2 = 2 * gr
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr2 * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr2 * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = 0
  vpsi%a(4) = 0
end function f_vrf
@ 
<<Implementation of spinor currents>>=
pure function f_vlrf (gl, gr, v, psi) result (vpsi)
  type(spinor) :: vpsi
  complex(kind=default), intent(in) :: gl, gr
  type(vector), intent(in) :: v
  type(spinor), intent(in) :: psi
  vpsi = f_vaf (gl+gr, gl-gr, v, psi)
end function f_vlrf
@
<<Declaration of spinor currents>>=
public :: f_fva, f_fv, f_fa, f_fvl, f_fvr, f_fvlr, f_fva2, &
          f_ftva, f_ftlr, f_ftrl, f_ftvam, f_ftlrm, f_ftrlm
@ 
<<Implementation of spinor currents>>=
pure function f_fva (gv, ga, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gv + ga
  gr = gv - ga
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = gl * (   psibar%a(3) * vp   + psibar%a(4) * v12)
  psibarv%a(2) = gl * (   psibar%a(3) * v12s + psibar%a(4) * vm )
  psibarv%a(3) = gr * (   psibar%a(1) * vm   - psibar%a(2) * v12)
  psibarv%a(4) = gr * ( - psibar%a(1) * v12s + psibar%a(2) * vp )
end function f_fva
@ 
<<Implementation of spinor currents>>=
pure function f_fva2 (gva, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in), dimension(2) :: gva
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gva(1) + gva(2)
  gr = gva(1) - gva(2)
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = gl * (   psibar%a(3) * vp   + psibar%a(4) * v12)
  psibarv%a(2) = gl * (   psibar%a(3) * v12s + psibar%a(4) * vm )
  psibarv%a(3) = gr * (   psibar%a(1) * vm   - psibar%a(2) * v12)
  psibarv%a(4) = gr * ( - psibar%a(1) * v12s + psibar%a(2) * vp )
end function f_fva2
@ 
<<Implementation of spinor currents>>=
pure function f_ftva (gv, ga, psibar, t) result (psibart)
  type(conjspinor) :: psibart
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(tensor2odd), intent(in) :: t
  complex(kind=default) :: gl, gr
  complex(kind=default) :: e21, e21s, b12, b12s, be3, be3s
  gr   = gv + ga
  gl   = gv - ga
  e21  = t%e(2) + t%e(1)*(0,1)
  e21s = t%e(2) - t%e(1)*(0,1)
  b12  = t%b(1) + t%b(2)*(0,1)
  b12s = t%b(1) - t%b(2)*(0,1)
  be3  = t%b(3) + t%e(3)*(0,1)
  be3s = t%b(3) - t%e(3)*(0,1)
  psibart%a(1) = 2*gl * (   psibar%a(1) * be3  + psibar%a(2) * (-e21s+b12 ))
  psibart%a(2) = 2*gl * ( - psibar%a(2) * be3  + psibar%a(1) * ( e21 +b12s))
  psibart%a(3) = 2*gr * (   psibar%a(3) * be3s + psibar%a(4) * ( e21s+b12 ))
  psibart%a(4) = 2*gr * ( - psibar%a(4) * be3s + psibar%a(3) * (-e21 +b12s))
end function f_ftva
@
<<Implementation of spinor currents>>=
pure function f_ftlr (gl, gr, psibar, t) result (psibart)
  type(conjspinor) :: psibart
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(tensor2odd), intent(in) :: t
  psibart = f_ftva (gr+gl, gr-gl, psibar, t)
end function f_ftlr
@
<<Implementation of spinor currents>>=
pure function f_ftrl (gr, gl, psibar, t) result (psibart)
  type(conjspinor) :: psibart
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(tensor2odd), intent(in) :: t
  psibart = f_ftva (gr+gl, gr-gl, psibar, t)
end function f_ftrl
@
<<Implementation of spinor currents>>=
pure function f_ftvam (gv, ga, psibar, v, k) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gv, ga
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  type(tensor2odd) :: t
  t = (v.wedge.k) * (0, 0.5)
  psibarv = f_ftva(gv, ga, psibar, t)
end function f_ftvam
@
<<Implementation of spinor currents>>=
pure function f_ftlrm (gl, gr, psibar, v, k) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  psibarv = f_ftvam (gr+gl, gr-gl, psibar, v, k)
end function f_ftlrm
@
<<Implementation of spinor currents>>=
pure function f_ftrlm (gr, gl, psibar, v, k) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  psibarv = f_ftvam (gr+gl, gr-gl, psibar, v, k)
end function f_ftrlm
@
<<Implementation of spinor currents>>=
pure function f_fv (gv, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gv
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = gv * (   psibar%a(3) * vp   + psibar%a(4) * v12)
  psibarv%a(2) = gv * (   psibar%a(3) * v12s + psibar%a(4) * vm )
  psibarv%a(3) = gv * (   psibar%a(1) * vm   - psibar%a(2) * v12)
  psibarv%a(4) = gv * ( - psibar%a(1) * v12s + psibar%a(2) * vp )
end function f_fv
@ 
<<Implementation of spinor currents>>=
pure function f_fa (ga, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: ga
  type(vector), intent(in) :: v
  type(conjspinor), intent(in) :: psibar
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = ga * (   psibar%a(3) * vp   + psibar%a(4) * v12)
  psibarv%a(2) = ga * (   psibar%a(3) * v12s + psibar%a(4) * vm )
  psibarv%a(3) = ga * ( - psibar%a(1) * vm   + psibar%a(2) * v12)
  psibarv%a(4) = ga * (   psibar%a(1) * v12s - psibar%a(2) * vp )
end function f_fa
@ 
<<Implementation of spinor currents>>=
pure function f_fvl (gl, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gl
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  complex(kind=default) :: gl2
  complex(kind=default) :: vp, vm, v12, v12s
  gl2 = 2 * gl
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = gl2 * (   psibar%a(3) * vp   + psibar%a(4) * v12)
  psibarv%a(2) = gl2 * (   psibar%a(3) * v12s + psibar%a(4) * vm )
  psibarv%a(3) = 0
  psibarv%a(4) = 0
end function f_fvl
@ 
<<Implementation of spinor currents>>=
pure function f_fvr (gr, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gr
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  complex(kind=default) :: gr2
  complex(kind=default) :: vp, vm, v12, v12s
  gr2 = 2 * gr
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  psibarv%a(1) = 0
  psibarv%a(2) = 0
  psibarv%a(3) = gr2 * (   psibar%a(1) * vm   - psibar%a(2) * v12)
  psibarv%a(4) = gr2 * ( - psibar%a(1) * v12s + psibar%a(2) * vp )
end function f_fvr
@ 
<<Implementation of spinor currents>>=
pure function f_fvlr (gl, gr, psibar, v) result (psibarv)
  type(conjspinor) :: psibarv
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  psibarv = f_fva (gl+gr, gl-gr, psibar, v)
end function f_fvlr
@ \subsection{Fermionic Scalar and Pseudo Scalar Couplings}
<<Declaration of spinor currents>>=
public :: sp_ff, s_ff, p_ff, sl_ff, sr_ff, slr_ff
@ 
<<Implementation of spinor currents>>=
pure function sp_ff (gs, gp, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gs, gp
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j =    (gs - gp) * (psibar%a(1)*psi%a(1) + psibar%a(2)*psi%a(2)) &
       + (gs + gp) * (psibar%a(3)*psi%a(3) + psibar%a(4)*psi%a(4))
end function sp_ff
@ 
<<Implementation of spinor currents>>=
pure function s_ff (gs, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gs
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j = gs * (psibar * psi)
end function s_ff
@ 
<<Implementation of spinor currents>>=
pure function p_ff (gp, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gp
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j = gp * (  psibar%a(3)*psi%a(3) + psibar%a(4)*psi%a(4) &
            - psibar%a(1)*psi%a(1) - psibar%a(2)*psi%a(2))
end function p_ff
@ 
<<Implementation of spinor currents>>=
pure function sl_ff (gl, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j =  2 * gl * (psibar%a(1)*psi%a(1) + psibar%a(2)*psi%a(2))
end function sl_ff
@ 
<<Implementation of spinor currents>>=
pure function sr_ff (gr, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j = 2 * gr * (psibar%a(3)*psi%a(3) + psibar%a(4)*psi%a(4))
end function sr_ff
@
\begin{equation}
     g_L(1-\gamma_5) + g_R(1+\gamma_5)
   = (g_R+g_L) + (g_R-g_L)\gamma_5
   = g_S + g_P\gamma_5
\end{equation}
<<Implementation of spinor currents>>=
pure function slr_ff (gl, gr, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  type(spinor), intent(in) :: psi
  j = sp_ff (gr+gl, gr-gl, psibar, psi)
end function slr_ff
@
<<Declaration of spinor currents>>=
public :: f_spf, f_sf, f_pf, f_slf, f_srf, f_slrf
@ 
<<Implementation of spinor currents>>=
pure function f_spf (gs, gp, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gs, gp
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi%a(1:2) = ((gs - gp) * phi) * psi%a(1:2)
  phipsi%a(3:4) = ((gs + gp) * phi) * psi%a(3:4)
end function f_spf
@ 
<<Implementation of spinor currents>>=
pure function f_sf (gs, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gs
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi%a = (gs * phi) * psi%a
end function f_sf
@ 
<<Implementation of spinor currents>>=
pure function f_pf (gp, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gp
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi%a(1:2) = (- gp * phi) * psi%a(1:2)
  phipsi%a(3:4) = (  gp * phi) * psi%a(3:4)
end function f_pf
@ 
<<Implementation of spinor currents>>=
pure function f_slf (gl, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gl
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi%a(1:2) = (2 * gl * phi) * psi%a(1:2)
  phipsi%a(3:4) = 0
end function f_slf
@ 
<<Implementation of spinor currents>>=
pure function f_srf (gr, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gr
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi%a(1:2) = 0
  phipsi%a(3:4) = (2 * gr * phi) * psi%a(3:4)
end function f_srf
@ 
<<Implementation of spinor currents>>=
pure function f_slrf (gl, gr, phi, psi) result (phipsi)
  type(spinor) :: phipsi
  complex(kind=default), intent(in) :: gl, gr
  complex(kind=default), intent(in) :: phi
  type(spinor), intent(in) :: psi
  phipsi =  f_spf (gr+gl, gr-gl, phi, psi)
end function f_slrf
@
<<Declaration of spinor currents>>=
public :: f_fsp, f_fs, f_fp, f_fsl, f_fsr, f_fslr
@ 
<<Implementation of spinor currents>>=
pure function f_fsp (gs, gp, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gs, gp
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi%a(1:2) = ((gs - gp) * phi) * psibar%a(1:2)
  psibarphi%a(3:4) = ((gs + gp) * phi) * psibar%a(3:4)
end function f_fsp
@ 
<<Implementation of spinor currents>>=
pure function f_fs (gs, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gs
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi%a = (gs * phi) * psibar%a
end function f_fs
@ 
<<Implementation of spinor currents>>=
pure function f_fp (gp, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gp
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi%a(1:2) = (- gp * phi) * psibar%a(1:2)
  psibarphi%a(3:4) = (  gp * phi) * psibar%a(3:4)
end function f_fp
@ 
<<Implementation of spinor currents>>=
pure function f_fsl (gl, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gl
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi%a(1:2) = (2 * gl * phi) * psibar%a(1:2)
  psibarphi%a(3:4) = 0
end function f_fsl
@ 
<<Implementation of spinor currents>>=
pure function f_fsr (gr, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gr
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi%a(1:2) = 0
  psibarphi%a(3:4) = (2 * gr * phi) * psibar%a(3:4)
end function f_fsr
@ 
<<Implementation of spinor currents>>=
pure function f_fslr (gl, gr, psibar, phi) result (psibarphi)
  type(conjspinor) :: psibarphi
  complex(kind=default), intent(in) :: gl, gr
  type(conjspinor), intent(in) :: psibar
  complex(kind=default), intent(in) :: phi
  psibarphi = f_fsp (gr+gl, gr-gl, psibar, phi)
end function f_fslr
<<Declaration of spinor currents>>=
public :: f_gravf, f_fgrav
@ 
<<Implementation of spinor currents>>=
pure function f_gravf (g, m, kb, k, t, psi) result (tpsi)
  type(spinor) :: tpsi
  complex(kind=default), intent(in) :: g
  real(kind=default), intent(in) :: m
  type(spinor), intent(in) :: psi
  type(tensor), intent(in) :: t
  type(momentum), intent(in) :: kb, k
  complex(kind=default) :: g2, g8, t_tr
  type(vector) :: kkb
  kkb = k + kb
  g2 = g / 2.0_default
  g8 = g / 8.0_default
  t_tr = t%t(0,0) - t%t(1,1) - t%t(2,2) - t%t(3,3)	
  tpsi = (- f_sf (g2, cmplx (m,0.0, kind=default), psi) & 
         - f_vf ((g8*m), kkb, psi)) * t_tr - &
	 f_vf (g8,(t*kkb + kkb*t),psi)
end function f_gravf
@ 
<<Implementation of spinor currents>>=
pure function f_fgrav (g, m, kb, k, psibar, t) result (psibart)
  type(conjspinor) :: psibart
  complex(kind=default), intent(in) :: g
  real(kind=default), intent(in) :: m
  type(conjspinor), intent(in) :: psibar
  type(tensor), intent(in) :: t
  type(momentum), intent(in) :: kb, k
  type(vector) :: kkb
  complex(kind=default) :: g2, g8, t_tr
  kkb = k + kb
  g2 = g / 2.0_default
  g8 = g / 8.0_default
  t_tr = t%t(0,0) - t%t(1,1) - t%t(2,2) - t%t(3,3)	
  psibart = (- f_fs (g2, psibar, cmplx (m, 0.0, kind=default)) &
      - f_fv ((g8 * m), psibar, kkb)) * t_tr - &
      f_fv (g8,psibar,(t*kkb + kkb*t)) 
end function f_fgrav
@ \subsection{On Shell Wave Functions}
<<Declaration of spinor on shell wave functions>>=
public :: u, ubar, v, vbar
private :: chi_plus, chi_minus
@
\begin{subequations}
\begin{align}
  \chi_+(\vec p) &=
     \frac{1}{\sqrt{2|\vec p|(|\vec p|+p_3)}}
     \begin{pmatrix} |\vec p|+p_3 \\ p_1 + \ii p_2 \end{pmatrix} \\
  \chi_-(\vec p) &=
     \frac{1}{\sqrt{2|\vec p|(|\vec p|+p_3)}}
     \begin{pmatrix} - p_1 + \ii p_2 \\ |\vec p|+p_3 \end{pmatrix}
\end{align}
\end{subequations}
<<Implementation of spinor on shell wave functions>>=
pure function chi_plus (p) result (chi)
  complex(kind=default), dimension(2) :: chi
  type(momentum), intent(in) :: p
  real(kind=default) :: pabs
  pabs = sqrt (dot_product (p%x, p%x))
  if (pabs + p%x(3) <= 1000 * epsilon (pabs) * pabs) then
     chi = (/ cmplx ( 0.0, 0.0, kind=default), &
              cmplx ( 1.0, 0.0, kind=default) /)
  else
     chi = 1 / sqrt (2*pabs*(pabs + p%x(3))) &
          * (/ cmplx (pabs + p%x(3), kind=default), &
               cmplx (p%x(1), p%x(2), kind=default) /)
  end if
end function chi_plus
@
<<Implementation of spinor on shell wave functions>>=
pure function chi_minus (p) result (chi)
  complex(kind=default), dimension(2) :: chi
  type(momentum), intent(in) :: p
  real(kind=default) :: pabs
  pabs = sqrt (dot_product (p%x, p%x))
  if (pabs + p%x(3) <= 1000 * epsilon (pabs) * pabs) then
     chi = (/ cmplx (-1.0, 0.0, kind=default), &
              cmplx ( 0.0, 0.0, kind=default) /)
  else
     chi = 1 / sqrt (2*pabs*(pabs + p%x(3))) &
          * (/ cmplx (-p%x(1), p%x(2), kind=default), &
               cmplx (pabs + p%x(3), kind=default) /)
  end if
end function chi_minus
@
\begin{equation}
  u_\pm(p,|m|) = 
     \begin{pmatrix}
       \sqrt{p_0\mp|\vec p|} \cdot \chi_\pm(\vec p) \\
       \sqrt{p_0\pm|\vec p|} \cdot \chi_\pm(\vec p)
     \end{pmatrix}\qquad
  u_\pm(p,-|m|) = 
     \begin{pmatrix}
       - i \sqrt{p_0\mp|\vec p|} \cdot \chi_\pm(\vec p) \\
       + i \sqrt{p_0\pm|\vec p|} \cdot \chi_\pm(\vec p)
     \end{pmatrix}
\end{equation}
Determining the mass from the momenta is a numerically haphazardous for
light particles.  Therefore, we accept some redundancy and pass the
mass explicitely.  Even if the mass is not used in the chiral
representation, we do so for symmetry with polarization vectors and to
be prepared for other representations.
<<Implementation of spinor on shell wave functions>>=
pure function u (mass, p, s) result (psi)
  type(spinor) :: psi
  real(kind=default), intent(in) :: mass
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  complex(kind=default), dimension(2) :: chi
  real(kind=default) :: pabs, delta, m
  m = abs(mass)
  pabs = sqrt (dot_product (p%x, p%x))
  if (m < epsilon (m) * pabs) then 
      delta = 0
  else
      delta = sqrt (max (p%t - pabs, 0._default))
  end if
  select case (s)
  case (1)
     chi = chi_plus (p)
     psi%a(1:2) = delta * chi
     psi%a(3:4) = sqrt (p%t + pabs) * chi
  case (-1)
     chi = chi_minus (p)
     psi%a(1:2) = sqrt (p%t + pabs) * chi
     psi%a(3:4) = delta * chi
  case default
     pabs = m ! make the compiler happy and use m
     psi%a = 0
  end select
  if (mass < 0) then
     psi%a(1:2) = - imago * psi%a(1:2)
     psi%a(3:4) = + imago * psi%a(3:4)
  end if
end function u
@ 
<<Implementation of spinor on shell wave functions>>=
pure function ubar (m, p, s) result (psibar)
  type(conjspinor) :: psibar
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  type(spinor) :: psi  
  psi = u (m, p, s)
  psibar%a(1:2) = conjg (psi%a(3:4))
  psibar%a(3:4) = conjg (psi%a(1:2))
end function ubar
@ 
\begin{equation}
  v_\pm(p) = 
     \begin{pmatrix}
       \mp\sqrt{p_0\pm|\vec p|} \cdot \chi_\mp(\vec p) \\
       \pm\sqrt{p_0\mp|\vec p|} \cdot \chi_\mp(\vec p)
     \end{pmatrix}
\end{equation}
<<Implementation of spinor on shell wave functions>>=
pure function v (mass, p, s) result (psi)
  type(spinor) :: psi
  real(kind=default), intent(in) :: mass
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  complex(kind=default), dimension(2) :: chi
  real(kind=default) :: pabs, delta, m
  m = abs(mass)
  pabs = sqrt (dot_product (p%x, p%x))
  if (m < epsilon (m) * pabs) then
      delta = 0
  else
      delta = sqrt (max (p%t - pabs, 0._default))
  end if
  select case (s)
  case (1)
     chi = chi_minus (p)
     psi%a(1:2) = - sqrt (p%t + pabs) * chi
     psi%a(3:4) =   delta * chi
  case (-1)
     chi = chi_plus (p)
     psi%a(1:2) =   delta * chi
     psi%a(3:4) = - sqrt (p%t + pabs) * chi
  case default
     pabs = m ! make the compiler happy and use m
     psi%a = 0
  end select
  if (mass < 0) then
     psi%a(1:2) = - imago * psi%a(1:2)
     psi%a(3:4) = + imago * psi%a(3:4)
   end if
end function v
@ 
<<Implementation of spinor on shell wave functions>>=
pure function vbar (m, p, s) result (psibar)
  type(conjspinor) :: psibar
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  type(spinor) :: psi
  psi = v (m, p, s)
  psibar%a(1:2) = conjg (psi%a(3:4))
  psibar%a(3:4) = conjg (psi%a(1:2))
end function vbar
@
\subsection{Off Shell Wave Functions}
I've just taken this over from Christian Schwinn's version. 
<<Declaration of spinor off shell wave functions>>=
public :: brs_u, brs_ubar, brs_v, brs_vbar
@
The off-shell wave functions needed for gauge checking are obtained from the LSZ-formulas:
\begin{subequations}
\begin{align}
\Braket{\text{Out}|d^\dagger|\text{In}}&=i\int d^4x \bar v
e^{-ikx}(i\fmslash\partial-m)\Braket{\text{Out}|\psi|\text{In}}\\
\Braket{\text{Out}|b|\text{In}}&=-i\int d^4x \bar u
e^{ikx}(i\fmslash\partial-m)\Braket{\text{Out}|\psi|\text{In}}\\
\Braket{\text{Out}|d|\text{In}}&=
  i\int d^4x \Braket{\text{Out}|\bar \psi|
  \text{In}}(-i\fmslash{\overleftarrow\partial}-m)v e^{ikx}\\
\Braket{\text{Out}|b^\dagger|\text{In}}&=
  -i\int d^4x \Braket{\text{Out}|\bar \psi|
  \text{In}}(-i\fmslash{\overleftarrow\partial}-m)u e^{-ikx}
\end{align}
\end{subequations}
Since the relative sign between fermions and antifermions is ignored for
on-shell amplitudes we must also ignore it here, so all wavefunctions must
have a $(-i)$ factor.
In momentum space we have:
\begin{equation}
brs u(p)=(-i) (\fmslash p-m)u(p)
\end{equation}
<<Implementation of spinor off shell wave functions>>=
pure function brs_u (m, p, s) result (dpsi)
    type(spinor) :: dpsi,psi
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) :: s
    type (vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
    vp=p
    psi=u(m,p,s)
    dpsi=cmplx(0.0,-1.0)*(f_vf(one,vp,psi)-m*psi)
end function brs_u
@
\begin{equation}
brs v(p)=i (\fmslash p+m)v(p)
\end{equation}
<<Implementation of spinor off shell wave functions>>=
pure function brs_v (m, p, s) result (dpsi)
    type(spinor) :: dpsi, psi
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) ::   s
    type (vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
    vp=p
    psi=v(m,p,s)
    dpsi=cmplx(0.0,1.0)*(f_vf(one,vp,psi)+m*psi)
end function brs_v
@
\begin{equation}
brs \bar{u}(p)=(-i)\bar u(p)(\fmslash p-m)
\end{equation}
<<Implementation of spinor off shell wave functions>>=
 pure function brs_ubar (m, p, s)result (dpsibar)
    type(conjspinor) :: dpsibar, psibar
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) :: s
    type (vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
     vp=p
     psibar=ubar(m,p,s)
    dpsibar=cmplx(0.0,-1.0)*(f_fv(one,psibar,vp)-m*psibar)
  end function brs_ubar
@
\begin{equation}
brs \bar{v}(p)=(i)\bar v(p)(\fmslash p+m)
\end{equation}
<<Implementation of spinor off shell wave functions>>=
 pure function brs_vbar (m, p, s) result (dpsibar)
    type(conjspinor) :: dpsibar,psibar
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) :: s
    type(vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
    vp=p
    psibar=vbar(m,p,s)
   dpsibar=cmplx(0.0,1.0)*(f_fv(one,psibar,vp)+m*psibar)
end function brs_vbar
@
NB: The remarks on momentum flow in the propagators don't apply
here since the incoming momenta are flipped for the wave functions.       
@ \subsection{Propagators}
NB: the common factor of~$\ii$ is extracted:
<<Declaration of spinor propagators>>=
public :: pr_psi, pr_psibar
public :: pj_psi, pj_psibar
public :: pg_psi, pg_psibar
@
\begin{equation}
   \frac{i(-\fmslash{p}+m)}{p^2-m^2+\ii m\Gamma}\psi
\end{equation}
NB: the sign of the momentum comes about because all momenta are
treated as \emph{outgoing} and the particle charge flow is therefore
opposite to the momentum.
<<Implementation of spinor propagators>>=
pure function pr_psi (p, m, w, psi) result (ppsi)
  type(spinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(spinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = (1 / cmplx (p*p - m**2, m*w, kind=default)) &
       * (- f_vf (one, vp, psi) + m * psi)
end function pr_psi
@
\begin{equation}
  \sqrt{\frac{\pi}{M\Gamma}}
    (-\fmslash{p}+m)\psi
\end{equation}
<<Implementation of spinor propagators>>=
pure function pj_psi (p, m, w, psi) result (ppsi)
  type(spinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(spinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = (0, -1) * sqrt (PI / m / w) * (- f_vf (one, vp, psi) + m * psi)
end function pj_psi
@ 
<<Implementation of spinor propagators>>=
pure function pg_psi (p, m, w, psi) result (ppsi)
  type(spinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(spinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = gauss(p*p, m, w) *  (- f_vf (one, vp, psi) + m * psi)
end function pg_psi
@
\begin{equation}
   \bar\psi \frac{i(\fmslash{p}+m)}{p^2-m^2+\ii m\Gamma}
\end{equation}
NB: the sign of the momentum comes about because all momenta are
treated as \emph{outgoing} and the antiparticle charge flow is
therefore parallel to the momentum.
<<Implementation of spinor propagators>>=
pure function pr_psibar (p, m, w, psibar) result (ppsibar)
  type(conjspinor) :: ppsibar
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(conjspinor), intent(in) :: psibar
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsibar = (1 / cmplx (p*p - m**2, m*w, kind=default)) &
       * (f_fv (one, psibar, vp) + m * psibar)
end function pr_psibar
@
\begin{equation}
  \sqrt{\frac{\pi}{M\Gamma}}
    \bar\psi (\fmslash{p}+m)
\end{equation}
NB: the sign of the momentum comes about because all momenta are
treated as \emph{outgoing} and the antiparticle charge flow is
therefore parallel to the momentum.
<<Implementation of spinor propagators>>=
pure function pj_psibar (p, m, w, psibar) result (ppsibar)
  type(conjspinor) :: ppsibar
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(conjspinor), intent(in) :: psibar
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsibar = (0, -1) * sqrt (PI / m / w) * (f_fv (one, psibar, vp) + m * psibar)
end function pj_psibar
@ 
<<Implementation of spinor propagators>>=
pure function pg_psibar (p, m, w, psibar) result (ppsibar)
  type(conjspinor) :: ppsibar
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(conjspinor), intent(in) :: psibar
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsibar = gauss (p*p, m, w) * (f_fv (one, psibar, vp) + m * psibar)
end function pg_psibar
@
\begin{equation}
   \frac{i(-\fmslash{p}+m)}{p^2-m^2+\ii m\Gamma} \sum_n \psi_n\otimes\bar\psi_n
\end{equation}
NB: the temporary variables [[psi(1:4)]] are not nice, but the compilers
should be able to optimize the unnecessary copies away.  In any case, even
if the copies are performed, they are (probably) negligible compared to the
floating point multiplications anyway \ldots
<<(Not used yet) Declaration of operations for spinors>>=
type, public :: spinordyad
   ! private (omegalib needs access, but DON'T TOUCH IT!)
   complex(kind=default), dimension(4,4) :: a
end type spinordyad
@ 
<<(Not used yet) Implementation of spinor propagators>>=
pure function pr_dyadleft (p, m, w, psipsibar) result (psipsibarp)
  type(spinordyad) :: psipsibarp
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(spinordyad), intent(in) :: psipsibar
  integer :: i
  type(vector) :: vp
  type(spinor), dimension(4) :: psi
  complex(kind=default) :: pole
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  pole = 1 / cmplx (p*p - m**2, m*w, kind=default)
  do i = 1, 4
     psi(i)%a = psipsibar%a(:,i)
     psi(i) = pole * (- f_vf (one, vp, psi(i)) + m * psi(i))
     psipsibarp%a(:,i) = psi(i)%a
  end do
end function pr_dyadleft
@
\begin{equation}
   \sum_n \psi_n\otimes\bar\psi_n \frac{i(\fmslash{p}+m)}{p^2-m^2+\ii m\Gamma}
\end{equation}
<<(Not used yet) Implementation of spinor propagators>>=
pure function pr_dyadright (p, m, w, psipsibar) result (psipsibarp)
  type(spinordyad) :: psipsibarp
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(spinordyad), intent(in) :: psipsibar
  integer :: i
  type(vector) :: vp
  type(conjspinor), dimension(4) :: psibar
  complex(kind=default) :: pole
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  pole = 1 / cmplx (p*p - m**2, m*w, kind=default)
  do i = 1, 4
     psibar(i)%a = psipsibar%a(i,:)
     psibar(i) = pole * (f_fv (one, psibar(i), vp) + m * psibar(i))
     psipsibarp%a(i,:) = psibar(i)%a
  end do
end function pr_dyadright
@
\section{Spinor Couplings Revisited}
<<[[omega_bispinor_couplings.f90]]>>=
<<Copyleft>>
module omega_bispinor_couplings
  use kinds
  use constants
  use omega_bispinors
  use omega_vectorspinors
  use omega_vectors
  use omega_couplings
  implicit none
  private
  <<Declaration of bispinor on shell wave functions>>
  <<Declaration of bispinor off shell wave functions>>
  <<Declaration of bispinor currents>>
  <<Declaration of bispinor propagators>>
  integer, parameter, public :: omega_bispinor_cpls_2010_01_A = 0
contains
  <<Implementation of bispinor on shell wave functions>>
  <<Implementation of bispinor off shell wave functions>>
  <<Implementation of bispinor currents>>
  <<Implementation of bispinor propagators>>
end module omega_bispinor_couplings
@
See table~\ref{tab:fermionic-currents} for the names of Fortran
functions.  We could have used long names instead, but this would
increase the chance of running past continuation line limits without
adding much to the legibility.
@
\subsection{Fermionic Vector and Axial Couplings}
There's more than one chiral representation.  This one is compatible
with HELAS~\cite{HELAS}.
\begin{subequations}
\begin{align}
  & \gamma^0 = \begin{pmatrix} 0 & \mathbf{1} \\ \mathbf{1} & 0 
    \end{pmatrix},\;
  \gamma^i = \begin{pmatrix} 0 & \sigma^i \\ -\sigma^i & 0 \end{pmatrix},\;
  \gamma_5 = i\gamma^0\gamma^1\gamma^2\gamma^3
           = \begin{pmatrix} -\mathbf{1} & 0 \\ 0 & \mathbf{1}
           \end{pmatrix}, \\ &
  C = \begin{pmatrix} \epsilon & 0 \\ 0 & - \epsilon \end{pmatrix} 
  \; , \qquad \epsilon = \begin{pmatrix} 0 & 1 \\ -1 & 0 \end{pmatrix}  .
\end{align}
\end{subequations}
Therefore
\begin{subequations}
\begin{align}
  g_S + g_P\gamma_5 &=
    \begin{pmatrix}
      g_S - g_P & 0         & 0         & 0         \\
      0         & g_S - g_P & 0         & 0         \\
      0         & 0         & g_S + g_P & 0         \\
      0         & 0         & 0         & g_S + g_P  
    \end{pmatrix} \\    
  g_V\gamma^0 - g_A\gamma^0\gamma_5 &=
    \begin{pmatrix}
      0         & 0         & g_V - g_A & 0         \\
      0         & 0         & 0         & g_V - g_A \\
      g_V + g_A & 0         & 0         & 0         \\
      0         & g_V + g_A & 0         & 0
    \end{pmatrix} \\
  g_V\gamma^1 - g_A\gamma^1\gamma_5 &=
    \begin{pmatrix}
      0           & 0           & 0         & g_V - g_A \\
      0           & 0           & g_V - g_A & 0         \\
      0           & - g_V - g_A & 0         & 0         \\
      - g_V - g_A & 0           & 0         & 0
    \end{pmatrix} \\
  g_V\gamma^2 - g_A\gamma^2\gamma_5 &=
    \begin{pmatrix}
      0               & 0              & 0              & -\ii(g_V - g_A) \\
      0               & 0              & \ii(g_V - g_A) & 0               \\
      0               & \ii(g_V + g_A) & 0              & 0               \\
      -\ii(g_V + g_A) & 0              & 0              & 0
    \end{pmatrix} \\
  g_V\gamma^3 - g_A\gamma^3\gamma_5 &=
    \begin{pmatrix}
      0           & 0         & g_V - g_A & 0           \\
      0           & 0         & 0         & - g_V + g_A \\
      - g_V - g_A & 0         & 0         & 0           \\
      0           & g_V + g_A & 0         & 0
    \end{pmatrix}
\end{align} 
\end{subequations}
and
\begin{subequations}                          
\begin{align}
  C(g_S + g_P\gamma_5) &=
    \begin{pmatrix}
      0           & g_S - g_P & 0         & 0           \\
      - g_S + g_P & 0         & 0         & 0           \\
      0           & 0         & 0         & - g_S - g_P \\
      0           & 0         & g_S + g_P & 0
    \end{pmatrix} \\              
  C(g_V\gamma^0 - g_A\gamma^0\gamma_5) &=
    \begin{pmatrix}
      0         & 0           & 0           & g_V - g_A \\
      0         & 0           & - g_V + g_A & 0         \\
      0         & - g_V - g_A & 0           & 0         \\
      g_V + g_A & 0           & 0           & 0
    \end{pmatrix} \\
  C(g_V\gamma^1 - g_A\gamma^1\gamma_5) &=
    \begin{pmatrix}
      0          & 0           & g_V - g_A & 0           \\
      0          & 0           & 0         & - g_V + g_A \\
      g_V + g_A  & 0           & 0         & 0           \\
      0          & - g_V - g_A & 0         & 0
    \end{pmatrix} \\                                     
  C(g_V\gamma^2 - g_A\gamma^2\gamma_5) &=
    \begin{pmatrix}
      0              & 0              & \ii(g_V - g_A) & 0            \\ 
      0              & 0              & 0              & \ii(g_V - g_A) \\
      \ii(g_V + g_A) & 0              & 0              & 0              \\
      0              & \ii(g_V + g_A) & 0              & 0
    \end{pmatrix} \\
  C(g_V\gamma^3 - g_A\gamma^3\gamma_5) &=
    \begin{pmatrix}
      0           & 0           & 0           & - g_V + g_A \\
      0           & 0           & - g_V + g_A & 0           \\
      0           & - g_V - g_A & 0           & 0           \\
      - g_V - g_A & 0           & 0           & 0
    \end{pmatrix}
\end{align}
\end{subequations}    
<<Declaration of bispinor currents>>=
public :: va_ff, v_ff, a_ff, vl_ff, vr_ff, vlr_ff, va2_ff
@
<<Implementation of bispinor currents>>=
pure function va_ff (gv, ga, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gv, ga
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: gl, gr
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  gl = gv + ga
  gr = gv - ga
  g13 = psil%a(1)*psir%a(3)
  g14 = psil%a(1)*psir%a(4)
  g23 = psil%a(2)*psir%a(3)
  g24 = psil%a(2)*psir%a(4)
  g31 = psil%a(3)*psir%a(1)
  g32 = psil%a(3)*psir%a(2)
  g41 = psil%a(4)*psir%a(1)
  g42 = psil%a(4)*psir%a(2)
  j%t    =  gr * (   g14 - g23) + gl * ( - g32 + g41)
  j%x(1) =  gr * (   g13 - g24) + gl * (   g31 - g42)
  j%x(2) = (gr * (   g13 + g24) + gl * (   g31 + g42)) * (0, 1)
  j%x(3) =  gr * ( - g14 - g23) + gl * ( - g32 - g41)
end function va_ff 
@ 
<<Implementation of bispinor currents>>=
pure function va2_ff (gva, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in), dimension(2) :: gva
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: gl, gr
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  gl = gva(1) + gva(2)
  gr = gva(1) - gva(2)
  g13 = psil%a(1)*psir%a(3)
  g14 = psil%a(1)*psir%a(4)
  g23 = psil%a(2)*psir%a(3)
  g24 = psil%a(2)*psir%a(4)
  g31 = psil%a(3)*psir%a(1)
  g32 = psil%a(3)*psir%a(2)
  g41 = psil%a(4)*psir%a(1)
  g42 = psil%a(4)*psir%a(2)
  j%t    =  gr * (   g14 - g23) + gl * ( - g32 + g41)
  j%x(1) =  gr * (   g13 - g24) + gl * (   g31 - g42)
  j%x(2) = (gr * (   g13 + g24) + gl * (   g31 + g42)) * (0, 1)
  j%x(3) =  gr * ( - g14 - g23) + gl * ( - g32 - g41)
end function va2_ff 
@ 
<<Implementation of bispinor currents>>=
pure function v_ff (gv, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gv
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  g13 = psil%a(1)*psir%a(3)
  g14 = psil%a(1)*psir%a(4)
  g23 = psil%a(2)*psir%a(3)
  g24 = psil%a(2)*psir%a(4)
  g31 = psil%a(3)*psir%a(1)
  g32 = psil%a(3)*psir%a(2)
  g41 = psil%a(4)*psir%a(1)
  g42 = psil%a(4)*psir%a(2)
  j%t    =   gv * (   g14 - g23 - g32 + g41)
  j%x(1) =   gv * (   g13 - g24 + g31 - g42)
  j%x(2) =   gv * (   g13 + g24 + g31 + g42) * (0, 1)
  j%x(3) =   gv * ( - g14 - g23 - g32 - g41)
end function v_ff           
@
<<Implementation of bispinor currents>>=
pure function a_ff (ga, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: ga
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: g13, g14, g23, g24, g31, g32, g41, g42
  g13 = psil%a(1)*psir%a(3)
  g14 = psil%a(1)*psir%a(4)
  g23 = psil%a(2)*psir%a(3)
  g24 = psil%a(2)*psir%a(4)
  g31 = psil%a(3)*psir%a(1)
  g32 = psil%a(3)*psir%a(2)
  g41 = psil%a(4)*psir%a(1)
  g42 = psil%a(4)*psir%a(2)
  j%t    =  -ga * (   g14 - g23 + g32 - g41)
  j%x(1) =  -ga * (   g13 - g24 - g31 + g42)
  j%x(2) =  -ga * (   g13 + g24 - g31 - g42) * (0, 1)
  j%x(3) =  -ga * ( - g14 - g23 + g32 + g41)
end function a_ff      
@
<<Implementation of bispinor currents>>=
pure function vl_ff (gl, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: gl2
  complex(kind=default) :: g31, g32, g41, g42
  gl2 = 2 * gl
  g31 = psil%a(3)*psir%a(1)
  g32 = psil%a(3)*psir%a(2)
  g41 = psil%a(4)*psir%a(1)
  g42 = psil%a(4)*psir%a(2)
  j%t    =   gl2 * ( - g32 + g41)
  j%x(1) =   gl2 * (   g31 - g42)
  j%x(2) =   gl2 * (   g31 + g42) * (0, 1)
  j%x(3) =   gl2 * ( - g32 - g41)
end function vl_ff      
@
<<Implementation of bispinor currents>>=
pure function vr_ff (gr, psil, psir) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gr
  type(bispinor), intent(in) :: psil, psir
  complex(kind=default) :: gr2
  complex(kind=default) :: g13, g14, g23, g24
  gr2 = 2 * gr
  g13 = psil%a(1)*psir%a(3)
  g14 = psil%a(1)*psir%a(4)
  g23 = psil%a(2)*psir%a(3)
  g24 = psil%a(2)*psir%a(4)
  j%t    = gr2 * (   g14 - g23)
  j%x(1) = gr2 * (   g13 - g24)
  j%x(2) = gr2 * (   g13 + g24) * (0, 1)
  j%x(3) = gr2 * ( - g14 - g23)
end function vr_ff      
@
<<Implementation of bispinor currents>>=
pure function vlr_ff (gl, gr, psibar, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(bispinor), intent(in) :: psibar
  type(bispinor), intent(in) :: psi
  j = va_ff (gl+gr, gl-gr, psibar, psi)
end function vlr_ff
@ 
and
\begin{equation}
  \fmslash{v} - \fmslash{a}\gamma_5 =
    \begin{pmatrix}
      0         & 0         &   v_- - a_- & - v^* + a^* \\
      0         & 0         & - v   + a   &   v_+ - a_+ \\
      v_+ + a_+ & v^* + a^* & 0           & 0           \\
      v +   a   & v_- + a_- & 0           & 0
    \end{pmatrix}
\end{equation}
with $v_\pm=v_0\pm v_3$, $a_\pm=a_0\pm a_3$, $v=v_1+\ii v_2$,
$v^*=v_1-\ii v_2$, $a=a_1+\ii a_2$, and $a^*=a_1-\ii a_2$.  But note
that~$\cdot^*$ is \emph{not} complex conjugation for complex~$v_\mu$
or~$a_\mu$.                      
<<Declaration of bispinor currents>>=
public :: f_vaf, f_vf, f_af, f_vlf, f_vrf, f_vlrf, f_va2f 
@
<<Implementation of bispinor currents>>=
pure function f_vaf (gv, ga, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: gv, ga
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gv + ga
  gr = gv - ga
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gl * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vaf   
@
<<Implementation of bispinor currents>>=
pure function f_va2f (gva, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in), dimension(2) :: gva
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: gl, gr
  complex(kind=default) :: vp, vm, v12, v12s
  gl = gva(1) + gva(2)
  gr = gva(1) - gva(2)
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gl * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_va2f   
@
<<Implementation of bispinor currents>>=
pure function f_vf (gv, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: gv
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gv * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gv * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = gv * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gv * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vf    
@
<<Implementation of bispinor currents>>=
pure function f_af (ga, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: ga
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: vp, vm, v12, v12s
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = ga * ( - vm  * psi%a(3) + v12s * psi%a(4))
  vpsi%a(2) = ga * (   v12 * psi%a(3) - vp   * psi%a(4))
  vpsi%a(3) = ga * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = ga * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_af   
@
<<Implementation of bispinor currents>>=
pure function f_vlf (gl, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: gl
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: gl2
  complex(kind=default) :: vp, vm, v12, v12s
  gl2 = 2 * gl
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = 0
  vpsi%a(2) = 0
  vpsi%a(3) = gl2 * (   vp  * psi%a(1) + v12s * psi%a(2))
  vpsi%a(4) = gl2 * (   v12 * psi%a(1) + vm   * psi%a(2))
end function f_vlf 
@
<<Implementation of bispinor currents>>=
pure function f_vrf (gr, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: gr
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  complex(kind=default) :: gr2
  complex(kind=default) :: vp, vm, v12, v12s
  gr2 = 2 * gr
  vp = v%t + v%x(3)
  vm = v%t - v%x(3)
  v12  =  v%x(1) + (0,1)*v%x(2)
  v12s =  v%x(1) - (0,1)*v%x(2)
  vpsi%a(1) = gr2 * (   vm  * psi%a(3) - v12s * psi%a(4))
  vpsi%a(2) = gr2 * ( - v12 * psi%a(3) + vp   * psi%a(4))
  vpsi%a(3) = 0
  vpsi%a(4) = 0
end function f_vrf
@
<<Implementation of bispinor currents>>=
pure function f_vlrf (gl, gr, v, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: gl, gr
  type(vector), intent(in) :: v
  type(bispinor), intent(in) :: psi
  vpsi = f_vaf (gl+gr, gl-gr, v, psi)
end function f_vlrf
@ \subsection{Fermionic Scalar and Pseudo Scalar Couplings}
<<Declaration of bispinor currents>>=
public :: sp_ff, s_ff, p_ff, sl_ff, sr_ff, slr_ff
@
<<Implementation of bispinor currents>>=
pure function sp_ff (gs, gp, psil, psir) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gs, gp
  type(bispinor), intent(in) :: psil, psir
  j =    (gs - gp) * (psil%a(1)*psir%a(2) - psil%a(2)*psir%a(1)) &
       + (gs + gp) * (- psil%a(3)*psir%a(4) + psil%a(4)*psir%a(3))
end function sp_ff
@
<<Implementation of bispinor currents>>=
pure function s_ff (gs, psil, psir) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gs
  type(bispinor), intent(in) :: psil, psir
  j = gs * (psil * psir)
end function s_ff
@
<<Implementation of bispinor currents>>=
pure function p_ff (gp, psil, psir) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gp
  type(bispinor), intent(in) :: psil, psir
  j = gp * (- psil%a(1)*psir%a(2) + psil%a(2)*psir%a(1) &
            - psil%a(3)*psir%a(4) + psil%a(4)*psir%a(3))
end function p_ff
@
<<Implementation of bispinor currents>>=
pure function sl_ff (gl, psil, psir) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(bispinor), intent(in) :: psil, psir
  j =  2 * gl * (psil%a(1)*psir%a(2) - psil%a(2)*psir%a(1))
end function sl_ff
@
<<Implementation of bispinor currents>>=
pure function sr_ff (gr, psil, psir) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(bispinor), intent(in) :: psil, psir
  j = 2 * gr * (- psil%a(3)*psir%a(4) + psil%a(4)*psir%a(3))
end function sr_ff    
@
<<Implementation of bispinor currents>>=
pure function slr_ff (gl, gr, psibar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(bispinor), intent(in) :: psibar
  type(bispinor), intent(in) :: psi
  j = sp_ff (gr+gl, gr-gl, psibar, psi)
end function slr_ff
@
<<Declaration of bispinor currents>>=
public :: f_spf, f_sf, f_pf, f_slf, f_srf, f_slrf
@
<<Implementation of bispinor currents>>=
pure function f_spf (gs, gp, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gs, gp
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%a(1:2) = ((gs - gp) * phi) * psi%a(1:2)
  phipsi%a(3:4) = ((gs + gp) * phi) * psi%a(3:4)
end function f_spf
@
<<Implementation of bispinor currents>>=
pure function f_sf (gs, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gs
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%a = (gs * phi) * psi%a
end function f_sf
@
<<Implementation of bispinor currents>>=
pure function f_pf (gp, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gp
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%a(1:2) = (- gp * phi) * psi%a(1:2)
  phipsi%a(3:4) = (  gp * phi) * psi%a(3:4)
end function f_pf
@
<<Implementation of bispinor currents>>=
pure function f_slf (gl, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gl
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%a(1:2) = (2 * gl * phi) * psi%a(1:2)
  phipsi%a(3:4) = 0
end function f_slf 
@
<<Implementation of bispinor currents>>=
pure function f_srf (gr, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gr
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%a(1:2) = 0
  phipsi%a(3:4) = (2 * gr * phi) * psi%a(3:4)
end function f_srf                  
@
<<Implementation of bispinor currents>>=
pure function f_slrf (gl, gr, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gl, gr
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi =  f_spf (gr+gl, gr-gl, phi, psi)
end function f_slrf
@ \subsection{Couplings for BRST Transformations}
\subsubsection{3-Couplings}
The lists of needed gamma matrices can be found in the next subsection with 
the gravitino couplings. 
<<Declaration of bispinor currents>>=
private :: vv_ff, f_vvf
@ 
<<Declaration of bispinor currents>>=
public :: vmom_ff, mom_ff, mom5_ff, moml_ff, momr_ff, lmom_ff, rmom_ff
@ 
<<Implementation of bispinor currents>>=
pure function vv_ff (psibar, psi, k) result (psibarpsi)
  type(vector) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: k 
  complex(kind=default) :: kp, km, k12, k12s
  type(bispinor) :: kgpsi1, kgpsi2, kgpsi3, kgpsi4
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)
  kgpsi1%a(1) = -k%x(3) * psi%a(1) - k12s * psi%a(2) 
  kgpsi1%a(2) = -k12 * psi%a(1) + k%x(3) * psi%a(2) 
  kgpsi1%a(3) = k%x(3) * psi%a(3) + k12s * psi%a(4)
  kgpsi1%a(4) = k12 * psi%a(3) - k%x(3) * psi%a(4)
  kgpsi2%a(1) = ((0,-1) * k%x(2)) * psi%a(1) - km * psi%a(2)
  kgpsi2%a(2) = - kp * psi%a(1) + ((0,1) * k%x(2)) * psi%a(2) 
  kgpsi2%a(3) = ((0,-1) * k%x(2)) * psi%a(3) + kp * psi%a(4)
  kgpsi2%a(4) = km * psi%a(3) + ((0,1) * k%x(2)) * psi%a(4) 
  kgpsi3%a(1) = (0,1) * (k%x(1) * psi%a(1) + km * psi%a(2))  
  kgpsi3%a(2) = (0,-1) * (kp * psi%a(1) + k%x(1) * psi%a(2)) 
  kgpsi3%a(3) = (0,1) * (k%x(1) * psi%a(3) - kp * psi%a(4))
  kgpsi3%a(4) = (0,1) * (km * psi%a(3) - k%x(1) * psi%a(4)) 
  kgpsi4%a(1) = -k%t * psi%a(1) - k12s * psi%a(2) 
  kgpsi4%a(2) = k12 * psi%a(1) + k%t * psi%a(2) 
  kgpsi4%a(3) = k%t * psi%a(3) - k12s * psi%a(4) 
  kgpsi4%a(4) = k12 * psi%a(3) - k%t * psi%a(4) 
  psibarpsi%t    = 2 * (psibar * kgpsi1)
  psibarpsi%x(1) = 2 * (psibar * kgpsi2) 
  psibarpsi%x(2) = 2 * (psibar * kgpsi3) 
  psibarpsi%x(3) = 2 * (psibar * kgpsi4)
end function vv_ff
@
<<Implementation of bispinor currents>>=
pure function f_vvf (v, psi, k) result (kvpsi)
  type(bispinor) :: kvpsi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: k, v 
    complex(kind=default) :: kv30, kv21, kv01, kv31, kv02, kv32
  complex(kind=default) :: ap, am, bp, bm, bps, bms
  kv30 = k%x(3) * v%t - k%t * v%x(3)
  kv21 = (0,1) * (k%x(2) * v%x(1) - k%x(1) * v%x(2))
  kv01 = k%t * v%x(1) - k%x(1) * v%t
  kv31 = k%x(3) * v%x(1) - k%x(1) * v%x(3)
  kv02 = (0,1) * (k%t * v%x(2) - k%x(2) * v%t)
  kv32 = (0,1) * (k%x(3) * v%x(2) - k%x(2) * v%x(3))
  ap  = 2 * (kv30 + kv21)
  am  = 2 * (-kv30 + kv21)
  bp  = 2 * (kv01 + kv31 + kv02 + kv32)
  bm  = 2 * (kv01 - kv31 + kv02 - kv32) 
  bps = 2 * (kv01 + kv31 - kv02 - kv32) 
  bms = 2 * (kv01 - kv31 - kv02 + kv32)
  kvpsi%a(1) = am * psi%a(1) + bms * psi%a(2)
  kvpsi%a(2) = bp * psi%a(1) - am * psi%a(2) 
  kvpsi%a(3) = ap * psi%a(3) - bps * psi%a(4)
  kvpsi%a(4) = -bm * psi%a(3) - ap * psi%a(4) 
end function f_vvf
@ 
<<Implementation of bispinor currents>>=
pure function vmom_ff (g, psibar, psi, k) result (psibarpsi)
  type(vector) :: psibarpsi
  complex(kind=default), intent(in) :: g 
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  type(vector) :: vk
  vk = k 
  psibarpsi = g * vv_ff (psibar, psi, vk)
end function vmom_ff
@ 
<<Implementation of bispinor currents>>=
pure function mom_ff (g, m, psibar, psi, k) result (psibarpsi)
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m
  type(bispinor) :: kmpsi 
  complex(kind=default) :: kp, km, k12, k12s
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)
  kmpsi%a(1) = km * psi%a(3) - k12s * psi%a(4) 
  kmpsi%a(2) = kp * psi%a(4) - k12 * psi%a(3) 
  kmpsi%a(3) = kp * psi%a(1) + k12s * psi%a(2) 
  kmpsi%a(4) = k12 * psi%a(1) + km * psi%a(2) 
  psibarpsi = g * (psibar * kmpsi) + s_ff (m, psibar, psi)
end function mom_ff 
@ 
<<Implementation of bispinor currents>>=
pure function mom5_ff (g, m, psibar, psi, k) result (psibarpsi) 
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m
  type(bispinor) :: g5psi
  g5psi%a(1:2) = - psi%a(1:2)
  g5psi%a(3:4) = psi%a(3:4)
  psibarpsi = mom_ff (g, m, psibar, g5psi, k)
end function mom5_ff 
@ 
<<Implementation of bispinor currents>>=
pure function moml_ff (g, m, psibar, psi, k) result (psibarpsi) 
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m
  type(bispinor) :: leftpsi
  leftpsi%a(1:2) = 2 * psi%a(1:2)
  leftpsi%a(3:4) = 0 
  psibarpsi = mom_ff (g, m, psibar, leftpsi, k)
end function moml_ff 
@ 
<<Implementation of bispinor currents>>=
pure function momr_ff (g, m, psibar, psi, k) result (psibarpsi) 
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m
  type(bispinor) :: rightpsi
  rightpsi%a(1:2) = 0 
  rightpsi%a(3:4) = 2 * psi%a(3:4)
  psibarpsi = mom_ff (g, m, psibar, rightpsi, k)
end function momr_ff 
@ 
<<Implementation of bispinor currents>>=
pure function lmom_ff (g, m, psibar, psi, k) result (psibarpsi) 
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m  
  psibarpsi = mom_ff  (g, m, psibar, psi, k) + & 
              mom5_ff (g,-m, psibar, psi, k) 
end function lmom_ff 
@ 
<<Implementation of bispinor currents>>=
pure function rmom_ff (g, m, psibar, psi, k) result (psibarpsi) 
  complex(kind=default) :: psibarpsi
  type(bispinor), intent(in) :: psibar, psi
  type(momentum), intent(in) :: k 
  complex(kind=default), intent(in) :: g, m  
  psibarpsi = mom_ff  (g, m, psibar, psi, k) - & 
              mom5_ff (g,-m, psibar, psi, k) 
end function rmom_ff 
@
<<Declaration of bispinor currents>>=
public :: f_vmomf, f_momf, f_mom5f, f_momlf, f_momrf, f_lmomf, f_rmomf
@
<<Implementation of bispinor currents>>=
pure function f_vmomf (g, v, psi, k) result (kvpsi)
  type(bispinor) :: kvpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: g
  type(momentum), intent(in) :: k
  type(vector), intent(in) :: v 
  type(vector) :: vk
  vk = k 
  kvpsi = g * f_vvf (v, psi, vk) 
end function f_vmomf
@ 
<<Implementation of bispinor currents>>=
pure function f_momf (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  complex(kind=default) :: kp, km, k12, k12s
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)
  kmpsi%a(1) = km * psi%a(3) - k12s * psi%a(4) 
  kmpsi%a(2) = -k12 * psi%a(3) + kp * psi%a(4) 
  kmpsi%a(3) = kp * psi%a(1) + k12s * psi%a(2) 
  kmpsi%a(4) = k12 * psi%a(1) + km * psi%a(2) 
  kmpsi = g * (phi * kmpsi) + f_sf (m, phi, psi)
end function f_momf  
@ 
<<Implementation of bispinor currents>>=
pure function f_mom5f (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  type(bispinor) :: g5psi
  g5psi%a(1:2) = - psi%a(1:2)
  g5psi%a(3:4) =   psi%a(3:4)
  kmpsi = f_momf (g, m, phi, g5psi, k)
end function f_mom5f  
@ 
<<Implementation of bispinor currents>>=
pure function f_momlf (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  type(bispinor) :: leftpsi 
  leftpsi%a(1:2) = 2 * psi%a(1:2)
  leftpsi%a(3:4) = 0 
  kmpsi = f_momf (g, m, phi, leftpsi, k) 
end function f_momlf  
@ 
<<Implementation of bispinor currents>>=
pure function f_momrf (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  type(bispinor) :: rightpsi 
  rightpsi%a(1:2) = 0
  rightpsi%a(3:4) = 2 * psi%a(3:4) 
  kmpsi = f_momf (g, m, phi, rightpsi, k) 
end function f_momrf  
@ 
<<Implementation of bispinor currents>>=
pure function f_lmomf (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  kmpsi = f_momf  (g, m, phi, psi, k) + &
          f_mom5f (g,-m, phi, psi, k) 
end function f_lmomf  
@ 
<<Implementation of bispinor currents>>=
pure function f_rmomf (g, m, phi, psi, k) result (kmpsi)
  type(bispinor) :: kmpsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: phi, g, m
  type(momentum), intent(in) :: k 
  kmpsi = f_momf  (g, m, phi, psi, k) - &
          f_mom5f (g,-m, phi, psi, k) 
end function f_rmomf  
@ 
\subsubsection{4-Couplings}
<<Declaration of bispinor currents>>=
public :: v2_ff, sv1_ff, sv2_ff, pv1_ff, pv2_ff, svl1_ff, svl2_ff, &
     svr1_ff, svr2_ff, svlr1_ff, svlr2_ff  
@
<<Implementation of bispinor currents>>=
pure function v2_ff (g, psibar, v, psi) result (v2)
  type(vector) :: v2 
  complex (kind=default), intent(in) :: g 
  type(bispinor), intent(in) :: psibar, psi 
  type(vector), intent(in) :: v
  v2 = (-g) * vv_ff (psibar, psi, v)
end function v2_ff
@ 
<<Implementation of bispinor currents>>=
pure function sv1_ff (g, psibar, v, psi) result (phi)
  complex(kind=default) :: phi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: v 
  complex(kind=default), intent(in) :: g 
  phi = psibar * f_vf (g, v, psi)
end function sv1_ff
@ 
<<Implementation of bispinor currents>>=
pure function sv2_ff (g, psibar, phi, psi) result (v)
  type(vector) :: v
  complex(kind=default), intent(in) :: phi, g
  type(bispinor), intent(in) :: psibar, psi
  v = phi * v_ff (g, psibar, psi)
end function sv2_ff
@ 
<<Implementation of bispinor currents>>=
pure function pv1_ff (g, psibar, v, psi) result (phi)
  complex(kind=default) :: phi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: v 
  complex(kind=default), intent(in) :: g 
  phi = - (psibar * f_af (g, v, psi))
end function pv1_ff
@ 
<<Implementation of bispinor currents>>=
pure function pv2_ff (g, psibar, phi, psi) result (v)
  type(vector) :: v
  complex(kind=default), intent(in) :: phi, g
  type(bispinor), intent(in) :: psibar, psi
  v = -(phi * a_ff (g, psibar, psi))
end function pv2_ff
@ 
<<Implementation of bispinor currents>>=
pure function svl1_ff (g, psibar, v, psi) result (phi)
  complex(kind=default) :: phi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: v 
  complex(kind=default), intent(in) :: g 
  phi = psibar * f_vlf (g, v, psi)
end function svl1_ff
@ 
<<Implementation of bispinor currents>>=
pure function svl2_ff (g, psibar, phi, psi) result (v)
  type(vector) :: v
  complex(kind=default), intent(in) :: phi, g
  type(bispinor), intent(in) :: psibar, psi
  v = phi * vl_ff (g, psibar, psi)
end function svl2_ff
@ 
<<Implementation of bispinor currents>>=
pure function svr1_ff (g, psibar, v, psi) result (phi)
  complex(kind=default) :: phi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: v 
  complex(kind=default), intent(in) :: g 
  phi = psibar * f_vrf (g, v, psi)
end function svr1_ff
@ 
<<Implementation of bispinor currents>>=
pure function svr2_ff (g, psibar, phi, psi) result (v)
  type(vector) :: v
  complex(kind=default), intent(in) :: phi, g
  type(bispinor), intent(in) :: psibar, psi
  v = phi * vr_ff (g, psibar, psi)
end function svr2_ff
@ 
<<Implementation of bispinor currents>>=
pure function svlr1_ff (gl, gr, psibar, v, psi) result (phi)
  complex(kind=default) :: phi
  type(bispinor), intent(in) :: psibar, psi
  type(vector), intent(in) :: v 
  complex(kind=default), intent(in) :: gl, gr 
  phi = psibar * f_vlrf (gl, gr, v, psi)
end function svlr1_ff
@ 
<<Implementation of bispinor currents>>=
pure function svlr2_ff (gl, gr, psibar, phi, psi) result (v)
  type(vector) :: v
  complex(kind=default), intent(in) :: phi, gl, gr
  type(bispinor), intent(in) :: psibar, psi
  v = phi * vlr_ff (gl, gr, psibar, psi)
end function svlr2_ff
@ 
<<Declaration of bispinor currents>>=
public :: f_v2f, f_svf, f_pvf, f_svlf, f_svrf, f_svlrf
@
<<Implementation of bispinor currents>>= 
pure function f_v2f (g, v1, v2, psi) result (vpsi)
  type(bispinor) :: vpsi
  complex(kind=default), intent(in) :: g 
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v1, v2
  vpsi = g * f_vvf (v2, psi, v1) 
end function f_v2f 
@ 
<<Implementation of bispinor currents>>=
pure function f_svf (g, phi, v, psi) result (pvpsi)
  type(bispinor) :: pvpsi
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  pvpsi = phi * f_vf (g, v, psi)
end function f_svf 
@ 
<<Implementation of bispinor currents>>=
pure function f_pvf (g, phi, v, psi) result (pvpsi)
  type(bispinor) :: pvpsi
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  pvpsi = -(phi * f_af (g, v, psi))
end function f_pvf 
@ 
<<Implementation of bispinor currents>>=
pure function f_svlf (g, phi, v, psi) result (pvpsi)
  type(bispinor) :: pvpsi
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  pvpsi = phi * f_vlf (g, v, psi)
end function f_svlf 
@ 
<<Implementation of bispinor currents>>=
pure function f_svrf (g, phi, v, psi) result (pvpsi)
  type(bispinor) :: pvpsi
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  pvpsi = phi * f_vrf (g, v, psi)
end function f_svrf 
@ 
<<Implementation of bispinor currents>>=
pure function f_svlrf (gl, gr, phi, v, psi) result (pvpsi)
  type(bispinor) :: pvpsi
  complex(kind=default), intent(in) :: gl, gr, phi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  pvpsi = phi * f_vlrf (gl, gr, v, psi)
end function f_svlrf 
@ \subsection{Gravitino Couplings}
<<Declaration of bispinor currents>>=
public :: pot_grf, pot_fgr, s_grf, s_fgr, p_grf, p_fgr, &
     sl_grf, sl_fgr, sr_grf, sr_fgr, slr_grf, slr_fgr
@ 
<<Declaration of bispinor currents>>=
private :: fgvgr, fgvg5gr, fggvvgr, grkgf, grkggf, grkkggf, &
	   fgkgr, fg5gkgr, grvgf, grg5vgf, grkgggf, fggkggr
@
<<Implementation of bispinor currents>>=
pure function pot_grf (g, gravbar, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi 
  type(vectorspinor) :: gamma_psi
  gamma_psi%psi(1)%a(1) = psi%a(3) 
  gamma_psi%psi(1)%a(2) = psi%a(4)
  gamma_psi%psi(1)%a(3) = psi%a(1) 
  gamma_psi%psi(1)%a(4) = psi%a(2)
  gamma_psi%psi(2)%a(1) = psi%a(4)
  gamma_psi%psi(2)%a(2) = psi%a(3)
  gamma_psi%psi(2)%a(3) = - psi%a(2)
  gamma_psi%psi(2)%a(4) = - psi%a(1)
  gamma_psi%psi(3)%a(1) = (0,-1) * psi%a(4)
  gamma_psi%psi(3)%a(2) = (0,1) * psi%a(3)
  gamma_psi%psi(3)%a(3) = (0,1) * psi%a(2)
  gamma_psi%psi(3)%a(4) = (0,-1) * psi%a(1)
  gamma_psi%psi(4)%a(1) = psi%a(3)
  gamma_psi%psi(4)%a(2) = - psi%a(4)
  gamma_psi%psi(4)%a(3) = - psi%a(1)
  gamma_psi%psi(4)%a(4) = psi%a(2)
  j = g * (gravbar * gamma_psi)
end function pot_grf
@
<<Implementation of bispinor currents>>=
pure function pot_fgr (g, psibar, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(bispinor) :: gamma_grav
  gamma_grav%a(1) = grav%psi(1)%a(3) - grav%psi(2)%a(4) + & 
	       ((0,1)*grav%psi(3)%a(4)) - grav%psi(4)%a(3)
  gamma_grav%a(2) = grav%psi(1)%a(4) - grav%psi(2)%a(3) - &
	       ((0,1)*grav%psi(3)%a(3)) + grav%psi(4)%a(4)
  gamma_grav%a(3) = grav%psi(1)%a(1) + grav%psi(2)%a(2) - &
	       ((0,1)*grav%psi(3)%a(2)) + grav%psi(4)%a(1)
  gamma_grav%a(4) = grav%psi(1)%a(2) + grav%psi(2)%a(1) + &
	       ((0,1)*grav%psi(3)%a(1)) - grav%psi(4)%a(2)
  j = g * (psibar * gamma_grav)
end function pot_fgr 
@
<<Implementation of bispinor currents>>=
pure function grvgf (gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default) :: kp, km, k12, k12s
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: k
  type(vectorspinor) :: kg_psi
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  !!! Since we are taking the spinor product here, NO explicit
  !!! charge conjugation matrix is needed!  
  kg_psi%psi(1)%a(1) = km * psi%a(1) - k12s * psi%a(2) 
  kg_psi%psi(1)%a(2) = (-k12) * psi%a(1) + kp * psi%a(2)
  kg_psi%psi(1)%a(3) = kp * psi%a(3) + k12s * psi%a(4)
  kg_psi%psi(1)%a(4) = k12 * psi%a(3) + km * psi%a(4)
  kg_psi%psi(2)%a(1) = k12s * psi%a(1) - km * psi%a(2)
  kg_psi%psi(2)%a(2) = (-kp) * psi%a(1) + k12 * psi%a(2)
  kg_psi%psi(2)%a(3) = k12s * psi%a(3) + kp * psi%a(4)
  kg_psi%psi(2)%a(4) = km * psi%a(3) + k12 * psi%a(4)
  kg_psi%psi(3)%a(1) = (0,1) * (k12s * psi%a(1) + km * psi%a(2))
  kg_psi%psi(3)%a(2) = (0,1) * (- kp * psi%a(1) - k12 * psi%a(2))
  kg_psi%psi(3)%a(3) = (0,1) * (k12s * psi%a(3) - kp * psi%a(4))
  kg_psi%psi(3)%a(4) = (0,1) * (km * psi%a(3) - k12 * psi%a(4))
  kg_psi%psi(4)%a(1) = (-km) * psi%a(1) - k12s * psi%a(2)
  kg_psi%psi(4)%a(2) = k12 * psi%a(1) + kp * psi%a(2)
  kg_psi%psi(4)%a(3) = kp * psi%a(3) - k12s * psi%a(4)
  kg_psi%psi(4)%a(4) = k12 * psi%a(3) - km * psi%a(4) 
  j = gravbar * kg_psi
end function grvgf  
@
<<Implementation of bispinor currents>>=
pure function grg5vgf (gravbar, psi, k) result (j)
  complex(kind=default) :: j
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: k
  type(bispinor) :: g5_psi
  g5_psi%a(1:2) = - psi%a(1:2)
  g5_psi%a(3:4) =   psi%a(3:4)
  j = grvgf (gravbar, g5_psi, k)
end function grg5vgf
@
<<Implementation of bispinor currents>>=
pure function s_grf (g, gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * grvgf (gravbar, psi, vk)
end function s_grf
@
<<Implementation of bispinor currents>>=
pure function sl_grf (gl, gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l
  type(momentum), intent(in) :: k
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  j = s_grf (gl, gravbar, psi_l, k)
end function sl_grf
@
<<Implementation of bispinor currents>>=
pure function sr_grf (gr, gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(momentum), intent(in) :: k
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = s_grf (gr, gravbar, psi_r, k)
end function sr_grf
@
<<Implementation of bispinor currents>>=
pure function slr_grf (gl, gr, gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  j = sl_grf (gl, gravbar, psi, k) + sr_grf (gr, gravbar, psi, k)
end function slr_grf
@
<<Implementation of bispinor currents>>=
pure function fgkgr (psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default) :: kp, km, k12, k12s
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: k
  type(bispinor) :: gk_grav
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  !!! Since we are taking the spinor product here, NO explicit
  !!! charge conjugation matrix is needed!
  gk_grav%a(1) =  kp * grav%psi(1)%a(1) + k12s * grav%psi(1)%a(2) &
	    	- k12 * grav%psi(2)%a(1) - km * grav%psi(2)%a(2) &
	       	+ (0,1) * k12 * grav%psi(3)%a(1)   &
		+ (0,1) * km * grav%psi(3)%a(2) &
		- kp * grav%psi(4)%a(1) - k12s * grav%psi(4)%a(2) 
  gk_grav%a(2) = k12 * grav%psi(1)%a(1) + km * grav%psi(1)%a(2) &
		- kp * grav%psi(2)%a(1) - k12s * grav%psi(2)%a(2) &
		- (0,1) * kp * grav%psi(3)%a(1) &
		- (0,1) * k12s * grav%psi(3)%a(2)  &
		+ k12 * grav%psi(4)%a(1) + km * grav%psi(4)%a(2)
  gk_grav%a(3) = km * grav%psi(1)%a(3) - k12s * grav%psi(1)%a(4) &
		- k12 * grav%psi(2)%a(3) + kp * grav%psi(2)%a(4) &
		+ (0,1) * k12 * grav%psi(3)%a(3)   &
		- (0,1) * kp * grav%psi(3)%a(4) & 
		+ km * grav%psi(4)%a(3) - k12s * grav%psi(4)%a(4)
  gk_grav%a(4) = - k12 * grav%psi(1)%a(3) + kp * grav%psi(1)%a(4) &
		+ km * grav%psi(2)%a(3) - k12s * grav%psi(2)%a(4) &
		+ (0,1) * km * grav%psi(3)%a(3) &
		- (0,1) * k12s * grav%psi(3)%a(4)  &
		+ k12 * grav%psi(4)%a(3) - kp * grav%psi(4)%a(4)
  j = psibar * gk_grav
end function fgkgr
@
<<Implementation of bispinor currents>>=
pure function fg5gkgr (psibar, grav, k) result (j)
  complex(kind=default) :: j
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: k
  type(bispinor) :: psibar_g5
  psibar_g5%a(1:2) = - psibar%a(1:2)
  psibar_g5%a(3:4) =   psibar%a(3:4)
  j = fgkgr (psibar_g5, grav, k)
end function fg5gkgr
@
<<Implementation of bispinor currents>>=
pure function s_fgr (g, psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * fgkgr (psibar, grav, vk)
end function s_fgr
@
<<Implementation of bispinor currents>>=
pure function sl_fgr (gl, psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l
  type(vectorspinor), intent(in) :: grav
  type(momentum), intent(in) :: k
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  j = s_fgr (gl, psibar_l, grav, k)
end function sl_fgr
@
<<Implementation of bispinor currents>>=
pure function sr_fgr (gr, psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_r
  type(vectorspinor), intent(in) :: grav
  type(momentum), intent(in) :: k
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = s_fgr (gr, psibar_r, grav, k)
end function sr_fgr
@
@
<<Implementation of bispinor currents>>=
pure function slr_fgr (gl, gr, psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_r
  type(vectorspinor), intent(in) :: grav
  type(momentum), intent(in) :: k
  j = sl_fgr (gl, psibar, grav, k) + sr_fgr (gr, psibar, grav, k)
end function slr_fgr
@
<<Implementation of bispinor currents>>=
pure function p_grf (g, gravbar, psi, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * grg5vgf (gravbar, psi, vk)
end function p_grf
@
<<Implementation of bispinor currents>>=
pure function p_fgr (g, psibar, grav, k) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * fg5gkgr (psibar, grav, vk)
end function p_fgr
@
<<Declaration of bispinor currents>>=
public :: f_potgr, f_sgr, f_pgr, f_vgr, f_vlrgr, f_slgr, f_srgr, f_slrgr
@
<<Implementation of bispinor currents>>=
pure function f_potgr (g, phi, psi) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(vectorspinor), intent(in) :: psi
  phipsi%a(1) = (g * phi) * (psi%psi(1)%a(3) - psi%psi(2)%a(4) + & 
	         ((0,1)*psi%psi(3)%a(4)) - psi%psi(4)%a(3))
  phipsi%a(2) = (g * phi) * (psi%psi(1)%a(4) - psi%psi(2)%a(3) - &
	         ((0,1)*psi%psi(3)%a(3)) + psi%psi(4)%a(4)) 
  phipsi%a(3) = (g * phi) * (psi%psi(1)%a(1) + psi%psi(2)%a(2) - &
	         ((0,1)*psi%psi(3)%a(2)) + psi%psi(4)%a(1))
  phipsi%a(4) = (g * phi) * (psi%psi(1)%a(2) + psi%psi(2)%a(1) + &
	         ((0,1)*psi%psi(3)%a(1)) - psi%psi(4)%a(2))
end function f_potgr 
@
The slashed notation:
\begin{equation}
  \fmslash{k} =
    \begin{pmatrix}
      0    & 0    &   k_- & - k^*  \\
      0    & 0    & - k   &   k_+  \\
      k_+  & k^*  &   0   &   0    \\
      k    & k_-  &   0   &   0
    \end{pmatrix} , \qquad
    \fmslash{k}\gamma_5 =
    \begin{pmatrix}
      0     &   0   &   k_- & - k^* \\
      0     &   0   & - k   &   k_+ \\
      - k_+ & - k^* &   0   &   0   \\
      - k   & - k_- &   0   &   0 \end{pmatrix}
\end{equation}
with $k_\pm=k_0\pm k_3$, $k=k_1+\ii k_2$,
$k^*=k_1-\ii k_2$.  But note that~$\cdot^*$ is \emph{not} complex
conjugation for complex~$k_\mu$. 
\begin{subequations}
\begin{alignat}{2}
  \gamma^0 \fmslash{k} &=
    \begin{pmatrix}
      k_+ & k^*  & 0   & 0     \\
      k   & k_-  & 0   & 0     \\
      0   & 0    & k_- & - k^* \\
      0   & 0    & - k & k_+
    \end{pmatrix} , & \qquad 
   \gamma^0 \fmslash{k} \gamma^5 & =
   \begin{pmatrix}
      - k_+ & - k^*  & 0   &   0     \\
      - k   & - k_-  & 0   &   0     \\
        0   &   0    & k_- & - k^*   \\
        0   &   0    & - k &   k_+
    \end{pmatrix}   \\
  \gamma^1 \fmslash{k} &=
    \begin{pmatrix}
      k    & k_- &   0   &   0   \\
      k_+  & k^* &   0   &   0   \\
      0    & 0   &   k   & - k_+ \\
      0    & 0   & - k_- &   k^*
    \end{pmatrix}, & \qquad  
  \gamma^1 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      - k    & - k_- &   0   &   0   \\
      - k_+  & - k^* &   0   &   0   \\
      0      &   0   &   k   & - k_+ \\
      0      &   0   & - k_- &   k^*
    \end{pmatrix} \\
  \gamma^2 \fmslash{k} &=
    \begin{pmatrix}
      - \ii k & - \ii k_- & 0         & 0       \\
      \ii k_+ & \ii k^*   & 0         & 0       \\
      0       & 0         & - \ii k   & \ii k_+ \\
      0       & 0         & - \ii k_- & \ii k^*
    \end{pmatrix}, & \qquad 
  \gamma^2 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      \ii k     & \ii k_-   & 0         & 0       \\
      - \ii k_+ & - \ii k^* & 0         & 0       \\
      0         & 0         & - \ii k   & \ii k_+ \\
      0         & 0         & - \ii k_- & \ii k^*
    \end{pmatrix} \\
  \gamma^3 \fmslash{k} &=
    \begin{pmatrix}
      k_+ & k^*   & 0      & 0    \\
      - k & - k_- & 0      & 0    \\
      0   & 0     & - k_-  & k^*  \\
      0   & 0     & - k    & k_+
    \end{pmatrix}, & \qquad
  \gamma^3 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      - k_+ & - k^* & 0      & 0    \\
      k     & k_-   & 0      & 0    \\
      0     & 0     & - k_-  & k^*  \\
      0     & 0     & - k    & k_+
    \end{pmatrix}
\end{alignat} 
\end{subequations}
and
\begin{subequations}
\begin{alignat}{2}
  \fmslash{k} \gamma^0&=
    \begin{pmatrix}
      k_- & - k^* & 0   & 0     \\
      - k & k_+   & 0   & 0     \\
      0   & 0     & k_+ & k^*   \\
      0   & 0     & k   & k_-
    \end{pmatrix} , & \qquad 
   \fmslash{k} \gamma^0 \gamma^5 & =
   \begin{pmatrix}
      - k_- & k^*    & 0   & 0     \\
      k     & - k_+  & 0   & 0     \\
      0     & 0      & k_+ & k^*   \\
      0     & 0      & k   & k_-
    \end{pmatrix}   \\
  \fmslash{k} \gamma^1 &=
    \begin{pmatrix}
      k^*    & - k_- &   0 & 0   \\
      - k_+  & k     &   0 & 0   \\
      0      & 0     & k^* & k_+ \\
      0      & 0     & k_- & k
    \end{pmatrix}, & \qquad  
  \fmslash{k} \gamma^1 \gamma^5 & =
    \begin{pmatrix}
      - k^* & k_- & 0   & 0   \\
      k_+   & - k & 0   & 0   \\
      0     & 0   & k^* & k_+ \\
      0     & 0   & k_- & k
    \end{pmatrix} \\
  \fmslash{k} \gamma^2 &=
    \begin{pmatrix}
      \ii k^*   & \ii k_- & 0       & 0         \\
      - \ii k_+ & - \ii k & 0       & 0         \\
      0         & 0       & \ii k^* & - \ii k_+ \\
      0         & 0       & \ii k_- & - \ii k
    \end{pmatrix}, & \qquad 
  \fmslash{k} \gamma^2 \gamma^5 & =
    \begin{pmatrix}
      - \ii k^* & - \ii k_- & 0       & 0         \\
      \ii k_+   & \ii k     & 0       & 0         \\
      0         & 0         & \ii k^* & - \ii k_+ \\
      0         & 0         & \ii k_- & - \ii k
    \end{pmatrix} \\
  \fmslash{k} \gamma^3 &=
    \begin{pmatrix}
      - k_- & - k^* & 0    & 0     \\
      k     & k_+   & 0    & 0     \\
      0     & 0     & k_+  & - k^* \\
      0     & 0     & k    & - k_-
    \end{pmatrix}, & \qquad
  \fmslash{k} \gamma^3 \gamma^5 & =
    \begin{pmatrix}
      k_- & k^*   & 0    & 0     \\
      - k & - k_+ & 0    & 0     \\
      0   & 0     & k_+  & - k^* \\
      0   & 0     & k    & - k_-
    \end{pmatrix}
\end{alignat} 
\end{subequations}
and
\begin{subequations}
\begin{alignat}{2}
  C \gamma^0 \fmslash{k} &=
    \begin{pmatrix}
      k     & k_-   & 0   & 0     \\
      - k_+ & - k^* & 0   & 0     \\
      0     & 0     & k   & - k_+ \\
      0     & 0     & k_- & - k^*
    \end{pmatrix} , & \qquad 
  C \gamma^0 \fmslash{k} \gamma^5 & =
   \begin{pmatrix}
      - k & - k_- & 0   &   0     \\
      k_+ & k^*   & 0   &   0     \\
      0   &   0   & k   & - k_+   \\
      0   &   0   & k_- & - k^*
    \end{pmatrix}   \\
  C \gamma^1 \fmslash{k} &=
    \begin{pmatrix}
      k_+ & k^*   & 0   & 0     \\
      - k & - k_- & 0   & 0     \\
      0   & 0     & k_- & - k^* \\
      0   & 0     & k   & - k_+
    \end{pmatrix}, & \qquad  
  C \gamma^1 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      - k_+ & - k^* & 0   & 0     \\
      k     & k_-   & 0   & 0     \\
      0     & 0     & k_- & - k^* \\
      0     & 0     & k   & - k_+
    \end{pmatrix} \\
  C \gamma^2 \fmslash{k} &=
    \begin{pmatrix}
      \ii k_+ & \ii k^* & 0       & 0         \\
      \ii k   & \ii k_- & 0       & 0         \\
      0       & 0       & \ii k_- & - \ii k^* \\
      0       & 0       & - \ii k & \ii k_+
    \end{pmatrix}, & \qquad 
  C \gamma^2 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      - \ii k_+ & - \ii k^* & 0       & 0       \\
      - \ii k   & - \ii k_- & 0       & 0       \\
      0         & 0         & \ii k_- & - \ii k^* \\
      0         & 0         & - \ii k & \ii k_+
    \end{pmatrix} \\
  C \gamma^3 \fmslash{k} &=
    \begin{pmatrix}
      - k   & - k_- & 0     & 0     \\
      - k_+ & - k^* & 0     & 0     \\
      0     & 0     & k     & - k_+ \\
      0     & 0     & - k_- & k^*
    \end{pmatrix}, & \qquad
  C \gamma^3 \fmslash{k} \gamma^5 & =
    \begin{pmatrix}
      k   & k_- & 0     & 0    \\
      k_+ & k^* & 0     & 0    \\
      0   & 0   & k     & - k_+ \\
      0   & 0   & - k_- & k^*
    \end{pmatrix}
\end{alignat} 
\end{subequations}
and
\begin{subequations}
\begin{alignat}{2}
  C \fmslash{k} \gamma^0&=
    \begin{pmatrix}
      - k   & k^+ & 0   & 0     \\
      - k_- & k^* & 0   & 0     \\
      0     & 0   & - k & - k_- \\
      0     & 0   & k_+ & k^*
    \end{pmatrix} , & \qquad 
  C \fmslash{k} \gamma^0 \gamma^5 & =
   \begin{pmatrix}
      k   & - k_+ & 0   & 0     \\
      k_- & - k^* & 0   & 0     \\
      0   & 0     & - k & - k_- \\
      0   & 0     & k_+ & k^*
    \end{pmatrix}   \\
  C \fmslash{k} \gamma^1 &=
    \begin{pmatrix}
      - k_+  & k   & 0     & 0   \\
      - k^*  & k_- & 0     & 0   \\
      0      & 0   & - k_- & - k \\
      0      & 0   & k^*   & k_+
    \end{pmatrix}, & \qquad  
  C \fmslash{k} \gamma^1 \gamma^5 & =
    \begin{pmatrix}
      k_+ & - k   & 0     & 0   \\
      k^* & - k_- & 0     & 0   \\
      0   & 0     & - k_- & - k \\
      0   & 0     & k^*   & k_+
    \end{pmatrix} \\
  C \fmslash{k} \gamma^2 &=
    \begin{pmatrix}
      - \ii k_+ & - \ii k   & 0         & 0         \\
      - \ii k^* & - \ii k_- & 0         & 0         \\
      0         & 0         & - \ii k_- & \ii k     \\
      0         & 0         & \ii k^*   & - \ii k_+
    \end{pmatrix}, & \qquad 
  C \fmslash{k} \gamma^2 \gamma^5 & =
    \begin{pmatrix}
      \ii k_+ & \ii k   & 0         & 0         \\
      \ii k^* & \ii k_- & 0         & 0         \\
      0       & 0       & - \ii k_- & \ii k     \\
      0       & 0       & \ii k^*   & - \ii k_+
    \end{pmatrix} \\
  C \fmslash{k} \gamma^3 &=
    \begin{pmatrix}
      k   & k_+ & 0   & 0     \\
      k_- & k^* & 0   & 0     \\
      0   & 0   & - k & k_-   \\
      0   & 0   & k_+ & - k^*
    \end{pmatrix}, & \qquad
  C \fmslash{k} \gamma^3 \gamma^5 & =
    \begin{pmatrix}
      - k   & - k_+ & 0   & 0     \\
      - k_- & - k^* & 0   & 0     \\
      0     & 0     & - k & k_-   \\
      0     & 0     & k_+ & - k^*
    \end{pmatrix}
\end{alignat} 
\end{subequations}
<<Implementation of bispinor currents>>=
pure function fgvgr (psi, k) result (kpsi)
  type(bispinor) :: kpsi
  complex(kind=default) :: kp, km, k12, k12s
  type(vector), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  kpsi%a(1) = kp * psi%psi(1)%a(1) + k12s * psi%psi(1)%a(2) &
	- k12 * psi%psi(2)%a(1) - km * psi%psi(2)%a(2) &
	+ (0,1) * k12 * psi%psi(3)%a(1) + (0,1) * km * psi%psi(3)%a(2) &
	- kp * psi%psi(4)%a(1) - k12s * psi%psi(4)%a(2)
  kpsi%a(2) = k12 * psi%psi(1)%a(1) + km * psi%psi(1)%a(2) &
	- kp * psi%psi(2)%a(1) - k12s * psi%psi(2)%a(2) &
	- (0,1) * kp * psi%psi(3)%a(1) - (0,1) * k12s * psi%psi(3)%a(2) &
	+ k12 * psi%psi(4)%a(1) + km * psi%psi(4)%a(2)
  kpsi%a(3) = km * psi%psi(1)%a(3) - k12s * psi%psi(1)%a(4) &
	- k12 * psi%psi(2)%a(3) + kp * psi%psi(2)%a(4) &
	+ (0,1) * k12 * psi%psi(3)%a(3) - (0,1) * kp * psi%psi(3)%a(4) &
	+ km * psi%psi(4)%a(3) - k12s * psi%psi(4)%a(4)
  kpsi%a(4) = - k12 * psi%psi(1)%a(3) + kp * psi%psi(1)%a(4) &
	+ km * psi%psi(2)%a(3) - k12s * psi%psi(2)%a(4) &
	+ (0,1) * km * psi%psi(3)%a(3) - (0,1) * k12s * psi%psi(3)%a(4) &
	+ k12 * psi%psi(4)%a(3) - kp * psi%psi(4)%a(4)
end function fgvgr
@
<<Implementation of bispinor currents>>=
pure function f_sgr (g, phi, psi, k) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(momentum), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  type(vector) :: vk
  vk = k 
  phipsi = (g * phi) * fgvgr (psi, vk)
end function f_sgr 
@
<<Implementation of bispinor currents>>=
pure function f_slgr (gl, phi, psi, k) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gl
  complex(kind=default), intent(in) :: phi
  type(momentum), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  phipsi = f_sgr (gl, phi, psi, k)
  phipsi%a(3:4) = 0
end function f_slgr 
@
<<Implementation of bispinor currents>>=
pure function f_srgr (gr, phi, psi, k) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: gr
  complex(kind=default), intent(in) :: phi
  type(momentum), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  phipsi = f_sgr (gr, phi, psi, k)
  phipsi%a(1:2) = 0
end function f_srgr 
@
<<Implementation of bispinor currents>>=
pure function f_slrgr (gl, gr, phi, psi, k) result (phipsi)
  type(bispinor) :: phipsi, phipsi_l, phipsi_r
  complex(kind=default), intent(in) :: gl, gr
  complex(kind=default), intent(in) :: phi
  type(momentum), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  phipsi_l = f_slgr (gl, phi, psi, k)
  phipsi_r = f_srgr (gr, phi, psi, k)
  phipsi%a(1:2) = phipsi_l%a(1:2)
  phipsi%a(3:4) = phipsi_r%a(3:4)
end function f_slrgr 
@
<<Implementation of bispinor currents>>=
pure function fgvg5gr (psi, k) result (kpsi)
  type(bispinor) :: kpsi
  type(vector), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  type(bispinor) :: kpsi_dum
  kpsi_dum = fgvgr (psi, k)
  kpsi%a(1:2) = - kpsi_dum%a(1:2)
  kpsi%a(3:4) =   kpsi_dum%a(3:4)
end function fgvg5gr
@ 
<<Implementation of bispinor currents>>=
pure function f_pgr (g, phi, psi, k) result (phipsi)
  type(bispinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(momentum), intent(in) :: k
  type(vectorspinor), intent(in) :: psi
  type(vector) :: vk
  vk = k
  phipsi = (g * phi) * fgvg5gr (psi, vk)
end function f_pgr
@
The needed construction of gamma matrices involving the commutator
of two gamma matrices. For the slashed terms we use as usual the 
abbreviations $k_\pm=k_0\pm k_3$, $k=k_1+\ii k_2$, $k^*=k_1-\ii k_2$ 
and analogous expressions for the vector $v^\mu$. We remind you 
that~$\cdot^*$ is \emph{not} complex conjugation for complex~$k_\mu$.
Furthermore we introduce (in what follows the brackets around the vector 
indices have the usual meaning of antisymmetrizing with respect to the 
indices inside the brackets, here without a factor two in the denominator)
\begin{subequations}
\begin{alignat}{2}
  a_+ &= \; k_+ v_- + k v^* - k_- v_+ - k^* v & \; = &
	 \; 2 (k_{[3} v_{0]} + \ii k_{[2} v_{1]}) \\  	
  a_- &= \; k_- v_+ + k v^* - k_+ v_- - k^* v & \; = &
	 \; 2 (-k_{[3} v_{0]} + \ii k_{[2} v_{1]}) \\
  b_+ &= \; 2 (k_+ v - k v_+) & \; = & 
	 \; 2 (k_{[0} v_{1]} + k_{[3} v_{1]} + \ii k_{[0} v_{2]} + \ii 
	       k_{[3} v_{2]}) \\
  b_- &= \; 2 (k_- v - k v_-) & \; = & 
	 \; 2 (k_{[0} v_{1]} - k_{[3} v_{1]} + \ii k_{[0} v_{2]} - \ii 
	       k_{[3} v_{2]}) \\
  b_{+*} &= \; 2 (k_+ v^* - k^* v_+) & \; = &
	    \; 2 (k_{[0} v_{1]} + k_{[3} v_{1]} - \ii k_{[0} v_{2]} - \ii 
	       k_{[3} v_{2]}) \\
  b_{-*} &= \; 2 (k_- v^* - k^* v_-) & \; = &   	
	    \; 2 (k_{[0} v_{1]} - k_{[3} v_{1]} - \ii k_{[0} v_{2]} + \ii 
	       k_{[3} v_{2]})
\end{alignat}
\end{subequations}
Of course, one could introduce a more advanced notation, but we don't want to 
become confused.
\begin{subequations}
\begin{align}
\lbrack \fmslash{k} , \gamma^0 \rbrack &=
    \begin{pmatrix}
	-2k_3 & -2 k^* & 0 & 0 \\
	-2k & 2k_3 & 0 & 0 \\
	0 & 0 & 2k_3 & 2k^* \\
	0 & 0 & 2k & -2k_3 
    \end{pmatrix} \\ 
\lbrack \fmslash{k} , \gamma^1 \rbrack &=
    \begin{pmatrix}
	-2\ii k_2 & -2k_- & 0 & 0 \\
	-2k_+ & 2\ii k_2 & 0 & 0 \\
	0 & 0 & -2\ii k_2 & 2k_+ \\
	0 & 0 & 2k_- & 2\ii k_2
    \end{pmatrix} \\ 
\lbrack \fmslash{k} , \gamma^2 \rbrack &=
    \begin{pmatrix}
	2\ii k_1 & 2\ii k_- & 0 & 0 \\
	-2\ii k_+ & -2\ii k_1 & 0 & 0 \\
	0 & 0 & 2\ii k_1 & -2\ii k_+ \\
	0 & 0 & 2\ii k_- & -2\ii k_1 
    \end{pmatrix} \\ 
\lbrack \fmslash{k} , \gamma^3 \rbrack &=
    \begin{pmatrix}
	-2k_0 & -2k^* & 0 & 0 \\
	2k & 2k_0 & 0 & 0 \\
	0 & 0 & 2k_0 & -2k^* \\
	0 & 0 & 2k & -2k_0 
    \end{pmatrix} \\ 
\lbrack \fmslash{k} , \fmslash{V} \rbrack &=
    \begin{pmatrix}
	a_- & b_{-*} & 0 & 0 \\
	b_+ & -a_- & 0 & 0 \\
	0 & 0 & a_+ & -b_{+*} \\
	0 & 0 & -b_- & -a_+ 
    \end{pmatrix} \\    
  \gamma^5\gamma^0 \lbrack \fmslash{k} , \fmslash{V} \rbrack &=
    \begin{pmatrix}
	0 & 0 & - a_+ & b_{+*} \\
	0 & 0 & b_- & a_+ \\
	a_- & b_{-*} & 0 & 0 \\
	b_+ & - a_- & 0 & 0 
    \end{pmatrix} \\    
 \gamma^5\gamma^1 \lbrack \fmslash{k} , \fmslash{V} \rbrack &=
    \begin{pmatrix}
	0 & 0 & b_- & a_+ \\
	0 & 0 & -a_+ & b_{+*} \\
	-b_+ & a_- & 0 & 0 & \\
	-a_- & -b_{-*} & 0 & 0
    \end{pmatrix} \\
  \gamma^5\gamma^2 \lbrack \fmslash{k} , \fmslash{V} \rbrack &=
    \begin{pmatrix}
	0 & 0 & -\ii b_- & -\ii a_+ \\
	0 & 0 & -\ii a_+ & \ii b_{+*} \\
	\ii b_+ & -\ii a_- & 0 & 0 \\
	-\ii a_- & -\ii b_{-*} & 0 & 0  
    \end{pmatrix} \\
  \gamma^5\gamma^3 \lbrack \fmslash{k} , \fmslash{V} \rbrack &=
    \begin{pmatrix}
	0 & 0 & -a_+ & b_{+*} \\
	0 & 0 & -b_- & -a_+ \\
	-a_- & -b_{-*} & 0 & 0 \\
	b_+ & -a_- & 0 & 0 
    \end{pmatrix} 
\end{align} 
\end{subequations}
and
\begin{subequations}
\begin{align}
  \lbrack \fmslash{k} , \fmslash{V} \rbrack \gamma^0 \gamma^5 &=
    \begin{pmatrix}
	0 & 0 & a_- & b_{-*} \\
	0 & 0 & b_+ & -a_- \\
	-a_+ & b_{+*} & 0 & 0 \\
	b_- & a_+ & 0 & 0  	
    \end{pmatrix} \\    
 \lbrack \fmslash{k} , \fmslash{V} \rbrack \gamma^1 \gamma^5 &=
    \begin{pmatrix}
	0 & 0 & b_{-*} & a_- \\
	0 & 0 & -a_- & b_+ \\
	-b_{+*} & a_+ & 0 & 0 \\
	-a_+ & -b_- & 0 & 0 
    \end{pmatrix} \\
  \lbrack \fmslash{k} , \fmslash{V} \rbrack \gamma^2 \gamma^5 &=
    \begin{pmatrix}
	0 & 0 & \ii b_{-*} & -\ii a_- \\
	0 & 0 & -\ii a_- & -\ii b_+ \\
	-\ii b_{+*} & -\ii a_+ & 0 & 0 \\
	-\ii a_+ & \ii b_- & 0 & 0
    \end{pmatrix} \\
  \lbrack \fmslash{k} , \fmslash{V} \rbrack \gamma^3 \gamma^5 &=
    \begin{pmatrix}
	0 & 0 & a_- & - b_{-*} \\
	0 & 0 & b_+ & a_- \\
	a_+ & b_{+*} & 0 & 0 \\
	-b_- & a_+ & 0 & 0
    \end{pmatrix} 
\end{align} 
\end{subequations}
In what follows $l$ always means twice the value of $k$, e.g. $l_+$ =
$2 k_+$. We use the abbreviation $C^{\mu\nu} \equiv C \lbrack
\fmslash{k}, \gamma^\mu \rbrack \gamma^\nu \gamma^5$. 
\begin{subequations}
\begin{alignat}{2}
  C^{00} &= \begin{pmatrix}  
  0 & 0 & -l & -l_3 \\ 0 & 0 & l_3 & l^*   \\
  l & -l_3 & 0 & 0  \\ -l_3 & -l^* & 0 & 0 \end{pmatrix} , & \qquad
  C^{20} &= \begin{pmatrix}
  0 & 0 & -\ii l_+ & -\ii l_1   \\ 0 & 0 & -\ii l_1 & -\ii l_-   \\
  \ii l_- & -\ii l_1 & 0 & 0    \\ -\ii l_1 & \ii l_+ & 0 & 0
  \end{pmatrix} \\
  C^{01} &= \begin{pmatrix}
  0 & 0 & l_3 & -l \\ 0 & 0 & l^* & l_3   \\
  l_3 & -l & 0 & 0 \\ l^* & l_3 & 0 & 0   \end{pmatrix} , & \qquad
  C^{21} &= \begin{pmatrix}
  0 & 0 & -\ii l_1 & -\ii l_+ \\ 0 & 0 & -\ii l_- & -\ii l_1 \\
  \ii l_1 & -\ii l_- & 0 & 0  \\ -\ii l_+ & \ii l_1 & 0 & 0 
  \end{pmatrix} \\
  C^{02} &= \begin{pmatrix}
  0 & 0 & \ii l_3 & \ii l \\ 0 & 0 & \ii l^* & -\ii l_3 \\
  \ii l_3 & \ii l & 0 & 0 \\ \ii l^* & -\ii l_3 & 0 & 0 \end{pmatrix}
  , & \qquad
  C^{22} &= \begin{pmatrix}
  0 & 0 & l_1 & -l_+  \\ 0 & 0 & l_- & -l_1 \\
  -l_1 & -l_- & 0 & 0 \\ l_+ & l_1 & 0 & 0 
  \end{pmatrix} \\
  C^{03} &= \begin{pmatrix} 
  0 & 0 & -l & -l_3 \\ 0 & 0 & l_3 & -l^* \\
  -l & -l_3 & 0 & 0 \\ l_3 & -l^* & 0 & 0 \end{pmatrix} , & \qquad
  C^{23} &= \begin{pmatrix}
  0 & 0 & -\ii l_+ & \ii l_1  \\ 0 & 0 & -\ii l_1 & \ii l_- \\
  -\ii l_- & -\ii l_1 & 0 & 0 \\ \ii l_1 & \ii l_+ & 0 & 0
  \end{pmatrix} \\
  C^{10} &= \begin{pmatrix}
  0 & 0 & -l_+ & \ii l_2 \\ 0 & 0 & \ii l_2 & l_-  \\
  l_- & \ii l_2 & 0 & 0  \\ \ii l_2 & -l_+ & 0 & 0 \end{pmatrix} , &
  \qquad
  C^{30} &= \begin{pmatrix}
  0 & 0 & l & l_0  \\ 0 & 0 & l_0 & l^*  \\	
  l & -l_0 & 0 & 0 \\ -l_0 & l^* & 0 & 0 
  \end{pmatrix} \\
  C^{11} &= \begin{pmatrix} 
  0 & 0 & \ii l_2 & -l_+  \\ 0 & 0 & l_- & \ii l_2 \\
  -\ii l_2 & -l_- & 0 & 0 \\ l_+ & -\ii l_2 & 0 & 0 \end{pmatrix} , &
  \qquad 
  C^{31} &= \begin{pmatrix}
  0 & 0 & l_0 & l  \\ 0 & 0 & l^* & l_0 \\
  l_0 & -l & 0 & 0 \\ -l^* & l_0 & 0 & 0
  \end{pmatrix} \\
  C^{12} &= \begin{pmatrix} 
  0 & 0 & -l_2 & \ii l_+ \\ 0 & 0 & \ii l_- & l_2 \\
  l_2 & \ii l_- & 0 & 0  \\ \ii l_+ & -l_2 & 0 & 0 \end{pmatrix} , &
  \qquad 
  C^{32} &= \begin{pmatrix}
  0 & 0 & \ii l_0 & -\ii l \\ 0 & 0 & \ii l^* & -\ii l_0  \\
  \ii l_0 & \ii l & 0 & 0  \\ -\ii l^* & -\ii l_0 & 0 & 0 
  \end{pmatrix} \\
  C^{13} &= \begin{pmatrix}
  0 & 0 & -l_+ & -\ii l_2 \\ 0 & 0 & \ii l_2 & - l_- \\
  -l_- & \ii l_2 & 0 & 0 \\ -\ii l_2 & -l_+ & 0 & 0 \end{pmatrix} , &
  \qquad 
  C^{33} &= \begin{pmatrix} 
  0 & 0 & l & -l_0  \\ 0 & 0 & l_0 & -l^* \\	
  -l & -l_0 & 0 & 0 \\ l_0 & l^* & 0 & 0
  \end{pmatrix}
\end{alignat}   
\end{subequations}
and, with the abbreviation $\tilde{C}^{\mu\nu} \equiv C \gamma^5
\gamma^\nu \lbrack \fmslash{k} , \gamma^\mu \rbrack$ (note the
reversed order of the indices!)
\begin{subequations}
\begin{alignat}{2}
  \tilde{C}^{00} &= \begin{pmatrix} 
  0 & 0 & -l & l_3 \\ 0 & 0 & l_3 & l^* \\
  l & -l_3 & 0 & 0 \\ -l_3 & -l^* & 0 & 0 \end{pmatrix} , & \qquad
  \tilde{C}^{20} &= \begin{pmatrix}
  0 & 0 & -\ii l_- & \ii l_1 \\ 0 & 0 & \ii l_1 & -\ii l_+ \\	
  \ii l_+ & \ii l_1 & 0 & 0  \\ \ii l_1 & \ii l_- & 0 & 0
  \end{pmatrix} \\
  \tilde{C}^{01} &= \begin{pmatrix}
  0 & 0 & -l_3 & -l^* \\ 0 & 0 & l & -l_3 \\
  -l_3 & -l^* & 0 & 0 \\ l & -l_3 & 0 & 0 \end{pmatrix} , & \qquad
  \tilde{C}^{21} &= \begin{pmatrix} 
  0 & 0 & -\ii l_1 & \ii l_+ \\ 0 & 0 & \ii l_- & -\ii l_1 \\
  \ii l_1 & \ii l_- & 0 & 0  \\ \ii l_+ & \ii l_1 & 0 & 0  
  \end{pmatrix} \\
  \tilde{C}^{02} &= \begin{pmatrix}
  0 & 0 & -\ii l_3 & -\ii l^* \\ 0 & 0 & -\ii l & \ii l_3 \\
  -\ii l_3 & -\ii l^* & 0 & 0 \\ -\ii l & \ii l_3 & 0 & 0
  \end{pmatrix} , & \qquad 
  \tilde{C}^{22} &= \begin{pmatrix}
  0 & 0 & l_1 & -l_+  \\ 0 & 0 & l_- & -l_1 \\
  -l_1 & -l_- & 0 & 0 \\ l_+ & l_1 & 0 & 0 
  \end{pmatrix} \\
  \tilde{C}^{03} &= \begin{pmatrix}
  0 & 0 & l & -l_3 \\ 0 & 0 & l_3 & l^* \\
  l & -l_3 & 0 & 0 \\ l_3 & l^* & 0 & 0 \end{pmatrix} , & \qquad 
  \tilde{C}^{23} &= \begin{pmatrix}
  0 & 0 & \ii l_- & -\ii l_1 \\ 0 & 0 & \ii l_1 & -\ii l_+ \\
  \ii l_+ & \ii l_1 & 0 & 0  \\ -\ii l_1 & -\ii l_- & 0 & 0  
  \end{pmatrix} \\
  \tilde{C}^{10} &= \begin{pmatrix}
  0 & 0 & -l_- & -\ii l_2 \\ 0 & 0 & -\ii l_2 & l_+ \\
  l_+ & -\ii l_2 & 0 & 0  \\ -\ii l_2 & -l_- & 0 & 0 \end{pmatrix} , &
  \qquad 
  \tilde{C}^{30} &= \begin{pmatrix} 
  0 & 0 & -l & l_0  \\ 0 & 0 & l_0 & -l^* \\
  -l & -l_0 & 0 & 0 \\ -l_0 & -l^* & 0 & 0
  \end{pmatrix} \\
  \tilde{C}^{11} &= \begin{pmatrix}
  0 & 0 & \ii l_2 & -l_+  \\ 0 & 0 & l_- & \ii l_2 \\
  -\ii l_2 & -l_- & 0 & 0 \\ l_+ & -\ii l_2 & 0 & 0 \end{pmatrix} , &
  \qquad  
  \tilde{C}^{31} &= \begin{pmatrix}
  0 & 0 & -l_0 & l^*  \\ 0 & 0 & l & -l_0 \\
  -l_0 & -l^* & 0 & 0 \\ -l & -l_0 & 0 & 0  
  \end{pmatrix} \\ 
  \tilde{C}^{12} &= \begin{pmatrix}
  0 & 0 & -l_2 & -\ii l_+ \\ 0 & 0 & -\ii l_- & l_2 \\
  l_2 & -\ii l_- & 0 & 0  \\ -\ii l_+ & -l_2 & 0 & 0 \end{pmatrix} , &
  \qquad 
  \tilde{C}^{32} &= \begin{pmatrix}
  0 & 0 & -\ii l_0 & \ii l^* \\ 0 & 0 & -\ii l & \ii l_0 \\
  -\ii l_0 & -\ii l^* & 0 & 0 \\ \ii l & \ii l_0 & 0 & 0
  \end{pmatrix} \\
  \tilde{C}^{13} &= \begin{pmatrix}
  0 & 0 & l_- & \ii l_2  \\ 0 & 0 & -\ii l_2 & l_+ \\
  l_+ & -\ii l_2 & 0 & 0 \\ \ii l_2 & l_- & 0 & 0 \end{pmatrix} , &
  \qquad 
  \tilde{C}^{33} &= \begin{pmatrix}
  0 & 0 & l & -l_0  \\ 0 & 0 & l_0 & -l^* \\
  -l & -l_0 & 0 & 0 \\ l_0 & l^* & 0 & 0 
  \end{pmatrix}  
\end{alignat}
\end{subequations}
<<Implementation of bispinor currents>>=
pure function fggvvgr (v, psi, k) result (psikv)
  type(bispinor) :: psikv
  type(vectorspinor), intent(in) :: psi
  type(vector), intent(in) :: v, k
  complex(kind=default) :: kv30, kv21, kv01, kv31, kv02, kv32
  complex(kind=default) :: ap, am, bp, bm, bps, bms
  kv30 = k%x(3) * v%t - k%t * v%x(3)
  kv21 = (0,1) * (k%x(2) * v%x(1) - k%x(1) * v%x(2))
  kv01 = k%t * v%x(1) - k%x(1) * v%t
  kv31 = k%x(3) * v%x(1) - k%x(1) * v%x(3)
  kv02 = (0,1) * (k%t * v%x(2) - k%x(2) * v%t)
  kv32 = (0,1) * (k%x(3) * v%x(2) - k%x(2) * v%x(3))
  ap  = 2 * (kv30 + kv21)
  am  = 2 * (-kv30 + kv21)
  bp  = 2 * (kv01 + kv31 + kv02 + kv32)
  bm  = 2 * (kv01 - kv31 + kv02 - kv32) 
  bps = 2 * (kv01 + kv31 - kv02 - kv32) 
  bms = 2 * (kv01 - kv31 - kv02 + kv32)
  psikv%a(1) =  (-ap) * psi%psi(1)%a(3) + bps * psi%psi(1)%a(4) &
	        + (-bm) * psi%psi(2)%a(3) + (-ap) * psi%psi(2)%a(4) &
	        + (0,1) * (bm * psi%psi(3)%a(3) + ap * psi%psi(3)%a(4)) &
	        + ap * psi%psi(4)%a(3) + (-bps) * psi%psi(4)%a(4)
  psikv%a(2) =  bm * psi%psi(1)%a(3) + ap * psi%psi(1)%a(4) &
		+ ap * psi%psi(2)%a(3) + (-bps) * psi%psi(2)%a(4) &
		+ (0,1) * (ap * psi%psi(3)%a(3) - bps * psi%psi(3)%a(4)) &
		+ bm * psi%psi(4)%a(3) + ap * psi%psi(4)%a(4)
  psikv%a(3) = 	am * psi%psi(1)%a(1) + bms * psi%psi(1)%a(2) &
		+ bp * psi%psi(2)%a(1) + (-am) * psi%psi(2)%a(2) &
		+ (0,-1) * (bp * psi%psi(3)%a(1) + (-am) * psi%psi(3)%a(2)) &
		+ am * psi%psi(4)%a(1) + bms * psi%psi(4)%a(2)
  psikv%a(4) =  bp * psi%psi(1)%a(1) + (-am) * psi%psi(1)%a(2) &
		+ am * psi%psi(2)%a(1) + bms * psi%psi(2)%a(2) &
		+ (0,1) * (am * psi%psi(3)%a(1) + bms * psi%psi(3)%a(2)) &
		+ (-bp) * psi%psi(4)%a(1) + am * psi%psi(4)%a(2)
end function fggvvgr
@
<<Implementation of bispinor currents>>=
pure function f_vgr (g, v, psi, k) result (psikkkv)
  type(bispinor) :: psikkkv
  type(vectorspinor), intent(in) :: psi
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  complex(kind=default), intent(in) :: g
  type(vector) :: vk
  vk = k 
  psikkkv = g * (fggvvgr (v, psi, vk))
end function f_vgr
@
<<Implementation of bispinor currents>>=
pure function f_vlrgr (gl, gr, v, psi, k) result (psikv)
  type(bispinor) :: psikv
  type(vectorspinor), intent(in) :: psi
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  complex(kind=default), intent(in) :: gl, gr
  type(vector) :: vk
  vk = k 
  psikv = fggvvgr (v, psi, vk)
  psikv%a(1:2) = gl * psikv%a(1:2)
  psikv%a(3:4) = gr * psikv%a(3:4)
end function f_vlrgr
@
<<Declaration of bispinor currents>>=
public :: gr_potf, gr_sf, gr_pf, gr_vf, gr_vlrf, gr_slf, gr_srf, gr_slrf
@
<<Implementation of bispinor currents>>=
pure function gr_potf (g, phi, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  phipsi%psi(1)%a(1) = (g * phi) * psi%a(3)
  phipsi%psi(1)%a(2) = (g * phi) * psi%a(4)
  phipsi%psi(1)%a(3) = (g * phi) * psi%a(1)
  phipsi%psi(1)%a(4) = (g * phi) * psi%a(2)
  phipsi%psi(2)%a(1) = (g * phi) * psi%a(4)
  phipsi%psi(2)%a(2) = (g * phi) * psi%a(3)
  phipsi%psi(2)%a(3) = ((-g) * phi) * psi%a(2)
  phipsi%psi(2)%a(4) = ((-g) * phi) * psi%a(1)
  phipsi%psi(3)%a(1) = ((0,-1) * g * phi) * psi%a(4)
  phipsi%psi(3)%a(2) = ((0,1) * g * phi) * psi%a(3)
  phipsi%psi(3)%a(3) = ((0,1) * g * phi) * psi%a(2)
  phipsi%psi(3)%a(4) = ((0,-1) * g * phi) * psi%a(1)
  phipsi%psi(4)%a(1) = (g * phi) * psi%a(3)
  phipsi%psi(4)%a(2) = ((-g) * phi) * psi%a(4)
  phipsi%psi(4)%a(3) = ((-g) * phi) * psi%a(1)
  phipsi%psi(4)%a(4) = (g * phi) * psi%a(2)
end function gr_potf 
@
<<Implementation of bispinor currents>>=
pure function grkgf (psi, k) result (kpsi)
  type(vectorspinor) :: kpsi
  complex(kind=default) :: kp, km, k12, k12s
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: k
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  kpsi%psi(1)%a(1) = km * psi%a(1) - k12s * psi%a(2)
  kpsi%psi(1)%a(2) = (-k12) * psi%a(1) + kp * psi%a(2)
  kpsi%psi(1)%a(3) = kp * psi%a(3) + k12s * psi%a(4)
  kpsi%psi(1)%a(4) = k12 * psi%a(3) + km * psi%a(4)
  kpsi%psi(2)%a(1) = k12s * psi%a(1) - km * psi%a(2)
  kpsi%psi(2)%a(2) = (-kp) * psi%a(1) + k12 * psi%a(2)
  kpsi%psi(2)%a(3) = k12s * psi%a(3) + kp * psi%a(4)
  kpsi%psi(2)%a(4) = km * psi%a(3) + k12 * psi%a(4)
  kpsi%psi(3)%a(1) = (0,1) * (k12s * psi%a(1) + km * psi%a(2))
  kpsi%psi(3)%a(2) = (0,-1) * (kp * psi%a(1) + k12 * psi%a(2))
  kpsi%psi(3)%a(3) = (0,1) * (k12s * psi%a(3) - kp * psi%a(4))
  kpsi%psi(3)%a(4) = (0,1) * (km * psi%a(3) - k12 * psi%a(4))
  kpsi%psi(4)%a(1) = -(km * psi%a(1) + k12s * psi%a(2))
  kpsi%psi(4)%a(2) = k12 * psi%a(1) + kp * psi%a(2)
  kpsi%psi(4)%a(3) = kp * psi%a(3) - k12s * psi%a(4)
  kpsi%psi(4)%a(4) = k12 * psi%a(3) - km * psi%a(4)
end function grkgf
@ 
<<Implementation of bispinor currents>>=
pure function gr_sf (g, phi, psi, k) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  phipsi = (g * phi) * grkgf (psi, vk)
end function gr_sf
@ 
<<Implementation of bispinor currents>>=
pure function gr_slf (gl, phi, psi, k) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: gl
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l
  type(momentum), intent(in) :: k
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  phipsi = gr_sf (gl, phi, psi_l, k)
end function gr_slf
@ 
<<Implementation of bispinor currents>>=
pure function gr_srf (gr, phi, psi, k) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: gr
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(momentum), intent(in) :: k
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  phipsi = gr_sf (gr, phi, psi_r, k)
end function gr_srf
@ 
<<Implementation of bispinor currents>>=
pure function gr_slrf (gl, gr, phi, psi, k) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: gl, gr
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(momentum), intent(in) :: k
  phipsi = gr_slf (gl, phi, psi, k) + gr_srf (gr, phi, psi, k)  
end function gr_slrf
@
<<Implementation of bispinor currents>>=
pure function grkggf (psi, k) result (kpsi)
  type(vectorspinor) :: kpsi
  complex(kind=default) :: kp, km, k12, k12s
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: k
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  kpsi%psi(1)%a(1) = (-km) * psi%a(1) + k12s * psi%a(2)
  kpsi%psi(1)%a(2) = k12 * psi%a(1) - kp * psi%a(2)
  kpsi%psi(1)%a(3) = kp * psi%a(3) + k12s * psi%a(4)
  kpsi%psi(1)%a(4) = k12 * psi%a(3) + km * psi%a(4)
  kpsi%psi(2)%a(1) = (-k12s) * psi%a(1) + km * psi%a(2)
  kpsi%psi(2)%a(2) = kp * psi%a(1) - k12 * psi%a(2)
  kpsi%psi(2)%a(3) = k12s * psi%a(3) + kp * psi%a(4)
  kpsi%psi(2)%a(4) = km * psi%a(3) + k12 * psi%a(4)
  kpsi%psi(3)%a(1) = (0,-1) * (k12s * psi%a(1) + km * psi%a(2))
  kpsi%psi(3)%a(2) = (0,1) * (kp * psi%a(1) + k12 * psi%a(2))
  kpsi%psi(3)%a(3) = (0,1) * (k12s * psi%a(3) - kp * psi%a(4))
  kpsi%psi(3)%a(4) = (0,1) * (km * psi%a(3) - k12 * psi%a(4))
  kpsi%psi(4)%a(1) = km * psi%a(1) + k12s * psi%a(2)
  kpsi%psi(4)%a(2) = -(k12 * psi%a(1) + kp * psi%a(2))
  kpsi%psi(4)%a(3) = kp * psi%a(3) - k12s * psi%a(4)
  kpsi%psi(4)%a(4) = k12 * psi%a(3) - km * psi%a(4)
end function grkggf
@
<<Implementation of bispinor currents>>=
pure function gr_pf (g, phi, psi, k) result (phipsi)
  type(vectorspinor) :: phipsi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi
  type(bispinor), intent(in) :: psi
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k
  phipsi = (g * phi) * grkggf (psi, vk) 
end function gr_pf 
@
<<Implementation of bispinor currents>>=
pure function grkkggf (v, psi, k) result (psikv)
  type(vectorspinor) :: psikv
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v, k
  complex(kind=default) :: kv30, kv21, kv01, kv31, kv02, kv32
  complex(kind=default) :: ap, am, bp, bm, bps, bms, imago
  imago = (0.0_default,1.0_default)
  kv30 = k%x(3) * v%t - k%t * v%x(3)
  kv21 = imago * (k%x(2) * v%x(1) - k%x(1) * v%x(2))
  kv01 = k%t * v%x(1) - k%x(1) * v%t
  kv31 = k%x(3) * v%x(1) - k%x(1) * v%x(3)
  kv02 = imago * (k%t * v%x(2) - k%x(2) * v%t)
  kv32 = imago * (k%x(3) * v%x(2) - k%x(2) * v%x(3))
  ap  = 2 * (kv30 + kv21)
  am  = 2 * ((-kv30) + kv21)
  bp  = 2 * (kv01 + kv31 + kv02 + kv32)
  bm  = 2 * (kv01 - kv31 + kv02 - kv32) 
  bps = 2 * (kv01 + kv31 - kv02 - kv32) 
  bms = 2 * (kv01 - kv31 - kv02 + kv32)
  psikv%psi(1)%a(1) = am * psi%a(3) + bms * psi%a(4)
  psikv%psi(1)%a(2) = bp * psi%a(3) + (-am) * psi%a(4)
  psikv%psi(1)%a(3) = (-ap) * psi%a(1) + bps * psi%a(2)
  psikv%psi(1)%a(4) = bm * psi%a(1) + ap * psi%a(2)
  psikv%psi(2)%a(1) = bms * psi%a(3) + am * psi%a(4)
  psikv%psi(2)%a(2) = (-am) * psi%a(3) + bp * psi%a(4)
  psikv%psi(2)%a(3) = (-bps) * psi%a(1) + ap * psi%a(2)
  psikv%psi(2)%a(4) = (-ap) * psi%a(1) + (-bm) * psi%a(2)
  psikv%psi(3)%a(1) = imago * (bms * psi%a(3) - am * psi%a(4)) 
  psikv%psi(3)%a(2) = (-imago) * (am * psi%a(3) + bp * psi%a(4))
  psikv%psi(3)%a(3) = (-imago) * (bps * psi%a(1) + ap * psi%a(2))
  psikv%psi(3)%a(4) = imago * ((-ap) * psi%a(1) + bm * psi%a(2))
  psikv%psi(4)%a(1) = am * psi%a(3) + (-bms) * psi%a(4)
  psikv%psi(4)%a(2) = bp * psi%a(3) + am * psi%a(4) 
  psikv%psi(4)%a(3) = ap * psi%a(1) + bps * psi%a(2)
  psikv%psi(4)%a(4) = (-bm) * psi%a(1) + ap * psi%a(2) 
end function grkkggf
@
<<Implementation of bispinor currents>>=
pure function gr_vf (g, v, psi, k) result (psikv)
  type(vectorspinor) :: psikv
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  complex(kind=default), intent(in) :: g
  type(vector) :: vk
  vk = k 
  psikv = g * (grkkggf (v, psi, vk))
end function gr_vf
@
<<Implementation of bispinor currents>>=
pure function gr_vlrf (gl, gr, v, psi, k) result (psikv)
  type(vectorspinor) :: psikv
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l, psi_r
  type(vector), intent(in) :: v
  type(momentum), intent(in) :: k
  complex(kind=default), intent(in) :: gl, gr
  type(vector) :: vk
  vk = k 
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  psikv = gl * grkkggf (v, psi_l, vk) + gr * grkkggf (v, psi_r, vk)
end function gr_vlrf
@
<<Declaration of bispinor currents>>=
public :: v_grf, v_fgr 
@
<<Declaration of bispinor currents>>=
public :: vlr_grf, vlr_fgr 
@
$V^\mu = \psi_\rho^T C^{\mu\rho} \psi$
<<Implementation of bispinor currents>>=
pure function grkgggf (psil, psir, k) result (j)
  type(vector) :: j
  type(vectorspinor), intent(in) :: psil
  type(bispinor), intent(in) :: psir
  type(vector), intent(in) :: k
  type(vectorspinor) :: c_psir0, c_psir1, c_psir2, c_psir3
  complex(kind=default) :: kp, km, k12, k12s, ik2
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  (k%x(1) + (0,1)*k%x(2))
  k12s =  (k%x(1) - (0,1)*k%x(2))	
  ik2 = (0,1) * k%x(2)
  !!! New version:
  c_psir0%psi(1)%a(1) = (-k%x(3)) * psir%a(3) + (-k12s) * psir%a(4)
  c_psir0%psi(1)%a(2) = (-k12) * psir%a(3) + k%x(3) * psir%a(4)
  c_psir0%psi(1)%a(3) = (-k%x(3)) * psir%a(1) + (-k12s) * psir%a(2)
  c_psir0%psi(1)%a(4) = (-k12) * psir%a(1) + k%x(3) * psir%a(2)
  c_psir0%psi(2)%a(1) = (-k12s) * psir%a(3) + (-k%x(3)) * psir%a(4)
  c_psir0%psi(2)%a(2) = k%x(3) * psir%a(3) + (-k12) * psir%a(4)
  c_psir0%psi(2)%a(3) = k12s * psir%a(1) + k%x(3) * psir%a(2)
  c_psir0%psi(2)%a(4) = (-k%x(3)) * psir%a(1) + k12 * psir%a(2)
  c_psir0%psi(3)%a(1) = (0,1) * ((-k12s) * psir%a(3) + k%x(3) * psir%a(4))
  c_psir0%psi(3)%a(2) = (0,1) * (k%x(3) * psir%a(3) + k12 * psir%a(4))
  c_psir0%psi(3)%a(3) = (0,1) * (k12s * psir%a(1) + (-k%x(3)) * psir%a(2))
  c_psir0%psi(3)%a(4) = (0,1) * ((-k%x(3)) * psir%a(1) + (-k12) * psir%a(2))
  c_psir0%psi(4)%a(1) = (-k%x(3)) * psir%a(3) + k12s * psir%a(4)
  c_psir0%psi(4)%a(2) = (-k12) * psir%a(3) + (-k%x(3)) * psir%a(4)
  c_psir0%psi(4)%a(3) = k%x(3) * psir%a(1) + (-k12s) * psir%a(2)
  c_psir0%psi(4)%a(4) = k12 * psir%a(1) + k%x(3) * psir%a(2) 
  !!!
  c_psir1%psi(1)%a(1) = (-ik2) * psir%a(3) + (-km) * psir%a(4)
  c_psir1%psi(1)%a(2) = (-kp) * psir%a(3) + ik2 * psir%a(4)
  c_psir1%psi(1)%a(3) = ik2 * psir%a(1) + (-kp) * psir%a(2) 
  c_psir1%psi(1)%a(4) = (-km) * psir%a(1) + (-ik2) * psir%a(2)
  c_psir1%psi(2)%a(1) = (-km) * psir%a(3) + (-ik2) * psir%a(4)
  c_psir1%psi(2)%a(2) = ik2 * psir%a(3) + (-kp) * psir%a(4)
  c_psir1%psi(2)%a(3) = kp * psir%a(1) + (-ik2) * psir%a(2)
  c_psir1%psi(2)%a(4) = ik2 * psir%a(1) + km * psir%a(2)
  c_psir1%psi(3)%a(1) = ((0,-1) * km) * psir%a(3) + (-k%x(2)) * psir%a(4)
  c_psir1%psi(3)%a(2) = (-k%x(2)) * psir%a(3) + ((0,1) * kp) * psir%a(4)
  c_psir1%psi(3)%a(3) = ((0,1) * kp) * psir%a(1) + (-k%x(2)) * psir%a(2)
  c_psir1%psi(3)%a(4) = (-k%x(2)) * psir%a(1) + ((0,-1) * km) * psir%a(2)
  c_psir1%psi(4)%a(1) = (-ik2) * psir%a(3) + km * psir%a(4)
  c_psir1%psi(4)%a(2) = (-kp) * psir%a(3) + (-ik2) * psir%a(4)
  c_psir1%psi(4)%a(3) = (-ik2) *  psir%a(1) + (-kp) * psir%a(2) 
  c_psir1%psi(4)%a(4) = km * psir%a(1) + (-ik2) * psir%a(2)
  !!!
  c_psir2%psi(1)%a(1) = (0,1) * (k%x(1) * psir%a(3) + km * psir%a(4))  
  c_psir2%psi(1)%a(2) = (0,-1) * (kp * psir%a(3) + k%x(1) * psir%a(4))
  c_psir2%psi(1)%a(3) = (0,1) * ((-k%x(1)) * psir%a(1) + kp * psir%a(2)) 
  c_psir2%psi(1)%a(4) = (0,1) * ((-km) * psir%a(1) + k%x(1) * psir%a(2))
  c_psir2%psi(2)%a(1) = (0,1) * (km * psir%a(3) + k%x(1) * psir%a(4))
  c_psir2%psi(2)%a(2) = (0,-1) * (k%x(1) * psir%a(3) + kp * psir%a(4))
  c_psir2%psi(2)%a(3) = (0,-1) * (kp * psir%a(1) + (-k%x(1)) * psir%a(2))
  c_psir2%psi(2)%a(4) = (0,-1) * (k%x(1) * psir%a(1) + (-km) * psir%a(2))
  c_psir2%psi(3)%a(1) = (-km) * psir%a(3) + k%x(1) * psir%a(4)
  c_psir2%psi(3)%a(2) = k%x(1) * psir%a(3) + (-kp) * psir%a(4)
  c_psir2%psi(3)%a(3) = kp * psir%a(1) + k%x(1) * psir%a(2) 
  c_psir2%psi(3)%a(4) = k%x(1) * psir%a(1) + km * psir%a(2)
  c_psir2%psi(4)%a(1) = (0,1) * (k%x(1) * psir%a(3) + (-km) * psir%a(4))
  c_psir2%psi(4)%a(2) = (0,1) * ((-kp) * psir%a(3) + k%x(1) * psir%a(4))
  c_psir2%psi(4)%a(3) = (0,1) * (k%x(1) * psir%a(1) + kp * psir%a(2))
  c_psir2%psi(4)%a(4) = (0,1) * (km * psir%a(1) + k%x(1) * psir%a(2))
  !!!
  c_psir3%psi(1)%a(1) = (-k%t) * psir%a(3) - k12s * psir%a(4)
  c_psir3%psi(1)%a(2) = k12 * psir%a(3) + k%t * psir%a(4)
  c_psir3%psi(1)%a(3) = (-k%t) * psir%a(1) + k12s * psir%a(2)
  c_psir3%psi(1)%a(4) = (-k12) * psir%a(1) + k%t * psir%a(2) 
  c_psir3%psi(2)%a(1) = (-k12s) * psir%a(3) + (-k%t) * psir%a(4)
  c_psir3%psi(2)%a(2) = k%t * psir%a(3) + k12 * psir%a(4)
  c_psir3%psi(2)%a(3) = (-k12s) * psir%a(1) + k%t * psir%a(2) 
  c_psir3%psi(2)%a(4) = (-k%t) * psir%a(1) + k12 * psir%a(2)
  c_psir3%psi(3)%a(1) = (0,-1) * (k12s * psir%a(3) + (-k%t) * psir%a(4)) 
  c_psir3%psi(3)%a(2) = (0,1) * (k%t * psir%a(3) + (-k12) * psir%a(4))
  c_psir3%psi(3)%a(3) = (0,-1) * (k12s * psir%a(1) + k%t * psir%a(2))
  c_psir3%psi(3)%a(4) = (0,-1) * (k%t * psir%a(1) + k12 * psir%a(2))
  c_psir3%psi(4)%a(1) = (-k%t) * psir%a(3) + k12s * psir%a(4)
  c_psir3%psi(4)%a(2) = k12 * psir%a(3) + (-k%t) * psir%a(4)
  c_psir3%psi(4)%a(3) = k%t * psir%a(1) + k12s * psir%a(2) 
  c_psir3%psi(4)%a(4) = k12 * psir%a(1) + k%t * psir%a(2)
  j%t    =   2 * (psil * c_psir0) 
  j%x(1) =   2 * (psil * c_psir1)
  j%x(2) =   2 * (psil * c_psir2)
  j%x(3) =   2 * (psil * c_psir3)
end function grkgggf
@
<<Implementation of bispinor currents>>=
pure function v_grf (g, psil, psir, k) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: psil
  type(bispinor), intent(in) :: psir
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * grkgggf (psil, psir, vk)
end function v_grf
@
<<Implementation of bispinor currents>>=
pure function vlr_grf (gl, gr, psil, psir, k) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: psil
  type(bispinor), intent(in) :: psir
  type(bispinor) :: psir_l, psir_r
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  psir_l%a(1:2) = psir%a(1:2) 
  psir_l%a(3:4) = 0 
  psir_r%a(1:2) = 0
  psir_r%a(3:4) = psir%a(3:4) 
  j = gl * grkgggf (psil, psir_l, vk) + gr * grkgggf (psil, psir_r, vk)
end function vlr_grf
@
$V^\mu = \psi^T \tilde{C}^{\mu\rho} \psi_\rho$; remember the reversed
index order in $\tilde{C}$. 
<<Implementation of bispinor currents>>=
pure function fggkggr (psil, psir, k) result (j)
  type(vector) :: j
  type(vectorspinor), intent(in) :: psir
  type(bispinor), intent(in) :: psil
  type(vector), intent(in) :: k
  type(bispinor) :: c_psir0, c_psir1, c_psir2, c_psir3
  complex(kind=default) :: kp, km, k12, k12s, ik1, ik2
  kp = k%t + k%x(3)
  km = k%t - k%x(3)
  k12  =  k%x(1) + (0,1)*k%x(2)
  k12s =  k%x(1) - (0,1)*k%x(2)	
  ik1 = (0,1) * k%x(1)
  ik2 = (0,1) * k%x(2)
  c_psir0%a(1) = k%x(3) * (psir%psi(1)%a(4) + psir%psi(4)%a(4) &
                + psir%psi(2)%a(3) + (0,1) * psir%psi(3)%a(3)) - &  
		k12 * (psir%psi(1)%a(3) + psir%psi(4)%a(3)) + & 
                k12s * (psir%psi(2)%a(4) + (0,1) * psir%psi(3)%a(4)) 
  c_psir0%a(2) = k%x(3) * (psir%psi(1)%a(3) - psir%psi(4)%a(3) + &
                psir%psi(2)%a(4) - (0,1) * psir%psi(3)%a(4)) + &
                k12s * (psir%psi(1)%a(4) - psir%psi(4)%a(4)) - &
                k12 * (psir%psi(2)%a(3) - (0,1) * psir%psi(3)%a(3))
  c_psir0%a(3) = k%x(3) * (-psir%psi(1)%a(2) + psir%psi(4)%a(2) + &
                psir%psi(2)%a(1) + (0,1) * psir%psi(3)%a(1)) + &
                k12 * (psir%psi(1)%a(1) - psir%psi(4)%a(1)) + &
                k12s * (psir%psi(2)%a(2) + (0,1) * psir%psi(3)%a(2))
  c_psir0%a(4) = k%x(3) * (-psir%psi(1)%a(1) - psir%psi(4)%a(1) + &
                psir%psi(2)%a(2) - (0,1) * psir%psi(3)%a(2)) -  &
                k12s * (psir%psi(1)%a(2) + psir%psi(4)%a(2)) - &
                k12 * (psir%psi(2)%a(1) - (0,1) * psir%psi(3)%a(1))
  !!!
  c_psir1%a(1) = ik2 * (-psir%psi(1)%a(4) - psir%psi(4)%a(4) - & 
                psir%psi(2)%a(3) - (0,1) * psir%psi(3)%a(3)) - & 
                km * (psir%psi(1)%a(3) + psir%psi(4)%a(3)) + & 
                kp * (psir%psi(2)%a(4) + (0,1) * psir%psi(3)%a(4))
  c_psir1%a(2) = ik2 * (-psir%psi(1)%a(3) - psir%psi(2)%a(4) + &
                psir%psi(4)%a(3) + (0,1) * psir%psi(3)%a(4)) + &
                kp * (psir%psi(1)%a(4) - psir%psi(4)%a(4)) - &
                km * (psir%psi(2)%a(3) - (0,1) * psir%psi(3)%a(3))
  c_psir1%a(3) = ik2 * (-psir%psi(1)%a(2) + psir%psi(2)%a(1) + &
                psir%psi(4)%a(2) + (0,1) * psir%psi(3)%a(1)) + &
                kp * (psir%psi(1)%a(1) - psir%psi(4)%a(1)) + &
                km * (psir%psi(2)%a(2) + (0,1) * psir%psi(3)%a(2))
  c_psir1%a(4) = ik2 * (-psir%psi(1)%a(1) + psir%psi(2)%a(2) - &
                psir%psi(4)%a(1) - (0,1) * psir%psi(3)%a(2)) - &
                km * (psir%psi(1)%a(2) + psir%psi(4)%a(2)) - &
                kp * (psir%psi(2)%a(1) - (0,1) * psir%psi(3)%a(1))
  !!!
  c_psir2%a(1) = ik1 * (psir%psi(2)%a(3) + psir%psi(1)%a(4) & 
                + psir%psi(4)%a(4) + (0,1) * psir%psi(3)%a(3)) - &
                ((0,1)*km) * (psir%psi(1)%a(3) + psir%psi(4)%a(3)) &
                + kp * (psir%psi(3)%a(4) - (0,1) * psir%psi(2)%a(4)) 
  c_psir2%a(2) = ik1 * (psir%psi(1)%a(3) + psir%psi(2)%a(4) - &
                psir%psi(4)%a(3) - (0,1) * psir%psi(3)%a(4)) - &
                ((0,1)*kp) * (psir%psi(1)%a(4) - psir%psi(4)%a(4)) &
                - km * (psir%psi(3)%a(3) + (0,1) * psir%psi(2)%a(3))
  c_psir2%a(3) = ik1 * (psir%psi(1)%a(2) - psir%psi(2)%a(1) - &
                psir%psi(4)%a(2) - (0,1) * psir%psi(3)%a(1)) + &
                ((0,1)*kp) * (psir%psi(1)%a(1) - psir%psi(4)%a(1)) &
                + km * (psir%psi(3)%a(2) - (0,1) * psir%psi(2)%a(2))
  c_psir2%a(4) = ik1 * (psir%psi(1)%a(1) - psir%psi(2)%a(2) + &
                psir%psi(4)%a(1) + (0,1) * psir%psi(3)%a(2)) + &
                ((0,1)*km) * (psir%psi(1)%a(2) + psir%psi(4)%a(2)) - &
                kp * (psir%psi(3)%a(1) + (0,1) * psir%psi(2)%a(1))
  !!!
  c_psir3%a(1) = k%t * (psir%psi(1)%a(4) + psir%psi(4)%a(4) + &
                psir%psi(2)%a(3) + (0,1) * psir%psi(3)%a(3)) - &
                k12 * (psir%psi(1)%a(3) + psir%psi(4)%a(3)) - &
                k12s * (psir%psi(2)%a(4) + (0,1) * psir%psi(3)%a(4))
  c_psir3%a(2) = k%t * (psir%psi(1)%a(3) - psir%psi(4)%a(3) + & 
                psir%psi(2)%a(4) - (0,1) * psir%psi(3)%a(4)) - & 
                k12s * (psir%psi(1)%a(4) - psir%psi(4)%a(4)) - &
                k12 * (psir%psi(2)%a(3) - (0,1) * psir%psi(3)%a(3))
  c_psir3%a(3) = k%t * (-psir%psi(1)%a(2) + psir%psi(2)%a(1) + &
                psir%psi(4)%a(2) + (0,1) * psir%psi(3)%a(1)) - &
                k12 * (psir%psi(1)%a(1) - psir%psi(4)%a(1)) + &
                k12s * (psir%psi(2)%a(2) + (0,1) * psir%psi(3)%a(2))
  c_psir3%a(4) = k%t * (-psir%psi(1)%a(1) + psir%psi(2)%a(2) - &
                psir%psi(4)%a(1) - (0,1) * psir%psi(3)%a(2)) - &
                k12s * (psir%psi(1)%a(2) + psir%psi(4)%a(2)) + &
                k12 * (psir%psi(2)%a(1) - (0,1) * psir%psi(3)%a(1))
  !!! Because we explicitly multiplied the charge conjugation matrix
  !!! we have to omit it from the spinor product and take the 
  !!! ordinary product!
  j%t    =   2 * dot_product (conjg (psil%a), c_psir0%a) 
  j%x(1) =   2 * dot_product (conjg (psil%a), c_psir1%a)
  j%x(2) =   2 * dot_product (conjg (psil%a), c_psir2%a)
  j%x(3) =   2 * dot_product (conjg (psil%a), c_psir3%a) 
end function fggkggr
@
<<Implementation of bispinor currents>>=
pure function v_fgr (g, psil, psir, k) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: psir
  type(bispinor), intent(in) :: psil
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  j = g * fggkggr (psil, psir, vk)
end function v_fgr
@
<<Implementation of bispinor currents>>=
pure function vlr_fgr (gl, gr, psil, psir, k) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: psir
  type(bispinor), intent(in) :: psil
  type(bispinor) :: psil_l
  type(bispinor) :: psil_r
  type(momentum), intent(in) :: k
  type(vector) :: vk
  vk = k 
  psil_l%a(1:2) = psil%a(1:2)
  psil_l%a(3:4) = 0
  psil_r%a(1:2) = 0
  psil_r%a(3:4) = psil%a(3:4)
  j = gl * fggkggr (psil_l, psir, vk) + gr * fggkggr (psil_r, psir, vk)
end function vlr_fgr
@ \subsection{Gravitino 4-Couplings}
<<Declaration of bispinor currents>>=
public :: f_s2gr, f_svgr, f_slvgr, f_srvgr, f_slrvgr, f_pvgr, f_v2gr, f_v2lrgr
@
<<Implementation of bispinor currents>>=
pure function f_s2gr (g, phi1, phi2, psi) result (phipsi)
  type(bispinor) :: phipsi
  type(vectorspinor), intent(in) :: psi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi1, phi2
  phipsi = phi2 * f_potgr (g, phi1, psi) 
end function f_s2gr 
@
<<Implementation of bispinor currents>>=
pure function f_svgr (g, phi, v, grav) result (phigrav)
  type(bispinor) :: phigrav
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: g, phi
  phigrav = (g * phi) * fgvg5gr (grav, v)
end function f_svgr
@
<<Implementation of bispinor currents>>=
pure function f_slvgr (gl, phi, v, grav) result (phigrav)
  type(bispinor) :: phigrav, phidum
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gl, phi
  phidum = (gl * phi) * fgvg5gr (grav, v)
  phigrav%a(1:2) = phidum%a(1:2)
  phigrav%a(3:4) = 0
end function f_slvgr
@
<<Implementation of bispinor currents>>=
pure function f_srvgr (gr, phi, v, grav) result (phigrav)
  type(bispinor) :: phigrav, phidum
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gr, phi
  phidum = (gr * phi) * fgvg5gr (grav, v)
  phigrav%a(1:2) = 0
  phigrav%a(3:4) = phidum%a(3:4)
end function f_srvgr
@
<<Implementation of bispinor currents>>=
pure function f_slrvgr (gl, gr, phi, v, grav) result (phigrav)
  type(bispinor) :: phigrav, phidum
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gl, gr, phi
  phigrav = f_slvgr (gl, phi, v, grav) + f_srvgr (gr, phi, v, grav)
end function f_slrvgr
@
<<Implementation of bispinor currents>>=
pure function f_pvgr (g, phi, v, grav) result (phigrav)
  type(bispinor) :: phigrav
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: g, phi
  phigrav = (g * phi) * fgvgr (grav, v)
end function f_pvgr
@ 
<<Implementation of bispinor currents>>=
pure function f_v2gr (g, v1, v2, grav) result (psi)
  type(bispinor) :: psi
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v1, v2
  psi = g * fggvvgr (v2, grav, v1)
end function f_v2gr
@ 
<<Implementation of bispinor currents>>=
pure function f_v2lrgr (gl, gr, v1, v2, grav) result (psi)
  type(bispinor) :: psi
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v1, v2
  psi = fggvvgr (v2, grav, v1)
  psi%a(1:2) = gl * psi%a(1:2)
  psi%a(3:4) = gr * psi%a(3:4)
end function f_v2lrgr
@
<<Declaration of bispinor currents>>=
public :: gr_s2f, gr_svf, gr_pvf, gr_slvf, gr_srvf, gr_slrvf, gr_v2f, gr_v2lrf
@
<<Implementation of bispinor currents>>=
pure function gr_s2f (g, phi1, phi2, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  complex(kind=default), intent(in) :: g
  complex(kind=default), intent(in) :: phi1, phi2
  phipsi = phi2 * gr_potf (g, phi1, psi) 
end function gr_s2f 
@
<<Implementation of bispinor currents>>=
pure function gr_svf (g, phi, v, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: g, phi
  phipsi = (g * phi) * grkggf (psi, v)
end function gr_svf
@
<<Implementation of bispinor currents>>=
pure function gr_slvf (gl, phi, v, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gl, phi
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  phipsi = (gl * phi) * grkggf (psi_l, v)
end function gr_slvf
@
<<Implementation of bispinor currents>>=
pure function gr_srvf (gr, phi, v, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gr, phi
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  phipsi = (gr * phi) * grkggf (psi_r, v)
end function gr_srvf
@
<<Implementation of bispinor currents>>=
pure function gr_slrvf (gl, gr, phi, v, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: gl, gr, phi
  phipsi = gr_slvf (gl, phi, v, psi) + gr_srvf (gr, phi, v, psi)
end function gr_slrvf
@
<<Implementation of bispinor currents>>=
pure function gr_pvf (g, phi, v, psi) result (phipsi)
  type(vectorspinor) :: phipsi
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  complex(kind=default), intent(in) :: g, phi
  phipsi = (g * phi) * grkgf (psi, v)
end function gr_pvf
@ 
<<Implementation of bispinor currents>>=
pure function gr_v2f (g, v1, v2, psi) result (vvpsi)
  type(vectorspinor) :: vvpsi
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v1, v2
  vvpsi = g * grkkggf (v2, psi, v1) 
end function gr_v2f
@ 
<<Implementation of bispinor currents>>=
pure function gr_v2lrf (gl, gr, v1, v2, psi) result (vvpsi)
  type(vectorspinor) :: vvpsi
  complex(kind=default), intent(in) :: gl, gr
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l, psi_r
  type(vector), intent(in) :: v1, v2
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  vvpsi = gl * grkkggf (v2, psi_l, v1) + gr * grkkggf (v2, psi_r, v1) 
end function gr_v2lrf
@
<<Declaration of bispinor currents>>=
public :: s2_grf, s2_fgr, sv1_grf, sv2_grf, sv1_fgr, sv2_fgr, &
          slv1_grf, slv2_grf, slv1_fgr, slv2_fgr, &
          srv1_grf, srv2_grf, srv1_fgr, srv2_fgr, &
          slrv1_grf, slrv2_grf, slrv1_fgr, slrv2_fgr, &
          pv1_grf, pv2_grf, pv1_fgr, pv2_fgr, v2_grf, v2_fgr, &
          v2lr_grf, v2lr_fgr
@
<<Implementation of bispinor currents>>=
pure function s2_grf (g, gravbar, phi, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi 
  j = phi * pot_grf (g, gravbar, psi) 
end function s2_grf
@
<<Implementation of bispinor currents>>=
pure function s2_fgr (g, psibar, phi, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav 
  j = phi * pot_fgr (g, psibar, grav) 
end function s2_fgr
@
<<Implementation of bispinor currents>>=
pure function sv1_grf (g, gravbar, v, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  j = g * grg5vgf (gravbar, psi, v)
end function sv1_grf
@
<<Implementation of bispinor currents>>=
pure function slv1_grf (gl, gravbar, v, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l
  type(vector), intent(in) :: v
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  j = gl * grg5vgf (gravbar, psi_l, v)
end function slv1_grf
@
<<Implementation of bispinor currents>>=
pure function srv1_grf (gr, gravbar, v, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  type(vector), intent(in) :: v
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = gr * grg5vgf (gravbar, psi_r, v)
end function srv1_grf
@
<<Implementation of bispinor currents>>=
pure function slrv1_grf (gl, gr, gravbar, v, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l, psi_r
  type(vector), intent(in) :: v
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = gl * grg5vgf (gravbar, psi_l, v) + gr * grg5vgf (gravbar, psi_r, v)
end function slrv1_grf
@ 
\begin{subequations}
\begin{align}
  C \gamma^0 \gamma^0 = - C \gamma^1 \gamma^1 = - C \gamma^2 \gamma^2
  = C \gamma^3 \gamma^3 = C &= \begin{pmatrix}
  0 & 1 & 0 & 0 \\ -1 & 0 & 0 & 0 \\ 0 & 0 & 0 & -1 \\ 0 & 0 & 1 & 0 
  \end{pmatrix} \\
  C \gamma^0 \gamma^1 = - C \gamma^1 \gamma^0 &= \begin{pmatrix}
  -1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & -1 & 0 \\ 0 & 0 & 0 & 1 
  \end{pmatrix} \\
  C \gamma^0 \gamma^2 = - C \gamma^2 \gamma^0 &= \begin{pmatrix}
  -\ii & 0 & 0 & 0 \\ 0 & -\ii & 0 & 0 \\ 0 & 0 & -\ii & 0 \\ 0 & 0 &
  0 & -\ii \end{pmatrix} \\
  C \gamma^0 \gamma^3 = - C \gamma^3 \gamma^0 &= \begin{pmatrix}
  0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0
  \end{pmatrix} \\
  C \gamma^1 \gamma^2 = - C \gamma^2 \gamma^1 &= \begin{pmatrix}
  0 & \ii & 0 & 0 \\ \ii & 0 & 0 & 0 \\ 0 & 0 & 0 & -\ii \\ 0 & 0 &
  -\ii & 0 \end{pmatrix} \\
  C \gamma^1 \gamma^3 = - C \gamma^3 \gamma^1 &= \begin{pmatrix}
  -1 & 0 & 0 & 0 \\ 0 & -1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 
  \end{pmatrix} \\
  C \gamma^2 \gamma^3 = - C \gamma^3 \gamma^2 &= \begin{pmatrix}
  -\ii & 0 & 0 & 0 \\ 0 & \ii & 0 & 0 \\ 0 & 0 & \ii & 0 \\ 0 & 0 & 0
  & -\ii \end{pmatrix} 
\end{align}
\end{subequations}
@
<<Implementation of bispinor currents>>=
pure function sv2_grf (g, gravbar, phi, psi) result (j) 
  type(vector) :: j 
  complex(kind=default), intent(in) :: g, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vectorspinor) :: g0_psi, g1_psi, g2_psi, g3_psi
  g0_psi%psi(1)%a(1:2) = - psi%a(1:2) 
  g0_psi%psi(1)%a(3:4) = psi%a(3:4) 
  g0_psi%psi(2)%a(1) = psi%a(2)
  g0_psi%psi(2)%a(2) = psi%a(1)
  g0_psi%psi(2)%a(3) = psi%a(4)
  g0_psi%psi(2)%a(4) = psi%a(3)
  g0_psi%psi(3)%a(1) = (0,-1) * psi%a(2) 
  g0_psi%psi(3)%a(2) = (0,1) * psi%a(1)
  g0_psi%psi(3)%a(3) = (0,-1) * psi%a(4)
  g0_psi%psi(3)%a(4) = (0,1) * psi%a(3)
  g0_psi%psi(4)%a(1) = psi%a(1)
  g0_psi%psi(4)%a(2) = - psi%a(2) 
  g0_psi%psi(4)%a(3) = psi%a(3)
  g0_psi%psi(4)%a(4) = - psi%a(4) 
  g1_psi%psi(1)%a(1:4) = - g0_psi%psi(2)%a(1:4)
  g1_psi%psi(2)%a(1:4) = - g0_psi%psi(1)%a(1:4)
  g1_psi%psi(3)%a(1) = (0,1) * psi%a(1)
  g1_psi%psi(3)%a(2) = (0,-1) * psi%a(2)
  g1_psi%psi(3)%a(3) = (0,-1) * psi%a(3)
  g1_psi%psi(3)%a(4) = (0,1) * psi%a(4) 
  g1_psi%psi(4)%a(1) = - psi%a(2)
  g1_psi%psi(4)%a(2) = psi%a(1)
  g1_psi%psi(4)%a(3) = psi%a(4)
  g1_psi%psi(4)%a(4) = - psi%a(3) 
  g2_psi%psi(1)%a(1:4) = - g0_psi%psi(3)%a(1:4)
  g2_psi%psi(2)%a(1:4) = - g1_psi%psi(3)%a(1:4)
  g2_psi%psi(3)%a(1:4) = - g0_psi%psi(1)%a(1:4)
  g2_psi%psi(4)%a(1) = (0,1) * psi%a(2)  
  g2_psi%psi(4)%a(2) = (0,1) * psi%a(1)
  g2_psi%psi(4)%a(3) = (0,-1) * psi%a(4)
  g2_psi%psi(4)%a(4) = (0,-1) * psi%a(3) 
  g3_psi%psi(1)%a(1:4) = - g0_psi%psi(4)%a(1:4)
  g3_psi%psi(2)%a(1:4) = - g1_psi%psi(4)%a(1:4)
  g3_psi%psi(3)%a(1:4) = - g2_psi%psi(4)%a(1:4)
  g3_psi%psi(4)%a(1:4) = - g0_psi%psi(1)%a(1:4) 
  j%t    =   (g * phi) * (gravbar * g0_psi) 
  j%x(1) =   (g * phi) * (gravbar * g1_psi)
  j%x(2) =   (g * phi) * (gravbar * g2_psi)
  j%x(3) =   (g * phi) * (gravbar * g3_psi) 
end function sv2_grf
@
<<Implementation of bispinor currents>>=
pure function slv2_grf (gl, gravbar, phi, psi) result (j) 
  type(vector) :: j 
  complex(kind=default), intent(in) :: gl, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  j = sv2_grf (gl, gravbar, phi, psi_l)
end function slv2_grf
@
<<Implementation of bispinor currents>>=
pure function srv2_grf (gr, gravbar, phi, psi) result (j) 
  type(vector) :: j 
  complex(kind=default), intent(in) :: gr, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_r
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = sv2_grf (gr, gravbar, phi, psi_r)
end function srv2_grf
@
<<Implementation of bispinor currents>>=
pure function slrv2_grf (gl, gr, gravbar, phi, psi) result (j) 
  type(vector) :: j 
  complex(kind=default), intent(in) :: gl, gr, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l, psi_r
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = sv2_grf (gl, gravbar, phi, psi_l) + sv2_grf (gr, gravbar, phi, psi_r)
end function slrv2_grf
@
<<Implementation of bispinor currents>>=
pure function sv1_fgr (g, psibar, v, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  j = g * fg5gkgr (psibar, grav, v) 
end function sv1_fgr
@
<<Implementation of bispinor currents>>=
pure function slv1_fgr (gl, psibar, v, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  j = gl * fg5gkgr (psibar_l, grav, v) 
end function slv1_fgr
@
<<Implementation of bispinor currents>>=
pure function srv1_fgr (gr, psibar, v, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gr
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_r
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = gr * fg5gkgr (psibar_r, grav, v) 
end function srv1_fgr
@
<<Implementation of bispinor currents>>=
pure function slrv1_fgr (gl, gr, psibar, v, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l, psibar_r
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = gl * fg5gkgr (psibar_l, grav, v)  + gr * fg5gkgr (psibar_r, grav, v) 
end function slrv1_fgr
@ 
<<Implementation of bispinor currents>>=
pure function sv2_fgr (g, psibar, phi, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g, phi
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(bispinor) :: g0_grav, g1_grav, g2_grav, g3_grav
  g0_grav%a(1) = -grav%psi(1)%a(1) +  grav%psi(2)%a(2) - &
                (0,1) * grav%psi(3)%a(2) + grav%psi(4)%a(1)
  g0_grav%a(2) = -grav%psi(1)%a(2) + grav%psi(2)%a(1) + &
                (0,1) * grav%psi(3)%a(1) - grav%psi(4)%a(2)
  g0_grav%a(3) = grav%psi(1)%a(3) + grav%psi(2)%a(4) - &
                (0,1) * grav%psi(3)%a(4) + grav%psi(4)%a(3)
  g0_grav%a(4) = grav%psi(1)%a(4) + grav%psi(2)%a(3) + &
                (0,1) * grav%psi(3)%a(3) - grav%psi(4)%a(4)
  !!!
  g1_grav%a(1) = grav%psi(1)%a(2) - grav%psi(2)%a(1) + & 
                (0,1) * grav%psi(3)%a(1) - grav%psi(4)%a(2) 
  g1_grav%a(2) = grav%psi(1)%a(1) - grav%psi(2)%a(2) - &
                (0,1) * grav%psi(3)%a(2) + grav%psi(4)%a(1)
  g1_grav%a(3) = grav%psi(1)%a(4) + grav%psi(2)%a(3) - &
                (0,1) * grav%psi(3)%a(3) + grav%psi(4)%a(4)
  g1_grav%a(4) = grav%psi(1)%a(3) + grav%psi(2)%a(4) + &
                (0,1) * grav%psi(3)%a(4) - grav%psi(4)%a(3)
  !!!
  g2_grav%a(1) = (0,1) * (-grav%psi(1)%a(2) - grav%psi(2)%a(1) + &
                grav%psi(4)%a(2)) - grav%psi(3)%a(1)
  g2_grav%a(2) = (0,1) * (grav%psi(1)%a(1) + grav%psi(2)%a(2) + &
                grav%psi(4)%a(1)) - grav%psi(3)%a(2)
  g2_grav%a(3) = (0,1) * (-grav%psi(1)%a(4) + grav%psi(2)%a(3) - & 
                grav%psi(4)%a(4)) + grav%psi(3)%a(3)
  g2_grav%a(4) = (0,1) * (grav%psi(1)%a(3) - grav%psi(2)%a(4) - &
                grav%psi(4)%a(3)) + grav%psi(3)%a(4)  
  !!!
  g3_grav%a(1) = -grav%psi(1)%a(2) + grav%psi(2)%a(2) - &
                (0,1) * grav%psi(3)%a(2) - grav%psi(4)%a(1)
  g3_grav%a(2) = grav%psi(1)%a(1) - grav%psi(2)%a(1) - &
                (0,1) * grav%psi(3)%a(1) - grav%psi(4)%a(2)
  g3_grav%a(3) = -grav%psi(1)%a(2) - grav%psi(2)%a(4) + &
                (0,1) * grav%psi(3)%a(4) + grav%psi(4)%a(3)
  g3_grav%a(4) = -grav%psi(1)%a(4) + grav%psi(2)%a(3) + &
                (0,1) * grav%psi(3)%a(3) + grav%psi(4)%a(4)
  j%t    =   (g * phi) * (psibar * g0_grav)
  j%x(1) =   (g * phi) * (psibar * g1_grav)
  j%x(2) =   (g * phi) * (psibar * g2_grav)
  j%x(3) =   (g * phi) * (psibar * g3_grav)
end function sv2_fgr
@ 
<<Implementation of bispinor currents>>=
pure function slv2_fgr (gl, psibar, phi, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, phi
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l
  type(vectorspinor), intent(in) :: grav
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  j = sv2_fgr (gl, psibar_l, phi, grav)
end function slv2_fgr
@ 
<<Implementation of bispinor currents>>=
pure function srv2_fgr (gr, psibar, phi, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gr, phi
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_r
  type(vectorspinor), intent(in) :: grav
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = sv2_fgr (gr, psibar_r, phi, grav)
end function srv2_fgr
@ 
<<Implementation of bispinor currents>>=
pure function slrv2_fgr (gl, gr, psibar, phi, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr, phi
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l, psibar_r
  type(vectorspinor), intent(in) :: grav
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = sv2_fgr (gl, psibar_l, phi, grav) + sv2_fgr (gr, psibar_r, phi, grav)
end function slrv2_fgr
@
<<Implementation of bispinor currents>>=
pure function pv1_grf (g, gravbar, v, psi) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  j = g * grvgf (gravbar, psi, v)
end function pv1_grf 
@
<<Implementation of bispinor currents>>=
pure function pv2_grf (g, gravbar, phi, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g, phi
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: g5_psi
  g5_psi%a(1:2) = - psi%a(1:2)
  g5_psi%a(3:4) = psi%a(3:4)
  j = sv2_grf (g, gravbar, phi, g5_psi)
end function pv2_grf
@
<<Implementation of bispinor currents>>=
pure function pv1_fgr (g, psibar, v, grav) result (j)
  complex(kind=default) :: j
  complex(kind=default), intent(in) :: g
  type(bispinor), intent(in) :: psibar
  type(vectorspinor), intent(in) :: grav
  type(vector), intent(in) :: v
  j = g * fgkgr (psibar, grav, v) 
end function pv1_fgr
@ 
<<Implementation of bispinor currents>>=
pure function pv2_fgr (g, psibar, phi, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g, phi
  type(vectorspinor), intent(in) :: grav
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_g5
  psibar_g5%a(1:2) = - psibar%a(1:2)
  psibar_g5%a(3:4) = psibar%a(3:4)
  j = sv2_fgr (g, psibar_g5, phi, grav)
end function pv2_fgr 
@ 
<<Implementation of bispinor currents>>=
pure function v2_grf (g, gravbar, v, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(vector), intent(in) :: v
  j = -g * grkgggf (gravbar, psi, v) 
end function v2_grf 
@ 
<<Implementation of bispinor currents>>=
pure function v2lr_grf (gl, gr, gravbar, v, psi) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: gravbar
  type(bispinor), intent(in) :: psi
  type(bispinor) :: psi_l, psi_r
  type(vector), intent(in) :: v
  psi_l%a(1:2) = psi%a(1:2)
  psi_l%a(3:4) = 0
  psi_r%a(1:2) = 0
  psi_r%a(3:4) = psi%a(3:4)
  j = -(gl * grkgggf (gravbar, psi_l, v) + gr * grkgggf (gravbar, psi_r, v))
end function v2lr_grf 
@ 
<<Implementation of bispinor currents>>=
pure function v2_fgr (g, psibar, v, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: g
  type(vectorspinor), intent(in) :: grav
  type(bispinor), intent(in) :: psibar
  type(vector), intent(in) :: v
  j = -g * fggkggr (psibar, grav, v) 
end function v2_fgr
@ 
<<Implementation of bispinor currents>>=
pure function v2lr_fgr (gl, gr, psibar, v, grav) result (j)
  type(vector) :: j
  complex(kind=default), intent(in) :: gl, gr
  type(vectorspinor), intent(in) :: grav
  type(bispinor), intent(in) :: psibar
  type(bispinor) :: psibar_l, psibar_r
  type(vector), intent(in) :: v
  psibar_l%a(1:2) = psibar%a(1:2)
  psibar_l%a(3:4) = 0
  psibar_r%a(1:2) = 0
  psibar_r%a(3:4) = psibar%a(3:4)
  j = -(gl * fggkggr (psibar_l, grav, v) + gr * fggkggr (psibar_r, grav, v))
end function v2lr_fgr
@ \subsection{On Shell Wave Functions}
<<Declaration of bispinor on shell wave functions>>=
public :: u, v, ghost       
@
\begin{subequations}
\begin{align}
  \chi_+(\vec p) &=
     \frac{1}{\sqrt{2|\vec p|(|\vec p|+p_3)}}
     \begin{pmatrix} |\vec p|+p_3 \\ p_1 + \ii p_2 \end{pmatrix} \\
  \chi_-(\vec p) &=
     \frac{1}{\sqrt{2|\vec p|(|\vec p|+p_3)}}
     \begin{pmatrix} - p_1 + \ii p_2 \\ |\vec p|+p_3 \end{pmatrix}
\end{align}
\end{subequations}
@
\begin{equation}
  u_\pm(p) =
     \begin{pmatrix}
       \sqrt{p_0\mp|\vec p|} \cdot \chi_\pm(\vec p) \\
       \sqrt{p_0\pm|\vec p|} \cdot \chi_\pm(\vec p)
     \end{pmatrix}
\end{equation}    
<<Implementation of bispinor on shell wave functions>>=
pure function u (mass, p, s) result (psi)
  type(bispinor) :: psi
  real(kind=default), intent(in) :: mass
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  complex(kind=default), dimension(2) :: chip, chim
  real(kind=default) :: pabs, norm, delta, m
  m = abs(mass)
  pabs = sqrt (dot_product (p%x, p%x))
  if (m < epsilon (m) * pabs) then
      delta = 0	
  else
      delta = sqrt (max (p%t - pabs, 0._default))
  end if
  if (pabs + p%x(3) <= 1000 * epsilon (pabs) * pabs) then
     chip = (/ cmplx ( 0.0, 0.0, kind=default), &
               cmplx ( 1.0, 0.0, kind=default) /)
     chim = (/ cmplx (-1.0, 0.0, kind=default), &
               cmplx ( 0.0, 0.0, kind=default) /)
  else
     norm = 1 / sqrt (2*pabs*(pabs + p%x(3)))
     chip = norm * (/ cmplx (pabs + p%x(3), kind=default), &
                      cmplx (p%x(1), p%x(2), kind=default) /)
     chim = norm * (/ cmplx (-p%x(1), p%x(2), kind=default), &
                      cmplx (pabs + p%x(3), kind=default) /)
  end if
  if (s > 0) then
     psi%a(1:2) = delta * chip
     psi%a(3:4) = sqrt (p%t + pabs) * chip
  else
     psi%a(1:2) = sqrt (p%t + pabs) * chim
     psi%a(3:4) = delta * chim
  end if
  pabs = m ! make the compiler happy and use m
  if (mass < 0) then
     psi%a(1:2) = - imago * psi%a(1:2)
     psi%a(3:4) = + imago * psi%a(3:4)
  end if
end function u
@
\begin{equation}
  v_\pm(p) =
     \begin{pmatrix}
       \mp\sqrt{p_0\pm|\vec p|} \cdot \chi_\mp(\vec p) \\
       \pm\sqrt{p_0\mp|\vec p|} \cdot \chi_\mp(\vec p)
     \end{pmatrix}
\end{equation}     
<<Implementation of bispinor on shell wave functions>>=
pure function v (mass, p, s) result (psi)
  type(bispinor) :: psi
  real(kind=default), intent(in) :: mass
  type(momentum), intent(in) :: p
  integer, intent(in) :: s
  complex(kind=default), dimension(2) :: chip, chim
  real(kind=default) :: pabs, norm, delta, m
  pabs = sqrt (dot_product (p%x, p%x))
  m = abs(mass)
  if (m < epsilon (m) * pabs) then
      delta = 0	
  else
      delta = sqrt (max (p%t - pabs, 0._default))
  end if
  if (pabs + p%x(3) <= 1000 * epsilon (pabs) * pabs) then
     chip = (/ cmplx ( 0.0, 0.0, kind=default), &
               cmplx ( 1.0, 0.0, kind=default) /)
     chim = (/ cmplx (-1.0, 0.0, kind=default), &
               cmplx ( 0.0, 0.0, kind=default) /)
  else
     norm = 1 / sqrt (2*pabs*(pabs + p%x(3)))
     chip = norm * (/ cmplx (pabs + p%x(3), kind=default), &
                      cmplx (p%x(1), p%x(2), kind=default) /)
     chim = norm * (/ cmplx (-p%x(1), p%x(2), kind=default), &
                      cmplx (pabs + p%x(3), kind=default) /)
  end if
  if (s > 0) then
     psi%a(1:2) = - sqrt (p%t + pabs) * chim
     psi%a(3:4) = delta * chim
  else
     psi%a(1:2) = delta * chip
     psi%a(3:4) = - sqrt (p%t + pabs) * chip
  end if
  pabs = m ! make the compiler happy and use m
  if (mass < 0) then
     psi%a(1:2) = - imago * psi%a(1:2)
     psi%a(3:4) = + imago * psi%a(3:4)
  end if 
end function v
@ 
<<Implementation of bispinor on shell wave functions>>=
pure function ghost (m, p, s) result (psi) 
    type(bispinor) :: psi
    real(kind=default), intent(in) :: m 
    type(momentum), intent(in) :: p 
    integer, intent(in) :: s    
    psi%a(:) = 0
    select case (s)
    case (1)
	psi%a(1)   = 1
	psi%a(2:4) = 0 
    case (2)
	psi%a(1)   = 0
	psi%a(2)   = 1
	psi%a(3:4) = 0
    case (3)
	psi%a(1:2) = 0
	psi%a(3)   = 1
	psi%a(4)   = 0   
    case (4) 
	psi%a(1:3) = 0
	psi%a(4)   = 1	
    case (5)
	psi%a(1) =    1.4
	psi%a(2) = -  2.3
	psi%a(3) = - 71.5
	psi%a(4) =    0.1
    end select 
end function ghost
@
 \subsection{Off Shell Wave Functions}
This is the same as for the Dirac fermions except that the expressions for 
[ubar] and [vbar] are missing. 
<<Declaration of bispinor off shell wave functions>>=
public :: brs_u, brs_v
@ 
In momentum space we have:
\begin{equation}
brs u(p)=(-i) (\fmslash p-m)u(p)
\end{equation}
<<Implementation of bispinor off shell wave functions>>=
pure function brs_u (m, p, s) result (dpsi)
    type(bispinor) :: dpsi, psi
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) :: s
    type (vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
    vp=p
    psi=u(m,p,s)
    dpsi=cmplx(0.0,-1.0)*(f_vf(one,vp,psi)-m*psi)
end function brs_u
@
\begin{equation}
brs v(p)=i (\fmslash p+m)v(p)
\end{equation}
<<Implementation of bispinor off shell wave functions>>=
pure function brs_v (m, p, s) result (dpsi)
    type(bispinor) :: dpsi, psi
    real(kind=default), intent(in) :: m
    type(momentum), intent(in) :: p
    integer, intent(in) ::   s
    type (vector)::vp
    complex(kind=default), parameter :: one = (1, 0)
    vp=p
    psi=v(m,p,s)
    dpsi=cmplx(0.0,1.0)*(f_vf(one,vp,psi)+m*psi)
end function brs_v
@ \subsection{Propagators}
<<Declaration of bispinor propagators>>=
public :: pr_psi, pr_grav 
public :: pj_psi, pg_psi
@                                                   
\begin{equation}
   \frac{\ii(-\fmslash{p}+m)}{p^2-m^2+\ii m\Gamma}\psi
\end{equation}
NB: the sign of the momentum comes about because all momenta are
treated as \emph{outgoing} and the particle charge flow is therefore
opposite to the momentum.
<<Implementation of bispinor propagators>>=
pure function pr_psi (p, m, w, psi) result (ppsi)
  type(bispinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(bispinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = (1 / cmplx (p*p - m**2, m*w, kind=default)) &
       * (- f_vf (one, vp, psi) + m * psi)  
end function pr_psi
@                                                   
\begin{equation}
  \sqrt{\frac{\pi}{M\Gamma}}
    (-\fmslash{p}+m)\psi
\end{equation}
<<Implementation of bispinor propagators>>=
pure function pj_psi (p, m, w, psi) result (ppsi)
  type(bispinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(bispinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = (0, -1) * sqrt (PI / m / w) * (- f_vf (one, vp, psi) + m * psi)  
end function pj_psi
@ 
<<Implementation of bispinor propagators>>=
pure function pg_psi (p, m, w, psi) result (ppsi)
  type(bispinor) :: ppsi
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(bispinor), intent(in) :: psi
  type(vector) :: vp
  complex(kind=default), parameter :: one = (1, 0)
  vp = p
  ppsi = gauss (p*p, m, w) * (- f_vf (one, vp, psi) + m * psi)  
end function pg_psi
@ 
\begin{equation}
 \dfrac{\ii\biggl\{(-\fmslash{p} + m)\left(-\eta_{\mu\nu} + \dfrac{p_\mu
 p_\nu}{m^2}\right) + \dfrac{1}{3} \left(\gamma_\mu -\dfrac{p_\mu}{m}\right)
 (\fmslash{p} + m)\left(\gamma_\nu -
 \dfrac{p_\nu}{m}\right)\biggr\}}{p^2 - m^2  + \ii m
 \Gamma} \; \psi^\nu
\end{equation}
<<Implementation of bispinor propagators>>=
pure function pr_grav (p, m, w, grav) result (propgrav)
  type(vectorspinor) :: propgrav
  type(momentum), intent(in) :: p
  real(kind=default), intent(in) :: m, w
  type(vectorspinor), intent(in) :: grav
  type(vector) :: vp
  type(bispinor) :: pgrav, ggrav, ggrav1, ggrav2, ppgrav
  type(vectorspinor) :: etagrav_dum, etagrav, pppgrav, &
                        gg_grav_dum, gg_grav
  complex(kind=default), parameter :: one = (1, 0)
  real(kind=default) :: minv
  integer :: i 
  vp = p
  minv = 1/m
  pgrav = p%t    * grav%psi(1) - p%x(1) * grav%psi(2) - &
          p%x(2) * grav%psi(3) - p%x(3) * grav%psi(4)
  ggrav%a(1) = grav%psi(1)%a(3) - grav%psi(2)%a(4) + (0,1) * &
               grav%psi(3)%a(4) - grav%psi(4)%a(3)
  ggrav%a(2) = grav%psi(1)%a(4) - grav%psi(2)%a(3) - (0,1) * &
               grav%psi(3)%a(3) + grav%psi(4)%a(4)
  ggrav%a(3) = grav%psi(1)%a(1) + grav%psi(2)%a(2) - (0,1) * &
               grav%psi(3)%a(2) + grav%psi(4)%a(1)
  ggrav%a(4) = grav%psi(1)%a(2) + grav%psi(2)%a(1) + (0,1) * &
               grav%psi(3)%a(1) - grav%psi(4)%a(2)
  ggrav1 = ggrav - minv * pgrav 
  ggrav2 = f_vf (one, vp, ggrav1) + m * ggrav - pgrav
  ppgrav = (-minv**2) * f_vf (one, vp, pgrav) + minv * pgrav
  do i = 1, 4
  etagrav_dum%psi(i) = f_vf (one, vp, grav%psi(i))
  end do 
  etagrav = etagrav_dum - m * grav
  pppgrav%psi(1) = p%t    * ppgrav
  pppgrav%psi(2) = p%x(1) * ppgrav
  pppgrav%psi(3) = p%x(2) * ppgrav
  pppgrav%psi(4) = p%x(3) * ppgrav
  gg_grav_dum%psi(1) = p%t    * ggrav2
  gg_grav_dum%psi(2) = p%x(1) * ggrav2
  gg_grav_dum%psi(3) = p%x(2) * ggrav2
  gg_grav_dum%psi(4) = p%x(3) * ggrav2
  gg_grav = gr_potf (one, one, ggrav2) - minv * gg_grav_dum  
  propgrav = (1 / cmplx (p*p - m**2, m*w, kind=default)) * &
       (etagrav + pppgrav + (1/3.0_default) * gg_grav)
end function pr_grav
@
\section{Polarization vectorspinors}
Here we construct the wavefunctions for (massive) gravitinos out of
the wavefunctions of (massive) vectorbosons and (massive) Majorana
fermions. 
\begin{subequations}
\begin{align}
\psi^\mu_{(u; 3/2)} (k) &= \; \epsilon^\mu_+ (k) \cdot u (k, +) \\
\psi^\mu_{(u; 1/2)} (k) &= \; \sqrt{\dfrac{1}{3}} \, \epsilon^\mu_+ (k) 
	\cdot u (k, -) + \sqrt{\dfrac{2}{3}} \, \epsilon^\mu_0 (k) \cdot
	u (k, +) \\
\psi^\mu_{(u; -1/2)} (k) &= \; \sqrt{\dfrac{2}{3}} \, \epsilon^\mu_0 (k)
	\cdot u (k, -) + \sqrt{\dfrac{1}{3}} \, \epsilon^\mu_- (k) \cdot
	u (k, +) \\
\psi^\mu_{(u; -3/2)} (k) &= \; \epsilon^\mu_- (k) \cdot u (k, -)
\end{align}
\end{subequations}
and in the same manner for $\psi^\mu_{(v; s)}$ with $u$ replaced by
$v$ and with the conjugated polarization vectors. These gravitino 
wavefunctions obey the Dirac equation, they are transverse and they
fulfill the irreducibility condition
\begin{equation}
	\gamma_\mu \psi^\mu_{(u/v; s)} = 0 .
\end{equation}
<<[[omega_vspinor_polarizations.f90]]>>=
<<Copyleft>>
module omega_vspinor_polarizations
  use kinds
  use constants
  use omega_vectors
  use omega_bispinors
  use omega_bispinor_couplings
  use omega_vectorspinors
  implicit none
  <<Declaration of polarization vectorspinors>>
  integer, parameter, public :: omega_vspinor_pols_2010_01_A = 0
contains
  <<Implementation of polarization vectorspinors>>
end module omega_vspinor_polarizations
@
<<Declaration of polarization vectorspinors>>=
public :: ueps, veps
private :: eps
private :: outer_product  
@ 
Here we implement the polarization vectors for vectorbosons with 
trigonometric functions, without the rotating of components done in 
HELAS~\cite{HELAS}. These are only used for generating the
polarization vectorspinors.
\begin{subequations}
\begin{align}
  \epsilon^\mu_+(k) &=
     \frac{- e^{+\ii\phi}}{\sqrt{2}}
        \left(0; \cos\theta\cos\phi - \ii\sin\phi,
                 \cos\theta\sin\phi + \ii\cos\phi,
                 -\sin\theta \right)  \\ 
  \epsilon^\mu_-(k) &=
     \frac{e^{-\ii\phi}}{\sqrt{2}}
        \left(0; \cos\theta\cos\phi + \ii \sin\phi, 
                 \cos\theta\sin\phi - \ii \cos\phi,
                 - \sin\theta \right) \\
  \epsilon^\mu_0(k) &= 
     \frac{1}{m} \left(|\vec k|; k^0\sin\theta\cos\phi, 
			         k^0\sin\theta\sin\phi, 
				 k^0\cos\theta\right)
\end{align}
\end{subequations}
Determining the mass from the momenta is a numerically haphazardous for
light particles.  Therefore, we accept some redundancy and pass the
mass explicitely. For the case that the momentum lies totally in the 
$z$-direction we take the convention $\cos\phi=1$ and $\sin\phi=0$.
<<Implementation of polarization vectorspinors>>=
pure function eps (mass, k, s) result (e)
  type(vector) :: e
  real(kind=default), intent(in) :: mass
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  real(kind=default) :: kabs, kabs2, sqrt2, m
  real(kind=default) :: cos_phi, sin_phi, cos_th, sin_th
  complex(kind=default) :: epiphi, emiphi
  sqrt2 = sqrt (2.0_default)
  kabs2 = dot_product (k%x, k%x)
  m = abs(mass)
  if (kabs2 > 0) then
     kabs = sqrt (kabs2)
     if ((k%x(1) == 0) .and. (k%x(2) == 0)) then
        cos_phi = 1
        sin_phi = 0
     else 
        cos_phi = k%x(1) / sqrt(k%x(1)**2 + k%x(2)**2)
        sin_phi = k%x(2) / sqrt(k%x(1)**2 + k%x(2)**2)
     end if
     cos_th = k%x(3) / kabs
     sin_th = sqrt(1 - cos_th**2)
     epiphi = cos_phi + (0,1) * sin_phi
     emiphi = cos_phi - (0,1) * sin_phi
     e%t = 0
     e%x = 0
     select case (s)
     case (1)
        e%x(1) = epiphi * (-cos_th * cos_phi + (0,1) * sin_phi) / sqrt2
        e%x(2) = epiphi * (-cos_th * sin_phi - (0,1) * cos_phi) / sqrt2
        e%x(3) = epiphi * ( sin_th / sqrt2)
     case (-1)
        e%x(1) = emiphi * ( cos_th * cos_phi + (0,1) * sin_phi) / sqrt2
        e%x(2) = emiphi * ( cos_th * sin_phi - (0,1) * cos_phi) / sqrt2 
        e%x(3) = emiphi * (-sin_th / sqrt2)
     case (0)
        if (m > 0) then
           e%t = kabs / m
           e%x = k%t / (m*kabs) * k%x 
        end if
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  else   !!! for particles in their rest frame defined to be
         !!! polarized along the 3-direction
     e%t = 0
     e%x = 0
     select case (s)
     case (1)
        e%x(1) = cmplx ( - 1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0,   1, kind=default) / sqrt2
     case (-1)
        e%x(1) = cmplx (   1,   0, kind=default) / sqrt2
        e%x(2) = cmplx (   0,   1, kind=default) / sqrt2
     case (0)
        if (m > 0) then
           e%x(3) = 1
        end if
     case (4)
        if (m > 0) then
           e = (1 / m) * k
        else
           e = (1 / k%t) * k
        end if
     end select
  end if
end function eps
@ 
<<Implementation of polarization vectorspinors>>=
pure function ueps (m, k, s) result (t)
  type(vectorspinor) :: t
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  integer :: i
  type(vector) :: ep, e0, em
  type(bispinor) :: up, um
  do i = 1, 4
    t%psi(i)%a = 0 
  end do
  select case (s)
  case (2)
     ep = eps (m, k, 1)
     up = u (m, k, 1)
     t = outer_product (ep, up)
  case (1)
     ep = eps (m, k, 1)
     e0 = eps (m, k, 0)
     up = u (m, k, 1)
     um = u (m, k, -1)
     t = (1 / sqrt (3.0_default)) * (outer_product (ep, um) & 
          + sqrt (2.0_default) * outer_product (e0, up)) 
  case (-1)
     e0 = eps (m, k, 0)
     em = eps (m, k, -1)
     up = u (m, k, 1)
     um = u (m, k, -1)
     t = (1 / sqrt (3.0_default)) * (sqrt (2.0_default) * &
          outer_product (e0, um) + outer_product (em, up)) 
  case (-2)
     em = eps (m, k, -1)
     um = u (m, k, -1)
     t = outer_product (em, um)
  end select
end function ueps 
@
<<Implementation of polarization vectorspinors>>=
pure function veps (m, k, s) result (t)
  type(vectorspinor) :: t
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  integer, intent(in) :: s
  integer :: i
  type(vector) :: ep, e0, em
  type(bispinor) :: vp, vm
  do i = 1, 4
    t%psi(i)%a = 0 
  end do
  select case (s)
  case (2)
     ep = conjg(eps (m, k, 1))
     vp = v (m, k, 1)
     t = outer_product (ep, vp)
  case (1)
     ep = conjg(eps (m, k, 1))
     e0 = conjg(eps (m, k, 0))
     vp = v (m, k, 1)
     vm = v (m, k, -1)
     t = (1 / sqrt (3.0_default)) * (outer_product (ep, vm) &
          + sqrt (2.0_default) * outer_product (e0, vp))
  case (-1)
     e0 = conjg(eps (m, k,  0))
     em = conjg(eps (m, k, -1))
     vp = v (m, k, 1)
     vm = v (m, k, -1)
     t = (1 / sqrt (3.0_default)) * (sqrt (2.0_default) &
          * outer_product (e0, vm) + outer_product (em, vp))
  case (-2)
     em = conjg(eps (m, k, -1))
     vm = v (m, k, -1)
     t = outer_product (em, vm)
  end select
end function veps 
@ 
<<Implementation of polarization vectorspinors>>=
pure function outer_product (ve, sp) result (vs)
  type(vectorspinor) :: vs
  type(vector), intent(in) :: ve
  type(bispinor), intent(in) :: sp
  integer :: i
  vs%psi(1)%a(1:4) = ve%t * sp%a(1:4)
  do i = 1, 3
     vs%psi((i+1))%a(1:4) = ve%x(i) * sp%a(1:4)
  end do
end function outer_product
@ \section{Color}
<<[[omega_color.f90]]>>=
<<Copyleft>>
module omega_color
  use kinds
  implicit none
  private
  <<Declaration of color types>>
  <<Declaration of color functions>>
  integer, parameter, public :: omega_color_2010_01_A = 0
contains
  <<Implementation of color functions>>
end module omega_color
@ \subsection{Color Sum}
<<Declaration of color types>>=
public :: omega_color_factor
type omega_color_factor
   integer :: i1, i2
   complex(kind=default) :: factor
end type omega_color_factor
@
<<Declaration of color functions>>=
public :: omega_color_sum
@ 
<<Implementation of color functions>>=
pure function omega_color_sum (flv, hel, amp, cf) result (amp2)
  complex(kind=default) :: amp2
  integer, intent(in) :: flv, hel
  complex(kind=default), dimension(:,:,:), intent(in) :: amp
  type(omega_color_factor), dimension(:), intent(in) :: cf
  integer :: n
  amp2 = 0
  do n = 1, size (cf)
     amp2 = amp2 &
          + cf(n)%factor * amp(flv,cf(n)%i1,hel) * conjg (amp(flv,cf(n)%i2,hel))
  end do
end function omega_color_sum
@ \section{Utilities}
<<[[omega_utils.f90]]>>=
<<Copyleft>>
module omega_utils
  use kinds
  use omega_vectors
  use omega_polarizations
  implicit none
  private
  <<Declaration of utility functions>>
  <<Numerical tolerances>>
  integer, parameter, public :: omega_utils_2010_01_A = 0
contains
  <<Implementation of utility functions>>
end module omega_utils
@ \subsection{Helicity Selection Rule Heuristics}
<<Declaration of utility functions>>=
public :: omega_update_helicity_selection
@ 
<<Implementation of utility functions>>=
pure subroutine omega_update_helicity_selection &
             (count, amp, max_abs, sum_abs, mask, threshold, cutoff, mask_dirty)
  integer, intent(inout) :: count
  complex(kind=default), dimension(:,:,:), intent(in) :: amp
  real(kind=default), dimension(:), intent(inout) :: max_abs
  real(kind=default), intent(inout) :: sum_abs
  logical, dimension(:), intent(inout) :: mask
  real(kind=default), intent(in) :: threshold
  integer, intent(in) :: cutoff
  logical, intent(out) :: mask_dirty
  integer :: h
  real(kind=default) :: avg
  mask_dirty = .false.
  if (threshold > 0) then
     count = count + 1
     if (count <= cutoff) then
        forall (h = lbound (amp, 3) : ubound (amp, 3))
           max_abs(h) = max (max_abs(h), maxval (abs (amp(:,:,h))))
        end forall
        sum_abs = sum_abs + sum (abs (amp))
        if (count == cutoff) then
           avg = sum_abs / size (amp) / cutoff
           mask = max_abs >= threshold * epsilon (avg) * avg
           mask_dirty = .true.
        end if
     end if
  end if
end subroutine omega_update_helicity_selection
@ \subsection{Diagnostics}
<<Declaration of utility functions>>=
public :: omega_report_helicity_selection
@ We shoul try to use [[msg_message]] from WHIZARD's [[diagnostics]] module,
but this would spoil independent builds.
<<Implementation of utility functions>>=
subroutine omega_report_helicity_selection (mask, spin_states, threshold, unit)
  logical, dimension(:), intent(in) :: mask
  integer, dimension(:,:), intent(in) :: spin_states
  real(kind=default), intent(in) :: threshold
  integer, intent(in), optional :: unit
  integer :: u
  integer :: h, i
  if (present(unit)) then
     u = unit
  else
     u = 6
  end if
  if (u >= 0) then
     write (unit = u, &
          fmt = "('| ','Contributing Helicity Combinations: ', I5, ' of ', I5)") &
          count (mask), size (mask)
     write (unit = u, &
          fmt = "('| ','Threshold: amp / avg > ', E9.2, ' = ', E9.2, ' * epsilon()')") &
          threshold * epsilon (threshold), threshold
     i = 0
     do h = 1, size (mask)
        if (mask(h)) then
           i = i + 1
           write (unit = u, fmt = "('| ',I4,': ',20I4)") i, spin_states (:, h)
        end if
     end do
  end if
end subroutine omega_report_helicity_selection
@ 
<<Declaration of utility functions>>=
public :: omega_ward_warn, omega_ward_panic
@ The O'Mega amplitudes have only one particle off shell and are the
sum of \emph{all} possible diagrams with the other particles
on-shell.
\begin{dubious}
  The problem with these gauge checks is that are numerically very
  small amplitudes that vanish analytically and that violate
  transversality.  The hard part is to determine the thresholds that
  make threse tests usable.
\end{dubious}
<<Implementation of utility functions>>=
subroutine omega_ward_warn (name, m, k, e)
  character(len=*), intent(in) :: name
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  type(vector), intent(in) :: e
  type(vector) :: ek
  real(kind=default) :: abs_eke, abs_ek_abs_e
  ek = eps (m, k, 4)
  abs_eke = abs (ek * e)
  abs_ek_abs_e = abs (ek) * abs (e)
  print *, name, ":", abs_eke / abs_ek_abs_e, abs (ek), abs (e)
  if (abs_eke > 1000 * epsilon (abs_ek_abs_e)) then
     print *, "O'Mega: warning: non-transverse vector field: ", &
          name, ":", abs_eke / abs_ek_abs_e, abs (e)
  end if
end subroutine omega_ward_warn
@
<<Implementation of utility functions>>=
subroutine omega_ward_panic (name, m, k, e)
  character(len=*), intent(in) :: name
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  type(vector), intent(in) :: e
  type(vector) :: ek
  real(kind=default) :: abs_eke, abs_ek_abs_e
  ek = eps (m, k, 4)
  abs_eke = abs (ek * e)
  abs_ek_abs_e = abs (ek) * abs (e)
  if (abs_eke > 1000 * epsilon (abs_ek_abs_e)) then
     print *, "O'Mega: panic: non-transverse vector field: ", &
          name, ":", abs_eke / abs_ek_abs_e, abs (e)
     stop
  end if
end subroutine omega_ward_panic
@ 
<<Declaration of utility functions>>=
public :: omega_slavnov_warn, omega_slavnov_panic
@
<<Implementation of utility functions>>=
subroutine omega_slavnov_warn (name, m, k, e, phi)
  character(len=*), intent(in) :: name
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  type(vector), intent(in) :: e
  complex(kind=default), intent(in) :: phi
  type(vector) :: ek
  real(kind=default) :: abs_eke, abs_ek_abs_e
  ek = eps (m, k, 4)
  abs_eke = abs (ek * e - phi)
  abs_ek_abs_e = abs (ek) * abs (e)
  print *, name, ":", abs_eke / abs_ek_abs_e, abs (ek), abs (e)
  if (abs_eke > 1000 * epsilon (abs_ek_abs_e)) then
     print *, "O'Mega: warning: non-transverse vector field: ", &
          name, ":", abs_eke / abs_ek_abs_e, abs (e)
  end if
end subroutine omega_slavnov_warn
@
<<Implementation of utility functions>>=
subroutine omega_slavnov_panic (name, m, k, e, phi)
  character(len=*), intent(in) :: name
  real(kind=default), intent(in) :: m
  type(momentum), intent(in) :: k
  type(vector), intent(in) :: e
  complex(kind=default), intent(in) :: phi
  type(vector) :: ek
  real(kind=default) :: abs_eke, abs_ek_abs_e
  ek = eps (m, k, 4)
  abs_eke = abs (ek * e - phi)
  abs_ek_abs_e = abs (ek) * abs (e)
  if (abs_eke > 1000 * epsilon (abs_ek_abs_e)) then
     print *, "O'Mega: panic: non-transverse vector field: ", &
          name, ":", abs_eke / abs_ek_abs_e, abs (e)
     stop
  end if
end subroutine omega_slavnov_panic
@ 
<<Declaration of utility functions>>=
public :: omega_check_arguments_warn, omega_check_arguments_panic
@
<<Implementation of utility functions>>=
subroutine omega_check_arguments_warn (n, k)
  integer, intent(in) :: n
  real(kind=default), dimension(0:,:), intent(in) :: k
  integer :: i
  i = size(k,dim=1)
  if (i /= 4) then
     print *, "O'Mega: warning: wrong # of dimensions:", i
  end if
  i = size(k,dim=2)
  if (i /= n) then
     print *, "O'Mega: warning: wrong # of momenta:", i, &
          ", expected", n
  end if
end subroutine omega_check_arguments_warn
@
<<Implementation of utility functions>>=
subroutine omega_check_arguments_panic (n, k)
  integer, intent(in) :: n
  real(kind=default), dimension(0:,:), intent(in) :: k
  logical :: error
  integer :: i
  error = .false.
  i = size(k,dim=1)
  if (i /= n) then
     print *, "O'Mega: warning: wrong # of dimensions:", i
     error = .true.
  end if
  i = size(k,dim=2)
  if (i /= n) then
     print *, "O'Mega: warning: wrong # of momenta:", i, &
          ", expected", n
     error = .true.
  end if
  if (error) then
     stop
  end if
end subroutine omega_check_arguments_panic
@
<<Declaration of utility functions>>=
public :: omega_check_helicities_warn, omega_check_helicities_panic
private :: omega_check_helicity
@
<<Implementation of utility functions>>=
function omega_check_helicity (m, smax, s) result (error)
  real(kind=default), intent(in) :: m
  integer, intent(in) :: smax, s
  logical :: error
  select case (smax)
  case (0)
     error = (s /= 0)
  case (1)
     error = (abs (s) /= 1)
  case (2)
     if (m == 0.0_default) then
        error = .not. (abs (s) == 1 .or. abs (s) == 4)
     else
        error = .not. (abs (s) <= 1 .or. abs (s) == 4)
     end if
  case (4)
     error = .true.
  case default
     error = .true.
  end select
end function omega_check_helicity
@
<<Implementation of utility functions>>=
subroutine omega_check_helicities_warn (m, smax, s)
  real(kind=default), dimension(:), intent(in) :: m
  integer, dimension(:), intent(in) :: smax, s
  integer :: i
  do i = 1, size (m)
     if (omega_check_helicity (m(i), smax(i), s(i))) then
        print *, "O'Mega: warning: invalid helicity", s(i)
     end if
  end do
end subroutine omega_check_helicities_warn
@
<<Implementation of utility functions>>=
subroutine omega_check_helicities_panic (m, smax, s)
  real(kind=default), dimension(:), intent(in) :: m
  integer, dimension(:), intent(in) :: smax, s
  logical :: error
  logical :: error1
  integer :: i
  error = .false.
  do i = 1, size (m)
     error1 = omega_check_helicity (m(i), smax(i), s(i))
     if (error1) then
        print *, "O'Mega: panic: invalid helicity", s(i)
        error = .true.
     end if
  end do
  if (error) then
     stop
  end if
end subroutine omega_check_helicities_panic
@
<<Declaration of utility functions>>=
public :: omega_check_momenta_warn, omega_check_momenta_panic
private :: check_momentum_conservation, check_mass_shell
@ 
<<Numerical tolerances>>=
integer, parameter, private :: MOMENTUM_TOLERANCE = 10000
@
<<Implementation of utility functions>>=
function check_momentum_conservation (k) result (error)
  real(kind=default), dimension(0:,:), intent(in) :: k
  logical :: error 
  error = any (abs (sum (k(:,3:), dim = 2) - k(:,1) - k(:,2)) > &
       MOMENTUM_TOLERANCE * epsilon (maxval (abs (k), dim = 2)))
  if (error) then
     print *, sum (k(:,3:), dim = 2) - k(:,1) - k(:,2)
     print *, MOMENTUM_TOLERANCE * epsilon (maxval (abs (k), dim = 2)), &
          maxval (abs (k), dim = 2)
  end if
end function check_momentum_conservation
@ 
<<Numerical tolerances>>=
integer, parameter, private :: ON_SHELL_TOLERANCE = 1000000
@
<<Implementation of utility functions>>=
function check_mass_shell (m, k) result (error)
  real(kind=default), intent(in) :: m
  real(kind=default), dimension(0:), intent(in) :: k
  real(kind=default) :: e2
  logical :: error
  e2 = k(1)**2 + k(2)**2 + k(3)**2 + m**2
  error = abs (k(0)**2 - e2) > ON_SHELL_TOLERANCE * epsilon (max (k(0)**2, e2))
  if (error) then
     print *, k(0)**2 - e2
     print *, ON_SHELL_TOLERANCE * epsilon (max (k(0)**2, e2)), max (k(0)**2, e2)
  end if
end function check_mass_shell
@
<<Implementation of utility functions>>=
subroutine omega_check_momenta_warn (m, k)
  real(kind=default), dimension(:), intent(in) :: m
  real(kind=default), dimension(0:,:), intent(in) :: k
  integer :: i
  if (check_momentum_conservation (k)) then
     print *, "O'Mega: warning: momentum not conserved"
  end if
  do i = 1, size(m)
     if (check_mass_shell (m(i), k(:,i))) then
        print *, "O'Mega: warning: particle #", i, "not on-shell"
     end if
  end do
end subroutine omega_check_momenta_warn
@
<<Implementation of utility functions>>=
subroutine omega_check_momenta_panic (m, k)
  real(kind=default), dimension(:), intent(in) :: m
  real(kind=default), dimension(0:,:), intent(in) :: k
  logical :: error
  logical :: error1
  integer :: i
  error = check_momentum_conservation (k)
  if (error) then
     print *, "O'Mega: panic: momentum not conserved"
  end if
  do i = 1, size(m)
     error1 = check_mass_shell (m(i), k(0:,i))
     if (error1) then
        print *, "O'Mega: panic: particle #", i, "not on-shell"
        error = .true.
     end if
  end do
  if (error) then
     stop
  end if
end subroutine omega_check_momenta_panic
@ \subsection{Obsolete Summation}
\subsubsection{Spin/Helicity Summation}
<<Declaration of obsolete utility functions>>=
public :: omega_sum, omega_sum_nonzero, omega_nonzero
private :: state_index
@
<<Implementation of obsolete utility functions>>=
pure function omega_sum (omega, p, states, fixed) result (sigma)
  real(kind=default) :: sigma
  real(kind=default), dimension(0:,:), intent(in) :: p
  integer, dimension(:), intent(in), optional :: states, fixed
  <<[[interface]] for O'Mega Amplitude>>
  integer, dimension(size(p,dim=2)) :: s, nstates
  integer :: j
  complex(kind=default) :: a
  if (present (states)) then
     nstates = states
  else
     nstates = 2
  end if
  sigma = 0
  s = -1
  sum_spins: do
     if (present (fixed)) then
        !!! print *, 's = ', s, ', fixed = ', fixed, ', nstates = ', nstates, &
        !!!    ', fixed|s = ', merge (fixed, s, mask = nstates == 0)
        a = omega (p, merge (fixed, s, mask = nstates == 0))
     else
        a = omega (p, s)
     end if
     sigma = sigma + a * conjg(a)
     <<Step [[s]] like a $n$-ary number and terminate when [[all (s == -1)]]>>
  end do sum_spins
  sigma = sigma / num_states (2, nstates(1:2))
end function omega_sum
@ We're looping over all spins like a $n$-ary numbers $(-1,\ldots,-1,-1)$,
$(-1,\ldots,-1,0)$, $(-1,\ldots,-1,1)$, $(-1,\ldots,0,-1)$, \ldots,
$(1,\ldots,1,0)$, $(1,\ldots,1,1)$:
<<Step [[s]] like a $n$-ary number and terminate when [[all (s == -1)]]>>=
do j = size (p, dim = 2), 1, -1
   select case (nstates (j))
   case (3) ! massive vectors
      s(j) = modulo (s(j) + 2, 3) - 1
   case (2) ! spinors, massless vectors
      s(j) = - s(j)
   case (1) ! scalars
      s(j) = -1
   case (0) ! fized spin
      s(j) = -1
   case default ! ???
      s(j) = -1
   end select
   if (s(j) /= -1) then
      cycle sum_spins
   end if
end do
exit sum_spins
@ The dual operation evaluates an $n$-number:
<<Implementation of obsolete utility functions>>=
pure function state_index (s, states) result (n)
  integer, dimension(:), intent(in) :: s
  integer, dimension(:), intent(in), optional :: states
  integer :: n
  integer :: j, p
  n = 1
  p = 1
  if (present (states)) then
     do j = size (s), 1, -1
        select case (states(j))
        case (3)
           n = n + p * (s(j) + 1) 
        case (2)
           n = n + p * (s(j) + 1) / 2
        end select
        p = p * states(j)
     end do
  else
     do j = size (s), 1, -1
        n = n + p * (s(j) + 1) / 2
        p = p * 2
     end do
  end if
end function state_index
@
<<[[interface]] for O'Mega Amplitude>>=
interface
   pure function omega (p, s) result (me)
     use kinds
     implicit none
     complex(kind=default) :: me
     real(kind=default), dimension(0:,:), intent(in) :: p
     integer, dimension(:), intent(in) :: s
   end function omega
end interface
@
<<Declaration of obsolete utility functions>>=
public :: num_states
@
<<Implementation of obsolete utility functions>>=
pure function num_states (n, states) result (ns)
  integer, intent(in) :: n
  integer, dimension(:), intent(in), optional :: states
  integer :: ns
  if (present (states)) then
     ns = product (states, mask = states == 2 .or. states == 3)
  else
     ns = 2**n
  end if
end function num_states
@ 
\section{\texttt{omega95}}
<<[[omega95.f90]]>>=
<<Copyleft>>
module omega95
  use constants
  use omega_spinors
  use omega_vectors
  use omega_polarizations
  use omega_tensors
  use omega_tensor_polarizations
  use omega_couplings
  use omega_spinor_couplings
  use omega_color
  use omega_utils
  public
end module omega95
@ 
\section{\texttt{omega95} Revisited}
<<[[omega95_bispinors.f90]]>>=
<<Copyleft>>
module omega95_bispinors
  use constants
  use omega_bispinors
  use omega_vectors
  use omega_vectorspinors
  use omega_polarizations
  use omega_vspinor_polarizations
  use omega_couplings
  use omega_bispinor_couplings
  use omega_color
  use omega_utils
  public
end module omega95_bispinors
@
\section{Testing}
<<[[omega_testtools.f90]]>>=
<<Copyleft>>
module omega_testtools
  use kinds
  implicit none
  private
  real(kind=default), parameter, private :: THRESHOLD_DEFAULT = 0.6
  real(kind=default), parameter, private :: THRESHOLD_WARN = 0.8
  <<Declaration of test support functions>>
contains
  <<Implementation of test support functions>>
end module omega_testtools
@ Quantify the agreement of two real or complex numbers
\begin{equation}
   \text{agreement}(x,y) = \frac{\ln \Delta(x,y)}{\ln\epsilon} \in[0,1]
\end{equation}
with
\begin{equation}
    \Delta(x,y) = \frac{|x-y|}{\max(|x|,|y|)}
\end{equation}
and values outside~$[0,1]$ replaced the closed value in the interval.
In other words
\begin{itemize}
  \item $1$ for $x-y=\max(|x|,|y|)\cdot\mathcal{O}(\epsilon)$ and
  \item $0$~for $x-y=\max(|x|,|y|)\cdot\mathcal{O}(1)$
\end{itemize}
with logarithmic interpolation.  The cases~$x=0$ and~$y=0$ must be
treated separately.
<<Declaration of test support functions>>=
public :: agreement
interface agreement
   module procedure agreement_real, agreement_complex, &
          agreement_real_complex, agreement_complex_real, &
          agreement_integer_complex, agreement_complex_integer, &
          agreement_integer_real, agreement_real_integer
end interface
private :: agreement_real, agreement_complex, &
     agreement_real_complex, agreement_complex_real, &
     agreement_integer_complex, agreement_complex_integer, &
     agreement_integer_real, agreement_real_integer
@
<<Implementation of test support functions>>=
elemental function agreement_real (x, y, base) result (a)
  real(kind=default) :: a
  real(kind=default), intent(in) :: x, y
  real(kind=default), intent(in), optional :: base
  real(kind=default) :: scale, dxy
  if (present (base)) then
     scale = max (abs (x), abs (y), abs (base))
  else
     scale = max (abs (x), abs (y))
  end if
  if (ieee_is_nan (x) .or. ieee_is_nan (y)) then
     a = 0
  else if (scale <= 0) then
     a = -1
  else
     dxy = abs (x - y) / scale
     if (dxy <= 0.0_default) then
        a = 1
     else
        a = log (dxy) / log (epsilon (scale))
        a = max (0.0_default, min (1.0_default, a))
        if (ieee_is_nan (a)) then
           a = 0
        end if
     end if
  end if
  if (ieee_is_nan (a)) then
     a = 0
  end if
end function agreement_real
@ Poor man's replacement
<<Implementation of test support functions>>=
elemental function ieee_is_nan (x) result (yorn)
  logical :: yorn
  real (kind=default), intent(in) :: x
  yorn = (x /= x)
end function ieee_is_nan
@
<<Implementation of test support functions>>=
elemental function agreement_complex (x, y, base) result (a)
  real(kind=default) :: a
  complex(kind=default), intent(in) :: x, y
  real(kind=default), intent(in), optional :: base
  real(kind=default) :: scale, dxy
  if (present (base)) then
     scale = max (abs (x), abs (y), abs (base))
  else
     scale = max (abs (x), abs (y))
  end if
  if (      ieee_is_nan (real (x, kind=default)) .or. ieee_is_nan (aimag (x)) &
       .or. ieee_is_nan (real (y, kind=default)) .or. ieee_is_nan (aimag (y))) then
     a = 0
  else if (scale <= 0) then
     a = -1
  else
     dxy = abs (x - y) / scale
     if (dxy <= 0.0_default) then
        a = 1
     else
        a = log (dxy) / log (epsilon (scale))
        a = max (0.0_default, min (1.0_default, a))
        if (ieee_is_nan (a)) then
           a = 0
        end if
     end if
  end if
  if (ieee_is_nan (a)) then
     a = 0
  end if
end function agreement_complex
@
<<Implementation of test support functions>>=
elemental function agreement_real_complex (x, y, base) result (a)
  real(kind=default) :: a
  real(kind=default), intent(in) :: x
  complex(kind=default), intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_complex (cmplx (x, kind=default), y, base)
end function agreement_real_complex
@
<<Implementation of test support functions>>=
elemental function agreement_complex_real (x, y, base) result (a)
  real(kind=default) :: a
  complex(kind=default), intent(in) :: x
  real(kind=default), intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_complex (x, cmplx (y, kind=default), base)
end function agreement_complex_real
@
<<Implementation of test support functions>>=
elemental function agreement_integer_complex (x, y, base) result (a)
  real(kind=default) :: a
  integer, intent(in) :: x
  complex(kind=default), intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_complex (cmplx (x, kind=default), y, base)
end function agreement_integer_complex
@
<<Implementation of test support functions>>=
elemental function agreement_complex_integer (x, y, base) result (a)
  real(kind=default) :: a
  complex(kind=default), intent(in) :: x
  integer, intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_complex (x, cmplx (y, kind=default), base)
end function agreement_complex_integer
@
<<Implementation of test support functions>>=
elemental function agreement_integer_real (x, y, base) result (a)
  real(kind=default) :: a
  integer, intent(in) :: x
  real(kind=default), intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_real (real(x, kind=default), y, base)
end function agreement_integer_real
@
<<Implementation of test support functions>>=
elemental function agreement_real_integer (x, y, base) result (a)
  real(kind=default) :: a
  real(kind=default), intent(in) :: x
  integer, intent(in) :: y
  real(kind=default), intent(in), optional :: base
  a = agreement_real (x, real (y, kind=default), base)
end function agreement_real_integer
@ 
<<Declaration of test support functions>>=
public:: vanishes
interface vanishes
   module procedure vanishes_real, vanishes_complex
end interface
private :: vanishes_real, vanishes_complex
@ 
<<Implementation of test support functions>>=
elemental function vanishes_real (x, scale) result (a)
  real(kind=default) :: a
  real(kind=default), intent(in) :: x
  real(kind=default), intent(in), optional :: scale
  real(kind=default) :: scaled_x
  if (x == 0.0_default) then
     a = 1
     return
  else if (ieee_is_nan (x)) then
     a = 0
     return
  end if
  scaled_x = x
  if (present (scale)) then
     if (scale /= 0) then
        scaled_x = x / abs (scale)
     else
        a = 0
        return
     end if
  else
  end if
  a = log (abs (scaled_x)) / log (epsilon (scaled_x))
  a = max (0.0_default, min (1.0_default, a))
  if (ieee_is_nan (a)) then
     a = 0
  end if
end function vanishes_real
@ 
<<Implementation of test support functions>>=
elemental function vanishes_complex (x, scale) result (a)
  real(kind=default) :: a
  complex(kind=default), intent(in) :: x
  real(kind=default), intent(in), optional :: scale
  a = vanishes_real (abs (x), scale)
end function vanishes_complex
@ 
<<Declaration of test support functions>>=
public :: expect
interface expect
   module procedure expect_integer, expect_real, expect_complex, &
        expect_real_integer, expect_integer_real, &
        expect_complex_integer, expect_integer_complex, &
        expect_complex_real, expect_real_complex
end interface
private :: expect_integer, expect_real, expect_complex, &
     expect_real_integer, expect_integer_real, &
     expect_complex_integer, expect_integer_complex, &
     expect_complex_real, expect_real_complex
@ 
<<Implementation of test support functions>>=
subroutine expect_integer (x, x0, msg, passed, quiet, buffer, unit)
  integer, intent(in) :: x, x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  logical, intent(in), optional :: quiet
  character(len=*), intent(inout), optional :: buffer
  integer, intent(in), optional :: unit
  logical :: failed, verbose
  character(len=*), parameter :: fmt = "(1X,A,': ',A)"
  character(len=*), parameter :: &
       fmt_verbose = "(1X,A,': ',A,' [expected ',I6,', got ',I6,']')"
  failed = .false.
  verbose = .true.
  if (present (quiet)) then
     verbose = .not.quiet
  end if
  if (x == x0) then
     if (verbose) then
        if (.not. (present (buffer) .or. present (unit))) then
           write (unit = *, fmt = fmt) msg, "passed"
        end if
        if (present (unit)) then
           write (unit = unit, fmt = fmt) msg, "passed"
        end if
        if (present (buffer)) then
           write (unit = buffer, fmt = fmt) msg, "passed"
        end if
     end if
  else
     if (.not. (present (buffer) .or. present (unit))) then
        write (unit = *, fmt = fmt_verbose) msg, "failed", x0, x
     end if
     if (present (unit)) then
        write (unit = unit, fmt = fmt_verbose) msg, "failed", x0, x
     end if
     if (present (buffer)) then
        write (unit = buffer, fmt = fmt_verbose) msg, "failed", x0, x
     end if
     failed = .true.
  end if
  if (present (passed)) then
     passed = passed .and. .not.failed 
  end if
end subroutine expect_integer
@ 
<<Implementation of test support functions>>=
subroutine expect_real (x, x0, msg, passed, threshold, quiet)
  real(kind=default), intent(in) :: x, x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  logical :: failed, verbose
  real(kind=default) :: agreement_threshold
  character(len=*), parameter :: fmt = "(1X,A,': ',A,' at ',I4,'%')"
  character(len=*), parameter :: fmt_verbose = "(1X,A,': ',A,' at ',I4,'%'," // &
       "' [expected ',E10.3,', got ',E10.3,']')"
  real(kind=default) :: a
  failed = .false.
  verbose = .true.
  if (present (quiet)) then
     verbose = .not.quiet
  end if
  if (x == x0) then
     if (verbose) then
        write (unit = *, fmt = fmt) msg, "passed", 100
     end if
  else
     if (x0 == 0) then
        a = vanishes (x)
     else
        a = agreement (x, x0)
     end if
     if (present (threshold)) then
        agreement_threshold = threshold
     else
        agreement_threshold = THRESHOLD_DEFAULT
     end if
     if (a >= agreement_threshold) then
        if (verbose) then
           if (a >= THRESHOLD_WARN) then
              write (unit = *, fmt = fmt) msg, "passed", int (a * 100)
           else
              write (unit = *, fmt = fmt_verbose) msg, "passed", int (a * 100), x0, x
           end if
        end if
     else
        failed = .true.
        write (unit = *, fmt = fmt_verbose) msg, "failed", int (a * 100), x0, x
     end if
  end if
  if (present (passed)) then
     passed = passed .and. .not.failed 
  end if
end subroutine expect_real
@ 
<<Implementation of test support functions>>=
subroutine expect_complex (x, x0, msg, passed, threshold, quiet)
  complex(kind=default), intent(in) :: x, x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  logical :: failed, verbose
  real(kind=default) :: agreement_threshold
  character(len=*), parameter :: fmt = "(1X,A,': ',A,' at ',I4,'%')"
  character(len=*), parameter :: fmt_verbose = "(1X,A,': ',A,' at ',I4,'%'," // &
       "' [expected (',E10.3,',',E10.3,'), got (',E10.3,',',E10.3,')]')"
  character(len=*), parameter :: fmt_phase = "(1X,A,': ',A,' at ',I4,'%'," // &
       "' [modulus passed at ',I4,'%',', phases ',F5.3,' vs. ',F5.3,']')"
  real(kind=default) :: a, a_modulus
  failed = .false.
  verbose = .true.
  if (present (quiet)) then
     verbose = .not.quiet
  end if
  if (x == x0) then
     if (verbose) then
        write (unit = *, fmt = fmt) msg, "passed", 100
     end if
  else
     if (x0 == 0) then
        a = vanishes (x)
     else
        a = agreement (x, x0)
     end if
     if (present (threshold)) then
        agreement_threshold = threshold
     else
        agreement_threshold = THRESHOLD_DEFAULT
     end if
     if (a >= agreement_threshold) then
        if (verbose) then
           if (a >= THRESHOLD_WARN) then
              write (unit = *, fmt = fmt) msg, "passed", int (a * 100)
           else
              write (unit = *, fmt = fmt_verbose) msg, "passed", int (a * 100), x0, x
           end if
        end if
     else
        a_modulus = agreement (abs (x), abs (x0))
        if (a_modulus >= agreement_threshold) then
           write (unit = *, fmt = fmt_phase) msg, "failed", int (a * 100), &
                int (a_modulus * 100), &
                atan2 (real (x, kind=default), aimag (x)), &
                atan2 (real (x0, kind=default), aimag (x0)) 
        else
           write (unit = *, fmt = fmt_verbose) msg, "failed", int (a * 100), x0, x
        end if
        failed = .true.
     end if
  end if
  if (present (passed)) then
     passed = passed .and. .not.failed 
  end if
end subroutine expect_complex
@ 
<<Implementation of test support functions>>=
subroutine expect_real_integer (x, x0, msg, passed, threshold, quiet)
  real(kind=default), intent(in) :: x
  integer, intent(in) :: x0
  character(len=*), intent(in) :: msg
  real(kind=default), intent(in), optional :: threshold
  logical, intent(inout), optional :: passed
  logical, intent(in), optional :: quiet
  call expect_real (x, real (x0, kind=default), msg, passed, threshold, quiet)
end subroutine expect_real_integer
@ 
<<Implementation of test support functions>>=
subroutine expect_integer_real (x, x0, msg, passed, threshold, quiet)
  integer, intent(in) :: x
  real(kind=default), intent(in) :: x0
  character(len=*), intent(in) :: msg
  real(kind=default), intent(in), optional :: threshold
  logical, intent(inout), optional :: passed
  logical, intent(in), optional :: quiet
  call expect_real (real (x, kind=default), x0, msg, passed, threshold, quiet)
end subroutine expect_integer_real
@ 
<<Implementation of test support functions>>=
subroutine expect_complex_integer (x, x0, msg, passed, threshold, quiet)
  complex(kind=default), intent(in) :: x
  integer, intent(in) :: x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  call expect_complex (x, cmplx (x0, kind=default), msg, passed, threshold, quiet)
end subroutine expect_complex_integer
@ 
<<Implementation of test support functions>>=
subroutine expect_integer_complex (x, x0, msg, passed, threshold, quiet)
  integer, intent(in) :: x
  complex(kind=default), intent(in) :: x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  call expect_complex (cmplx (x, kind=default), x0, msg, passed, threshold, quiet)
end subroutine expect_integer_complex
@ 
<<Implementation of test support functions>>=
subroutine expect_complex_real (x, x0, msg, passed, threshold, quiet)
  complex(kind=default), intent(in) :: x
  real(kind=default), intent(in) :: x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  call expect_complex (x, cmplx (x0, kind=default), msg, passed, threshold, quiet)
end subroutine expect_complex_real
@ 
<<Implementation of test support functions>>=
subroutine expect_real_complex (x, x0, msg, passed, threshold, quiet)
  real(kind=default), intent(in) :: x
  complex(kind=default), intent(in) :: x0
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  call expect_complex (cmplx (x, kind=default), x0, msg, passed, threshold, quiet)
end subroutine expect_real_complex
@ 
<<Declaration of test support functions>>=
public :: expect_zero
interface expect_zero
   module procedure expect_zero_integer, expect_zero_real, expect_zero_complex
end interface
private :: expect_zero_integer, expect_zero_real, expect_zero_complex
@ 
<<Implementation of test support functions>>=
subroutine expect_zero_integer (x, msg, passed)
  integer, intent(in) :: x
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  call expect_integer (x, 0, msg, passed)
end subroutine expect_zero_integer
@ 
<<Implementation of test support functions>>=
subroutine expect_zero_real (x, scale, msg, passed, threshold, quiet)
  real(kind=default), intent(in) :: x, scale
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  logical :: failed, verbose
  real(kind=default) :: agreement_threshold
  character(len=*), parameter :: fmt = "(1X,A,': ',A,' at ',I4,'%')"
  character(len=*), parameter :: fmt_verbose = "(1X,A,': ',A,' at ',I4,'%'," // &
       "' [expected 0 (relative to ',E10.3,') got ',E10.3,']')"
  real(kind=default) :: a
  failed = .false.
  verbose = .true.
  if (present (quiet)) then
     verbose = .not.quiet
  end if
  if (x == 0) then
     if (verbose) then
        write (unit = *, fmt = fmt) msg, "passed", 100
     end if
  else
     a = vanishes (x, scale = scale)
     if (present (threshold)) then
        agreement_threshold = threshold
     else
        agreement_threshold = THRESHOLD_DEFAULT
     end if
     if (a >= agreement_threshold) then
        if (verbose) then
           if (a >= THRESHOLD_WARN) then
              write (unit = *, fmt = fmt) msg, "passed", int (a * 100)
           else
              write (unit = *, fmt = fmt_verbose) msg, "passed", int (a * 100), scale, x
           end if
        end if
     else
        failed = .true.
        write (unit = *, fmt = fmt_verbose) msg, "failed", int (a * 100), scale, x
     end if
  end if
  if (present (passed)) then
     passed = passed .and. .not.failed 
  end if
end subroutine expect_zero_real
@ 
<<Implementation of test support functions>>=
subroutine expect_zero_complex (x, scale, msg, passed, threshold, quiet)
  complex(kind=default), intent(in) :: x
  real(kind=default), intent(in) :: scale
  character(len=*), intent(in) :: msg
  logical, intent(inout), optional :: passed
  real(kind=default), intent(in), optional :: threshold
  logical, intent(in), optional :: quiet
  call expect_zero_real (abs (x), scale, msg, passed, threshold, quiet)
end subroutine expect_zero_complex
@ 
<<Implementation of test support functions>>=
subroutine print_matrix (a)
  complex(kind=default), dimension(:,:), intent(in) :: a
  integer :: row
  do row = 1, size (a, dim=1)
     write (unit = *, fmt = "(10(tr2, f5.2, '+', f5.2, 'I'))") a(row,:)
  end do
end subroutine print_matrix
@ 
<<Declaration of test support functions>>=
public :: print_matrix
@ 
<<[[test_omega95.f90]]>>=
<<Copyleft>>
program test_omega95
  use kinds
  use omega95
  use omega_testtools
  implicit none
  real(kind=default) :: m, pabs, qabs, w
  real(kind=default), dimension(0:3) :: r
  complex(kind=default) :: c_one, c_nil
  type(momentum) :: p, q, p0
  type(vector) :: vp, vq, vtest, v0
  type(tensor) :: ttest
  integer, dimension(8) :: date_time
  integer :: rsize
  logical :: passed
  call date_and_time (values = date_time)
  call random_seed (size = rsize)
  call random_seed (put = spread (product (date_time), dim = 1, ncopies = rsize))
  w = 1.4142
  c_one = 1.0_default
  c_nil = 0.0_default
  m = 13
  pabs = 42 
  qabs = 137
  call random_number (r)
  vtest%t = cmplx (10.0_default * r(0), kind=default)
  vtest%x(1:3) = cmplx (10.0_default * r(1:3), kind=default)
  ttest = vtest.tprod.vtest
  call random_momentum (p, pabs, m)
  call random_momentum (q, qabs, m)
  call random_momentum (p0, 0.0_default, m)
  vp = p
  vq = q
  v0 = p0
  passed = .true.
  <<Test [[omega95]]>>
  if (.not. passed) then
    stop 1
  end if
end program test_omega95
@ 
<<Test [[omega95]]>>=
print *, "*** Checking the equations of motion ***:"
call expect (abs(f_vf(c_one,vp,u(m,p,+1))-m*u(m,p,+1)), 0, "|[p-m]u(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,u(m,p,-1))-m*u(m,p,-1)), 0, "|[p-m]u(-)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(m,p,+1))+m*v(m,p,+1)), 0, "|[p+m]v(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(m,p,-1))+m*v(m,p,-1)), 0, "|[p+m]v(-)|=0", passed)
call expect (abs(f_fv(c_one,ubar(m,p,+1),vp)-m*ubar(m,p,+1)), 0, "|ubar(+)[p-m]|=0", passed)
call expect (abs(f_fv(c_one,ubar(m,p,-1),vp)-m*ubar(m,p,-1)), 0, "|ubar(-)[p-m]|=0", passed)
call expect (abs(f_fv(c_one,vbar(m,p,+1),vp)+m*vbar(m,p,+1)), 0, "|vbar(+)[p+m]|=0", passed)
call expect (abs(f_fv(c_one,vbar(m,p,-1),vp)+m*vbar(m,p,-1)), 0, "|vbar(-)[p+m]|=0", passed)
print *, "*** Checking the equations of motion for negative mass***:"
call expect (abs(f_vf(c_one,vp,u(-m,p,+1))+m*u(-m,p,+1)), 0, "|[p+m]u(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,u(-m,p,-1))+m*u(-m,p,-1)), 0, "|[p+m]u(-)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(-m,p,+1))-m*v(-m,p,+1)), 0, "|[p-m]v(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(-m,p,-1))-m*v(-m,p,-1)), 0, "|[p-m]v(-)|=0", passed)
call expect (abs(f_fv(c_one,ubar(-m,p,+1),vp)+m*ubar(-m,p,+1)), 0, "|ubar(+)[p+m]|=0", passed)
call expect (abs(f_fv(c_one,ubar(-m,p,-1),vp)+m*ubar(-m,p,-1)), 0, "|ubar(-)[p+m]|=0", passed)
call expect (abs(f_fv(c_one,vbar(-m,p,+1),vp)-m*vbar(-m,p,+1)), 0, "|vbar(+)[p-m]|=0", passed)
call expect (abs(f_fv(c_one,vbar(-m,p,-1),vp)-m*vbar(-m,p,-1)), 0, "|vbar(-)[p-m]|=0", passed)
@ 
<<Test [[omega95]]>>=
print *, "*** Checking the normalization ***:"
call expect (ubar(m,p,+1)*u(m,p,+1), +2*m, "ubar(+)*u(+)=+2m", passed)
call expect (ubar(m,p,-1)*u(m,p,-1), +2*m, "ubar(-)*u(-)=+2m", passed)
call expect (vbar(m,p,+1)*v(m,p,+1), -2*m, "vbar(+)*v(+)=-2m", passed)
call expect (vbar(m,p,-1)*v(m,p,-1), -2*m, "vbar(-)*v(-)=-2m", passed)
call expect (ubar(m,p,+1)*v(m,p,+1),    0, "ubar(+)*v(+)=0  ", passed)
call expect (ubar(m,p,-1)*v(m,p,-1),    0, "ubar(-)*v(-)=0  ", passed)
call expect (vbar(m,p,+1)*u(m,p,+1),    0, "vbar(+)*u(+)=0  ", passed)
call expect (vbar(m,p,-1)*u(m,p,-1),    0, "vbar(-)*u(-)=0  ", passed)
print *, "*** Checking the normalization for negative masses***:"
call expect (ubar(-m,p,+1)*u(-m,p,+1), -2*m, "ubar(+)*u(+)=-2m", passed)
call expect (ubar(-m,p,-1)*u(-m,p,-1), -2*m, "ubar(-)*u(-)=-2m", passed)
call expect (vbar(-m,p,+1)*v(-m,p,+1), +2*m, "vbar(+)*v(+)=+2m", passed)
call expect (vbar(-m,p,-1)*v(-m,p,-1), +2*m, "vbar(-)*v(-)=+2m", passed)
call expect (ubar(-m,p,+1)*v(-m,p,+1),    0, "ubar(+)*v(+)=0  ", passed)
call expect (ubar(-m,p,-1)*v(-m,p,-1),    0, "ubar(-)*v(-)=0  ", passed)
call expect (vbar(-m,p,+1)*u(-m,p,+1),    0, "vbar(+)*u(+)=0  ", passed)
call expect (vbar(-m,p,-1)*u(-m,p,-1),    0, "vbar(-)*u(-)=0  ", passed)
@ 
<<Test [[omega95]]>>=
print *, "*** Checking the currents ***:"
call expect (abs(v_ff(c_one,ubar(m,p,+1),u(m,p,+1))-2*vp), 0, "ubar(+).V.u(+)=2p", passed)
call expect (abs(v_ff(c_one,ubar(m,p,-1),u(m,p,-1))-2*vp), 0, "ubar(-).V.u(-)=2p", passed)
call expect (abs(v_ff(c_one,vbar(m,p,+1),v(m,p,+1))-2*vp), 0, "vbar(+).V.v(+)=2p", passed)
call expect (abs(v_ff(c_one,vbar(m,p,-1),v(m,p,-1))-2*vp), 0, "vbar(-).V.v(-)=2p", passed)
print *, "*** Checking the currents for negative masses***:"
call expect (abs(v_ff(c_one,ubar(-m,p,+1),u(-m,p,+1))-2*vp), 0, "ubar(+).V.u(+)=2p", passed)
call expect (abs(v_ff(c_one,ubar(-m,p,-1),u(-m,p,-1))-2*vp), 0, "ubar(-).V.u(-)=2p", passed)
call expect (abs(v_ff(c_one,vbar(-m,p,+1),v(-m,p,+1))-2*vp), 0, "vbar(+).V.v(+)=2p", passed)
call expect (abs(v_ff(c_one,vbar(-m,p,-1),v(-m,p,-1))-2*vp), 0, "vbar(-).V.v(-)=2p", passed)
@ 
<<Test [[omega95]]>>=
print *, "*** Checking current conservation ***:"
call expect ((vp-vq)*v_ff(c_one,ubar(m,p,+1),u(m,q,+1)), 0, "d(ubar(+).V.u(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,ubar(m,p,-1),u(m,q,-1)), 0, "d(ubar(-).V.u(-))=0", passed)
call expect ((vp-vq)*v_ff(c_one,vbar(m,p,+1),v(m,q,+1)), 0, "d(vbar(+).V.v(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,vbar(m,p,-1),v(m,q,-1)), 0, "d(vbar(-).V.v(-))=0", passed)
print *, "*** Checking current conservation for negative masses***:"
call expect ((vp-vq)*v_ff(c_one,ubar(-m,p,+1),u(-m,q,+1)), 0, "d(ubar(+).V.u(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,ubar(-m,p,-1),u(-m,q,-1)), 0, "d(ubar(-).V.u(-))=0", passed)
call expect ((vp-vq)*v_ff(c_one,vbar(-m,p,+1),v(-m,q,+1)), 0, "d(vbar(+).V.v(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,vbar(-m,p,-1),v(-m,q,-1)), 0, "d(vbar(-).V.v(-))=0", passed)
@ 
<<Test [[omega95]]>>=
if (m == 0) then
   print *, "*** Checking axial current conservation ***:"
   call expect ((vp-vq)*a_ff(c_one,ubar(m,p,+1),u(m,q,+1)), 0, "d(ubar(+).A.u(+))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,ubar(m,p,-1),u(m,q,-1)), 0, "d(ubar(-).A.u(-))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,vbar(m,p,+1),v(m,q,+1)), 0, "d(vbar(+).A.v(+))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,vbar(m,p,-1),v(m,q,-1)), 0, "d(vbar(-).A.v(-))=0", passed)
end if
@ 
<<Test [[omega95]]>>=
print *, "*** Checking implementation of the sigma vertex funktions ***:"
call expect ((vp*tvam_ff(c_one,c_nil,ubar(m,p,+1),u(m,q,+1),q) - (p*q-m**2)*(ubar(m,p,+1)*u(m,q,+1))), 0, &
             "p*[ubar(p,+).(Isigma*q).u(q,+)] - (p*q-m^2)*ubar(p,+).u(q,+) = 0", passed)
call expect ((vp*tvam_ff(c_one,c_nil,ubar(m,p,-1),u(m,q,-1),q) - (p*q-m**2)*(ubar(m,p,-1)*u(m,q,-1))), 0, &
             "p*[ubar(p,-).(Isigma*q).u(q,-)] - (p*q-m^2)*ubar(p,-).u(q,-) = 0", passed)
call expect ((vp*tvam_ff(c_one,c_nil,vbar(m,p,+1),v(m,q,+1),q) - (p*q-m**2)*(vbar(m,p,+1)*v(m,q,+1))), 0, &
             "p*[vbar(p,+).(Isigma*q).v(q,+)] - (p*q-m^2)*vbar(p,+).v(q,+) = 0", passed)
call expect ((vp*tvam_ff(c_one,c_nil,vbar(m,p,-1),v(m,q,-1),q) - (p*q-m**2)*(vbar(m,p,-1)*v(m,q,-1))), 0, &
             "p*[vbar(p,-).(Isigma*q).v(q,-)] - (p*q-m^2)*vbar(p,-).v(q,-) = 0", passed)
call expect ((ubar(m,p,+1)*f_tvamf(c_one,c_nil,vp,u(m,q,+1),q) - (p*q-m**2)*(ubar(m,p,+1)*u(m,q,+1))), 0, &
             "ubar(p,+).[p*(Isigma*q).u(q,+)] - (p*q-m^2)*ubar(p,+).u(q,+) = 0", passed)
call expect ((ubar(m,p,-1)*f_tvamf(c_one,c_nil,vp,u(m,q,-1),q) - (p*q-m**2)*(ubar(m,p,-1)*u(m,q,-1))), 0, &
             "ubar(p,-).[p*(Isigma*q).u(q,-)] - (p*q-m^2)*ubar(p,-).u(q,-) = 0", passed)
call expect ((vbar(m,p,+1)*f_tvamf(c_one,c_nil,vp,v(m,q,+1),q) - (p*q-m**2)*(vbar(m,p,+1)*v(m,q,+1))), 0, &
             "vbar(p,+).[p*(Isigma*q).v(q,+)] - (p*q-m^2)*vbar(p,+).v(q,+) = 0", passed)
call expect ((vbar(m,p,-1)*f_tvamf(c_one,c_nil,vp,v(m,q,-1),q) - (p*q-m**2)*(vbar(m,p,-1)*v(m,q,-1))), 0, &
             "vbar(p,-).[p*(Isigma*q).v(q,-)] - (p*q-m^2)*vbar(p,-).v(q,-) = 0", passed)
call expect ((f_ftvam(c_one,c_nil,ubar(m,p,+1),vp,q)*u(m,q,+1) - (p*q-m**2)*(ubar(m,p,+1)*u(m,q,+1))), 0, &
             "[ubar(p,+).p*(Isigma*q)].u(q,+) - (p*q-m^2)*ubar(p,+).u(q,+) = 0", passed)
call expect ((f_ftvam(c_one,c_nil,ubar(m,p,-1),vp,q)*u(m,q,-1) - (p*q-m**2)*(ubar(m,p,-1)*u(m,q,-1))), 0, &
             "[ubar(p,-).p*(Isigma*q)].u(q,-) - (p*q-m^2)*ubar(p,-).u(q,-) = 0", passed)
call expect ((f_ftvam(c_one,c_nil,vbar(m,p,+1),vp,q)*v(m,q,+1) - (p*q-m**2)*(vbar(m,p,+1)*v(m,q,+1))), 0, &
             "[vbar(p,+).p*(Isigma*q)].v(q,+) - (p*q-m^2)*vbar(p,+).v(q,+) = 0", passed)
call expect ((f_ftvam(c_one,c_nil,vbar(m,p,-1),vp,q)*v(m,q,-1) - (p*q-m**2)*(vbar(m,p,-1)*v(m,q,-1))), 0, &
             "[vbar(p,-).p*(Isigma*q)].v(q,-) - (p*q-m^2)*vbar(p,-).v(q,-) = 0", passed)

call expect ((vp*tvam_ff(c_nil,c_one,ubar(m,p,+1),u(m,q,+1),q) - (p*q+m**2)*p_ff(c_one,ubar(m,p,+1),u(m,q,+1))), 0, &
             "p*[ubar(p,+).(Isigma*q).g5.u(q,+)] - (p*q+m^2)*ubar(p,+).g5.u(q,+) = 0", passed)
call expect ((vp*tvam_ff(c_nil,c_one,ubar(m,p,-1),u(m,q,-1),q) - (p*q+m**2)*p_ff(c_one,ubar(m,p,-1),u(m,q,-1))), 0, &
             "p*[ubar(p,-).(Isigma*q).g5.u(q,-)] - (p*q+m^2)*ubar(p,-).g5.u(q,-) = 0", passed)
call expect ((vp*tvam_ff(c_nil,c_one,vbar(m,p,+1),v(m,q,+1),q) - (p*q+m**2)*p_ff(c_one,vbar(m,p,+1),v(m,q,+1))), 0, &
             "p*[vbar(p,+).(Isigma*q).g5.v(q,+)] - (p*q+m^2)*vbar(p,+).g5.v(q,+) = 0", passed)
call expect ((vp*tvam_ff(c_nil,c_one,vbar(m,p,-1),v(m,q,-1),q) - (p*q+m**2)*p_ff(c_one,vbar(m,p,-1),v(m,q,-1))), 0, &
             "p*[vbar(p,-).(Isigma*q).g5.v(q,-)] - (p*q+m^2)*vbar(p,-).g5.v(q,-) = 0", passed)
call expect ((ubar(m,p,+1)*f_tvamf(c_nil,c_one,vp,u(m,q,+1),q) - (p*q+m**2)*p_ff(c_one,ubar(m,p,+1),u(m,q,+1))), 0, &
             "p*[ubar(p,+).(Isigma*q).g5.u(q,+)] - (p*q+m^2)*ubar(p,+).g5.u(q,+) = 0", passed)
call expect ((ubar(m,p,-1)*f_tvamf(c_nil,c_one,vp,u(m,q,-1),q) - (p*q+m**2)*p_ff(c_one,ubar(m,p,-1),u(m,q,-1))), 0, &
             "p*[ubar(p,-).(Isigma*q).g5.u(q,-)] - (p*q+m^2)*ubar(p,-).g5.u(q,-) = 0", passed)
call expect ((vbar(m,p,+1)*f_tvamf(c_nil,c_one,vp,v(m,q,+1),q) - (p*q+m**2)*p_ff(c_one,vbar(m,p,+1),v(m,q,+1))), 0, &
             "p*[vbar(p,+).(Isigma*q).g5.v(q,+)] - (p*q+m^2)*vbar(p,+).g5.v(q,+) = 0", passed)
call expect ((vbar(m,p,-1)*f_tvamf(c_nil,c_one,vp,v(m,q,-1),q) - (p*q+m**2)*p_ff(c_one,vbar(m,p,-1),v(m,q,-1))), 0, &
             "p*[vbar(p,-).(Isigma*q).g5.v(q,-)] - (p*q+m^2)*vbar(p,-).g5.v(q,-) = 0", passed)
call expect ((f_ftvam(c_nil,c_one,ubar(m,p,+1),vp,q)*u(m,q,+1) - (p*q+m**2)*p_ff(c_one,ubar(m,p,+1),u(m,q,+1))), 0, &
             "p*[ubar(p,+).(Isigma*q).g5.u(q,+)] - (p*q+m^2)*ubar(p,+).g5.u(q,+) = 0", passed)
call expect ((f_ftvam(c_nil,c_one,ubar(m,p,-1),vp,q)*u(m,q,-1) - (p*q+m**2)*p_ff(c_one,ubar(m,p,-1),u(m,q,-1))), 0, &
             "p*[ubar(p,-).(Isigma*q).g5.u(q,-)] - (p*q+m^2)*ubar(p,-).g5.u(q,-) = 0", passed)
call expect ((f_ftvam(c_nil,c_one,vbar(m,p,+1),vp,q)*v(m,q,+1) - (p*q+m**2)*p_ff(c_one,vbar(m,p,+1),v(m,q,+1))), 0, &
             "p*[vbar(p,+).(Isigma*q).g5.v(q,+)] - (p*q+m^2)*vbar(p,+).g5.v(q,+) = 0", passed)
call expect ((f_ftvam(c_nil,c_one,vbar(m,p,-1),vp,q)*v(m,q,-1) - (p*q+m**2)*p_ff(c_one,vbar(m,p,-1),v(m,q,-1))), 0, &
             "p*[vbar(p,-).(Isigma*q).g5.v(q,-)] - (p*q+m^2)*vbar(p,-).g5.v(q,-) = 0", passed)
@ 
<<Test [[omega95]]>>=
print *, "*** Checking polarisation vectors: ***"
call expect (conjg(eps(m,p, 1))*eps(m,p, 1), -1, "e( 1).e( 1)=-1", passed)
call expect (conjg(eps(m,p, 1))*eps(m,p,-1),  0, "e( 1).e(-1)= 0", passed)
call expect (conjg(eps(m,p,-1))*eps(m,p, 1),  0, "e(-1).e( 1)= 0", passed)
call expect (conjg(eps(m,p,-1))*eps(m,p,-1), -1, "e(-1).e(-1)=-1", passed)
call expect (                 p*eps(m,p, 1),  0, "    p.e( 1)= 0", passed)
call expect (                 p*eps(m,p,-1),  0, "    p.e(-1)= 0", passed)
if (m > 0) then
   call expect (conjg(eps(m,p, 1))*eps(m,p, 0),  0, "e( 1).e( 0)= 0", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p, 1),  0, "e( 0).e( 1)= 0", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p, 0), -1, "e( 0).e( 0)=-1", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p,-1),  0, "e( 0).e(-1)= 0", passed)
   call expect (conjg(eps(m,p,-1))*eps(m,p, 0),  0, "e(-1).e( 0)= 0", passed)
   call expect (                p*eps(m,p, 0),  0, "    p.e( 0)= 0", passed)
end if
@ 
<<Test [[omega95]]>>=
print *, "*** Checking epsilon tensor: ***"
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,q,1),eps(m,p,1),eps(m,p,0),eps(m,q,0)), "eps(1<->2)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,p,0),eps(m,q,1),eps(m,p,1),eps(m,q,0)), "eps(1<->3)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,q,0),eps(m,q,1),eps(m,p,0),eps(m,p,1)), "eps(1<->4)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,p,1),eps(m,p,0),eps(m,q,1),eps(m,q,0)), "eps(2<->3)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,p,1),eps(m,q,0),eps(m,p,0),eps(m,q,1)), "eps(2<->4)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
             - pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,q,0),eps(m,p,0)), "eps(3<->4)", passed)
call expect (  pseudo_scalar(eps(m,p,1),eps(m,q,1),eps(m,p,0),eps(m,q,0)), &
               eps(m,p,1)*pseudo_vector(eps(m,q,1),eps(m,p,0),eps(m,q,0)), "eps'", passed)
@
\begin{equation}
   \frac{1}{2} [x\wedge y]^*_{\mu\nu} [x\wedge y]^{\mu\nu}
     = \frac{1}{2} (x^*_\mu y^*_\nu-x^*_\nu y^*_\mu) (x^\mu y^\nu-x^\nu y^\mu)
     = (x^*x) (y^*y) - (x^*y) (y^*x)
\end{equation}
<<Test [[omega95]]>>=
print *, "*** Checking tensors: ***"
call expect (conjg(p.wedge.q)*(p.wedge.q), (p*p)*(q*q)-(p*q)**2, &
     "[p,q].[q,p]=p.p*q.q-p.q^2", passed)
call expect (conjg(p.wedge.q)*(q.wedge.p), (p*q)**2-(p*p)*(q*q), &
     "[p,q].[q,p]=p.q^2-p.p*q.q", passed)
@ i.\,e.
\begin{equation}
   \frac{1}{2} [p\wedge\epsilon(p,i)]^*_{\mu\nu} [p\wedge\epsilon(p,j)]^{\mu\nu}
     = - p^2 \delta_{ij}
\end{equation}
<<Test [[omega95]]>>=
call expect (conjg(p.wedge.eps(m,p, 1))*(p.wedge.eps(m,p, 1)), -p*p, &
     "[p,e( 1)].[p,e( 1)]=-p.p", passed)
call expect (conjg(p.wedge.eps(m,p, 1))*(p.wedge.eps(m,p,-1)),    0, &
     "[p,e( 1)].[p,e(-1)]=0", passed)
call expect (conjg(p.wedge.eps(m,p,-1))*(p.wedge.eps(m,p, 1)),    0, &
     "[p,e(-1)].[p,e( 1)]=0", passed)
call expect (conjg(p.wedge.eps(m,p,-1))*(p.wedge.eps(m,p,-1)), -p*p, &
     "[p,e(-1)].[p,e(-1)]=-p.p", passed)
if (m > 0) then
   call expect (conjg(p.wedge.eps(m,p, 1))*(p.wedge.eps(m,p, 0)),    0, &
        "[p,e( 1)].[p,e( 0)]=0", passed)
   call expect (conjg(p.wedge.eps(m,p, 0))*(p.wedge.eps(m,p, 1)),    0, &
        "[p,e( 0)].[p,e( 1)]=0", passed)
   call expect (conjg(p.wedge.eps(m,p, 0))*(p.wedge.eps(m,p, 0)), -p*p, &
        "[p,e( 0)].[p,e( 0)]=-p.p", passed)
   call expect (conjg(p.wedge.eps(m,p, 0))*(p.wedge.eps(m,p,-1)),    0, &
        "[p,e( 1)].[p,e(-1)]=0", passed)
   call expect (conjg(p.wedge.eps(m,p,-1))*(p.wedge.eps(m,p, 0)),    0, &
        "[p,e(-1)].[p,e( 0)]=0", passed)
end if
@ also
\begin{align}
   [x\wedge y]_{\mu\nu} z^\nu &= x_\mu (yz) - y_\mu (xz) \\
   z_\mu [x\wedge y]^{\mu\nu} &= (zx) y^\nu - (zy) x^\nu
\end{align}
<<Test [[omega95]]>>=
call expect (abs ((p.wedge.eps(m,p, 1))*p + (p*p)*eps(m,p, 1)), 0, &
     "[p,e( 1)].p=-p.p*e( 1)]", passed)
call expect (abs ((p.wedge.eps(m,p, 0))*p + (p*p)*eps(m,p, 0)), 0, &
     "[p,e( 0)].p=-p.p*e( 0)]", passed)
call expect (abs ((p.wedge.eps(m,p,-1))*p + (p*p)*eps(m,p,-1)), 0, &
     "[p,e(-1)].p=-p.p*e(-1)]", passed)
call expect (abs (p*(p.wedge.eps(m,p, 1)) - (p*p)*eps(m,p, 1)), 0, &
     "p.[p,e( 1)]=p.p*e( 1)]", passed)
call expect (abs (p*(p.wedge.eps(m,p, 0)) - (p*p)*eps(m,p, 0)), 0, &
     "p.[p,e( 0)]=p.p*e( 0)]", passed)
call expect (abs (p*(p.wedge.eps(m,p,-1)) - (p*p)*eps(m,p,-1)), 0, &
     "p.[p,e(-1)]=p.p*e(-1)]", passed)
@ 
<<Test [[omega95]]>>=
print *, "*** Checking polarisation tensors: ***"
call expect (conjg(eps2(m,p, 2))*eps2(m,p, 2), 1, "e2( 2).e2( 2)=1", passed)
call expect (conjg(eps2(m,p, 2))*eps2(m,p,-2), 0, "e2( 2).e2(-2)=0", passed)
call expect (conjg(eps2(m,p,-2))*eps2(m,p, 2), 0, "e2(-2).e2( 2)=0", passed)
call expect (conjg(eps2(m,p,-2))*eps2(m,p,-2), 1, "e2(-2).e2(-2)=1", passed)
if (m > 0) then
   call expect (conjg(eps2(m,p, 2))*eps2(m,p, 1), 0, "e2( 2).e2( 1)=0", passed)
   call expect (conjg(eps2(m,p, 2))*eps2(m,p, 0), 0, "e2( 2).e2( 0)=0", passed)
   call expect (conjg(eps2(m,p, 2))*eps2(m,p,-1), 0, "e2( 2).e2(-1)=0", passed)
   call expect (conjg(eps2(m,p, 1))*eps2(m,p, 2), 0, "e2( 1).e2( 2)=0", passed)
   call expect (conjg(eps2(m,p, 1))*eps2(m,p, 1), 1, "e2( 1).e2( 1)=1", passed)
   call expect (conjg(eps2(m,p, 1))*eps2(m,p, 0), 0, "e2( 1).e2( 0)=0", passed)
   call expect (conjg(eps2(m,p, 1))*eps2(m,p,-1), 0, "e2( 1).e2(-1)=0", passed)
   call expect (conjg(eps2(m,p, 1))*eps2(m,p,-2), 0, "e2( 1).e2(-2)=0", passed)
   call expect (conjg(eps2(m,p, 0))*eps2(m,p, 2), 0, "e2( 0).e2( 2)=0", passed)
   call expect (conjg(eps2(m,p, 0))*eps2(m,p, 1), 0, "e2( 0).e2( 1)=0", passed)
   call expect (conjg(eps2(m,p, 0))*eps2(m,p, 0), 1, "e2( 0).e2( 0)=1", passed)
   call expect (conjg(eps2(m,p, 0))*eps2(m,p,-1), 0, "e2( 0).e2(-1)=0", passed)
   call expect (conjg(eps2(m,p, 0))*eps2(m,p,-2), 0, "e2( 0).e2(-2)=0", passed)
   call expect (conjg(eps2(m,p,-1))*eps2(m,p, 2), 0, "e2(-1).e2( 2)=0", passed)
   call expect (conjg(eps2(m,p,-1))*eps2(m,p, 1), 0, "e2(-1).e2( 1)=0", passed)
   call expect (conjg(eps2(m,p,-1))*eps2(m,p, 0), 0, "e2(-1).e2( 0)=0", passed)
   call expect (conjg(eps2(m,p,-1))*eps2(m,p,-1), 1, "e2(-1).e2(-1)=1", passed)
   call expect (conjg(eps2(m,p,-1))*eps2(m,p,-2), 0, "e2(-1).e2(-2)=0", passed)
   call expect (conjg(eps2(m,p,-2))*eps2(m,p, 1), 0, "e2(-2).e2( 1)=0", passed)
   call expect (conjg(eps2(m,p,-2))*eps2(m,p, 0), 0, "e2(-2).e2( 0)=0", passed)
   call expect (conjg(eps2(m,p,-2))*eps2(m,p,-1), 0, "e2(-2).e2(-1)=0", passed)
end if
@ 
<<Test [[omega95]]>>=
call expect (           abs(p*eps2(m,p, 2)  ), 0, " |p.e2( 2)|  =0", passed)
call expect (             abs(eps2(m,p, 2)*p), 0, "   |e2( 2).p|=0", passed)
call expect (           abs(p*eps2(m,p,-2)  ), 0, " |p.e2(-2)|  =0", passed)
call expect (             abs(eps2(m,p,-2)*p), 0, "   |e2(-2).p|=0", passed)
if (m > 0) then
   call expect (           abs(p*eps2(m,p, 1)  ), 0, " |p.e2( 1)|  =0", passed)
   call expect (             abs(eps2(m,p, 1)*p), 0, "   |e2( 1).p|=0", passed)
   call expect (           abs(p*eps2(m,p, 0)  ), 0, " |p.e2( 0)|  =0", passed)
   call expect (             abs(eps2(m,p, 0)*p), 0, "   |e2( 0).p|=0", passed)
   call expect (           abs(p*eps2(m,p,-1)  ), 0, " |p.e2(-1)|  =0", passed)
   call expect (             abs(eps2(m,p,-1)*p), 0, "   |e2(-1).p|=0", passed)
end if
@ 
<<XXX Test [[omega95]]>>=
print *, " *** Checking the polarization tensors for massive gravitons:"
call expect (abs(p * eps2(m,p,2)),  0, "p.e(+2)=0", passed)
call expect (abs(p * eps2(m,p,1)),  0, "p.e(+1)=0", passed)
call expect (abs(p * eps2(m,p,0)),  0, "p.e( 0)=0", passed)
call expect (abs(p * eps2(m,p,-1)), 0, "p.e(-1)=0", passed)
call expect (abs(p * eps2(m,p,-2)), 0, "p.e(-2)=0", passed)
call expect (abs(trace(eps2 (m,p,2))),  0, "Tr[e(+2)]=0", passed)
call expect (abs(trace(eps2 (m,p,1))),  0, "Tr[e(+1)]=0", passed)
call expect (abs(trace(eps2 (m,p,0))),  0, "Tr[e( 0)]=0", passed)
call expect (abs(trace(eps2 (m,p,-1))), 0, "Tr[e(-1)]=0", passed)
call expect (abs(trace(eps2 (m,p,-2))), 0, "Tr[e(-2)]=0", passed)
call expect (abs(eps2(m,p,2) * eps2(m,p,2)),   1, &
     "e(2).e(2)   = 1", passed)
call expect (abs(eps2(m,p,2) * eps2(m,p,1)),   0, &
     "e(2).e(1)   = 0", passed)
call expect (abs(eps2(m,p,2) * eps2(m,p,0)),   0, &
     "e(2).e(0)   = 0", passed)
call expect (abs(eps2(m,p,2) * eps2(m,p,-1)),  0, &
     "e(2).e(-1)  = 0", passed)
call expect (abs(eps2(m,p,2) * eps2(m,p,-2)),  0, &
     "e(2).e(-2)  = 0", passed)
call expect (abs(eps2(m,p,1) * eps2(m,p,1)),   1, &
     "e(1).e(1)   = 1", passed)
call expect (abs(eps2(m,p,1) * eps2(m,p,0)),   0, &
     "e(1).e(0)   = 0", passed)
call expect (abs(eps2(m,p,1) * eps2(m,p,-1)),  0, &
     "e(1).e(-1)  = 0", passed)
call expect (abs(eps2(m,p,1) * eps2(m,p,-2)),  0, &
     "e(1).e(-2)  = 0", passed)
call expect (abs(eps2(m,p,0) * eps2(m,p,0)),   1, &
     "e(0).e(0)   = 1", passed)
call expect (abs(eps2(m,p,0) * eps2(m,p,-1)),  0, &
     "e(0).e(-1)  = 0", passed)
call expect (abs(eps2(m,p,0) * eps2(m,p,-2)),  0, &
     "e(0).e(-2)  = 0", passed)
call expect (abs(eps2(m,p,-1) * eps2(m,p,-1)), 1, &
     "e(-1).e(-1) = 1", passed)
call expect (abs(eps2(m,p,-1) * eps2(m,p,-2)), 0, &
     "e(-1).e(-2) = 0", passed)
call expect (abs(eps2(m,p,-2) * eps2(m,p,-2)), 1, &
     "e(-2).e(-2) = 1", passed)
@ 
<<Test [[omega95]]>>=
print *, " *** Checking the graviton propagator:"
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,eps2(m,p,-2)))), 0, "p.pr.e(-2)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,eps2(m,p,-1)))), 0, "p.pr.e(-1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,eps2(m,p,0)))), 0, "p.pr.e(0)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,eps2(m,p,1)))), 0, "p.pr.e(1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,eps2(m,p,2)))), 0, "p.pr.e(2)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_tensor(p,m,w,ttest))), 0, "p.pr.ttest", passed)
@ 
<<[[test_omega95_bispinors.f90]]>>=
<<Copyleft>>
program test_omega95_bispinors
  use kinds
  use omega95_bispinors
  use omega_vspinor_polarizations
  use omega_testtools
  implicit none
  integer :: i, j
  real(kind=default) :: m, pabs, qabs, tabs, zabs, w
  real(kind=default), dimension(4) :: r
  complex(kind=default) :: c_one, c_two
  type(momentum) :: p, q, t, z, p_0
  type(vector) :: vp, vq, vt, vz
  type(vectorspinor) :: testv
  logical :: passed
  call random_seed ()
  c_one = 1
  c_two = 2
  w = 1.4142
  m = 13
  pabs = 42
  qabs = 137
  tabs = 84
  zabs = 3.1415
  p_0%t = m
  p_0%x = 0
  call random_momentum (p, pabs, m)
  call random_momentum (q, qabs, m)
  call random_momentum (t, tabs, m)
  call random_momentum (z, zabs, m)
  call random_number (r)
  do i = 1, 4
     testv%psi(1)%a(i) = (0.0_default, 0.0_default)
  end do
  do i = 2, 3
     do j = 1, 4
        testv%psi(i)%a(j) = cmplx (10.0_default * r(j))
    end do
  end do
  testv%psi(4)%a(1) = (1.0_default, 0.0_default)
  testv%psi(4)%a(2) = (0.0_default, 2.0_default)
  testv%psi(4)%a(3) = (1.0_default, 0.0_default)
  testv%psi(4)%a(4) = (3.0_default, 0.0_default)
  vp = p
  vq = q
  vt = t
  vz = z
  passed = .true.
  <<Test [[omega95_bispinors]]>>
  if (.not. passed) then
    stop 1
  end if
end program test_omega95_bispinors
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking the equations of motion ***:"
call expect (abs(f_vf(c_one,vp,u(m,p,+1))-m*u(m,p,+1)), 0, "|[p-m]u(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,u(m,p,-1))-m*u(m,p,-1)), 0, "|[p-m]u(-)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(m,p,+1))+m*v(m,p,+1)), 0, "|[p+m]v(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(m,p,-1))+m*v(m,p,-1)), 0, "|[p+m]v(-)|=0", passed)
print *, "*** Checking the equations of motion for negative masses***:"
call expect (abs(f_vf(c_one,vp,u(-m,p,+1))+m*u(-m,p,+1)), 0, "|[p+m]u(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,u(-m,p,-1))+m*u(-m,p,-1)), 0, "|[p+m]u(-)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(-m,p,+1))-m*v(-m,p,+1)), 0, "|[p-m]v(+)|=0", passed)
call expect (abs(f_vf(c_one,vp,v(-m,p,-1))-m*v(-m,p,-1)), 0, "|[p-m]v(-)|=0", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking the normalization ***:"
call expect (s_ff(c_one,v(m,p,+1),u(m,p,+1)), +2*m, "ubar(+)*u(+)=+2m", passed)
call expect (s_ff(c_one,v(m,p,-1),u(m,p,-1)), +2*m, "ubar(-)*u(-)=+2m", passed)
call expect (s_ff(c_one,u(m,p,+1),v(m,p,+1)), -2*m, "vbar(+)*v(+)=-2m", passed)
call expect (s_ff(c_one,u(m,p,-1),v(m,p,-1)), -2*m, "vbar(-)*v(-)=-2m", passed)
call expect (s_ff(c_one,v(m,p,+1),v(m,p,+1)),    0, "ubar(+)*v(+)=0  ", passed)
call expect (s_ff(c_one,v(m,p,-1),v(m,p,-1)),    0, "ubar(-)*v(-)=0  ", passed)
call expect (s_ff(c_one,u(m,p,+1),u(m,p,+1)),    0, "vbar(+)*u(+)=0  ", passed)
call expect (s_ff(c_one,u(m,p,-1),u(m,p,-1)),    0, "vbar(-)*u(-)=0  ", passed)
print *, "*** Checking the normalization for negative masses***:"
call expect (s_ff(c_one,v(-m,p,+1),u(-m,p,+1)), -2*m, "ubar(+)*u(+)=-2m", passed)
call expect (s_ff(c_one,v(-m,p,-1),u(-m,p,-1)), -2*m, "ubar(-)*u(-)=-2m", passed)
call expect (s_ff(c_one,u(-m,p,+1),v(-m,p,+1)), +2*m, "vbar(+)*v(+)=+2m", passed)
call expect (s_ff(c_one,u(-m,p,-1),v(-m,p,-1)), +2*m, "vbar(-)*v(-)=+2m", passed)
call expect (s_ff(c_one,v(-m,p,+1),v(-m,p,+1)),    0, "ubar(+)*v(+)=0  ", passed)
call expect (s_ff(c_one,v(-m,p,-1),v(-m,p,-1)),    0, "ubar(-)*v(-)=0  ", passed)
call expect (s_ff(c_one,u(-m,p,+1),u(-m,p,+1)),    0, "vbar(+)*u(+)=0  ", passed)
call expect (s_ff(c_one,u(-m,p,-1),u(-m,p,-1)),    0, "vbar(-)*u(-)=0  ", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking the currents ***:"
call expect (abs(v_ff(c_one,v(m,p,+1),u(m,p,+1))-2*vp), 0, "ubar(+).V.u(+)=2p", passed)
call expect (abs(v_ff(c_one,v(m,p,-1),u(m,p,-1))-2*vp), 0, "ubar(-).V.u(-)=2p", passed)
call expect (abs(v_ff(c_one,u(m,p,+1),v(m,p,+1))-2*vp), 0, "vbar(+).V.v(+)=2p", passed)
call expect (abs(v_ff(c_one,u(m,p,-1),v(m,p,-1))-2*vp), 0, "vbar(-).V.v(-)=2p", passed)
print *, "*** Checking the currents for negative masses***:"
call expect (abs(v_ff(c_one,v(-m,p,+1),u(-m,p,+1))-2*vp), 0, "ubar(+).V.u(+)=2p", passed)
call expect (abs(v_ff(c_one,v(-m,p,-1),u(-m,p,-1))-2*vp), 0, "ubar(-).V.u(-)=2p", passed)
call expect (abs(v_ff(c_one,u(-m,p,+1),v(-m,p,+1))-2*vp), 0, "vbar(+).V.v(+)=2p", passed)
call expect (abs(v_ff(c_one,u(-m,p,-1),v(-m,p,-1))-2*vp), 0, "vbar(-).V.v(-)=2p", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking current conservation ***:"
call expect ((vp-vq)*v_ff(c_one,v(m,p,+1),u(m,q,+1)), 0, "d(ubar(+).V.u(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,v(m,p,-1),u(m,q,-1)), 0, "d(ubar(-).V.u(-))=0", passed)
call expect ((vp-vq)*v_ff(c_one,u(m,p,+1),v(m,q,+1)), 0, "d(vbar(+).V.v(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,u(m,p,-1),v(m,q,-1)), 0, "d(vbar(-).V.v(-))=0", passed)
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking current conservation for negative masses***:"
call expect ((vp-vq)*v_ff(c_one,v(-m,p,+1),u(-m,q,+1)), 0, "d(ubar(+).V.u(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,v(-m,p,-1),u(-m,q,-1)), 0, "d(ubar(-).V.u(-))=0", passed)
call expect ((vp-vq)*v_ff(c_one,u(-m,p,+1),v(-m,q,+1)), 0, "d(vbar(+).V.v(+))=0", passed)
call expect ((vp-vq)*v_ff(c_one,u(-m,p,-1),v(-m,q,-1)), 0, "d(vbar(-).V.v(-))=0", passed)
@ 
<<Test [[omega95_bispinors]]>>=
if (m == 0) then
   print *, "*** Checking axial current conservation ***:"
   call expect ((vp-vq)*a_ff(c_one,v(m,p,+1),u(m,q,+1)), 0, "d(ubar(+).A.u(+))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,v(m,p,-1),u(m,q,-1)), 0, "d(ubar(-).A.u(-))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,u(m,p,+1),v(m,q,+1)), 0, "d(vbar(+).A.v(+))=0", passed)
   call expect ((vp-vq)*a_ff(c_one,u(m,p,-1),v(m,q,-1)), 0, "d(vbar(-).A.v(-))=0", passed)
end if
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking polarization vectors: ***"
call expect (conjg(eps(m,p, 1))*eps(m,p, 1), -1, "e( 1).e( 1)=-1", passed)
call expect (conjg(eps(m,p, 1))*eps(m,p,-1),  0, "e( 1).e(-1)= 0", passed)
call expect (conjg(eps(m,p,-1))*eps(m,p, 1),  0, "e(-1).e( 1)= 0", passed)
call expect (conjg(eps(m,p,-1))*eps(m,p,-1), -1, "e(-1).e(-1)=-1", passed)
call expect (                 p*eps(m,p, 1),  0, "    p.e( 1)= 0", passed)
call expect (                 p*eps(m,p,-1),  0, "    p.e(-1)= 0", passed)
if (m > 0) then
   call expect (conjg(eps(m,p, 1))*eps(m,p, 0),  0, "e( 1).e( 0)= 0", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p, 1),  0, "e( 0).e( 1)= 0", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p, 0), -1, "e( 0).e( 0)=-1", passed)
   call expect (conjg(eps(m,p, 0))*eps(m,p,-1),  0, "e( 0).e(-1)= 0", passed)
   call expect (conjg(eps(m,p,-1))*eps(m,p, 0),  0, "e(-1).e( 0)= 0", passed)
   call expect (                 p*eps(m,p, 0),  0, "    p.e( 0)= 0", passed)
end if
@
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking polarization vectorspinors: ***"
call expect (abs(p * ueps(m, p,  2)),  0, "p.ueps ( 2)= 0", passed)
call expect (abs(p * ueps(m, p,  1)),  0, "p.ueps ( 1)= 0", passed)
call expect (abs(p * ueps(m, p, -1)),  0, "p.ueps (-1)= 0", passed)
call expect (abs(p * ueps(m, p, -2)),  0, "p.ueps (-2)= 0", passed)
call expect (abs(p * veps(m, p,  2)),  0, "p.veps ( 2)= 0", passed)
call expect (abs(p * veps(m, p,  1)),  0, "p.veps ( 1)= 0", passed)
call expect (abs(p * veps(m, p, -1)),  0, "p.veps (-1)= 0", passed)
call expect (abs(p * veps(m, p, -2)),  0, "p.veps (-2)= 0", passed)
print *, "*** Checking polarization vectorspinors (neg. masses): ***"
call expect (abs(p * ueps(-m, p,  2)),  0, "p.ueps ( 2)= 0", passed)
call expect (abs(p * ueps(-m, p,  1)),  0, "p.ueps ( 1)= 0", passed)
call expect (abs(p * ueps(-m, p, -1)),  0, "p.ueps (-1)= 0", passed)
call expect (abs(p * ueps(-m, p, -2)),  0, "p.ueps (-2)= 0", passed)
call expect (abs(p * veps(-m, p,  2)),  0, "p.veps ( 2)= 0", passed)
call expect (abs(p * veps(-m, p,  1)),  0, "p.veps ( 1)= 0", passed)
call expect (abs(p * veps(-m, p, -1)),  0, "p.veps (-1)= 0", passed)
call expect (abs(p * veps(-m, p, -2)),  0, "p.veps (-2)= 0", passed)
print *, "*** in the rest frame ***"
call expect (abs(p_0 * ueps(m, p_0,  2)),  0, "p0.ueps ( 2)= 0", passed)
call expect (abs(p_0 * ueps(m, p_0,  1)),  0, "p0.ueps ( 1)= 0", passed)
call expect (abs(p_0 * ueps(m, p_0, -1)),  0, "p0.ueps (-1)= 0", passed)
call expect (abs(p_0 * ueps(m, p_0, -2)),  0, "p0.ueps (-2)= 0", passed)
call expect (abs(p_0 * veps(m, p_0,  2)),  0, "p0.veps ( 2)= 0", passed)
call expect (abs(p_0 * veps(m, p_0,  1)),  0, "p0.veps ( 1)= 0", passed)
call expect (abs(p_0 * veps(m, p_0, -1)),  0, "p0.veps (-1)= 0", passed)
call expect (abs(p_0 * veps(m, p_0, -2)),  0, "p0.veps (-2)= 0", passed)
print *, "*** in the rest frame (neg. masses) ***"
call expect (abs(p_0 * ueps(-m, p_0,  2)),  0, "p0.ueps ( 2)= 0", passed)
call expect (abs(p_0 * ueps(-m, p_0,  1)),  0, "p0.ueps ( 1)= 0", passed)
call expect (abs(p_0 * ueps(-m, p_0, -1)),  0, "p0.ueps (-1)= 0", passed)
call expect (abs(p_0 * ueps(-m, p_0, -2)),  0, "p0.ueps (-2)= 0", passed)
call expect (abs(p_0 * veps(-m, p_0,  2)),  0, "p0.veps ( 2)= 0", passed)
call expect (abs(p_0 * veps(-m, p_0,  1)),  0, "p0.veps ( 1)= 0", passed)
call expect (abs(p_0 * veps(-m, p_0, -1)),  0, "p0.veps (-1)= 0", passed)
call expect (abs(p_0 * veps(-m, p_0, -2)),  0, "p0.veps (-2)= 0", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Checking the irreducibility condition: ***"
call expect (abs(f_potgr (c_one, c_one, ueps(m, p,  2))),  0, "g.ueps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p,  1))),  0, "g.ueps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p, -1))),  0, "g.ueps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p, -2))),  0, "g.ueps (-2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p,  2))),  0, "g.veps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p,  1))),  0, "g.veps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p, -1))),  0, "g.veps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p, -2))),  0, "g.veps (-2)", passed)
print *, "*** Checking the irreducibility condition (neg. masses): ***"
call expect (abs(f_potgr (c_one, c_one, ueps(-m, p,  2))),  0, "g.ueps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(-m, p,  1))),  0, "g.ueps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(-m, p, -1))),  0, "g.ueps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(-m, p, -2))),  0, "g.ueps (-2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(-m, p,  2))),  0, "g.veps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(-m, p,  1))),  0, "g.veps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(-m, p, -1))),  0, "g.veps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(-m, p, -2))),  0, "g.veps (-2)", passed)
print *, "*** in the rest frame ***"
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0,  2))),  0, "g.ueps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0,  1))),  0, "g.ueps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0, -1))),  0, "g.ueps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0, -2))),  0, "g.ueps (-2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0,  2))),  0, "g.veps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0,  1))),  0, "g.veps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0, -1))),  0, "g.veps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0, -2))),  0, "g.veps (-2)", passed)
print *, "*** in the rest frame (neg. masses) ***"
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0,  2))),  0, "g.ueps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0,  1))),  0, "g.ueps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0, -1))),  0, "g.ueps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, ueps(m, p_0, -2))),  0, "g.ueps (-2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0,  2))),  0, "g.veps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0,  1))),  0, "g.veps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0, -1))),  0, "g.veps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, veps(m, p_0, -2))),  0, "g.veps (-2)", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Testing vectorspinor normalization ***"
call expect (veps(m,p, 2)*ueps(m,p, 2), -2*m, "ueps( 2).ueps( 2)= -2m", passed)
call expect (veps(m,p, 1)*ueps(m,p, 1), -2*m, "ueps( 1).ueps( 1)= -2m", passed)
call expect (veps(m,p,-1)*ueps(m,p,-1), -2*m, "ueps(-1).ueps(-1)= -2m", passed)
call expect (veps(m,p,-2)*ueps(m,p,-2), -2*m, "ueps(-2).ueps(-2)= -2m", passed)
call expect (ueps(m,p, 2)*veps(m,p, 2),  2*m, "veps( 2).veps( 2)= +2m", passed)
call expect (ueps(m,p, 1)*veps(m,p, 1),  2*m, "veps( 1).veps( 1)= +2m", passed)
call expect (ueps(m,p,-1)*veps(m,p,-1),  2*m, "veps(-1).veps(-1)= +2m", passed)
call expect (ueps(m,p,-2)*veps(m,p,-2),  2*m, "veps(-2).veps(-2)= +2m", passed)
call expect (ueps(m,p, 2)*ueps(m,p, 2),    0, "ueps( 2).veps( 2)=   0", passed)
call expect (ueps(m,p, 1)*ueps(m,p, 1),    0, "ueps( 1).veps( 1)=   0", passed)
call expect (ueps(m,p,-1)*ueps(m,p,-1),    0, "ueps(-1).veps(-1)=   0", passed)
call expect (ueps(m,p,-2)*ueps(m,p,-2),    0, "ueps(-2).veps(-2)=   0", passed)
call expect (veps(m,p, 2)*veps(m,p, 2),    0, "veps( 2).ueps( 2)=   0", passed)
call expect (veps(m,p, 1)*veps(m,p, 1),    0, "veps( 1).ueps( 1)=   0", passed)
call expect (veps(m,p,-1)*veps(m,p,-1),    0, "veps(-1).ueps(-1)=   0", passed)
call expect (veps(m,p,-2)*veps(m,p,-2),    0, "veps(-2).ueps(-2)=   0", passed)
print *, "*** Testing vectorspinor normalization (neg. masses) ***"
call expect (veps(-m,p, 2)*ueps(-m,p, 2), +2*m, "ueps( 2).ueps( 2)= +2m", passed)
call expect (veps(-m,p, 1)*ueps(-m,p, 1), +2*m, "ueps( 1).ueps( 1)= +2m", passed)
call expect (veps(-m,p,-1)*ueps(-m,p,-1), +2*m, "ueps(-1).ueps(-1)= +2m", passed)
call expect (veps(-m,p,-2)*ueps(-m,p,-2), +2*m, "ueps(-2).ueps(-2)= +2m", passed)
call expect (ueps(-m,p, 2)*veps(-m,p, 2), -2*m, "veps( 2).veps( 2)= -2m", passed)
call expect (ueps(-m,p, 1)*veps(-m,p, 1), -2*m, "veps( 1).veps( 1)= -2m", passed)
call expect (ueps(-m,p,-1)*veps(-m,p,-1), -2*m, "veps(-1).veps(-1)= -2m", passed)
call expect (ueps(-m,p,-2)*veps(-m,p,-2), -2*m, "veps(-2).veps(-2)= -2m", passed)
call expect (ueps(-m,p, 2)*ueps(-m,p, 2),    0, "ueps( 2).veps( 2)=   0", passed)
call expect (ueps(-m,p, 1)*ueps(-m,p, 1),    0, "ueps( 1).veps( 1)=   0", passed)
call expect (ueps(-m,p,-1)*ueps(-m,p,-1),    0, "ueps(-1).veps(-1)=   0", passed)
call expect (ueps(-m,p,-2)*ueps(-m,p,-2),    0, "ueps(-2).veps(-2)=   0", passed)
call expect (veps(-m,p, 2)*veps(-m,p, 2),    0, "veps( 2).ueps( 2)=   0", passed)
call expect (veps(-m,p, 1)*veps(-m,p, 1),    0, "veps( 1).ueps( 1)=   0", passed)
call expect (veps(-m,p,-1)*veps(-m,p,-1),    0, "veps(-1).ueps(-1)=   0", passed)
call expect (veps(-m,p,-2)*veps(-m,p,-2),    0, "veps(-2).ueps(-2)=   0", passed)
print *, "*** in the rest frame ***"
call expect (veps(m,p_0, 2)*ueps(m,p_0, 2), -2*m, "ueps( 2).ueps( 2)= -2m", passed)
call expect (veps(m,p_0, 1)*ueps(m,p_0, 1), -2*m, "ueps( 1).ueps( 1)= -2m", passed)
call expect (veps(m,p_0,-1)*ueps(m,p_0,-1), -2*m, "ueps(-1).ueps(-1)= -2m", passed)
call expect (veps(m,p_0,-2)*ueps(m,p_0,-2), -2*m, "ueps(-2).ueps(-2)= -2m", passed)
call expect (ueps(m,p_0, 2)*veps(m,p_0, 2),  2*m, "veps( 2).veps( 2)= +2m", passed)
call expect (ueps(m,p_0, 1)*veps(m,p_0, 1),  2*m, "veps( 1).veps( 1)= +2m", passed)
call expect (ueps(m,p_0,-1)*veps(m,p_0,-1),  2*m, "veps(-1).veps(-1)= +2m", passed)
call expect (ueps(m,p_0,-2)*veps(m,p_0,-2),  2*m, "veps(-2).veps(-2)= +2m", passed)
call expect (ueps(m,p_0, 2)*ueps(m,p_0, 2),    0, "ueps( 2).veps( 2)=   0", passed)
call expect (ueps(m,p_0, 1)*ueps(m,p_0, 1),    0, "ueps( 1).veps( 1)=   0", passed)
call expect (ueps(m,p_0,-1)*ueps(m,p_0,-1),    0, "ueps(-1).veps(-1)=   0", passed)
call expect (ueps(m,p_0,-2)*ueps(m,p_0,-2),    0, "ueps(-2).veps(-2)=   0", passed)
call expect (veps(m,p_0, 2)*veps(m,p_0, 2),    0, "veps( 2).ueps( 2)=   0", passed)
call expect (veps(m,p_0, 1)*veps(m,p_0, 1),    0, "veps( 1).ueps( 1)=   0", passed)
call expect (veps(m,p_0,-1)*veps(m,p_0,-1),    0, "veps(-1).ueps(-1)=   0", passed)
call expect (veps(m,p_0,-2)*veps(m,p_0,-2),    0, "veps(-2).ueps(-2)=   0", passed)
print *, "*** in the rest frame (neg. masses) ***"
call expect (veps(-m,p_0, 2)*ueps(-m,p_0, 2), +2*m, "ueps( 2).ueps( 2)= +2m", passed)
call expect (veps(-m,p_0, 1)*ueps(-m,p_0, 1), +2*m, "ueps( 1).ueps( 1)= +2m", passed)
call expect (veps(-m,p_0,-1)*ueps(-m,p_0,-1), +2*m, "ueps(-1).ueps(-1)= +2m", passed)
call expect (veps(-m,p_0,-2)*ueps(-m,p_0,-2), +2*m, "ueps(-2).ueps(-2)= +2m", passed)
call expect (ueps(-m,p_0, 2)*veps(-m,p_0, 2), -2*m, "veps( 2).veps( 2)= -2m", passed)
call expect (ueps(-m,p_0, 1)*veps(-m,p_0, 1), -2*m, "veps( 1).veps( 1)= -2m", passed)
call expect (ueps(-m,p_0,-1)*veps(-m,p_0,-1), -2*m, "veps(-1).veps(-1)= -2m", passed)
call expect (ueps(-m,p_0,-2)*veps(-m,p_0,-2), -2*m, "veps(-2).veps(-2)= -2m", passed)
call expect (ueps(-m,p_0, 2)*ueps(-m,p_0, 2),    0, "ueps( 2).veps( 2)=   0", passed)
call expect (ueps(-m,p_0, 1)*ueps(-m,p_0, 1),    0, "ueps( 1).veps( 1)=   0", passed)
call expect (ueps(-m,p_0,-1)*ueps(-m,p_0,-1),    0, "ueps(-1).veps(-1)=   0", passed)
call expect (ueps(-m,p_0,-2)*ueps(-m,p_0,-2),    0, "ueps(-2).veps(-2)=   0", passed)
call expect (veps(-m,p_0, 2)*veps(-m,p_0, 2),    0, "veps( 2).ueps( 2)=   0", passed)
call expect (veps(-m,p_0, 1)*veps(-m,p_0, 1),    0, "veps( 1).ueps( 1)=   0", passed)
call expect (veps(-m,p_0,-1)*veps(-m,p_0,-1),    0, "veps(-1).ueps(-1)=   0", passed)
call expect (veps(-m,p_0,-2)*veps(-m,p_0,-2),    0, "veps(-2).ueps(-2)=   0", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Majorana properties of gravitino vertices: ***"
call expect (abs(u (m,q,1) * f_sgr (c_one, c_one, ueps(m,p,2), t) + & 
   ueps(m,p,2) * gr_sf(c_one,c_one,u(m,q,1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_sgr (c_one, c_one, ueps(m,p,2), t) + & 
!!!    ueps(m,p,2) * gr_sf(c_one,c_one,u(m,q,-1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,1) * f_sgr (c_one, c_one, ueps(m,p,1), t) + & 
!!!    ueps(m,p,1) * gr_sf(c_one,c_one,u(m,q,1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_sgr (c_one, c_one, ueps(m,p,1), t) + & 
!!!    ueps(m,p,1) * gr_sf(c_one,c_one,u(m,q,-1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,1) * f_sgr (c_one, c_one, ueps(m,p,-1), t) + & 
!!!    ueps(m,p,-1) * gr_sf(c_one,c_one,u(m,q,1),t)),  0, "f_sgr   + gr_sf       = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_sgr (c_one, c_one, ueps(m,p,-1), t) + & 
!!!    ueps(m,p,-1) * gr_sf(c_one,c_one,u(m,q,-1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,1) * f_sgr (c_one, c_one, ueps(m,p,-2), t) + & 
!!!    ueps(m,p,-2) * gr_sf(c_one,c_one,u(m,q,1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_sgr (c_one, c_one, ueps(m,p,-2), t) + & 
!!!    ueps(m,p,-2) * gr_sf(c_one,c_one,u(m,q,-1),t)),  0, "f_sgr     + gr_sf     = 0", passed)
call expect (abs(u (m,q,1) * f_slgr (c_one, c_one, ueps(m,p,2), t) + & 
   ueps(m,p,2) * gr_slf(c_one,c_one,u(m,q,1),t)),  0, "f_slgr    + gr_slf    = 0", passed)
call expect (abs(u (m,q,1) * f_srgr (c_one, c_one, ueps(m,p,2), t) + & 
   ueps(m,p,2) * gr_srf(c_one,c_one,u(m,q,1),t)),  0, "f_srgr    + gr_srf    = 0", passed)
call expect (abs(u (m,q,1) * f_slrgr (c_one, c_two, c_one, ueps(m,p,2), t) + & 
   ueps(m,p,2) * gr_slrf(c_one,c_two,c_one,u(m,q,1),t)),  0, "f_slrgr   + gr_slrf   = 0", passed)
call expect (abs(u (m,q,1) * f_pgr (c_one, c_one, ueps(m,p,2), t) + & 
   ueps(m,p,2) * gr_pf(c_one,c_one,u(m,q,1),t)),  0, "f_pgr     + gr_pf     = 0", passed)
call expect (abs(u (m,q,1) * f_vgr (c_one, vt, ueps(m,p,2), p+q) + & 
   ueps(m,p,2) * gr_vf(c_one,vt,u(m,q,1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
call expect (abs(u (m,q,1) * f_vlrgr (c_one, c_two, vt, ueps(m,p,2), p+q) + & 
   ueps(m,p,2) * gr_vlrf(c_one,c_two,vt,u(m,q,1),p+q)),  0, "f_vlrgr   + gr_vlrf   = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_vgr (c_one, vt, ueps(m,p,2), p+q) + & 
!!!    ueps(m,p,2) * gr_vf(c_one,vt,u(m,q,-1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(u (m,q,1) * f_vgr (c_one, vt, ueps(m,p,1), p+q) + & 
!!!    ueps(m,p,1) * gr_vf(c_one,vt,u(m,q,1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_vgr (c_one, vt, ueps(m,p,1), p+q) + & 
!!!    ueps(m,p,1) * gr_vf(c_one,vt,u(m,q,-1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(u (m,q,1) * f_vgr (c_one, vt, ueps(m,p,-1), p+q) + & 
!!!    ueps(m,p,-1) * gr_vf(c_one,vt,u(m,q,1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_vgr (c_one, vt, veps(m,p,-1), p+q) + & 
!!!    veps(m,p,-1) * gr_vf(c_one,vt,u(m,q,-1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(v (m,q,1) * f_vgr (c_one, vt, ueps(m,p,-2), p+q) + & 
!!!    ueps(m,p,-2) * gr_vf(c_one,vt,v(m,q,1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
!!! call expect (abs(u (m,q,-1) * f_vgr (c_one, vt, ueps(m,p,-2), p+q) + & 
!!!    ueps(m,p,-2) * gr_vf(c_one,vt,u(m,q,-1),p+q)),  0, "f_vgr     + gr_vf     = 0", passed)
call expect (abs(s_grf (c_one, ueps(m,p,2), u(m,q,1),t) + & 
   s_fgr(c_one,u(m,q,1),ueps(m,p,2),t)),  0, "s_grf     + s_fgr     = 0", passed)
call expect (abs(sl_grf (c_one, ueps(m,p,2), u(m,q,1),t) + & 
   sl_fgr(c_one,u(m,q,1),ueps(m,p,2),t)),  0, "sl_grf    + sl_fgr    = 0", passed)
call expect (abs(sr_grf (c_one, ueps(m,p,2), u(m,q,1),t) + & 
   sr_fgr(c_one,u(m,q,1),ueps(m,p,2),t)),  0, "sr_grf    + sr_fgr    = 0", passed)
call expect (abs(slr_grf (c_one, c_two, ueps(m,p,2), u(m,q,1),t) + & 
   slr_fgr(c_one,c_two,u(m,q,1),ueps(m,p,2),t)),  0, "slr_grf   + slr_fgr   = 0", passed)
call expect (abs(p_grf (c_one, ueps(m,p,2), u(m,q,1),t) + & 
   p_fgr(c_one,u(m,q,1),ueps(m,p,2),t)),  0, "p_grf     + p_fgr     = 0", passed)
call expect (abs(v_grf (c_one, ueps(m,p,2), u(m,q,1),t) + & 
   v_fgr(c_one,u(m,q,1),ueps(m,p,2),t)),  0, "v_grf     + v_fgr     = 0", passed)
call expect (abs(vlr_grf (c_one, c_two, ueps(m,p,2), u(m,q,1),t) + & 
   vlr_fgr(c_one,c_two,u(m,q,1),ueps(m,p,2),t)),  0, "vlr_grf   + vlr_fgr   = 0", passed)
call expect (abs(u(m,p,1) * f_potgr (c_one,c_one,testv) - testv * gr_potf &
   (c_one,c_one,u (m,p,1))), 0, "f_potgr   - gr_potf   = 0", passed)
call expect (abs (pot_fgr (c_one,u(m,p,1),testv) - pot_grf(c_one, & 
   testv,u(m,p,1))), 0, "pot_fgr   - pot_grf   = 0", passed)
call expect (abs(u(m,p,1) * f_s2gr (c_one,c_one,c_one,testv) - testv * gr_s2f &
   (c_one,c_one,c_one,u (m,p,1))), 0, "f_s2gr    - gr_s2f    = 0", passed)
call expect (abs (s2_fgr (c_one,u(m,p,1),c_one,testv) - s2_grf(c_one, &
   testv,c_one,u(m,p,1))), 0, "s2_fgr    - s2_grf    = 0", passed)
call expect (abs(u (m,q,1) * f_svgr (c_one, c_one, vt, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_svf(c_one,c_one,vt,u(m,q,1))),  0, "f_svgr    + gr_svf    = 0", passed)
call expect (abs(u (m,q,1) * f_slvgr (c_one, c_one, vt, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_slvf(c_one,c_one,vt,u(m,q,1))),  0, "f_slvgr   + gr_slvf   = 0", passed)
call expect (abs(u (m,q,1) * f_srvgr (c_one, c_one, vt, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_srvf(c_one,c_one,vt,u(m,q,1))),  0, "f_srvgr   + gr_srvf   = 0", passed)
call expect (abs(u (m,q,1) * f_slrvgr (c_one, c_two, c_one, vt, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_slrvf(c_one,c_two,c_one,vt,u(m,q,1))),  0, "f_slrvgr  + gr_slrvf  = 0", passed)
call expect (abs (sv1_fgr (c_one,u(m,p,1),vt,ueps(m,q,2)) + sv1_grf(c_one, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "sv1_fgr   + sv1_grf   = 0", passed)
call expect (abs (sv2_fgr (c_one,u(m,p,1),c_one,ueps(m,q,2)) + sv2_grf(c_one, &
   ueps(m,q,2),c_one,u(m,p,1))), 0, "sv2_fgr   + sv2_grf   = 0", passed)
call expect (abs (slv1_fgr (c_one,u(m,p,1),vt,ueps(m,q,2)) + slv1_grf(c_one, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "slv1_fgr  + slv1_grf  = 0", passed)
call expect (abs (srv2_fgr (c_one,u(m,p,1),c_one,ueps(m,q,2)) + srv2_grf(c_one, &
   ueps(m,q,2),c_one,u(m,p,1))), 0, "srv2_fgr  + srv2_grf  = 0", passed)
call expect (abs (slrv1_fgr (c_one,c_two,u(m,p,1),vt,ueps(m,q,2)) + slrv1_grf(c_one,c_two, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "slrv1_fgr + slrv1_grf = 0", passed)
call expect (abs (slrv2_fgr (c_one,c_two,u(m,p,1),c_one,ueps(m,q,2)) + slrv2_grf(c_one, &
   c_two,ueps(m,q,2),c_one,u(m,p,1))), 0, "slrv2_fgr + slrv2_grf = 0", passed)
call expect (abs(u (m,q,1) * f_pvgr (c_one, c_one, vt, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_pvf(c_one,c_one,vt,u(m,q,1))),  0, "f_pvgr    + gr_pvf    = 0", passed)
call expect (abs (pv1_fgr (c_one,u(m,p,1),vt,ueps(m,q,2)) + pv1_grf(c_one, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "pv1_fgr   + pv1_grf   = 0", passed)
call expect (abs (pv2_fgr (c_one,u(m,p,1),c_one,ueps(m,q,2)) + pv2_grf(c_one, &
   ueps(m,q,2),c_one,u(m,p,1))), 0, "pv2_fgr   + pv2_grf   = 0", passed)
call expect (abs(u (m,q,1) * f_v2gr (c_one, vt, vz, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_v2f(c_one,vt,vz,u(m,q,1))),  0, "f_v2gr    + gr_v2f    = 0", passed)
call expect (abs(u (m,q,1) * f_v2lrgr (c_one, c_two, vt, vz, ueps(m,p,2)) + & 
   ueps(m,p,2) * gr_v2lrf(c_one,c_two,vt,vz,u(m,q,1))),  0, "f_v2lrgr  + gr_v2lrf  = 0", passed)
call expect (abs (v2_fgr (c_one,u(m,p,1),vt,ueps(m,q,2)) + v2_grf(c_one, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "v2_fgr    + v2_grf    = 0", passed)
call expect (abs (v2lr_fgr (c_one,c_two,u(m,p,1),vt,ueps(m,q,2)) + v2lr_grf(c_one, c_two, &
   ueps(m,q,2),vt,u(m,p,1))), 0, "v2lr_fgr  + v2lr_grf  = 0", passed)
@ 
<<Test [[omega95_bispinors]]>>=
print *, "*** Testing the gravitino propagator: ***"
print *, "Transversality:"
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,testv))), 0, "p.pr.test", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,ueps(m,p,2)))),  0, "p.pr.ueps ( 2)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,ueps(m,p,1)))),  0, "p.pr.ueps ( 1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,ueps(m,p,-1)))), 0, "p.pr.ueps (-1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,ueps(m,p,-2)))), 0, "p.pr.ueps (-2)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,veps(m,p,2)))),  0, "p.pr.veps ( 2)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,veps(m,p,1)))),  0, "p.pr.veps ( 1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,veps(m,p,-1)))), 0, "p.pr.veps (-1)", passed)
call expect (abs(p * (cmplx (p*p - m**2, m*w, kind=default) * &
             pr_grav(p,m,w,veps(m,p,-2)))), 0, "p.pr.veps (-2)", passed)
print *, "Irreducibility:"
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,testv)))), 0, "g.pr.test", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,ueps(m,p,2))))), 0, &
             "g.pr.ueps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,ueps(m,p,1))))), 0, &
             "g.pr.ueps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,ueps(m,p,-1))))), 0, &
             "g.pr.ueps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,ueps(m,p,-2))))), 0, &
             "g.pr.ueps (-2)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,veps(m,p,2))))), 0, &
             "g.pr.veps ( 2)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,veps(m,p,1))))), 0, &
             "g.pr.veps ( 1)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,veps(m,p,-1))))), 0, &
             "g.pr.veps (-1)", passed)
call expect (abs(f_potgr (c_one, c_one, (cmplx (p*p - m**2, m*w, & 
             kind=default) * pr_grav(p,m,w,veps(m,p,-2))))), 0, &
             "g.pr.veps (-2)", passed)
@ 
<<[[omega_bundle.f90]]>>=
<<[[omega_vectors.f90]]>>
<<[[omega_spinors.f90]]>>
<<[[omega_bispinors.f90]]>>
<<[[omega_vectorspinors.f90]]>>
<<[[omega_polarizations.f90]]>>
<<[[omega_tensors.f90]]>>
<<[[omega_tensor_polarizations.f90]]>>
<<[[omega_couplings.f90]]>>
<<[[omega_spinor_couplings.f90]]>>
<<[[omega_bispinor_couplings.f90]]>>
<<[[omega_vspinor_polarizations.f90]]>>
<<[[omega_utils.f90]]>>
<<[[omega95.f90]]>>
<<[[omega95_bispinors.f90]]>>
<<[[omega_parameters.f90]]>>
<<[[omega_parameters_madgraph.f90]]>>
@ 
<<[[omega_bundle_whizard.f90]]>>=
<<[[omega_bundle.f90]]>>
<<[[omega_parameters_whizard.f90]]>>
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O'Mega Virtual Machine}
<<[[omegavm95.f90]]>>=
<<Copyleft>>
module omegavm95
  use kinds
  use omega95
  ! use omega95_bispinors
  implicit none
  private
  <<OVM Procedure Declarations>>
  <<OVM Data Declarations>>
  <<OVM Instructions>>
contains
  <<OVM Procedure Implementations>>
end module omegavm95
@
\subsection{Memory Layout}
On one hand, we need a memory pool for all the intermediate results
<<OVM Data Declarations>>=
type, public :: ovm
   private
   complex(kind=default) :: amp
   type(momentum), dimension(:), pointer :: p
   complex(kind=default), dimension(:), pointer :: phi
   type(spinor), dimension(:), pointer :: psi
   type(conjspinor), dimension(:), pointer :: psibar
   ! type(bispinor), dimension(:), pointer :: chi
   type(vector), dimension(:), pointer :: v
end type ovm
@
<<OVM Procedure Declarations>>=
public :: alloc
@
<<OVM Procedure Implementations>>=
subroutine alloc (vm, momenta, scalars, spinors, conjspinors, vectors)
  type(ovm), intent(inout) :: vm
  integer, intent(in) :: momenta, scalars, spinors, conjspinors, vectors
  allocate (vm%p(momenta))
  allocate (vm%phi(scalars))
  allocate (vm%psi(spinors))
  allocate (vm%psibar(conjspinors))
  allocate (vm%v(vectors))
end subroutine alloc
@ and on the other hand, we need to access coupling parameters that
define the environment
<<OVM Data Declarations>>=
type, public :: ovm_env
   private
   real(kind=default), dimension(:), pointer :: gr
   real(kind=default), dimension(:,:), pointer :: gr2
   complex(kind=default), dimension(:), pointer :: gc
   complex(kind=default), dimension(:,:), pointer :: gc2
end type ovm_env
@ NB: during, execution, the type of the coupling constant is implicit
in the instruction. 
\begin{dubious}
  How to load coupling constants?  Is brute force linear lookup good
  enough?
\end{dubious}
@ \subsection{Instruction Set}
<<OVM Data Declarations>>=
integer, parameter, private :: MAX_RHS = 3
type, public :: instr
   private
   integer :: code, sign, coupl, lhs
   integer, dimension(MAX_RHS) :: rhs
end type instr
@
<<OVM Procedure Declarations>>=
public :: eval
@
<<OVM Procedure Implementations>>=
pure subroutine eval (vm, amp, env, amplitude, p, s)
  type(ovm), intent(inout) :: vm
  complex(kind=default), intent(out) :: amp
  type(ovm_env), intent(in) :: env
  type(instr), dimension(:), intent(in) :: amplitude
  real(kind=default), dimension(0:,:), intent(in) :: p
  integer, dimension(:), intent(in) :: s
  integer :: code, sign, coupl, lhs
  integer, dimension(MAX_RHS) :: rhs
  integer :: i, pc
  vm%p(1) = - p(:,1)
  vm%p(2) = - p(:,2)
  do i = 3, size (p, dim = 2)
     vm%p(i) = p(:,i)
  end do
  do pc = 1, size (amplitude)
     code = amplitude(pc)%code
     sign = amplitude(pc)%sign
     coupl = amplitude(pc)%coupl
     lhs = amplitude(pc)%lhs
     rhs = amplitude(pc)%rhs
     select case (code)
     <<[[case]]s of [[code]]>>
     end select
  end do
  amp = vm%amp
end subroutine eval
@ \subsubsection{Loading External states}
<<OVM Instructions>>=
integer, public, parameter :: OVM_LOAD_SCALAR = 1
integer, public, parameter :: OVM_LOAD_U = 2
integer, public, parameter :: OVM_LOAD_UBAR = 3
integer, public, parameter :: OVM_LOAD_V = 4
integer, public, parameter :: OVM_LOAD_VBAR = 5
integer, public, parameter :: OVM_LOAD_VECTOR = 6
@ 
<<[[case]]s of [[code]]>>=
case (OVM_LOAD_SCALAR)
   vm%phi(lhs) = 1
case (OVM_LOAD_U)
   if (lhs <= 2) then
      vm%psi(lhs) = u (env%gr(coupl), - vm%p(rhs(1)), s(rhs(2)))
   else
      vm%psi(lhs) = u (env%gr(coupl), vm%p(rhs(1)), s(rhs(2)))
   end if
case (OVM_LOAD_UBAR)
   if (lhs <= 2) then
      vm%psibar(lhs) = ubar (env%gr(coupl), - vm%p(rhs(1)), s(rhs(2)))
   else
      vm%psibar(lhs) = ubar (env%gr(coupl), vm%p(rhs(1)), s(rhs(2)))
   end if
case (OVM_LOAD_V)
   if (lhs <= 2) then
      vm%psi(lhs) = v (env%gr(coupl), - vm%p(rhs(1)), s(rhs(2)))
   else
      vm%psi(lhs) = v (env%gr(coupl), vm%p(rhs(1)), s(rhs(2)))
   end if
case (OVM_LOAD_VBAR)
   if (lhs <= 2) then
      vm%psibar(lhs) = vbar (env%gr(coupl), - vm%p(rhs(1)), s(rhs(2)))
   else
      vm%psibar(lhs) = vbar (env%gr(coupl), vm%p(rhs(1)), s(rhs(2)))
   end if
case (OVM_LOAD_VECTOR)
   if (lhs <= 2) then
      vm%v(lhs) = eps (env%gr(coupl), - vm%p(rhs(1)), s(rhs(2)))
   else
      vm%v(lhs) = eps (env%gr(coupl), vm%p(rhs(1)), s(rhs(2)))
   end if
@
<<OVM Instructions>>=
integer, public, parameter :: OVM_ADD_MOMENTA = 10
@ 
<<[[case]]s of [[code]]>>=
case (OVM_ADD_MOMENTA)
   vm%p(lhs) = vm%p(rhs(1)) + vm%p(rhs(2))
@
<<OVM Instructions>>=
integer, public, parameter :: OVM_PROPAGATE_SCALAR = 11
integer, public, parameter :: OVM_PROPAGATE_SPINOR = 12
@ 
<<[[case]]s of [[code]]>>=
case (OVM_PROPAGATE_SCALAR)
   vm%phi(lhs) = pr_phi (vm%p(lhs),env%gr(rhs(1)),env%gr(rhs(2)),vm%phi(lhs))
case (OVM_PROPAGATE_SPINOR)
   vm%psi(lhs) = pr_psi (vm%p(lhs),env%gr(rhs(1)),env%gr(rhs(2)),vm%psi(lhs))
@
<<OVM Instructions>>=
integer, public, parameter :: OVM_FUSE_VECTOR_PSIBAR_PSI = 21
integer, public, parameter :: OVM_FUSE_PSI_VECTOR_PSI = 22
integer, public, parameter :: OVM_FUSE_PSIBAR_PSIBAR_VECTOR = 23
@ 
<<[[case]]s of [[code]]>>=
case (OVM_FUSE_VECTOR_PSIBAR_PSI)
   vm%v(lhs) = &
        v_ff (sign*env%gc(coupl), vm%psibar(rhs(1)), vm%psi(rhs(2)))
case (OVM_FUSE_PSI_VECTOR_PSI)
   vm%psi(lhs) = &
        f_vf (sign*env%gc(coupl), vm%v(rhs(1)), vm%psi(rhs(2)))
case (OVM_FUSE_PSIBAR_PSIBAR_VECTOR)
   vm%psibar(lhs) = &
        f_fv (sign*env%gc(coupl), vm%psibar(rhs(1)), vm%v(rhs(2)))
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<Copyleft>>=
!  $Id: omegalib.nw 4662 2013-09-23 13:21:34Z msekulla $
!
!  Copyright (C) 1999-2009 by 
!      Wolfgang Kilian <kilian@physik.uni-siegen.de>
!      Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
!      Juergen Reuter <juergen.reuter@desy.de>
!
!  WHIZARD is free software; you can redistribute it and/or modify it
!  under the terms of the GNU General Public License as published by 
!  the Free Software Foundation; either version 2, or (at your option)
!  any later version.
!
!  WHIZARD is distributed in the hope that it will be useful, but
!  WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program; if not, write to the Free Software
!  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:noweb
% noweb-doc-mode:latex-mode
% noweb-code-mode:f90-mode
% indent-tabs-mode:nil
% page-delimiter:"^@ %%%.*\n"
% End:
